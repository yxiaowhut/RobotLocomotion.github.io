<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::multibody::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacedrake_1_1multibody_1_1detail.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drake::multibody::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abfd00d0007459c207b623fc278389108"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, Eigen::Vector4d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a></td></tr>
<tr class="memdesc:abfd00d0007459c207b623fc278389108"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from the name of a material to its color.  <a href="#abfd00d0007459c207b623fc278389108">More...</a><br /></td></tr>
<tr class="separator:abfd00d0007459c207b623fc278389108"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a608679d0c67322dbcd5dab58c36e8c05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#a608679d0c67322dbcd5dab58c36e8c05">default_friction</a> ()</td></tr>
<tr class="memdesc:a608679d0c67322dbcd5dab58c36e8c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default value of the Coulomb's law coefficients of friction for when they are not specified in the URDF/SDF file.  <a href="#a608679d0c67322dbcd5dab58c36e8c05">More...</a><br /></td></tr>
<tr class="separator:a608679d0c67322dbcd5dab58c36e8c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eca6e02e85ffc38a4d5dcd6ad52a07d"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#a0eca6e02e85ffc38a4d5dcd6ad52a07d">ToVector3</a> (const ignition::math::Vector3d &amp;<a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">vector</a>)</td></tr>
<tr class="memdesc:a0eca6e02e85ffc38a4d5dcd6ad52a07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to express an ignition::math::Vector3d instance as a Vector3d instance.  <a href="#a0eca6e02e85ffc38a4d5dcd6ad52a07d">More...</a><br /></td></tr>
<tr class="separator:a0eca6e02e85ffc38a4d5dcd6ad52a07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13dbb8038dd521c47b627fee0f1c8f8"><td class="memItemLeft" align="right" valign="top">Isometry3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#ad13dbb8038dd521c47b627fee0f1c8f8">ToIsometry3</a> (const ignition::math::Pose3d &amp;<a class="el" href="pose__smoother__test_8cc.html#a52d2d9a6c62244da2b2367bf389d0546">pose</a>)</td></tr>
<tr class="memdesc:ad13dbb8038dd521c47b627fee0f1c8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to express an ignition::math::Pose3d instance as an Isometry3d instance.  <a href="#ad13dbb8038dd521c47b627fee0f1c8f8">More...</a><br /></td></tr>
<tr class="separator:ad13dbb8038dd521c47b627fee0f1c8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf95e07a12bc0b8f407eb2bdf279eee"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#abbf95e07a12bc0b8f407eb2bdf279eee">GetFullPath</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:abbf95e07a12bc0b8f407eb2bdf279eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the full path of .  <a href="#abbf95e07a12bc0b8f407eb2bdf279eee">More...</a><br /></td></tr>
<tr class="separator:abbf95e07a12bc0b8f407eb2bdf279eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66c24a3cf7f43c19d678a06eb616141"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#aa66c24a3cf7f43c19d678a06eb616141">ResolveUri</a> (const std::string &amp;uri, const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;package_map, const std::string &amp;root_dir)</td></tr>
<tr class="memdesc:aa66c24a3cf7f43c19d678a06eb616141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves the full path of a URI.  <a href="#aa66c24a3cf7f43c19d678a06eb616141">More...</a><br /></td></tr>
<tr class="separator:aa66c24a3cf7f43c19d678a06eb616141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd3120d8bd21b09aca3fb1a3862d6e5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#acdd3120d8bd21b09aca3fb1a3862d6e5">MakeShapeFromSdfGeometry</a> (const sdf::Geometry &amp;sdf_geometry)</td></tr>
<tr class="memdesc:acdd3120d8bd21b09aca3fb1a3862d6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an sdf::Geometry object representing a &lt;geometry&gt; element from an SDF file, this method makes a new <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications. ">drake::geometry::Shape</a> object from this specification.  <a href="#acdd3120d8bd21b09aca3fb1a3862d6e5">More...</a><br /></td></tr>
<tr class="separator:acdd3120d8bd21b09aca3fb1a3862d6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3676511637c127d84a8bb589d2d90f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">GeometryInstance</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#a5b3676511637c127d84a8bb589d2d90f">MakeGeometryInstanceFromSdfVisual</a> (const sdf::Visual &amp;sdf_visual)</td></tr>
<tr class="memdesc:a5b3676511637c127d84a8bb589d2d90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an sdf::Visual object representing a &lt;visual&gt; element from an SDF file, this method makes a new <a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html" title="A geometry instance combines a geometry definition (i.e., a shape of some sort), a pose (relative to ...">drake::geometry::GeometryInstance</a> object from this specification.  <a href="#a5b3676511637c127d84a8bb589d2d90f">More...</a><br /></td></tr>
<tr class="separator:a5b3676511637c127d84a8bb589d2d90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d595f48e91553a7233e3ee984bae4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">IllustrationProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#af8d595f48e91553a7233e3ee984bae4d">MakeVisualPropertiesFromSdfVisual</a> (const sdf::Visual &amp;sdf_visual)</td></tr>
<tr class="separator:af8d595f48e91553a7233e3ee984bae4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b6dac0a30dc27eaec653be4cd81056"><td class="memItemLeft" align="right" valign="top">Isometry3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#aa0b6dac0a30dc27eaec653be4cd81056">MakeGeometryPoseFromSdfCollision</a> (const sdf::Collision &amp;sdf_collision)</td></tr>
<tr class="separator:aa0b6dac0a30dc27eaec653be4cd81056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48445aa248ebb7363d2a3be05f7c17a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#af48445aa248ebb7363d2a3be05f7c17a">MakeCoulombFrictionFromSdfCollisionOde</a> (const sdf::Collision &amp;sdf_collision)</td></tr>
<tr class="memdesc:af48445aa248ebb7363d2a3be05f7c17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the material properties from the given sdf::Visual object.  <a href="#af48445aa248ebb7363d2a3be05f7c17a">More...</a><br /></td></tr>
<tr class="separator:af48445aa248ebb7363d2a3be05f7c17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0ffe5867d6427daab52ff5b28470c7"><td class="memItemLeft" align="right" valign="top">sdf::Visual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#abf0ffe5867d6427daab52ff5b28470c7">ResolveVisualUri</a> (const sdf::Visual &amp;original, const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">multibody::PackageMap</a> &amp;package_map, const std::string &amp;root_dir)</td></tr>
<tr class="memdesc:abf0ffe5867d6427daab52ff5b28470c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an sdf::Visual object representing a &lt;visual&gt; element from an SDF file, this method makes a new Visual object which resolves the uri for the mesh element, if present.  <a href="#abf0ffe5867d6427daab52ff5b28470c7">More...</a><br /></td></tr>
<tr class="separator:abf0ffe5867d6427daab52ff5b28470c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12845da0430bac558be18798011f5c0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#a12845da0430bac558be18798011f5c0a">AddModelFromSdfFile</a> (const std::string &amp;file_name, const std::string &amp;model_name, const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;package_map, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *plant, <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *scene_graph=nullptr)</td></tr>
<tr class="memdesc:a12845da0430bac558be18798011f5c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a <code>&lt;model&gt;</code> element from the SDF file specified by <code>file_name</code> and adds it to <code>plant</code>.  <a href="#a12845da0430bac558be18798011f5c0a">More...</a><br /></td></tr>
<tr class="separator:a12845da0430bac558be18798011f5c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce5c2ee07186c7d8bc5fa96eafaf16e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#adce5c2ee07186c7d8bc5fa96eafaf16e">AddModelsFromSdfFile</a> (const std::string &amp;file_name, const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;package_map, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *plant, <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *scene_graph=nullptr)</td></tr>
<tr class="memdesc:adce5c2ee07186c7d8bc5fa96eafaf16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses all <code>&lt;model&gt;</code> elements from the SDF file specified by <code>file_name</code> and adds them to <code>plant</code>.  <a href="#adce5c2ee07186c7d8bc5fa96eafaf16e">More...</a><br /></td></tr>
<tr class="separator:adce5c2ee07186c7d8bc5fa96eafaf16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffa8aaeb73c0156e955ed126d012e7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#a3ffa8aaeb73c0156e955ed126d012e7a">ParseStringAttribute</a> (const tinyxml2::XMLElement *node, const char *attribute_name, std::string *val)</td></tr>
<tr class="memdesc:a3ffa8aaeb73c0156e955ed126d012e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a string attribute of <code>node</code> named <code>attribute_name</code> into <code>val</code>.  <a href="#a3ffa8aaeb73c0156e955ed126d012e7a">More...</a><br /></td></tr>
<tr class="separator:a3ffa8aaeb73c0156e955ed126d012e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8addd4deaf7393247738c4099dff88ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#a8addd4deaf7393247738c4099dff88ce">ParseScalarAttribute</a> (const tinyxml2::XMLElement *node, const char *attribute_name, <a class="el" href="classdouble.html">double</a> *val)</td></tr>
<tr class="memdesc:a8addd4deaf7393247738c4099dff88ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a scalar attribute of <code>node</code> named <code>attribute_name</code> into <code>val</code>.  <a href="#a8addd4deaf7393247738c4099dff88ce">More...</a><br /></td></tr>
<tr class="separator:a8addd4deaf7393247738c4099dff88ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40a8c6836f446facd11fca258f18453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#ac40a8c6836f446facd11fca258f18453">ParseVectorAttribute</a> (const tinyxml2::XMLElement *node, const char *attribute_name, Eigen::Vector3d *val)</td></tr>
<tr class="memdesc:ac40a8c6836f446facd11fca258f18453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an attribute of <code>node</code> named <code>attribute_name</code> consisting of 3 scalar values into <code>val</code>.  <a href="#ac40a8c6836f446facd11fca258f18453">More...</a><br /></td></tr>
<tr class="separator:ac40a8c6836f446facd11fca258f18453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d7ab8ac8103f1eec39cbc658b6b17b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#a64d7ab8ac8103f1eec39cbc658b6b17b">ParseVectorAttribute</a> (const tinyxml2::XMLElement *node, const char *attribute_name, Eigen::Vector4d *val)</td></tr>
<tr class="memdesc:a64d7ab8ac8103f1eec39cbc658b6b17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an attribute of <code>node</code> named <code>attribute_name</code> consisting of 4 scalar values into <code>val</code>.  <a href="#a64d7ab8ac8103f1eec39cbc658b6b17b">More...</a><br /></td></tr>
<tr class="separator:a64d7ab8ac8103f1eec39cbc658b6b17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cccf8ea14d8d14818d324fd09db242"><td class="memItemLeft" align="right" valign="top">Eigen::Isometry3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#af3cccf8ea14d8d14818d324fd09db242">OriginAttributesToTransform</a> (const tinyxml2::XMLElement *node)</td></tr>
<tr class="memdesc:af3cccf8ea14d8d14818d324fd09db242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses "xyz" and "rpy" attributes from <code>node</code> and returns an Isometry3d created from them.  <a href="#af3cccf8ea14d8d14818d324fd09db242">More...</a><br /></td></tr>
<tr class="separator:af3cccf8ea14d8d14818d324fd09db242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d43126f7596ab1e3a48016e29a07d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#a27d43126f7596ab1e3a48016e29a07d2">ParseThreeVectorAttribute</a> (const tinyxml2::XMLElement *node, const char *attribute_name, Eigen::Vector3d *val)</td></tr>
<tr class="memdesc:a27d43126f7596ab1e3a48016e29a07d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a three vector value from parameter <code>node</code>, which is an XML node.  <a href="#a27d43126f7596ab1e3a48016e29a07d2">More...</a><br /></td></tr>
<tr class="separator:a27d43126f7596ab1e3a48016e29a07d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad356633711e262750a3e5490373c9dc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#ad356633711e262750a3e5490373c9dc9">ParseMaterial</a> (const XMLElement *node, <a class="el" href="namespacedrake_1_1multibody_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *materials)</td></tr>
<tr class="separator:ad356633711e262750a3e5490373c9dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62d7a57d1a48218cfef64ce902f56c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#aa62d7a57d1a48218cfef64ce902f56c7">ParseVisual</a> (const std::string &amp;parent_element_name, const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;package_map, const std::string &amp;root_dir, const XMLElement *node, <a class="el" href="namespacedrake_1_1multibody_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *materials)</td></tr>
<tr class="separator:aa62d7a57d1a48218cfef64ce902f56c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd7c3fc2c9b82ab5ce5d69929b2a0c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#abfd7c3fc2c9b82ab5ce5d69929b2a0c0">ParseCollision</a> (const std::string &amp;parent_element_name, const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;package_map, const std::string &amp;root_dir, const XMLElement *node, <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *friction)</td></tr>
<tr class="separator:abfd7c3fc2c9b82ab5ce5d69929b2a0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9388f6fabb4d8f8bac2ef3321570cd33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#a9388f6fabb4d8f8bac2ef3321570cd33">ParseMaterial</a> (const tinyxml2::XMLElement *node, <a class="el" href="namespacedrake_1_1multibody_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *materials)</td></tr>
<tr class="memdesc:a9388f6fabb4d8f8bac2ef3321570cd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a "material" element in <code>node</code> and adds the result to <code>materials</code>.  <a href="#a9388f6fabb4d8f8bac2ef3321570cd33">More...</a><br /></td></tr>
<tr class="separator:a9388f6fabb4d8f8bac2ef3321570cd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7ef4dbbc2295a741d1187ca9510fb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#a3e7ef4dbbc2295a741d1187ca9510fb7">ParseVisual</a> (const std::string &amp;parent_element_name, const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;package_map, const std::string &amp;root_dir, const tinyxml2::XMLElement *node, <a class="el" href="namespacedrake_1_1multibody_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *materials)</td></tr>
<tr class="memdesc:a3e7ef4dbbc2295a741d1187ca9510fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a "visual" element in <code>node</code>.  <a href="#a3e7ef4dbbc2295a741d1187ca9510fb7">More...</a><br /></td></tr>
<tr class="separator:a3e7ef4dbbc2295a741d1187ca9510fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724205e29d47df8834fd20f321dcab47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#a724205e29d47df8834fd20f321dcab47">ParseCollision</a> (const std::string &amp;parent_element_name, const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;package_map, const std::string &amp;root_dir, const tinyxml2::XMLElement *node, <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *friction)</td></tr>
<tr class="memdesc:a724205e29d47df8834fd20f321dcab47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a "collision" element in <code>node</code>.  <a href="#a724205e29d47df8834fd20f321dcab47">More...</a><br /></td></tr>
<tr class="separator:a724205e29d47df8834fd20f321dcab47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649bcddcef956bac71a3420b890d4c15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#a649bcddcef956bac71a3420b890d4c15">AddModelFromUrdfFile</a> (const std::string &amp;file_name, const std::string &amp;model_name, const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;package_map, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *plant, <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *scene_graph=nullptr)</td></tr>
<tr class="memdesc:a649bcddcef956bac71a3420b890d4c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a <code>&lt;robot&gt;</code> element from the URDF file specified by <code>file_name</code> and adds it to <code>plant</code>.  <a href="#a649bcddcef956bac71a3420b890d4c15">More...</a><br /></td></tr>
<tr class="separator:a649bcddcef956bac71a3420b890d4c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abfd00d0007459c207b623fc278389108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd00d0007459c207b623fc278389108">&#9670;&nbsp;</a></span>MaterialMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, Eigen::Vector4d&gt; <a class="el" href="namespacedrake_1_1multibody_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map from the name of a material to its color. </p>
<p>The color is specified in RGBA (Red, Green, Blue, Alpha) format. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a12845da0430bac558be18798011f5c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12845da0430bac558be18798011f5c0a">&#9670;&nbsp;</a></span>AddModelFromSdfFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> AddModelFromSdfFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>plant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>scene_graph</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a <code>&lt;model&gt;</code> element from the SDF file specified by <code>file_name</code> and adds it to <code>plant</code>. </p>
<p>The SDF file can only contain a single <code>&lt;model&gt;</code> element. <code>&lt;world&gt;</code> elements (used for instance to specify gravity) are ignored by this method. A new model instance will be added to <code>plant</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the file is not in accordance with the SDF specification containing a message with a list of errors encountered while parsing the file. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if there is more than one <code>&lt;model&gt;</code> element or zero of them. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if plant is nullptr or if <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">MultibodyPlant::Finalize()</a> was already called on <code>plant</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>The name of the SDF file to be parsed. </td></tr>
    <tr><td class="paramname">model_name</td><td>The name given to the newly created instance of this model. If empty, the "name" attribute from the model tag will be used. </td></tr>
    <tr><td class="paramname">package_map</td><td>An object that maps ROS packages to their full pathnames. </td></tr>
    <tr><td class="paramname">plant</td><td>A pointer to a mutable <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> object to which the model will be added. </td></tr>
    <tr><td class="paramname">scene_graph</td><td>A pointer to a mutable SceneGraph object used for geometry registration (either to model visual or contact geometry). May be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The model instance index for the newly added model. </dd></dl>

</div>
</div>
<a id="a649bcddcef956bac71a3420b890d4c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649bcddcef956bac71a3420b890d4c15">&#9670;&nbsp;</a></span>AddModelFromUrdfFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> AddModelFromUrdfFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>plant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>scene_graph</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a <code>&lt;robot&gt;</code> element from the URDF file specified by <code>file_name</code> and adds it to <code>plant</code>. </p>
<p>A new model instance will be added to <code>plant</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the file is not in accordance with the URDF specification. The exception contains a message with a list of errors encountered while parsing the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>The name of the URDF file to be parsed. </td></tr>
    <tr><td class="paramname">model_name</td><td>The name given to the newly created instance of this model. If empty, the "name" attribute from the model tag will be used. </td></tr>
    <tr><td class="paramname">plant</td><td>A pointer to a mutable <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> object to which the model will be added. </td></tr>
    <tr><td class="paramname">scene_graph</td><td>A pointer to a mutable SceneGraph object used for geometry registration (either to model visual or contact geometry). May be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The model instance index for the newly added model. </dd></dl>

</div>
</div>
<a id="adce5c2ee07186c7d8bc5fa96eafaf16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce5c2ee07186c7d8bc5fa96eafaf16e">&#9670;&nbsp;</a></span>AddModelsFromSdfFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; AddModelsFromSdfFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>plant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>scene_graph</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses all <code>&lt;model&gt;</code> elements from the SDF file specified by <code>file_name</code> and adds them to <code>plant</code>. </p>
<p>The SDF file can contain multiple <code>&lt;model&gt;</code> elements. New model instances will be added to <code>plant</code> for each <code>&lt;model&gt;</code> tag in the SDF file.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the file is not in accordance with the SDF specification containing a message with a list of errors encountered while parsing the file. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the file contains no models. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if plant is nullptr or if <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">MultibodyPlant::Finalize()</a> was already called on <code>plant</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>The name of the SDF file to be parsed. </td></tr>
    <tr><td class="paramname">plant</td><td>A pointer to a mutable <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> object to which the model will be added. </td></tr>
    <tr><td class="paramname">package_map</td><td>An object that maps ROS packages to their full pathnames. </td></tr>
    <tr><td class="paramname">scene_graph</td><td>A pointer to a mutable SceneGraph object used for geometry registration (either to model visual or contact geometry). May be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of model instance indices for the newly added models. </dd></dl>

</div>
</div>
<a id="a608679d0c67322dbcd5dab58c36e8c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608679d0c67322dbcd5dab58c36e8c05">&#9670;&nbsp;</a></span>default_friction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; drake::multibody::detail::default_friction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default value of the Coulomb's law coefficients of friction for when they are not specified in the URDF/SDF file. </p>

</div>
</div>
<a id="abbf95e07a12bc0b8f407eb2bdf279eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf95e07a12bc0b8f407eb2bdf279eee">&#9670;&nbsp;</a></span>GetFullPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetFullPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the full path of . </p>
<p>If <code>file_name</code> is already a full path (i.e., it starts with a "/"), the path is not modified. If <code>file_name</code> is a relative path, this method converts it into an absolute path based on the current working directory.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the file does not exist or if <code>file_name</code> is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af48445aa248ebb7363d2a3be05f7c17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48445aa248ebb7363d2a3be05f7c17a">&#9670;&nbsp;</a></span>MakeCoulombFrictionFromSdfCollisionOde()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; MakeCoulombFrictionFromSdfCollisionOde </td>
          <td>(</td>
          <td class="paramtype">const sdf::Collision &amp;&#160;</td>
          <td class="paramname"><em>sdf_collision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the material properties from the given sdf::Visual object. </p>
<p>The sdf::Visual object represents a corresponding &lt;visual&gt; tag from an SDF file. The material properties are placed into a <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role. ">geometry::IllustrationProperties</a> as follows:</p>
<table class="doxtable">
<tr>
<th align="center">Group </th><th align="center">Name </th><th align="center">Type </th><th align="left">Description  </th></tr>
<tr>
<td align="center">phong </td><td align="center">diffuse </td><td align="center">Vector4&lt;double&gt; </td><td align="left">The normalized rgba values for the diffuse color </td></tr>
<tr>
<td align="center">phong </td><td align="center">ambient </td><td align="center">Vector4&lt;double&gt; </td><td align="left">The normalized rgba values for the ambient color </td></tr>
<tr>
<td align="center">phong </td><td align="center">specular </td><td align="center">Vector4&lt;double&gt; </td><td align="left">The normalized rgba values for the specular color </td></tr>
<tr>
<td align="center">phong </td><td align="center">emissive </td><td align="center">Vector4&lt;double&gt; </td><td align="left">The normalized rgba values for the emissive color </td></tr>
</table>
<p>These are properties to be used in the <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">Phong lighting model</a> and are taken from the similarly named property tags (see below). If any of <code>ambient</code>, <code>diffuse</code>, <code>specular</code>, or <code>emissive</code> tags are missing, that property will be omitted from the property set and the impact of those missing properties will depend on the downstream consumers documented handling of missing parameters.</p>
<p>The material properties come from the child &lt;material&gt; tag. E.g., </p><div class="fragment"><div class="line">&lt;<span class="keywordtype">visual</span>&gt;</div><div class="line">  &lt;<span class="keywordtype">geometry</span>&gt;</div><div class="line">  ...</div><div class="line">  &lt;/<span class="keywordtype">geometry</span>&gt;</div><div class="line">  &lt;<span class="keywordtype">material</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">ambient</span>&gt;<span class="keyword">r_a</span> <span class="keyword">g_a</span> <span class="keyword">b_a</span> <span class="keyword">a_a</span>&lt;/<span class="keywordtype">ambient</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">diffuse</span>&gt;<span class="keyword">r_d</span> <span class="keyword">g_d</span> <span class="keyword">b_d</span> <span class="keyword">a_d</span>&lt;/<span class="keywordtype">diffuse</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">specular</span>&gt;<span class="keyword">r_s</span> <span class="keyword">g_s</span> <span class="keyword">b_s</span> <span class="keyword">a_s</span>&lt;/<span class="keywordtype">specular</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">emissive</span>&gt;<span class="keyword">r_e</span> <span class="keyword">g_e</span> <span class="keyword">b_e</span> <span class="keyword">a_e</span>&lt;/<span class="keywordtype">emissive</span>&gt;</div><div class="line">  &lt;/<span class="keywordtype">material</span>&gt;</div><div class="line">&lt;/<span class="keywordtype">visual</span>&gt;</div></div><!-- fragment --><p>An instance of <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role. ">geometry::IllustrationProperties</a> will always be returned. If there is no material tag, no material property tags, or no successfully parsed material property tags, the property set will be empty. */ <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role. ">geometry::IllustrationProperties</a> MakeVisualPropertiesFromSdfVisual( const sdf::Visual&amp; sdf_visual);</p>
<p>/** Given <code>sdf_collision</code> stemming from the parsing of a <code>&lt;collision&gt;</code> element in an SDF file, this method makes the pose <code>X_LG</code> of frame G for the geometry of that collision element in the frame L of the link it belongs to. */ Eigen::Isometry3d MakeGeometryPoseFromSdfCollision( const sdf::Collision&amp; sdf_collision);</p>
<p>/** Parses friction coefficients from <code>sdf_collision</code>. This method looks for the definitions specific to ODE, as given by the SDF specification in <code>&lt;collision&gt;&lt;surface&gt;&lt;friction&gt;&lt;ode&gt;</code>. Drake understands <code>&lt;mu&gt;</code> as the static coefficient of friction and <code>&lt;mu2&gt;</code> as the dynamic coefficient of friction. Consider the example below: </p><div class="fragment"><div class="line">&lt;<span class="keywordtype">collision</span>&gt;</div><div class="line">  &lt;<span class="keywordtype">surface</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">friction</span>&gt;</div><div class="line">      &lt;<span class="keywordtype">ode</span>&gt;</div><div class="line">        &lt;<span class="keywordtype">mu</span>&gt;0.8&lt;/<span class="keywordtype">mu</span>&gt;</div><div class="line">        &lt;<span class="keywordtype">mu2</span>&gt;0.3&lt;/<span class="keywordtype">mu2</span>&gt;</div><div class="line">      &lt;/<span class="keywordtype">ode</span>&gt;</div><div class="line">    &lt;/<span class="keywordtype">friction</span>&gt;</div><div class="line">  &lt;/<span class="keywordtype">surface</span>&gt;</div><div class="line">&lt;/<span class="keywordtype">collision</span>&gt;</div></div><!-- fragment --><p> If a <code>&lt;surface&gt;</code> is not found, it returns the coefficients for a frictionless surface. If <code>&lt;surface&gt;</code> is found, all other nested elements are required and an exception is thrown if not present. </p>

</div>
</div>
<a id="a5b3676511637c127d84a8bb589d2d90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3676511637c127d84a8bb589d2d90f">&#9670;&nbsp;</a></span>MakeGeometryInstanceFromSdfVisual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a> &gt; MakeGeometryInstanceFromSdfVisual </td>
          <td>(</td>
          <td class="paramtype">const sdf::Visual &amp;&#160;</td>
          <td class="paramname"><em>sdf_visual</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an sdf::Visual object representing a &lt;visual&gt; element from an SDF file, this method makes a new <a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html" title="A geometry instance combines a geometry definition (i.e., a shape of some sort), a pose (relative to ...">drake::geometry::GeometryInstance</a> object from this specification. </p>
<p>This method returns nullptr when the given SDF specification corresponds to a geometry of type <code>sdf::GeometryType::EMPTY</code> (&lt;empty&gt; SDF tag.) </p>

</div>
</div>
<a id="aa0b6dac0a30dc27eaec653be4cd81056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b6dac0a30dc27eaec653be4cd81056">&#9670;&nbsp;</a></span>MakeGeometryPoseFromSdfCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Isometry3d drake::multibody::detail::MakeGeometryPoseFromSdfCollision </td>
          <td>(</td>
          <td class="paramtype">const sdf::Collision &amp;&#160;</td>
          <td class="paramname"><em>sdf_collision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdd3120d8bd21b09aca3fb1a3862d6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd3120d8bd21b09aca3fb1a3862d6e5">&#9670;&nbsp;</a></span>MakeShapeFromSdfGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &gt; MakeShapeFromSdfGeometry </td>
          <td>(</td>
          <td class="paramtype">const sdf::Geometry &amp;&#160;</td>
          <td class="paramname"><em>sdf_geometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an sdf::Geometry object representing a &lt;geometry&gt; element from an SDF file, this method makes a new <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications. ">drake::geometry::Shape</a> object from this specification. </p>
<p>For <code>sdf_geometry.Type() == sdf::GeometryType::EMPTY</code>, corresponding to the &lt;empty&gt; SDF tag, it returns <code>nullptr</code>. </p>

</div>
</div>
<a id="af8d595f48e91553a7233e3ee984bae4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d595f48e91553a7233e3ee984bae4d">&#9670;&nbsp;</a></span>MakeVisualPropertiesFromSdfVisual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">IllustrationProperties</a> drake::multibody::detail::MakeVisualPropertiesFromSdfVisual </td>
          <td>(</td>
          <td class="paramtype">const sdf::Visual &amp;&#160;</td>
          <td class="paramname"><em>sdf_visual</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3cccf8ea14d8d14818d324fd09db242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cccf8ea14d8d14818d324fd09db242">&#9670;&nbsp;</a></span>OriginAttributesToTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Isometry3d OriginAttributesToTransform </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses "xyz" and "rpy" attributes from <code>node</code> and returns an Isometry3d created from them. </p>
<p>If either the "xyz" or "rpy" attributes are omitted they will be initialized with zero values.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the "xyz" or "rpy" attributes are malformed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a724205e29d47df8834fd20f321dcab47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724205e29d47df8834fd20f321dcab47">&#9670;&nbsp;</a></span>ParseCollision() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a> drake::multibody::detail::ParseCollision </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parent_element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>friction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a "collision" element in <code>node</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent_element_name</td><td>The name of the parent link element, used to construct default geometry names and for error reporting. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">friction</td><td>Coulomb friction for the associated geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfd7c3fc2c9b82ab5ce5d69929b2a0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd7c3fc2c9b82ab5ce5d69929b2a0c0">&#9670;&nbsp;</a></span>ParseCollision() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a> drake::multibody::detail::ParseCollision </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parent_element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>friction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9388f6fabb4d8f8bac2ef3321570cd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9388f6fabb4d8f8bac2ef3321570cd33">&#9670;&nbsp;</a></span>ParseMaterial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::multibody::detail::ParseMaterial </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *&#160;</td>
          <td class="paramname"><em>materials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a "material" element in <code>node</code> and adds the result to <code>materials</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the material is missing required attributes or if it was already defined with different properties. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad356633711e262750a3e5490373c9dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad356633711e262750a3e5490373c9dc9">&#9670;&nbsp;</a></span>ParseMaterial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::multibody::detail::ParseMaterial </td>
          <td>(</td>
          <td class="paramtype">const XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *&#160;</td>
          <td class="paramname"><em>materials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8addd4deaf7393247738c4099dff88ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8addd4deaf7393247738c4099dff88ce">&#9670;&nbsp;</a></span>ParseScalarAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParseScalarAttribute </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a scalar attribute of <code>node</code> named <code>attribute_name</code> into <code>val</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>false if the attribute is not present</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the attribute doesn't contain a single numeric value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ffa8aaeb73c0156e955ed126d012e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffa8aaeb73c0156e955ed126d012e7a">&#9670;&nbsp;</a></span>ParseStringAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParseStringAttribute </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a string attribute of <code>node</code> named <code>attribute_name</code> into <code>val</code>. </p>
<p>If the attribute is not present, <code>val</code> will be cleared.</p>
<dl class="section return"><dt>Returns</dt><dd>false if the attribute is not present </dd></dl>

</div>
</div>
<a id="a27d43126f7596ab1e3a48016e29a07d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d43126f7596ab1e3a48016e29a07d2">&#9670;&nbsp;</a></span>ParseThreeVectorAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParseThreeVectorAttribute </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a three vector value from parameter <code>node</code>, which is an XML node. </p>
<p>Parses a three vector value from parameter <code>node</code>, which is an XML node.</p>
<p>The value is specified by an attribute within the XML whose name is apecified by parameter <code>attribute_name</code>. This method also supports a three vector specified by a single scalar value, which it automatically converts into a three vector by using the same scalar value for all three dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A pointer to the XML element node that contains an attribute with a three vector or a scalar value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute_name</td><td>The name of the attribute containing the three vector or scalar value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">val</td><td>The three vector where the results should be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the attribute is not present</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If any problem is encountered parsing the three vector value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac40a8c6836f446facd11fca258f18453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40a8c6836f446facd11fca258f18453">&#9670;&nbsp;</a></span>ParseVectorAttribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParseVectorAttribute </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses an attribute of <code>node</code> named <code>attribute_name</code> consisting of 3 scalar values into <code>val</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>false if the attribute is not present</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the attribute doesn't contain three numeric values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64d7ab8ac8103f1eec39cbc658b6b17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d7ab8ac8103f1eec39cbc658b6b17b">&#9670;&nbsp;</a></span>ParseVectorAttribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParseVectorAttribute </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4d *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses an attribute of <code>node</code> named <code>attribute_name</code> consisting of 4 scalar values into <code>val</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>false if the attribute is not present</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the attribute doesn't contain four numeric values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e7ef4dbbc2295a741d1187ca9510fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7ef4dbbc2295a741d1187ca9510fb7">&#9670;&nbsp;</a></span>ParseVisual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a> drake::multibody::detail::ParseVisual </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parent_element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *&#160;</td>
          <td class="paramname"><em>materials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a "visual" element in <code>node</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent_element_name</td><td>The name of the parent link element, used to construct default geometry names and for error reporting. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">materials</td><td>The MaterialMap is used to look up materials which are referenced by name only in the visual element. New materials which are specified by both color and name will be added to the map and can be used by later visual elements. Material definitions may be repeated if the material properties are identical. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa62d7a57d1a48218cfef64ce902f56c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62d7a57d1a48218cfef64ce902f56c7">&#9670;&nbsp;</a></span>ParseVisual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a> drake::multibody::detail::ParseVisual </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parent_element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *&#160;</td>
          <td class="paramname"><em>materials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa66c24a3cf7f43c19d678a06eb616141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66c24a3cf7f43c19d678a06eb616141">&#9670;&nbsp;</a></span>ResolveUri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ResolveUri </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolves the full path of a URI. </p>
<p>If <code>uri</code> starts with "package:" or "model:", the ROS packages specified in <code>package_map</code> are searched. Otherwise, <code>uri</code> is appended to the end of <code>root_dir</code> (if it's not already an absolute path) and checked for existence. If the file does not exist or is not found, a warning is printed to <code>std::cerr</code> and an empty string is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uri</td><td>The name of the resource to find.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">package_map</td><td>A map where the keys are ROS package names and the values are the paths to the packages. This is only used if <code>filename</code> starts with "package:"or "model:".</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_dir</td><td>The root directory to look in. This is only used when <code>filename</code> does not start with "package:".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file's full path or an empty string if the file is not found or does not exist. </dd></dl>

</div>
</div>
<a id="abf0ffe5867d6427daab52ff5b28470c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0ffe5867d6427daab52ff5b28470c7">&#9670;&nbsp;</a></span>ResolveVisualUri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sdf::Visual ResolveVisualUri </td>
          <td>(</td>
          <td class="paramtype">const sdf::Visual &amp;&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_package_map.html">multibody::PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an sdf::Visual object representing a &lt;visual&gt; element from an SDF file, this method makes a new Visual object which resolves the uri for the mesh element, if present. </p>
<p>If the mesh element is not present, the new object will be identical to the original. See parsers::ResolveFilename() for more detail on this operation.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the &lt;mesh&gt; tag is present but missing &lt;uri&gt; or if the file referenced in &lt;uri&gt; can not be found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad13dbb8038dd521c47b627fee0f1c8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13dbb8038dd521c47b627fee0f1c8f8">&#9670;&nbsp;</a></span>ToIsometry3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Isometry3d ToIsometry3 </td>
          <td>(</td>
          <td class="paramtype">const ignition::math::Pose3d &amp;&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to express an ignition::math::Pose3d instance as an Isometry3d instance. </p>

</div>
</div>
<a id="a0eca6e02e85ffc38a4d5dcd6ad52a07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eca6e02e85ffc38a4d5dcd6ad52a07d">&#9670;&nbsp;</a></span>ToVector3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d ToVector3 </td>
          <td>(</td>
          <td class="paramtype">const ignition::math::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to express an ignition::math::Vector3d instance as a Vector3d instance. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody_1_1detail.html">detail</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
