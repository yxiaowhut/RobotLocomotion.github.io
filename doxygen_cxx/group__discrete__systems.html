<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Discrete Systems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__discrete__systems.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Discrete Systems<div class="ingroups"><a class="el" href="group__systems.html">Modeling Dynamical Systems</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p>This page describes discrete systems modeled by difference equations (contrast to continuous systems modeled by ordinary differential equations) as well as considerations for implementing these systems in Drake. </p>
<p>The state space dynamics of a discrete system is: </p><div class="fragment"><div class="line">xₙ₊₁ = f(n, xₙ, uₙ)    <span class="comment">// update</span></div><div class="line">yₙ   = g(n, xₙ, uₙ)    <span class="comment">// output</span></div><div class="line">x₀   = xᵢₙᵢₜ           <span class="comment">// initialize</span></div></div><!-- fragment --><p>where n ∈ ℕ is the step number (typically starting at zero), x is the discrete state variable ("discrete" refers to the countability of the elements of the sequence, x₀, x₁, ..., xₙ and not the values that x can take), y is the desired output, and u is an external input. f(.) and g(.) are the <em>update</em> and <em>output</em> functions, respectively. Any of these quantities can be vector-valued. The subscript notation (e.g., x₀) is used to show that the state, input, and output result from a discrete process. We use square bracket notation, e.g. x[1] to designate particular elements of a vector-valued quantity (indexing from 0). Combined, x₁[3] would be the value of the fourth element of the x vector, evaluated at step n=1. In code we use a Latex-like underscore to indicate the step number, so we write x_1[3] to represent x₁[3].</p>
<h3>A pedagogical example: simple difference equation</h3>
<p>The following class implements in Drake the simple discrete system </p><div class="fragment"><div class="line">xₙ₊₁ = xₙ + 1</div><div class="line">yₙ   = 10 xₙ</div><div class="line">x₀   = 0</div></div><!-- fragment --><p> which should generate the sequence <code>S = 0 10 20 30 ...</code> (that is, <code>Sₙ = 10*n</code>).</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ExampleDiscreteSystem : <span class="keyword">public</span> LeafSystem&lt;double&gt; {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="drake__copyable_8h.html#a3ee22789c29a46dddd6a7fd2b982731c">DRAKE_NO_COPY_NO_MOVE_NO_ASSIGN</a>(ExampleDiscreteSystem)</div><div class="line"></div><div class="line">  ExampleDiscreteSystem() {</div><div class="line">    DeclareDiscreteState(1);  <span class="comment">// Just one state variable, x[0], default=0.</span></div><div class="line"></div><div class="line">    <span class="comment">// Output yₙ using a Drake &quot;publish&quot; event (occurs at the end of step n).</span></div><div class="line">    DeclarePeriodicEvent(<a class="code" href="simulator__test_8cc.html#ad1cb8167f82ff91a28f440ec40cda1db">kPeriod</a>, kOffset,</div><div class="line">                         systems::PublishEvent&lt;double&gt;(</div><div class="line">                             [<span class="keyword">this</span>](<span class="keyword">const</span> systems::Context&lt;double&gt;&amp; context,</div><div class="line">                                    <span class="keyword">const</span> systems::PublishEvent&lt;double&gt;&amp;) {</div><div class="line">                               PrintResult(context);</div><div class="line">                             }));</div><div class="line"></div><div class="line">    <span class="comment">// Update to xₙ₊₁, using a Drake &quot;discrete update&quot; event (occurs at the</span></div><div class="line">    <span class="comment">// beginning of step n+1).</span></div><div class="line">    DeclarePeriodicEvent(<a class="code" href="simulator__test_8cc.html#ad1cb8167f82ff91a28f440ec40cda1db">kPeriod</a>, kOffset,</div><div class="line">                         systems::DiscreteUpdateEvent&lt;double&gt;(</div><div class="line">                             [<span class="keyword">this</span>](<span class="keyword">const</span> systems::Context&lt;double&gt;&amp; context,</div><div class="line">                                    <span class="keyword">const</span> systems::DiscreteUpdateEvent&lt;double&gt;&amp;,</div><div class="line">                                    systems::DiscreteValues&lt;double&gt;* xd) {</div><div class="line">                               Update(context, xd);</div><div class="line">                             }));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">double</span> <a class="code" href="simulator__test_8cc.html#ad1cb8167f82ff91a28f440ec40cda1db">kPeriod</a> = 1/50.;  <span class="comment">// Update at 50Hz (h=1/50).</span></div><div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">double</span> kOffset = 0.;  <span class="comment">// Trigger events at n=0.</span></div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Update function xₙ₊₁ = f(n, xₙ).</span></div><div class="line">  <span class="keywordtype">void</span> Update(<span class="keyword">const</span> systems::Context&lt;double&gt;&amp; context,</div><div class="line">              systems::DiscreteValues&lt;double&gt;* xd)<span class="keyword"> const </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x_n = GetX(context);</div><div class="line">    (*xd)[0] = x_n + 1.;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Prints the result of output function yₙ = g(n, xₙ) to cout.</span></div><div class="line">  <span class="keywordtype">void</span> PrintResult(<span class="keyword">const</span> systems::Context&lt;double&gt;&amp; context)<span class="keyword"> const </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> t = context.get_time();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> n = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<a class="code" href="namespace_eigen.html#ac1217be143aca68b33af6812033c4656">std::round</a>(t / kPeriod));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> S_n = 10 * GetX(context);  <span class="comment">// 10 xₙ[0]</span></div><div class="line">    std::cout &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; S_n &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> GetX(<span class="keyword">const</span> Context&lt;double&gt;&amp; context)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> context.get_discrete_state()[0];</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>Stepping this system forward using the following code fragment: </p><div class="fragment"><div class="line">ExampleDiscreteSystem system;</div><div class="line">Simulator&lt;double&gt; simulator(system);</div><div class="line">simulator.StepTo(3 * <a class="code" href="simulator__test_8cc.html#ad1cb8167f82ff91a28f440ec40cda1db">ExampleDiscreteSystem::kPeriod</a>);</div></div><!-- fragment --><p> yields the following output: </p><div class="fragment"><div class="line">0: 0 (0)</div><div class="line">1: 10 (0.02)</div><div class="line">2: 20 (0.04)</div><div class="line">3: 30 (0.06)</div></div><!-- fragment --><h3>Modeling discrete systems in Drake's hybrid systems framework</h3>
<p>Purely-discrete systems produce values only intermittently. For example, the system above generates values only at integer values of n: </p><pre></pre><pre>     yₙ
      |
   30 |              ●
      |              ┆             Figure 1. The discrete-valued system
   20 |         ●    ┆             from the example above.
      |         ┆    ┆
   10 |    ●    ┆    ┆
      |    ┆    ┆    ┆
    0 ●----+----+----+--
      0    1    2    3   n
      +----+----+----+--
      0   .02  .04  .06  t
</pre><p>Drake's simulator is for hybrid systems, that is, systems that advance through <em>time</em>, and evolve in time both continuously (flow) and discretely (jump). It is easy enough to use time to represent the discrete steps n, by the conversion <code>t=n*h</code> where h is a periodic sampling time. In Figure 1 we've shown the conversion to time used by the example above as a second horizontal axis, assuming h=0.02 seconds.</p>
<p>However, since Drake simulations advance through <em>continuous</em> time, it must be possible to obtain the values of all state variables and outputs at <em>any</em> time t, not just at discrete times. So the question arises: what is the value of y(t) for values of t in between the sample times shown above? The answer doesn't matter for the example above, but becomes significant when we mix continuous and discrete systems, since they are typically interdependent.</p>
<p>Sample-and-hold is the most common way to go from a discrete value to a continuous one. There are two equally-plausible ways to use sample-and-hold to fill in the gaps between the discrete sample times above, shown in Figure 2: </p><pre></pre><pre>      y(t)             ●━                    y(t)
        |              ┆                       |
     30 |         ●━━━━○                    30 |              ●━
        |         ┆                            |              ┆
     20 |    ●━━━━○                         20 |         ●━━━━○
        |    ┆                                 |         ┆
     10 ●━━━━○                              10 |    ●━━━━○
        ┆                                      |    ┆
      0 ○----+----+----+-- t                 0 ●━━━━○----+----+-- t
        0   .02  .04  .06                      0   .02  .04  .06</pre><pre>   (a) Sample at start of step.           (b) Sample at end of step.
       (Drake uses this method.)              (Not used in Drake.)</pre><pre>          Figure 2: two ways to make a continuous function from
          a discrete one, using sample-and-hold.
</pre><p> In the figure, the ○ markers show the function value at time t <em>before</em> the update function is invoked, while the ● markers show the value <em>after</em> the update. In (a), the ○ markers coincide with the original discrete values, while in (b), the ● markers do.</p>
<p>You might expect that 2(b) would be the most natural mapping from the discrete system to a continuous one. In practice, however, it is problematic for mixed discrete/continuous (hybrid) systems so Drake uses the mapping in 2(a). The advantage of 2(a) is that the hybrid update function <code>xₙ₊₁ = f(t,n,xₙ,u(t))</code> is invoked at time <code>t=n*h</code>, while in 2(b) it would be invoked at time <code>t=(n+1)*h</code>. That would make it difficult to coordinate discrete and continuous signals.</p>
<p>Drake's choice of 2(a) dictates what value a discrete quantity will have when evaluated at times <em>between</em> update times. In particular, consider a discrete variable x evaluated during a simulation from a publish, update, or derivative function at times <code>t ∈ (n*h, (n+1)*h]</code>. x will be seen to have value <code>x(t) = xₙ₊₁</code> (<em>not</em> <code>xₙ</code>). You can see that clearly by inspection of Figure 2(a).</p>
<h3>Timing of publish vs. discrete update events in Drake</h3>
<p>A discrete system viewed in continuous time does not have a unique value at its sample times. In Figure 2, each pair of ○ and ● symbols shows two possible values at the same time. For a given sample time t, we use the notation x⁻(t) to denote the "pre-update" value of the state x, and x⁺(t) to denote the "post-update" value of x. So x⁻(t) is the value of x at time t <em>before</em> discrete variables are updated, and x⁺(t) the value of x at time t <em>after</em> they are updated. Thus if we have <code>t = n*h</code> as in the discussion above, then <code>x⁻(t) = xₙ</code> and <code>x⁺(t) = xₙ₊₁</code>. State-dependent computations are affected by the scheduling of these updates. For example, evaluating an input u(t) yields u⁻(t) before discrete updates, and u⁺(t) afterwards, meaning that the input evaluation is carried out using x⁻(t) or x⁺(t), respectively.</p>
<p>With those distinctions drawn, we can define Drake's state update behavior during a time step:</p><ul>
<li><code>Publish</code> events at time t see x⁻(t), so if a publish event handler evaluates an input it sees u⁻(t). This occurs at the end of a step, shown as ○ markers in Figure 2.</li>
<li><code>Update</code> events (of all kinds) at time t also see x⁻(t) and u⁻(t), and produce x⁺(t). This occurs at the start of the next step, shown as ● markers in Figure 2.</li>
<li><code>Continuous</code> update (numerical integration and time advancement) starts with x⁺(t). Input and derivative evaluations will occur repeatedly as the time and continuous state advance. Each evaluation will be performed using updated values for continuous states xc and time. However, the discrete variables (state partitions xd and xa) are held constant at their x⁺(t) values, that is, at xd⁺(t) and xa⁺(t).</li>
</ul>
<p>If you define periodic events starting at t=0 as we did in the example above, the first publish event occurs at the end of initialization, while the first discrete update event occurs at the beginning of the first step, followed by continuous time and state advancement.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">drake::systems::Simulator</a> for more details. </dd></dl>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
