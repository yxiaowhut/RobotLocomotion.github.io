<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: ArticulatedBodyInertia&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_articulated_body_inertia.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdrake_1_1multibody_1_1_articulated_body_inertia-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ArticulatedBodyInertia&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><em>Articulated Body Inertia</em> is the inertia that a body appears to have when it is the base (or root) of a rigid-body system, also referred to as <em>Articulated Body</em> in the context of articulated body algorithms.  
 <a href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#details">More...</a></p>

<p><code>#include &lt;drake/multibody/tree/articulated_body_inertia.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a789bb634fbbbc0569e5e9c59584b3657"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#a789bb634fbbbc0569e5e9c59584b3657">ArticulatedBodyInertia</a> ()=default</td></tr>
<tr class="memdesc:a789bb634fbbbc0569e5e9c59584b3657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a> constructor initializes all matrix values to NaN for a quick detection of uninitialized values.  <a href="#a789bb634fbbbc0569e5e9c59584b3657">More...</a><br /></td></tr>
<tr class="separator:a789bb634fbbbc0569e5e9c59584b3657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508691682062b23625c4b3f75a134709"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#a508691682062b23625c4b3f75a134709">ArticulatedBodyInertia</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;M_SQ_E)</td></tr>
<tr class="memdesc:a508691682062b23625c4b3f75a134709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an articulated body inertia for an articulated body consisting of a single rigid body given its spatial inertia.  <a href="#a508691682062b23625c4b3f75a134709">More...</a><br /></td></tr>
<tr class="separator:a508691682062b23625c4b3f75a134709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb919c29ad40fcea2d070cd32f8ff854"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:acb919c29ad40fcea2d070cd32f8ff854"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#acb919c29ad40fcea2d070cd32f8ff854">ArticulatedBodyInertia</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:acb919c29ad40fcea2d070cd32f8ff854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an articulated body inertia from an input matrix.  <a href="#acb919c29ad40fcea2d070cd32f8ff854">More...</a><br /></td></tr>
<tr class="separator:acb919c29ad40fcea2d070cd32f8ff854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cac09c2a7846e47cfd12ac939882d67"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a5cac09c2a7846e47cfd12ac939882d67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#a5cac09c2a7846e47cfd12ac939882d67">cast</a> () const</td></tr>
<tr class="memdesc:a5cac09c2a7846e47cfd12ac939882d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new ArticulatedBodyInertia object templated on <code>Scalar</code> with casted values of <code>this</code> articulated body inertia.  <a href="#a5cac09c2a7846e47cfd12ac939882d67">More...</a><br /></td></tr>
<tr class="separator:a5cac09c2a7846e47cfd12ac939882d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4218b7c32aa0b01cb0b9a6c2dc44a16"><td class="memTemplParams" colspan="2">template&lt;typename T1  = T&gt; </td></tr>
<tr class="memitem:aa4218b7c32aa0b01cb0b9a6c2dc44a16"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt; T1 &gt;::is_bool, <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#aa4218b7c32aa0b01cb0b9a6c2dc44a16">IsPhysicallyValid</a> () const</td></tr>
<tr class="memdesc:aa4218b7c32aa0b01cb0b9a6c2dc44a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a number of checks to verify that this is a physically valid articulated body inertia.  <a href="#aa4218b7c32aa0b01cb0b9a6c2dc44a16">More...</a><br /></td></tr>
<tr class="separator:aa4218b7c32aa0b01cb0b9a6c2dc44a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1bd7b221e380e1bac184d3792abf5f"><td class="memTemplParams" colspan="2">template&lt;typename T1  = T&gt; </td></tr>
<tr class="memitem:a7d1bd7b221e380e1bac184d3792abf5f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt; T1 &gt;::is_bool, <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#a7d1bd7b221e380e1bac184d3792abf5f">IsPhysicallyValid</a> () const</td></tr>
<tr class="memdesc:a7d1bd7b221e380e1bac184d3792abf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#aa4218b7c32aa0b01cb0b9a6c2dc44a16" title="Performs a number of checks to verify that this is a physically valid articulated body inertia...">IsPhysicallyValid()</a> for non-numeric scalar types is not supported.  <a href="#a7d1bd7b221e380e1bac184d3792abf5f">More...</a><br /></td></tr>
<tr class="separator:a7d1bd7b221e380e1bac184d3792abf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413ff91e8caf0498a96e5b1e06da9cd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#a413ff91e8caf0498a96e5b1e06da9cd1">CopyToFullMatrix6</a> () const</td></tr>
<tr class="memdesc:a413ff91e8caf0498a96e5b1e06da9cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy to a full 6x6 matrix representation.  <a href="#a413ff91e8caf0498a96e5b1e06da9cd1">More...</a><br /></td></tr>
<tr class="separator:a413ff91e8caf0498a96e5b1e06da9cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4bcc3ca011dbb3e484ebb19ce7faa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#a9b4bcc3ca011dbb3e484ebb19ce7faa5">ShiftInPlace</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QR_E)</td></tr>
<tr class="memdesc:a9b4bcc3ca011dbb3e484ebb19ce7faa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>this</code> articulated body inertia <code>P_AQ_E</code> for some articulated body A, computed about point Q, and expressed in frame E, this method uses the rigid body shift operator to compute the same articulated body inertia about a new point R.  <a href="#a9b4bcc3ca011dbb3e484ebb19ce7faa5">More...</a><br /></td></tr>
<tr class="separator:a9b4bcc3ca011dbb3e484ebb19ce7faa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2a3ad9747df360ab2ccfebe5a2e55b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#a4a2a3ad9747df360ab2ccfebe5a2e55b">Shift</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QR_E) const</td></tr>
<tr class="memdesc:a4a2a3ad9747df360ab2ccfebe5a2e55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>this</code> articulated body inertia <code>P_AQ_E</code> for some articulated body A, computed about point Q, and expressed in frame E, this method uses the rigid body shift operator to compute the same articulated body inertia about a new point R.  <a href="#a4a2a3ad9747df360ab2ccfebe5a2e55b">More...</a><br /></td></tr>
<tr class="separator:a4a2a3ad9747df360ab2ccfebe5a2e55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148bc958b5d02693bd0136917046b68e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#a148bc958b5d02693bd0136917046b68e">operator+=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt; T &gt; &amp;P_BQ_E)</td></tr>
<tr class="memdesc:a148bc958b5d02693bd0136917046b68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds in to this articulated body inertia <code>P_AQ_E</code> for an articulated body A about a point Q and expressed in a frame E the articulated body inertia <code>P_BQ_E</code> for a second articulated body B about the same point Q and expressed in the same frame E.  <a href="#a148bc958b5d02693bd0136917046b68e">More...</a><br /></td></tr>
<tr class="separator:a148bc958b5d02693bd0136917046b68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3565c4b5cbe9be575d03ebd4b99327"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:afe3565c4b5cbe9be575d03ebd4b99327"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::Product&lt; Eigen::SelfAdjointView&lt; const <a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt; T &gt;, Eigen::Lower &gt;, OtherDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#afe3565c4b5cbe9be575d03ebd4b99327">operator*</a> (const Eigen::MatrixBase&lt; OtherDerived &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:afe3565c4b5cbe9be575d03ebd4b99327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> articulated body inertia on the right by a matrix or vector.  <a href="#afe3565c4b5cbe9be575d03ebd4b99327">More...</a><br /></td></tr>
<tr class="separator:afe3565c4b5cbe9be575d03ebd4b99327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:ab1114b94d5f66d6df3605856fa2c6cc6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#ab1114b94d5f66d6df3605856fa2c6cc6">ArticulatedBodyInertia</a> (const <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a> &amp;)=default</td></tr>
<tr class="separator:ab1114b94d5f66d6df3605856fa2c6cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589e7341c3eeb0ac0c4c71c57c03e8ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#a589e7341c3eeb0ac0c4c71c57c03e8ce">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a> &amp;)=default</td></tr>
<tr class="separator:a589e7341c3eeb0ac0c4c71c57c03e8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bea6e19974f4c24d747976ada0efef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#a05bea6e19974f4c24d747976ada0efef">ArticulatedBodyInertia</a> (<a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a05bea6e19974f4c24d747976ada0efef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47d1b4caefc3416208c61e09d221e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#ad47d1b4caefc3416208c61e09d221e18">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ad47d1b4caefc3416208c61e09d221e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af8b25c3b08abdc24e4de1e63ab09ef04"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:af8b25c3b08abdc24e4de1e63ab09ef04"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a></td></tr>
<tr class="separator:af8b25c3b08abdc24e4de1e63ab09ef04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf02d86e540a40456f8803150b806fa"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:accf02d86e540a40456f8803150b806fa"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::Product&lt; OtherDerived, Eigen::SelfAdjointView&lt; const <a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt; T &gt;, Eigen::Lower &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#accf02d86e540a40456f8803150b806fa">operator*</a> (const Eigen::MatrixBase&lt; OtherDerived &gt; &amp;lhs, const <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a> &amp;rhs)</td></tr>
<tr class="memdesc:accf02d86e540a40456f8803150b806fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> articulated body inertia on the left by a matrix or vector.  <a href="#accf02d86e540a40456f8803150b806fa">More...</a><br /></td></tr>
<tr class="separator:accf02d86e540a40456f8803150b806fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::ArticulatedBodyInertia&lt; T &gt;</h3>

<p><em>Articulated Body Inertia</em> is the inertia that a body appears to have when it is the base (or root) of a rigid-body system, also referred to as <em>Articulated Body</em> in the context of articulated body algorithms. </p>
<p>The <em>Articulated Body Inertia</em> is a very useful multibody dynamics concept that was introduced by Featherstone [Featherstone 1983] to develop the remarkable <code>O(n)</code> Articulated <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> Algorithm (ABA) for solving forward dynamics. Recall that the Newton-Euler equations allow us to describe the combined rotational and translational dynamics of a rigid body: </p><pre>
  F_BBo_W = M_B_W * A_WB + b_Bo_W                                    (1)
</pre><p> where the spatial inertia (see <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia. ">SpatialInertia</a>) <code>M_B_W</code> of body B expressed in the world frame W linearly relates the spatial acceleration (see <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html" title="This class is used to represent a spatial acceleration that combines rotational (angular acceleration...">SpatialAcceleration</a>) of body B in the world frame with the total applied spatial forces (see <a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html" title="This class is used to represent a spatial force (also called a wrench) that combines both rotational ...">SpatialForce</a>) <code>F_BBo</code> on body B and where <code>b_Bo_W</code> contains the velocity dependent gyroscopic terms.</p>
<p>A similar relationship is found for an articulated body with a rigid body B at the base (or root). Even though the bodies in this multibody system are allowed to have relative motions among them, there still is a linear relationship between the spatial force <code>F_BBo_W</code> applied on this body and the resulting acceleration <code>A_WB</code>: </p><pre>
  F_BBo_W = P_B_W * A_WB + z_Bo_W                                       (2)
</pre><p> where <code>P_B_W</code> is the articulated body inertia of body B and <code>z_Bo_W</code> is a bias force that includes the gyroscopic and Coriolis forces and becomes zero when all body velocities and all applied generalized forces outboard from body B are zero [Jain 2010, §7.2.1]. The articulated body inertia <code>P_B_W</code> is related to the multibody subsystem consisting only of bodies that are outboard of body B. We refer to this subsystem as the <em>articulated body subsystem</em> associated with body B. Equation (2) describes the acceleration response of body B, but also taking into account all outboard bodies connected to B. A special case is that of an articulated body composed of a single rigid body. For this special case, Eq. (2) reduces to Eq. (1) for the dynamics of rigid body B. In other words, the ABI for an articulated body consisting of a single rigid body exactly equals the spatial inertia of that body.</p>
<p>Articulated body inertias are elements of ℝ⁶ˣ⁶ that, as for spatial inertias, are symmetric and positive semi-definite. However, ABI objects <b>are not</b> spatial inertias. The spatial inertia of a rigid body can be described by a reduced set of ten parameters, namely the mass, center of mass and the six components of the rotational inertia for that body. However, this parametrization by ten parameters is just not possible for an ABI and the full 21 elements of the symmetric <code>6x6</code> matrix must be specified [Jain 2010, §6.4]. As a result ABI objects can have different properties than spatial inertia objects. As an example, the apparent mass of an articulated body will in general depend on the direction of the applied force. That is, the simple relationship <code>F = m * a</code> is no longer valid for an articulated body's center of mass (refer to the excellent example 7.1 in [Featherstone 2008]).</p>
<p>We adopt the notation introduced by [Jain 2010] and generally we will use an uppercase P to represent an ABI. Thus, in typeset material we use the symbol \( [P^{A/Q}]_E \) to represent the spatial inertia of an articulated body A, about a point Q, expressed in a frame E. For this inertia, the monogram notation reads <code>P_AQ_E</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This class does not implement any mechanism to track the frame E in which an articulated body inertia is expressed or about what point is computed. Methods and operators on this class have no means to determine frame consistency through operations. It is therefore the responsibility of users of this class to keep track of frames in which operations are performed. We suggest doing that using disciplined notation, as described above.</dd></dl>
<ul>
<li>[Featherstone 1983] Featherstone, R., 1983. The calculation of robot dynamics using articulated-body inertias. The International Journal of Robotics Research, 2(1), pp.13-30.</li>
<li>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics algorithms. Springer.</li>
<li>[Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis and algorithms. Springer Science &amp; Business Media.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The underlying scalar type. Must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar.</td></tr>
  </table>
  </dd>
</dl>
<p>Instantiated templates for the following kinds of T's are provided:</p>
<ul>
<li>double</li>
<li>AutoDiffXd</li>
</ul>
<p>They are already available to link against in the containing library. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab1114b94d5f66d6df3605856fa2c6cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1114b94d5f66d6df3605856fa2c6cc6">&#9670;&nbsp;</a></span>ArticulatedBodyInertia() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05bea6e19974f4c24d747976ada0efef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bea6e19974f4c24d747976ada0efef">&#9670;&nbsp;</a></span>ArticulatedBodyInertia() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a789bb634fbbbc0569e5e9c59584b3657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789bb634fbbbc0569e5e9c59584b3657">&#9670;&nbsp;</a></span>ArticulatedBodyInertia() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a> constructor initializes all matrix values to NaN for a quick detection of uninitialized values. </p>

</div>
</div>
<a id="a508691682062b23625c4b3f75a134709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508691682062b23625c4b3f75a134709">&#9670;&nbsp;</a></span>ArticulatedBodyInertia() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_SQ_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an articulated body inertia for an articulated body consisting of a single rigid body given its spatial inertia. </p>
<p>From an input spatial inertia <code>M_SQ_E</code> for a body or composite body S, about point Q, and expressed in a frame E, this constructor creates an articulated body inertia about the same point Q and expressed in the same frame E.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M_SQ_E</td><td>The spatial inertia of a body or composite body S about point Q and expressed in frame E. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb919c29ad40fcea2d070cd32f8ff854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb919c29ad40fcea2d070cd32f8ff854">&#9670;&nbsp;</a></span>ArticulatedBodyInertia() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an articulated body inertia from an input matrix. </p>
<p>In Debug, this constructor checks for the physical validity of the resulting ArticulatedBodyInertia with <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#aa4218b7c32aa0b01cb0b9a6c2dc44a16" title="Performs a number of checks to verify that this is a physically valid articulated body inertia...">IsPhysicallyValid()</a> and throws a std::runtime_error exception in the event the provided input matrix leads to a non-physically viable articulated body inertia.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>A matrix or matrix expression representing the articulated body inertia. Only the lower triangular region is used and the strictly upper part is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in Debug builds if <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#aa4218b7c32aa0b01cb0b9a6c2dc44a16" title="Performs a number of checks to verify that this is a physically valid articulated body inertia...">IsPhysicallyValid()</a> for <code>this</code> inertia is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5cac09c2a7846e47cfd12ac939882d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cac09c2a7846e47cfd12ac939882d67">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt;Scalar&gt; cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new ArticulatedBodyInertia object templated on <code>Scalar</code> with casted values of <code>this</code> articulated body inertia. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type on which the new articulated body inertia will be templated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a>&lt;From&gt;::cast&lt;To&gt;()</code> creates a new <code><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a>&lt;To&gt;</code> from an <code><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a>&lt;From&gt;</code> but only if type <code>To</code> is constructible from type <code>From</code>. As an example of this, <code><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a>&lt;double&gt;::cast&lt;AutoDiffXd&gt;()</code> is valid since <code>AutoDiffXd a(1.0)</code> is valid. However, <code><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a>&lt;AutoDiffXd&gt;::cast&lt;double&gt;()</code> is not. </dd></dl>

</div>
</div>
<a id="a413ff91e8caf0498a96e5b1e06da9cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413ff91e8caf0498a96e5b1e06da9cd1">&#9670;&nbsp;</a></span>CopyToFullMatrix6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt;T&gt; CopyToFullMatrix6 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy to a full 6x6 matrix representation. </p>

</div>
</div>
<a id="aa4218b7c32aa0b01cb0b9a6c2dc44a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4218b7c32aa0b01cb0b9a6c2dc44a16">&#9670;&nbsp;</a></span>IsPhysicallyValid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt;T1&gt;::is_bool, <a class="el" href="classbool.html">bool</a>&gt; IsPhysicallyValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a number of checks to verify that this is a physically valid articulated body inertia. </p>
<p>The checks performed are:</p><ul>
<li>The matrix is positive semi-definite. </li>
</ul>

</div>
</div>
<a id="a7d1bd7b221e380e1bac184d3792abf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1bd7b221e380e1bac184d3792abf5f">&#9670;&nbsp;</a></span>IsPhysicallyValid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt;T1&gt;::is_bool, <a class="el" href="classbool.html">bool</a>&gt; IsPhysicallyValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#aa4218b7c32aa0b01cb0b9a6c2dc44a16" title="Performs a number of checks to verify that this is a physically valid articulated body inertia...">IsPhysicallyValid()</a> for non-numeric scalar types is not supported. </p>

</div>
</div>
<a id="afe3565c4b5cbe9be575d03ebd4b99327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3565c4b5cbe9be575d03ebd4b99327">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Product&lt;Eigen::SelfAdjointView&lt;const <a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt;T&gt;, Eigen::Lower&gt;, OtherDerived&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> articulated body inertia on the right by a matrix or vector. </p>
<dl class="section note"><dt>Note</dt><dd>This method does not evaluate the product immediately. Instead, it returns an intermediate <a class="el" href="namespace_eigen.html">Eigen</a> quantity that can be optimized automatically during compile time. </dd></dl>

</div>
</div>
<a id="a148bc958b5d02693bd0136917046b68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148bc958b5d02693bd0136917046b68e">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt;T&gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>P_BQ_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds in to this articulated body inertia <code>P_AQ_E</code> for an articulated body A about a point Q and expressed in a frame E the articulated body inertia <code>P_BQ_E</code> for a second articulated body B about the same point Q and expressed in the same frame E. </p>
<p>The result is equivalent to the articulated body inertia <code>P_CQ_E</code> for the composite articulated body C which has at its base a rigid body composed of the bases of A and B welded together [Featherstone 2008, example 7.1]. The composite articulated body inertia <code>P_CQ_E</code> is also about the same point Q and expressed in the same frame E as the addends.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P_BQ_E</td><td>An articulated body inertia of some articulated body B to be added to <code>this</code> articulated body inertia. It must be defined about the same point Q as <code>this</code> inertia, and expressed in the same frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> articulated body inertia, which has been updated to include the given articulated body inertia <code>P_BQ_E</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation is only valid if both articulated body inertias are computed about the same point Q and expressed in the same frame E. </dd></dl>

</div>
</div>
<a id="ad47d1b4caefc3416208c61e09d221e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47d1b4caefc3416208c61e09d221e18">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a589e7341c3eeb0ac0c4c71c57c03e8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589e7341c3eeb0ac0c4c71c57c03e8ce">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a2a3ad9747df360ab2ccfebe5a2e55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2a3ad9747df360ab2ccfebe5a2e55b">&#9670;&nbsp;</a></span>Shift()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt;T&gt; Shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_QR_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <code>this</code> articulated body inertia <code>P_AQ_E</code> for some articulated body A, computed about point Q, and expressed in frame E, this method uses the rigid body shift operator to compute the same articulated body inertia about a new point R. </p>
<p>The result still is expressed in frame E.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#a9b4bcc3ca011dbb3e484ebb19ce7faa5" title="Given this articulated body inertia P_AQ_E for some articulated body A, computed about point Q...">ShiftInPlace()</a> for more details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_QR_E</td><td>Vector from the original about point Q to the new about point R, expressed in the same frame E <code>this</code> articulated body inertia is expressed in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">P_AR_E</td><td>This same articulated body inertia for articulated body A but now computed about about a new point R. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b4bcc3ca011dbb3e484ebb19ce7faa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4bcc3ca011dbb3e484ebb19ce7faa5">&#9670;&nbsp;</a></span>ShiftInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt;T&gt;&amp; ShiftInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_QR_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <code>this</code> articulated body inertia <code>P_AQ_E</code> for some articulated body A, computed about point Q, and expressed in frame E, this method uses the rigid body shift operator to compute the same articulated body inertia about a new point R. </p>
<p>The result still is expressed in frame E.</p>
<p>Mathematically, this is equivalent to: </p><pre>
P_AR_E = Φ(P_RQ_E) P_AQ_E Φ(p_RQ_E)ᵀ
</pre><p> where <code>Φ(p_RQ_E)</code> is the rigid body shift operator as defined by [Jain 2010]. The definition of <code>Φ(p_RQ_E)</code> uses <code>p_QR_E×</code>, which is the skew-symmetric cross product matrix (defined such that <code>a× b = a.cross(b)</code>). </p><pre>
Φ(p_RQ_E) =
| I₃  p_RQ_E× |
| 0        I₃ |
</pre><p> where <code>p_RQ_E× = -p_QR_E×</code>.</p>
<p>This operation is performed in-place modifying the original object. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#a4a2a3ad9747df360ab2ccfebe5a2e55b" title="Given this articulated body inertia P_AQ_E for some articulated body A, computed about point Q...">Shift()</a> which does not modify this object.</dd></dl>
<p>For details see Section 6.2.5, Page 105 of [Jain 2010].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_QR_E</td><td>Vector from the original about point Q to the new about point R, expressed in the same frame E <code>this</code> articulated body inertia is expressed in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> articulated body inertia for articulated body A but now computed about a new point R. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af8b25c3b08abdc24e4de1e63ab09ef04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b25c3b08abdc24e4de1e63ab09ef04">&#9670;&nbsp;</a></span>ArticulatedBodyInertia</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accf02d86e540a40456f8803150b806fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf02d86e540a40456f8803150b806fa">&#9670;&nbsp;</a></span>operator*</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Product&lt;OtherDerived, Eigen::SelfAdjointView&lt;const <a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt;T&gt;, Eigen::Lower&gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> articulated body inertia on the left by a matrix or vector. </p>
<dl class="section note"><dt>Note</dt><dd>This method does not evaluate the product immediately. Instead, it returns an intermediate <a class="el" href="namespace_eigen.html">Eigen</a> quantity that can be optimized automatically during compile time. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/tree/<a class="el" href="articulated__body__inertia_8h.html">articulated_body_inertia.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
