<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::parsers Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacedrake_1_1parsers.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drake::parsers Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake_1_1parsers_1_1sdf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1parsers_1_1sdf.html">sdf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1parsers_1_1urdf"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1parsers_1_1urdf.html">urdf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1parsers_1_1_floating_joint_constants.html">FloatingJointConstants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines constants used by <a class="el" href="namespacedrake_1_1parsers.html#a699fba0bea3f8e8aa73ae59e4dbeb735">AddFloatingJoint()</a>.  <a href="structdrake_1_1parsers_1_1_floating_joint_constants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a161e257dbc76cf0de6196932ffeb428e"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1parsers.html#a161e257dbc76cf0de6196932ffeb428e">ModelInstanceIdTable</a></td></tr>
<tr class="memdesc:a161e257dbc76cf0de6196932ffeb428e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a data type that maps model names to their instance IDs within the <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code>.  <a href="#a161e257dbc76cf0de6196932ffeb428e">More...</a><br /></td></tr>
<tr class="separator:a161e257dbc76cf0de6196932ffeb428e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1164ffd900163f47b262ea543a2d1d4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1parsers.html#ae1164ffd900163f47b262ea543a2d1d4">PackageMap</a> = <a class="el" href="classdrake_1_1multibody_1_1parsing_1_1_package_map.html">drake::multibody::parsing::PackageMap</a></td></tr>
<tr class="separator:ae1164ffd900163f47b262ea543a2d1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ace890e6626233f405ed51cb9c9fe5215"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1parsers.html#ace890e6626233f405ed51cb9c9fe5215">AddModelInstancesToTable</a> (const <a class="el" href="namespacedrake_1_1parsers.html#a161e257dbc76cf0de6196932ffeb428e">drake::parsers::ModelInstanceIdTable</a> &amp;source_table, <a class="el" href="namespacedrake_1_1parsers.html#a161e257dbc76cf0de6196932ffeb428e">drake::parsers::ModelInstanceIdTable</a> *dest_table)</td></tr>
<tr class="memdesc:ace890e6626233f405ed51cb9c9fe5215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the model instances in <code>source_table</code> to <code>dest_table</code>.  <a href="#ace890e6626233f405ed51cb9c9fe5215">More...</a><br /></td></tr>
<tr class="separator:ace890e6626233f405ed51cb9c9fe5215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699fba0bea3f8e8aa73ae59e4dbeb735"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1parsers.html#a699fba0bea3f8e8aa73ae59e4dbeb735">AddFloatingJoint</a> (const FloatingBaseType floating_base_type, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;body_indices, const std::shared_ptr&lt; <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; weld_to_frame, const <a class="el" href="pose__map_8h.html#a6915d8bdb957e735e3b9e6ea9e5dd473">PoseMap</a> *pose_map, <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *tree)</td></tr>
<tr class="separator:a699fba0bea3f8e8aa73ae59e4dbeb735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0dbae85693ad79a49348309427ec4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_compliant_material.html">CompliantMaterial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1parsers.html#a8a0dbae85693ad79a49348309427ec4a">ParseCollisionCompliance</a> (XMLElement *node)</td></tr>
<tr class="separator:a8a0dbae85693ad79a49348309427ec4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bc296146ff32447599b507abfe349f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1parsers.html#a77bc296146ff32447599b507abfe349f">ParseCollisionFilterGroup</a> (<a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *tree, XMLElement *node, <a class="el" href="classint.html">int</a> model_instance_id)</td></tr>
<tr class="separator:a77bc296146ff32447599b507abfe349f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a84ce2c287c6a74cc4af3be1ec1c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1parsers.html#a86a84ce2c287c6a74cc4af3be1ec1c3a">AddFloatingJoint</a> (<a class="el" href="namespacedrake_1_1multibody_1_1joints.html#a50cf3eda4d4ab9469c222364b683710b">multibody::joints::FloatingBaseType</a> floating_base_type, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;body_indices, const std::shared_ptr&lt; <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; weld_to_frame, const <a class="el" href="pose__map_8h.html#a6915d8bdb957e735e3b9e6ea9e5dd473">PoseMap</a> *pose_map, <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *tree)</td></tr>
<tr class="memdesc:a86a84ce2c287c6a74cc4af3be1ec1c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a floating joint to each body specified by <code>body_indices</code> that does not already have a parent.  <a href="#a86a84ce2c287c6a74cc4af3be1ec1c3a">More...</a><br /></td></tr>
<tr class="separator:a86a84ce2c287c6a74cc4af3be1ec1c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d32d28abe19c432edb0b22e0087503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_compliant_material.html">systems::CompliantMaterial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1parsers.html#a49d32d28abe19c432edb0b22e0087503">ParseCollisionCompliance</a> (tinyxml2::XMLElement *node)</td></tr>
<tr class="memdesc:a49d32d28abe19c432edb0b22e0087503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a CompliantMaterial instance from an XMLNode.  <a href="#a49d32d28abe19c432edb0b22e0087503">More...</a><br /></td></tr>
<tr class="separator:a49d32d28abe19c432edb0b22e0087503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e851a16ef2d14f206f4ce435a1936a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1parsers.html#ad9e851a16ef2d14f206f4ce435a1936a">ParseCollisionFilterGroup</a> (<a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *tree, tinyxml2::XMLElement *node, <a class="el" href="classint.html">int</a> model_instance_id)</td></tr>
<tr class="memdesc:ad9e851a16ef2d14f206f4ce435a1936a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the Drake collision filter group specification.  <a href="#ad9e851a16ef2d14f206f4ce435a1936a">More...</a><br /></td></tr>
<tr class="separator:ad9e851a16ef2d14f206f4ce435a1936a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a161e257dbc76cf0de6196932ffeb428e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161e257dbc76cf0de6196932ffeb428e">&#9670;&nbsp;</a></span>ModelInstanceIdTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="classint.html">int</a>&gt; <a class="el" href="namespacedrake_1_1parsers.html#a161e257dbc76cf0de6196932ffeb428e">ModelInstanceIdTable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a data type that maps model names to their instance IDs within the <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code>. </p>
<p>The model names are defined in a single URDF or SDF file and are thus guaranteed to be unique within an instance of this data type. The instance IDs are determined by by the <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code> and are unique among all model instances within the tree. This data type is used to inform applications of the IDs that were assigned to model instances as they were added to a <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code> while parsing a URDF or SDF description.</p>
<p>The model names within this data type are specified by the URDF and SDF. They are <em>not</em> the same as "model instance names" since multiple instances of the same model may be added to the same <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code>. Model instance names can be decided by the application based on the information contained within this data type. It is recommended, but not required, that applications separately create mappings from model instance IDs to meaningful model instance names. This is because an instance ID, as an integer, does not convey much information about the model instance. </p>

</div>
</div>
<a id="ae1164ffd900163f47b262ea543a2d1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1164ffd900163f47b262ea543a2d1d4">&#9670;&nbsp;</a></span>PackageMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1parsers.html#ae1164ffd900163f47b262ea543a2d1d4">PackageMap</a> =  <a class="el" href="classdrake_1_1multibody_1_1parsing_1_1_package_map.html">drake::multibody::parsing::PackageMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a699fba0bea3f8e8aa73ae59e4dbeb735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699fba0bea3f8e8aa73ae59e4dbeb735">&#9670;&nbsp;</a></span>AddFloatingJoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> drake::parsers::AddFloatingJoint </td>
          <td>(</td>
          <td class="paramtype">const FloatingBaseType&#160;</td>
          <td class="paramname"><em>floating_base_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>weld_to_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="pose__map_8h.html#a6915d8bdb957e735e3b9e6ea9e5dd473">PoseMap</a> *&#160;</td>
          <td class="paramname"><em>pose_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86a84ce2c287c6a74cc4af3be1ec1c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a84ce2c287c6a74cc4af3be1ec1c3a">&#9670;&nbsp;</a></span>AddFloatingJoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> drake::parsers::AddFloatingJoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody_1_1joints.html#a50cf3eda4d4ab9469c222364b683710b">multibody::joints::FloatingBaseType</a>&#160;</td>
          <td class="paramname"><em>floating_base_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>weld_to_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="pose__map_8h.html#a6915d8bdb957e735e3b9e6ea9e5dd473">PoseMap</a> *&#160;</td>
          <td class="paramname"><em>pose_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a floating joint to each body specified by <code>body_indices</code> that does not already have a parent. </p>
<p>This method is only intended to be called by parsers since parsers add bodies to the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> <em>en masse</em>. The logic in this method is necessary to identify which of the rigid bodies specified by <code>body_indices</code> get floating joints.</p>
<p>When manually adding a model instance to the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>, i.e., directly using the C++ API rather than via a parser, this method should <em>not</em> be necessary since floating joints can be directly added by calling <a class="el" href="class_rigid_body.html#a418b727878b8a58d8b8e97282cf2d5cc" title="Sets the parent joint through which this rigid body connects to its parent rigid body. ">RigidBody::setJoint()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">floating_base_type</td><td>The floating joint's type.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_indices</td><td>A list of body indexes to check. A floating joint is added to any body in this list that does not have a parent joint.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weld_to_frame</td><td>The frame to which the floating joint should attach the parent-less non-world bodies. This parameter may be nullptr, in which case the body is welded to the world with zero offset.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pose_map</td><td>A mapping where the key is the body's name and the value is the transform from the frame of the body to the frame of the model to which the body belongs. This parameter will may be nullptr, in which case an identity transform is used.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tree</td><td>The <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> to which to add the floating joints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of floating joint added to this rigid body tree.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the floating_base_type is unrecognized or zero floating joints were added to the model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace890e6626233f405ed51cb9c9fe5215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace890e6626233f405ed51cb9c9fe5215">&#9670;&nbsp;</a></span>AddModelInstancesToTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddModelInstancesToTable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1parsers.html#a161e257dbc76cf0de6196932ffeb428e">drake::parsers::ModelInstanceIdTable</a> &amp;&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1parsers.html#a161e257dbc76cf0de6196932ffeb428e">drake::parsers::ModelInstanceIdTable</a> *&#160;</td>
          <td class="paramname"><em>dest_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the model instances in <code>source_table</code> to <code>dest_table</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there is a collision in the model names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49d32d28abe19c432edb0b22e0087503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d32d28abe19c432edb0b22e0087503">&#9670;&nbsp;</a></span>ParseCollisionCompliance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_compliant_material.html">systems::CompliantMaterial</a> drake::parsers::ParseCollisionCompliance </td>
          <td>(</td>
          <td class="paramtype">tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates a CompliantMaterial instance from an XMLNode. </p>
<p>It ignores unrecognized elements, but throws an exception if a recognized element's contents cannot be converted to a double. Omitted property elements remain tied to the default parameter value. If either friction coefficient is defined, <em>both</em> must be defined. Furthermore, the coefficient for static friction must be greater than or equal to the dynamic friction and both must be non-negative.</p>
<p>Looks for the following tags in URDF and SDF:</p>
<div class="fragment"><div class="line">...</div><div class="line">&lt;<span class="keywordtype">collision</span> ...&gt;</div><div class="line">  &lt;<span class="keywordtype">geometry...</span>&gt;</div><div class="line">  &lt;/<span class="keywordtype">geometry</span>&gt;</div><div class="line"></div><div class="line">  &lt;<span class="keywordtype">drake_compliance</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">youngs_modulus</span>&gt;##&lt;/<span class="keywordtype">youngs_modulus</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">dissipation</span>&gt;##&lt;/<span class="keywordtype">dissipation</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">static_friction</span>&gt;##&lt;/<span class="keywordtype">static_friction</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">dynamic_friction</span>&gt;##&lt;/<span class="keywordtype">dynamic_friction</span>&gt;</div><div class="line">  &lt;/<span class="keywordtype">drake_compliance</span>&gt;</div><div class="line"></div><div class="line">&lt;/<span class="keywordtype">collision</span>&gt;</div><div class="line">...</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The <em>parent</em> node which ostensibly contains a declaration of drake compliance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a0dbae85693ad79a49348309427ec4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0dbae85693ad79a49348309427ec4a">&#9670;&nbsp;</a></span>ParseCollisionCompliance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_compliant_material.html">CompliantMaterial</a> drake::parsers::ParseCollisionCompliance </td>
          <td>(</td>
          <td class="paramtype">XMLElement *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9e851a16ef2d14f206f4ce435a1936a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e851a16ef2d14f206f4ce435a1936a">&#9670;&nbsp;</a></span>ParseCollisionFilterGroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::parsers::ParseCollisionFilterGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_instance_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the Drake collision filter group specification. </p>
<p>Attempts to add collision filter groups (with their member lists and ignore lists) to the tree specification. Inconsistent definitions will lead to thrown exceptions.</p>
<p>See <a class="el" href="group__collision__filter__group.html#cfg_impl">this discussion</a> for details on the XML specification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The rigid body tree containing the bodies to which the filters will be applied. </td></tr>
    <tr><td class="paramname">node</td><td>The XML node containing the filter details. </td></tr>
    <tr><td class="paramname">model_instance_id</td><td>The id of the current model instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77bc296146ff32447599b507abfe349f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bc296146ff32447599b507abfe349f">&#9670;&nbsp;</a></span>ParseCollisionFilterGroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::parsers::ParseCollisionFilterGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_instance_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1parsers.html">parsers</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
