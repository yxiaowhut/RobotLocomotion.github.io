<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: MultibodyTree&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MultibodyTree&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>MultibodyTree provides a representation for a physical system consisting of a collection of interconnected rigid and deformable bodies.  
 <a href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#details">More...</a></p>

<p><code>#include &lt;drake/multibody/tree/multibody_tree_forward_decl.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad678b6cb49a8bf1b988f8f19d0881980"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ad678b6cb49a8bf1b988f8f19d0881980">MultibodyTree</a> ()</td></tr>
<tr class="memdesc:ad678b6cb49a8bf1b988f8f19d0881980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html" title="MultibodyTree provides a representation for a physical system consisting of a collection of interconn...">MultibodyTree</a> containing only a <b>world</b> body.  <a href="#ad678b6cb49a8bf1b988f8f19d0881980">More...</a><br /></td></tr>
<tr class="separator:ad678b6cb49a8bf1b988f8f19d0881980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7f02e861a8f89fc0b575b2f30333d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ada7f02e861a8f89fc0b575b2f30333d3">num_frames</a> () const</td></tr>
<tr class="memdesc:ada7f02e861a8f89fc0b575b2f30333d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ada7f02e861a8f89fc0b575b2f30333d3">More...</a><br /></td></tr>
<tr class="separator:ada7f02e861a8f89fc0b575b2f30333d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92b53211e54243aff4490a700168eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af92b53211e54243aff4490a700168eb4">num_bodies</a> () const</td></tr>
<tr class="memdesc:af92b53211e54243aff4490a700168eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bodies in the MultibodyTree including the <em>world</em> body.  <a href="#af92b53211e54243aff4490a700168eb4">More...</a><br /></td></tr>
<tr class="separator:af92b53211e54243aff4490a700168eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636804b6c40e538d83d5c2dfefb7929e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a636804b6c40e538d83d5c2dfefb7929e">num_joints</a> () const</td></tr>
<tr class="memdesc:a636804b6c40e538d83d5c2dfefb7929e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of joints added with <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a437f86026a2268c0fb06936b899ba8d7" title="This method adds a Joint of type JointType between the frames specified by the joint. ">AddJoint()</a> to the MultibodyTree.  <a href="#a636804b6c40e538d83d5c2dfefb7929e">More...</a><br /></td></tr>
<tr class="separator:a636804b6c40e538d83d5c2dfefb7929e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8601c026e9807127b4dd41e7585d2cfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8601c026e9807127b4dd41e7585d2cfc">num_actuators</a> () const</td></tr>
<tr class="memdesc:a8601c026e9807127b4dd41e7585d2cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of actuators in the model.  <a href="#a8601c026e9807127b4dd41e7585d2cfc">More...</a><br /></td></tr>
<tr class="separator:a8601c026e9807127b4dd41e7585d2cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4534e419e421208e87433f3e7243752"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ad4534e419e421208e87433f3e7243752">num_mobilizers</a> () const</td></tr>
<tr class="memdesc:ad4534e419e421208e87433f3e7243752"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ad4534e419e421208e87433f3e7243752">More...</a><br /></td></tr>
<tr class="separator:ad4534e419e421208e87433f3e7243752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7f0267d163693025fa04f78bb18333"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a6b7f0267d163693025fa04f78bb18333">num_force_elements</a> () const</td></tr>
<tr class="memdesc:a6b7f0267d163693025fa04f78bb18333"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a6b7f0267d163693025fa04f78bb18333">More...</a><br /></td></tr>
<tr class="separator:a6b7f0267d163693025fa04f78bb18333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89140adb93cb9e507f71c30eb783198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ac89140adb93cb9e507f71c30eb783198">num_model_instances</a> () const</td></tr>
<tr class="memdesc:ac89140adb93cb9e507f71c30eb783198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of model instances in the <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html" title="MultibodyTree provides a representation for a physical system consisting of a collection of interconn...">MultibodyTree</a>.  <a href="#ac89140adb93cb9e507f71c30eb783198">More...</a><br /></td></tr>
<tr class="separator:ac89140adb93cb9e507f71c30eb783198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aba2887f0ca1fbbdfb49cf6b0ee21e553">num_positions</a> () const</td></tr>
<tr class="memdesc:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of generalized positions of the model.  <a href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">More...</a><br /></td></tr>
<tr class="separator:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab669e070e6178c4aeeb067a1f4b6122e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ab669e070e6178c4aeeb067a1f4b6122e">num_positions</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:ab669e070e6178c4aeeb067a1f4b6122e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of generalized positions in a specific model instance.  <a href="#ab669e070e6178c4aeeb067a1f4b6122e">More...</a><br /></td></tr>
<tr class="separator:ab669e070e6178c4aeeb067a1f4b6122e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0163ac0976659d811e3337647ff0313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ae0163ac0976659d811e3337647ff0313">num_velocities</a> () const</td></tr>
<tr class="memdesc:ae0163ac0976659d811e3337647ff0313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of generalized velocities of the model.  <a href="#ae0163ac0976659d811e3337647ff0313">More...</a><br /></td></tr>
<tr class="separator:ae0163ac0976659d811e3337647ff0313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a686a8389beffdc5fb8a7690967e741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a0a686a8389beffdc5fb8a7690967e741">num_velocities</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a0a686a8389beffdc5fb8a7690967e741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of generalized velocities in a specific model instance.  <a href="#a0a686a8389beffdc5fb8a7690967e741">More...</a><br /></td></tr>
<tr class="separator:a0a686a8389beffdc5fb8a7690967e741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbd3e24f7648ab7712c803ca8a63f3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a3cbd3e24f7648ab7712c803ca8a63f3e">num_states</a> () const</td></tr>
<tr class="memdesc:a3cbd3e24f7648ab7712c803ca8a63f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total size of the state vector in the model.  <a href="#a3cbd3e24f7648ab7712c803ca8a63f3e">More...</a><br /></td></tr>
<tr class="separator:a3cbd3e24f7648ab7712c803ca8a63f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73b2e9e79342ca3ca8195ecd5daf01e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af73b2e9e79342ca3ca8195ecd5daf01e">num_states</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:af73b2e9e79342ca3ca8195ecd5daf01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total size of the state vector in a specific model instance.  <a href="#af73b2e9e79342ca3ca8195ecd5daf01e">More...</a><br /></td></tr>
<tr class="separator:af73b2e9e79342ca3ca8195ecd5daf01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ae3fc8de8de8eaf2d37a24c79d6be8e97">num_actuated_dofs</a> () const</td></tr>
<tr class="memdesc:ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ae3fc8de8de8eaf2d37a24c79d6be8e97">More...</a><br /></td></tr>
<tr class="separator:ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279e31367e76849d4a45fd7db0f116f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a279e31367e76849d4a45fd7db0f116f1">num_actuated_dofs</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a279e31367e76849d4a45fd7db0f116f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a279e31367e76849d4a45fd7db0f116f1">More...</a><br /></td></tr>
<tr class="separator:a279e31367e76849d4a45fd7db0f116f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf904af9e2715a5a2db668d207173c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a7cf904af9e2715a5a2db668d207173c8">tree_height</a> () const</td></tr>
<tr class="memdesc:a7cf904af9e2715a5a2db668d207173c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height of the tree data structure of <code>this</code> MultibodyTree.  <a href="#a7cf904af9e2715a5a2db668d207173c8">More...</a><br /></td></tr>
<tr class="separator:a7cf904af9e2715a5a2db668d207173c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ef779ddfeea96c5d80c27d68a4f864"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a29ef779ddfeea96c5d80c27d68a4f864">world_body</a> () const</td></tr>
<tr class="memdesc:a29ef779ddfeea96c5d80c27d68a4f864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the <em>world</em> body.  <a href="#a29ef779ddfeea96c5d80c27d68a4f864">More...</a><br /></td></tr>
<tr class="separator:a29ef779ddfeea96c5d80c27d68a4f864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95da38020c32452f62a8cf973057c7a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html">BodyFrame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ac95da38020c32452f62a8cf973057c7a">world_frame</a> () const</td></tr>
<tr class="memdesc:ac95da38020c32452f62a8cf973057c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the <em>world</em> frame.  <a href="#ac95da38020c32452f62a8cf973057c7a">More...</a><br /></td></tr>
<tr class="separator:ac95da38020c32452f62a8cf973057c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9547075b5a67b2354f3dabf0f2f787"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ada9547075b5a67b2354f3dabf0f2f787">get_body</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:ada9547075b5a67b2354f3dabf0f2f787"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ada9547075b5a67b2354f3dabf0f2f787">More...</a><br /></td></tr>
<tr class="separator:ada9547075b5a67b2354f3dabf0f2f787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad293b63a81a28c455fdfb7e5f04c35b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ad293b63a81a28c455fdfb7e5f04c35b0">get_joint</a> (<a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> joint_index) const</td></tr>
<tr class="memdesc:ad293b63a81a28c455fdfb7e5f04c35b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ad293b63a81a28c455fdfb7e5f04c35b0">More...</a><br /></td></tr>
<tr class="separator:ad293b63a81a28c455fdfb7e5f04c35b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56a3621a122cdff1729f71b756a75d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ab56a3621a122cdff1729f71b756a75d0">get_mutable_joint</a> (<a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> joint_index)</td></tr>
<tr class="memdesc:ab56a3621a122cdff1729f71b756a75d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ab56a3621a122cdff1729f71b756a75d0">More...</a><br /></td></tr>
<tr class="separator:ab56a3621a122cdff1729f71b756a75d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb237ffaadc7323d817ba0e07e78a8f4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#abb237ffaadc7323d817ba0e07e78a8f4">get_joint_actuator</a> (<a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> actuator_index) const</td></tr>
<tr class="memdesc:abb237ffaadc7323d817ba0e07e78a8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#abb237ffaadc7323d817ba0e07e78a8f4">More...</a><br /></td></tr>
<tr class="separator:abb237ffaadc7323d817ba0e07e78a8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cafdc0efac53fe097f9380b955e396"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a95cafdc0efac53fe097f9380b955e396">get_frame</a> (<a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> frame_index) const</td></tr>
<tr class="memdesc:a95cafdc0efac53fe097f9380b955e396"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a95cafdc0efac53fe097f9380b955e396">More...</a><br /></td></tr>
<tr class="separator:a95cafdc0efac53fe097f9380b955e396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1fdaf43db3e9f6327a78b6f34e4410"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html">Mobilizer</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aff1fdaf43db3e9f6327a78b6f34e4410">get_mobilizer</a> (<a class="el" href="namespacedrake_1_1multibody_1_1internal.html#a5296da869e93358c7ea8fd7e15a8757c">MobilizerIndex</a> mobilizer_index) const</td></tr>
<tr class="memdesc:aff1fdaf43db3e9f6327a78b6f34e4410"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#aff1fdaf43db3e9f6327a78b6f34e4410">More...</a><br /></td></tr>
<tr class="separator:aff1fdaf43db3e9f6327a78b6f34e4410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99be499eb59f00037b05ec60b51e177"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ab99be499eb59f00037b05ec60b51e177">GetModelInstanceName</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:ab99be499eb59f00037b05ec60b51e177"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ab99be499eb59f00037b05ec60b51e177">More...</a><br /></td></tr>
<tr class="separator:ab99be499eb59f00037b05ec60b51e177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b40d661d83759731ad9a54553fc13f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af3b40d661d83759731ad9a54553fc13f">GetBodyByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:af3b40d661d83759731ad9a54553fc13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#af3b40d661d83759731ad9a54553fc13f">More...</a><br /></td></tr>
<tr class="separator:af3b40d661d83759731ad9a54553fc13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d93818409f0144bb63248dc64a9130f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a3d93818409f0144bb63248dc64a9130f">GetBodyByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a3d93818409f0144bb63248dc64a9130f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a3d93818409f0144bb63248dc64a9130f">More...</a><br /></td></tr>
<tr class="separator:a3d93818409f0144bb63248dc64a9130f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b557087f117859fd5246112f0d829cd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a4b557087f117859fd5246112f0d829cd">GetFrameByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:a4b557087f117859fd5246112f0d829cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a4b557087f117859fd5246112f0d829cd">More...</a><br /></td></tr>
<tr class="separator:a4b557087f117859fd5246112f0d829cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d552a24e1ad06c0b16004cec20fe94"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af4d552a24e1ad06c0b16004cec20fe94">GetFrameByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:af4d552a24e1ad06c0b16004cec20fe94"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#af4d552a24e1ad06c0b16004cec20fe94">More...</a><br /></td></tr>
<tr class="separator:af4d552a24e1ad06c0b16004cec20fe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef21c2455a83e7a086df24f8411e26b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a1ef21c2455a83e7a086df24f8411e26b">GetRigidBodyByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:a1ef21c2455a83e7a086df24f8411e26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a1ef21c2455a83e7a086df24f8411e26b">More...</a><br /></td></tr>
<tr class="separator:a1ef21c2455a83e7a086df24f8411e26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1b9a39c20706b20221ea2c142d2cfd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a0b1b9a39c20706b20221ea2c142d2cfd">GetRigidBodyByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a0b1b9a39c20706b20221ea2c142d2cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a0b1b9a39c20706b20221ea2c142d2cfd">More...</a><br /></td></tr>
<tr class="separator:a0b1b9a39c20706b20221ea2c142d2cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19361c135196cb155e2c8bca02dcbc78"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class JointType = Joint&gt; </td></tr>
<tr class="memitem:a19361c135196cb155e2c8bca02dcbc78"><td class="memTemplItemLeft" align="right" valign="top">const JointType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a19361c135196cb155e2c8bca02dcbc78">GetJointByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; model_instance=<a class="el" href="namespacedrake.html#acd293644b847dc4549de80a090d66625">nullopt</a>) const</td></tr>
<tr class="memdesc:a19361c135196cb155e2c8bca02dcbc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a19361c135196cb155e2c8bca02dcbc78">More...</a><br /></td></tr>
<tr class="separator:a19361c135196cb155e2c8bca02dcbc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392df3335cb46b0c87f943bdd9fd5279"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class JointType = Joint&gt; </td></tr>
<tr class="memitem:a392df3335cb46b0c87f943bdd9fd5279"><td class="memTemplItemLeft" align="right" valign="top">JointType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a392df3335cb46b0c87f943bdd9fd5279">GetMutableJointByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; model_instance=<a class="el" href="namespacedrake.html#acd293644b847dc4549de80a090d66625">nullopt</a>)</td></tr>
<tr class="memdesc:a392df3335cb46b0c87f943bdd9fd5279"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a392df3335cb46b0c87f943bdd9fd5279">More...</a><br /></td></tr>
<tr class="separator:a392df3335cb46b0c87f943bdd9fd5279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab835365a3c40185b23454f7e08cad083"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ab835365a3c40185b23454f7e08cad083">GetJointActuatorByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:ab835365a3c40185b23454f7e08cad083"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ab835365a3c40185b23454f7e08cad083">More...</a><br /></td></tr>
<tr class="separator:ab835365a3c40185b23454f7e08cad083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760fbe4384415d8cfd39c9e7e4f31422"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a760fbe4384415d8cfd39c9e7e4f31422">GetJointActuatorByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a760fbe4384415d8cfd39c9e7e4f31422"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a760fbe4384415d8cfd39c9e7e4f31422">More...</a><br /></td></tr>
<tr class="separator:a760fbe4384415d8cfd39c9e7e4f31422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a177e855cc5efe12d15adc4c697930f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a2a177e855cc5efe12d15adc4c697930f">GetModelInstanceByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:a2a177e855cc5efe12d15adc4c697930f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a2a177e855cc5efe12d15adc4c697930f">More...</a><br /></td></tr>
<tr class="separator:a2a177e855cc5efe12d15adc4c697930f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53169605aca35402fdc495db8150d98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ae53169605aca35402fdc495db8150d98">topology_is_valid</a> () const</td></tr>
<tr class="memdesc:ae53169605aca35402fdc495db8150d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this MultibodyTree was finalized with <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> after all multibody elements were added, and <code>false</code> otherwise.  <a href="#ae53169605aca35402fdc495db8150d98">More...</a><br /></td></tr>
<tr class="separator:ae53169605aca35402fdc495db8150d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37389ac2ca2dbdc0bef040c6554565e3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a37389ac2ca2dbdc0bef040c6554565e3">get_topology</a> () const</td></tr>
<tr class="memdesc:a37389ac2ca2dbdc0bef040c6554565e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the topology information for this multibody tree.  <a href="#a37389ac2ca2dbdc0bef040c6554565e3">More...</a><br /></td></tr>
<tr class="separator:a37389ac2ca2dbdc0bef040c6554565e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fee61d7a783cade1a3d07fe86284d27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27">Finalize</a> ()</td></tr>
<tr class="memdesc:a8fee61d7a783cade1a3d07fe86284d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed.  <a href="#a8fee61d7a783cade1a3d07fe86284d27">More...</a><br /></td></tr>
<tr class="separator:a8fee61d7a783cade1a3d07fe86284d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3979ee6b095e61009a536caac365297b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_leaf_context.html">systems::LeafContext</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a3979ee6b095e61009a536caac365297b">CreateDefaultContext</a> () const</td></tr>
<tr class="memdesc:a3979ee6b095e61009a536caac365297b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Allocates a new context for this MultibodyTree uniquely identifying the state of the multibody system.  <a href="#a3979ee6b095e61009a536caac365297b">More...</a><br /></td></tr>
<tr class="separator:a3979ee6b095e61009a536caac365297b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bd33a2e8520eccde63ffbd423c056a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af8bd33a2e8520eccde63ffbd423c056a">SetDefaultState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:af8bd33a2e8520eccde63ffbd423c056a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#af8bd33a2e8520eccde63ffbd423c056a">More...</a><br /></td></tr>
<tr class="separator:af8bd33a2e8520eccde63ffbd423c056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438d233107845df9ea2ee0321094946c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a438d233107845df9ea2ee0321094946c">SetRandomState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state, <a class="el" href="namespacedrake.html#ab262f8e82f09d8df2990d0dc5869c34f">RandomGenerator</a> *generator) const</td></tr>
<tr class="memdesc:a438d233107845df9ea2ee0321094946c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a438d233107845df9ea2ee0321094946c">More...</a><br /></td></tr>
<tr class="separator:a438d233107845df9ea2ee0321094946c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c4037d7f25d2e511f86e9102772290"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a61c4037d7f25d2e511f86e9102772290">GetPositionsAndVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a61c4037d7f25d2e511f86e9102772290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const <a class="el" href="namespace_eigen.html">Eigen</a> vector reference containing the vector <code>[q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities.  <a href="#a61c4037d7f25d2e511f86e9102772290">More...</a><br /></td></tr>
<tr class="separator:a61c4037d7f25d2e511f86e9102772290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed3389732867302278b87d4605509a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a7ed3389732867302278b87d4605509a2">GetPositionsAndVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a7ed3389732867302278b87d4605509a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="namespace_eigen.html">Eigen</a> vector containing the multibody state <code>x = [q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities for model instance <code>model_instance</code>.  <a href="#a7ed3389732867302278b87d4605509a2">More...</a><br /></td></tr>
<tr class="separator:a7ed3389732867302278b87d4605509a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca225909f1909f8a37b0b3f89884f29b"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aca225909f1909f8a37b0b3f89884f29b">GetMutablePositionsAndVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:aca225909f1909f8a37b0b3f89884f29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable <a class="el" href="namespace_eigen.html">Eigen</a> vector containing the vector <code>[q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities.  <a href="#aca225909f1909f8a37b0b3f89884f29b">More...</a><br /></td></tr>
<tr class="separator:aca225909f1909f8a37b0b3f89884f29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e3715f67d9c2abd27454522c85322a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ab1e3715f67d9c2abd27454522c85322a">SetPositionsAndVelocities</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;instance_state, <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:ab1e3715f67d9c2abd27454522c85322a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>context</code> to store the vector <code>[q; v]</code> with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities for model instance <code>model_instance</code>.  <a href="#ab1e3715f67d9c2abd27454522c85322a">More...</a><br /></td></tr>
<tr class="separator:ab1e3715f67d9c2abd27454522c85322a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fd0f1de1971c578083e42d0b2705cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a80fd0f1de1971c578083e42d0b2705cf">SetFreeBodyPoseOrThrow</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;X_WB, <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a80fd0f1de1971c578083e42d0b2705cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a2afeb2fce8493fe177dd3cd155819bb9" title="Sets context to store the pose X_WB of a given body B in the world frame W. ">MultibodyPlant::SetFreeBodyPose</a>.  <a href="#a80fd0f1de1971c578083e42d0b2705cf">More...</a><br /></td></tr>
<tr class="separator:a80fd0f1de1971c578083e42d0b2705cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98c91d6aa10a8320efbc8c6d428b9ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aa98c91d6aa10a8320efbc8c6d428b9ad">SetFreeBodySpatialVelocityOrThrow</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;V_WB, <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:aa98c91d6aa10a8320efbc8c6d428b9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae4c3b2ef66032df5f2a377c47e90ccb7" title="Sets context to store the spatial velocity V_WB of a given body B in the world frame W...">MultibodyPlant::SetFreeBodySpatialVelocity</a>.  <a href="#aa98c91d6aa10a8320efbc8c6d428b9ad">More...</a><br /></td></tr>
<tr class="separator:aa98c91d6aa10a8320efbc8c6d428b9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c546a708bac99c2819bd2b3a83f49a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ac5c546a708bac99c2819bd2b3a83f49a">SetFreeBodyPoseOrThrow</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;X_WB, const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:ac5c546a708bac99c2819bd2b3a83f49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a2afeb2fce8493fe177dd3cd155819bb9" title="Sets context to store the pose X_WB of a given body B in the world frame W. ">MultibodyPlant::SetFreeBodyPose</a>.  <a href="#ac5c546a708bac99c2819bd2b3a83f49a">More...</a><br /></td></tr>
<tr class="separator:ac5c546a708bac99c2819bd2b3a83f49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b286640b1245f8c2df6212e628e1c9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a4b286640b1245f8c2df6212e628e1c9c">SetFreeBodySpatialVelocityOrThrow</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;V_WB, const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:a4b286640b1245f8c2df6212e628e1c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See MutibodyPlant::SetFreeBodySpatialVelocity.  <a href="#a4b286640b1245f8c2df6212e628e1c9c">More...</a><br /></td></tr>
<tr class="separator:a4b286640b1245f8c2df6212e628e1c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c9973e5bec9022fa46dfcedb34df84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ae1c9973e5bec9022fa46dfcedb34df84">MakeStateSelectorMatrix</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;user_to_joint_index_map) const</td></tr>
<tr class="memdesc:ae1c9973e5bec9022fa46dfcedb34df84"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ae1c9973e5bec9022fa46dfcedb34df84">More...</a><br /></td></tr>
<tr class="separator:ae1c9973e5bec9022fa46dfcedb34df84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28384608fd90b16df01c2f9ff029e458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a28384608fd90b16df01c2f9ff029e458">MakeStateSelectorMatrixFromJointNames</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; std::string &gt; &amp;selected_joints) const</td></tr>
<tr class="memdesc:a28384608fd90b16df01c2f9ff029e458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative signature to build a state selector matrix from a std::vector of joint names.  <a href="#a28384608fd90b16df01c2f9ff029e458">More...</a><br /></td></tr>
<tr class="separator:a28384608fd90b16df01c2f9ff029e458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d9ba2b26eb3887a1e277875a5af127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a91d9ba2b26eb3887a1e277875a5af127">MakeActuatorSelectorMatrix</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> &gt; &amp;user_to_actuator_index_map) const</td></tr>
<tr class="memdesc:a91d9ba2b26eb3887a1e277875a5af127"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a91d9ba2b26eb3887a1e277875a5af127">More...</a><br /></td></tr>
<tr class="separator:a91d9ba2b26eb3887a1e277875a5af127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90a2eb58b242d1a85176e32435004c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af90a2eb58b242d1a85176e32435004c9">MakeActuatorSelectorMatrix</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;user_to_joint_index_map) const</td></tr>
<tr class="memdesc:af90a2eb58b242d1a85176e32435004c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#af90a2eb58b242d1a85176e32435004c9">More...</a><br /></td></tr>
<tr class="separator:af90a2eb58b242d1a85176e32435004c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785245d5f0f534300a31f9c7cc1b70c0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a785245d5f0f534300a31f9c7cc1b70c0">Clone</a> () const</td></tr>
<tr class="memdesc:a785245d5f0f534300a31f9c7cc1b70c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of <code>this</code> MultibodyTree templated on the same scalar type T as <code>this</code> tree.  <a href="#a785245d5f0f534300a31f9c7cc1b70c0">More...</a><br /></td></tr>
<tr class="separator:a785245d5f0f534300a31f9c7cc1b70c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af043fd921c9543fc70c3e903295a9e87"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af043fd921c9543fc70c3e903295a9e87">ToAutoDiffXd</a> () const</td></tr>
<tr class="memdesc:af043fd921c9543fc70c3e903295a9e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of <code>this</code> MultibodyTree templated on AutoDiffXd.  <a href="#af043fd921c9543fc70c3e903295a9e87">More...</a><br /></td></tr>
<tr class="separator:af043fd921c9543fc70c3e903295a9e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa867ed6fe063cc08113ff54918da55a7"><td class="memTemplParams" colspan="2">template&lt;typename ToScalar &gt; </td></tr>
<tr class="memitem:aa867ed6fe063cc08113ff54918da55a7"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; ToScalar &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aa867ed6fe063cc08113ff54918da55a7">CloneToScalar</a> () const</td></tr>
<tr class="memdesc:aa867ed6fe063cc08113ff54918da55a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of <code>this</code> MultibodyTree templated on the scalar type <code>ToScalar</code>.  <a href="#aa867ed6fe063cc08113ff54918da55a7">More...</a><br /></td></tr>
<tr class="separator:aa867ed6fe063cc08113ff54918da55a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed59e6f62bfe30a418ba8d8c611580af"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aed59e6f62bfe30a418ba8d8c611580af">EvalPositionKinematics</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aed59e6f62bfe30a418ba8d8c611580af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates position kinematics cached in context.  <a href="#aed59e6f62bfe30a418ba8d8c611580af">More...</a><br /></td></tr>
<tr class="separator:aed59e6f62bfe30a418ba8d8c611580af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0adc712bc2d51f9aa758e8d726276d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_velocity_kinematics_cache.html">VelocityKinematicsCache</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a4d0adc712bc2d51f9aa758e8d726276d">EvalVelocityKinematics</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a4d0adc712bc2d51f9aa758e8d726276d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates velocity kinematics cached in context.  <a href="#a4d0adc712bc2d51f9aa758e8d726276d">More...</a><br /></td></tr>
<tr class="separator:a4d0adc712bc2d51f9aa758e8d726276d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1640dac294e20deb224eec1f6496c316"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a1640dac294e20deb224eec1f6496c316">set_tree_system</a> (<a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree_system.html">MultibodyTreeSystem</a>&lt; T &gt; *tree_system)</td></tr>
<tr class="memdesc:a1640dac294e20deb224eec1f6496c316"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Informs the <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html" title="MultibodyTree provides a representation for a physical system consisting of a collection of interconn...">MultibodyTree</a> how to access its resources within a Context.  <a href="#a1640dac294e20deb224eec1f6496c316">More...</a><br /></td></tr>
<tr class="separator:a1640dac294e20deb224eec1f6496c316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9ccb27e7c45be210dad2156344bb32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aad9ccb27e7c45be210dad2156344bb32">CalcAcrossNodeGeometricJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;pc, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a>&lt; T &gt;&gt; *H_PB_W_cache) const</td></tr>
<tr class="memdesc:aad9ccb27e7c45be210dad2156344bb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal) Computes the cache entry associated with the geometric Jacobian H_PB_W for each node.  <a href="#aad9ccb27e7c45be210dad2156344bb32">More...</a><br /></td></tr>
<tr class="separator:aad9ccb27e7c45be210dad2156344bb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a0f5fa5e7cd808af3f302ece79ef798bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a0f5fa5e7cd808af3f302ece79ef798bb">MultibodyTree</a> (const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a> &amp;)=delete</td></tr>
<tr class="separator:a0f5fa5e7cd808af3f302ece79ef798bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7d88ffae63ddf3c6c81b23fe3d7a89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aba7d88ffae63ddf3c6c81b23fe3d7a89">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a> &amp;)=delete</td></tr>
<tr class="separator:aba7d88ffae63ddf3c6c81b23fe3d7a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dbe8fe859cf4fe29d66a92ac86aac1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a56dbe8fe859cf4fe29d66a92ac86aac1">MultibodyTree</a> (<a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a56dbe8fe859cf4fe29d66a92ac86aac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa14b83a5d66b905376d7654ef7cf7a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#afa14b83a5d66b905376d7654ef7cf7a2">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:afa14b83a5d66b905376d7654ef7cf7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to add new MultibodyTree elements.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>To create a MultibodyTree users will add multibody elements like bodies, joints, force elements, constraints, etc, using one of these methods.</p>
<p>Once a user is done adding multibody elements, the <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> method <b>must</b> be called before invoking any MultibodyTree method. See <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> for details. </p>
</div></td></tr>
<tr class="memitem:aad2a8b4067faf5cff8b2bc380dc698be"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class BodyType&gt; </td></tr>
<tr class="memitem:aad2a8b4067faf5cff8b2bc380dc698be"><td class="memTemplItemLeft" align="right" valign="top">const BodyType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aad2a8b4067faf5cff8b2bc380dc698be">AddBody</a> (std::unique_ptr&lt; BodyType&lt; T &gt;&gt; body)</td></tr>
<tr class="memdesc:aad2a8b4067faf5cff8b2bc380dc698be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of <code>body</code> and adds it to <code>this</code> MultibodyTree.  <a href="#aad2a8b4067faf5cff8b2bc380dc698be">More...</a><br /></td></tr>
<tr class="separator:aad2a8b4067faf5cff8b2bc380dc698be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252677addd073f9b045b1e6cc2b750aa"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class BodyType, typename... Args&gt; </td></tr>
<tr class="memitem:a252677addd073f9b045b1e6cc2b750aa"><td class="memTemplItemLeft" align="right" valign="top">const BodyType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a252677addd073f9b045b1e6cc2b750aa">AddBody</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a252677addd073f9b045b1e6cc2b750aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new body with type <code>BodyType</code> with the given <code>args</code>, and adds it to <code>this</code> MultibodyTree, which retains ownership.  <a href="#a252677addd073f9b045b1e6cc2b750aa">More...</a><br /></td></tr>
<tr class="separator:a252677addd073f9b045b1e6cc2b750aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6a68c31772eaa0c855ebb44eeaa0b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a9f6a68c31772eaa0c855ebb44eeaa0b7">AddRigidBody</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;M_BBo_B)</td></tr>
<tr class="memdesc:a9f6a68c31772eaa0c855ebb44eeaa0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid body with the provided name, model instance, and spatial inertia.  <a href="#a9f6a68c31772eaa0c855ebb44eeaa0b7">More...</a><br /></td></tr>
<tr class="separator:a9f6a68c31772eaa0c855ebb44eeaa0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461a59b672f8c3f7c0dcc5caed56d245"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a461a59b672f8c3f7c0dcc5caed56d245">AddRigidBody</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;M_BBo_B)</td></tr>
<tr class="memdesc:a461a59b672f8c3f7c0dcc5caed56d245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid body with the provided name, model instance, and spatial inertia.  <a href="#a461a59b672f8c3f7c0dcc5caed56d245">More...</a><br /></td></tr>
<tr class="separator:a461a59b672f8c3f7c0dcc5caed56d245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474c90a0b3e4f9349533207026413186"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class FrameType&gt; </td></tr>
<tr class="memitem:a474c90a0b3e4f9349533207026413186"><td class="memTemplItemLeft" align="right" valign="top">const FrameType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a474c90a0b3e4f9349533207026413186">AddFrame</a> (std::unique_ptr&lt; FrameType&lt; T &gt;&gt; frame)</td></tr>
<tr class="memdesc:a474c90a0b3e4f9349533207026413186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of <code>frame</code> and adds it to <code>this</code> MultibodyTree.  <a href="#a474c90a0b3e4f9349533207026413186">More...</a><br /></td></tr>
<tr class="separator:a474c90a0b3e4f9349533207026413186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e119424a5a8fdf49e5fa611086d8321"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class FrameType, typename... Args&gt; </td></tr>
<tr class="memitem:a9e119424a5a8fdf49e5fa611086d8321"><td class="memTemplItemLeft" align="right" valign="top">const FrameType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a9e119424a5a8fdf49e5fa611086d8321">AddFrame</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9e119424a5a8fdf49e5fa611086d8321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new frame with type <code>FrameType</code> with the given <code>args</code>, and adds it to <code>this</code> MultibodyTree, which retains ownership.  <a href="#a9e119424a5a8fdf49e5fa611086d8321">More...</a><br /></td></tr>
<tr class="separator:a9e119424a5a8fdf49e5fa611086d8321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8886c79b1a00896934a25d70317f1033"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class MobilizerType&gt; </td></tr>
<tr class="memitem:a8886c79b1a00896934a25d70317f1033"><td class="memTemplItemLeft" align="right" valign="top">const MobilizerType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8886c79b1a00896934a25d70317f1033">AddMobilizer</a> (std::unique_ptr&lt; MobilizerType&lt; T &gt;&gt; mobilizer)</td></tr>
<tr class="memdesc:a8886c79b1a00896934a25d70317f1033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of <code>mobilizer</code> and adds it to <code>this</code> MultibodyTree.  <a href="#a8886c79b1a00896934a25d70317f1033">More...</a><br /></td></tr>
<tr class="separator:a8886c79b1a00896934a25d70317f1033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc1a892b1280cd50ad8ad4b3d43cd7a"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class MobilizerType, typename... Args&gt; </td></tr>
<tr class="memitem:a5cc1a892b1280cd50ad8ad4b3d43cd7a"><td class="memTemplItemLeft" align="right" valign="top">const MobilizerType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a5cc1a892b1280cd50ad8ad4b3d43cd7a">AddMobilizer</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5cc1a892b1280cd50ad8ad4b3d43cd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new mobilizer with type <code>MobilizerType</code> with the given <code>args</code>, and adds it to <code>this</code> MultibodyTree, which retains ownership.  <a href="#a5cc1a892b1280cd50ad8ad4b3d43cd7a">More...</a><br /></td></tr>
<tr class="separator:a5cc1a892b1280cd50ad8ad4b3d43cd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb63d2130f743dab6cda576e8f3c56d"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class ForceElementType&gt; </td></tr>
<tr class="memitem:a8eb63d2130f743dab6cda576e8f3c56d"><td class="memTemplItemLeft" align="right" valign="top">const ForceElementType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8eb63d2130f743dab6cda576e8f3c56d">AddForceElement</a> (std::unique_ptr&lt; ForceElementType&lt; T &gt;&gt; force_element)</td></tr>
<tr class="memdesc:a8eb63d2130f743dab6cda576e8f3c56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and adds to <code>this</code> MultibodyTree (which retains ownership) a new <code><a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a></code> member with the specific type <code>ForceElementType</code>.  <a href="#a8eb63d2130f743dab6cda576e8f3c56d">More...</a><br /></td></tr>
<tr class="separator:a8eb63d2130f743dab6cda576e8f3c56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48009c793b01c5a6dd079d33265435a3"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class ForceElementType, typename... Args&gt; </td></tr>
<tr class="memitem:a48009c793b01c5a6dd079d33265435a3"><td class="memTemplItemLeft" align="right" valign="top">const ForceElementType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a48009c793b01c5a6dd079d33265435a3">AddForceElement</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a48009c793b01c5a6dd079d33265435a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new force element model of type <code>ForceElementType</code> to <code>this</code> MultibodyTree.  <a href="#a48009c793b01c5a6dd079d33265435a3">More...</a><br /></td></tr>
<tr class="separator:a48009c793b01c5a6dd079d33265435a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cff198ad9234fff817bef3f25b98345"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class ForceElementType, typename... Args&gt; </td></tr>
<tr class="memitem:a2cff198ad9234fff817bef3f25b98345"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; ForceElementType&lt; T &gt;, <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html">UniformGravityFieldElement</a>&lt; T &gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const ForceElementType&lt; T &gt; &amp; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a2cff198ad9234fff817bef3f25b98345">AddForceElement</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a2cff198ad9234fff817bef3f25b98345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437f86026a2268c0fb06936b899ba8d7"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class JointType&gt; </td></tr>
<tr class="memitem:a437f86026a2268c0fb06936b899ba8d7"><td class="memTemplItemLeft" align="right" valign="top">const JointType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a437f86026a2268c0fb06936b899ba8d7">AddJoint</a> (std::unique_ptr&lt; JointType&lt; T &gt;&gt; joint)</td></tr>
<tr class="memdesc:a437f86026a2268c0fb06936b899ba8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <code>JointType</code> between the frames specified by the joint.  <a href="#a437f86026a2268c0fb06936b899ba8d7">More...</a><br /></td></tr>
<tr class="separator:a437f86026a2268c0fb06936b899ba8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac828f1c818a0ed3f47ff5f342fa0ee0c"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class JointType, typename... Args&gt; </td></tr>
<tr class="memitem:ac828f1c818a0ed3f47ff5f342fa0ee0c"><td class="memTemplItemLeft" align="right" valign="top">const JointType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ac828f1c818a0ed3f47ff5f342fa0ee0c">AddJoint</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;parent, const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;X_PF, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;child, const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;X_BM, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac828f1c818a0ed3f47ff5f342fa0ee0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method helps to create a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <code>JointType</code> between two bodies.  <a href="#ac828f1c818a0ed3f47ff5f342fa0ee0c">More...</a><br /></td></tr>
<tr class="separator:ac828f1c818a0ed3f47ff5f342fa0ee0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5096160ffb18ddc72e2e29c0edfc5064"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a5096160ffb18ddc72e2e29c0edfc5064">AddJointActuator</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;joint)</td></tr>
<tr class="memdesc:a5096160ffb18ddc72e2e29c0edfc5064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and adds a <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> model for an actuator acting on a given <code>joint</code>.  <a href="#a5096160ffb18ddc72e2e29c0edfc5064">More...</a><br /></td></tr>
<tr class="separator:a5096160ffb18ddc72e2e29c0edfc5064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edf1daa65069a26255c903b02bce4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a4edf1daa65069a26255c903b02bce4c6">AddModelInstance</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a4edf1daa65069a26255c903b02bce4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new model instance.  <a href="#a4edf1daa65069a26255c903b02bce4c6">More...</a><br /></td></tr>
<tr class="separator:a4edf1daa65069a26255c903b02bce4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Querying for multibody elements by name</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods allow a user to query whether a given multibody element is part of <code>this</code> model.</p>
<p>These queries can be performed at any time during the lifetime of a MultibodyTree model, i.e. there is no restriction on whether they must be called before or after <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a>. That is, these queries can be performed while new multibody elements are being added to the model. </p>
</div></td></tr>
<tr class="memitem:a89a198b6549e543018c7c9873d4e6dc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="separator:a89a198b6549e543018c7c9873d4e6dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5aa85a70a9f0f196091ed298266c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a2c5aa85a70a9f0f196091ed298266c57">HasBodyNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="separator:a2c5aa85a70a9f0f196091ed298266c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3530f8f6747cb603a24accba5901bd00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a3530f8f6747cb603a24accba5901bd00">HasFrameNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:a3530f8f6747cb603a24accba5901bd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a3530f8f6747cb603a24accba5901bd00">More...</a><br /></td></tr>
<tr class="separator:a3530f8f6747cb603a24accba5901bd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab3a66ab482037c12c4d556800c550a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a7ab3a66ab482037c12c4d556800c550a">HasFrameNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a7ab3a66ab482037c12c4d556800c550a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a7ab3a66ab482037c12c4d556800c550a">More...</a><br /></td></tr>
<tr class="separator:a7ab3a66ab482037c12c4d556800c550a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c811258a0d93dd116d61648334a392"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a02c811258a0d93dd116d61648334a392">HasJointNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:a02c811258a0d93dd116d61648334a392"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a02c811258a0d93dd116d61648334a392">More...</a><br /></td></tr>
<tr class="separator:a02c811258a0d93dd116d61648334a392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ebee03109f4cb8990124949e97caa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ac7ebee03109f4cb8990124949e97caa1">HasJointNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:ac7ebee03109f4cb8990124949e97caa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ac7ebee03109f4cb8990124949e97caa1">More...</a><br /></td></tr>
<tr class="separator:ac7ebee03109f4cb8990124949e97caa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dd7e61bafa3221193e7d68e4be7cbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a30dd7e61bafa3221193e7d68e4be7cbc">HasJointActuatorNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:a30dd7e61bafa3221193e7d68e4be7cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a30dd7e61bafa3221193e7d68e4be7cbc">More...</a><br /></td></tr>
<tr class="separator:a30dd7e61bafa3221193e7d68e4be7cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6ad707643bf5220e76678e71291175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a0f6ad707643bf5220e76678e71291175">HasJointActuatorNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a0f6ad707643bf5220e76678e71291175"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a0f6ad707643bf5220e76678e71291175">More...</a><br /></td></tr>
<tr class="separator:a0f6ad707643bf5220e76678e71291175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b71664c8e2e91bc3fc92fef222a9bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a05b71664c8e2e91bc3fc92fef222a9bf">HasModelInstanceNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:a05b71664c8e2e91bc3fc92fef222a9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">See MultibodyMethod.  <a href="#a05b71664c8e2e91bc3fc92fef222a9bf">More...</a><br /></td></tr>
<tr class="separator:a05b71664c8e2e91bc3fc92fef222a9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Model instance accessors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Many functions on MultibodyTree expect vectors of tree state or joint actuator inputs which encompass the entire tree.</p>
<p>Methods in this section are convenience accessors for the portion of those vectors which apply to a single model instance only. </p>
</div></td></tr>
<tr class="memitem:aec851e17ae2c34da1b87a03ce85f460a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aec851e17ae2c34da1b87a03ce85f460a">SetActuationInArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;u_instance, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; u) const</td></tr>
<tr class="memdesc:aec851e17ae2c34da1b87a03ce85f460a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#aec851e17ae2c34da1b87a03ce85f460a">More...</a><br /></td></tr>
<tr class="separator:aec851e17ae2c34da1b87a03ce85f460a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd88fc59ef9748edd8e6824f029c38f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#acd88fc59ef9748edd8e6824f029c38f1">GetPositionsFromArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;q) const</td></tr>
<tr class="memdesc:acd88fc59ef9748edd8e6824f029c38f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#acd88fc59ef9748edd8e6824f029c38f1">More...</a><br /></td></tr>
<tr class="separator:acd88fc59ef9748edd8e6824f029c38f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de72c319632f5a263fe6c9e96c70614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a3de72c319632f5a263fe6c9e96c70614">SetPositionsInArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;q_instance, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; q) const</td></tr>
<tr class="memdesc:a3de72c319632f5a263fe6c9e96c70614"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a3de72c319632f5a263fe6c9e96c70614">More...</a><br /></td></tr>
<tr class="separator:a3de72c319632f5a263fe6c9e96c70614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312d791d9b130cd29d5e0587777f2472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a312d791d9b130cd29d5e0587777f2472">GetVelocitiesFromArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;v_array) const</td></tr>
<tr class="memdesc:a312d791d9b130cd29d5e0587777f2472"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a312d791d9b130cd29d5e0587777f2472">More...</a><br /></td></tr>
<tr class="separator:a312d791d9b130cd29d5e0587777f2472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e24d7263c7886bdf1adab111e34f33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aa3e24d7263c7886bdf1adab111e34f33">SetVelocitiesInArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;model_v, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; v_array) const</td></tr>
<tr class="memdesc:aa3e24d7263c7886bdf1adab111e34f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vector of generalized velocities for <code>model_instance</code> in <code>v</code> using <code>v_instance</code>, leaving all other elements in the array untouched.  <a href="#aa3e24d7263c7886bdf1adab111e34f33">More...</a><br /></td></tr>
<tr class="separator:aa3e24d7263c7886bdf1adab111e34f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Kinematic computations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Kinematics computations are concerned with the motion of bodies in the model without regard to their mass or the forces and moments that cause the motion.</p>
<p>Methods in this category include the computation of poses and spatial velocities. </p>
</div></td></tr>
<tr class="memitem:aaeadfd9964b1aee6282b5be5938e267b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aaeadfd9964b1aee6282b5be5938e267b">CalcAllBodyPosesInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt;&gt; *X_WB) const</td></tr>
<tr class="memdesc:aaeadfd9964b1aee6282b5be5938e267b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#aaeadfd9964b1aee6282b5be5938e267b">More...</a><br /></td></tr>
<tr class="separator:aaeadfd9964b1aee6282b5be5938e267b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29481c9f2a7aa54ce05ce374ad6f359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ac29481c9f2a7aa54ce05ce374ad6f359">CalcAllBodySpatialVelocitiesInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt;&gt; *V_WB) const</td></tr>
<tr class="memdesc:ac29481c9f2a7aa54ce05ce374ad6f359"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ac29481c9f2a7aa54ce05ce374ad6f359">More...</a><br /></td></tr>
<tr class="separator:ac29481c9f2a7aa54ce05ce374ad6f359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8d1363712b6824a1490b4a6ff16fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a5f8d1363712b6824a1490b4a6ff16fbe">CalcRelativeTransform</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B) const</td></tr>
<tr class="memdesc:a5f8d1363712b6824a1490b4a6ff16fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a5f8d1363712b6824a1490b4a6ff16fbe">More...</a><br /></td></tr>
<tr class="separator:a5f8d1363712b6824a1490b4a6ff16fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bce36db6170b2ed1ee53481f8017a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a27bce36db6170b2ed1ee53481f8017a5">CalcPointsPositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;p_BQi, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; p_AQi) const</td></tr>
<tr class="memdesc:a27bce36db6170b2ed1ee53481f8017a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a27bce36db6170b2ed1ee53481f8017a5">More...</a><br /></td></tr>
<tr class="separator:a27bce36db6170b2ed1ee53481f8017a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27053b1ed343ccd9640259fd442d8e14"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a27053b1ed343ccd9640259fd442d8e14">EvalBodyPoseInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body_B) const</td></tr>
<tr class="memdesc:a27053b1ed343ccd9640259fd442d8e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a27053b1ed343ccd9640259fd442d8e14">More...</a><br /></td></tr>
<tr class="separator:a27053b1ed343ccd9640259fd442d8e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019e8c73d7084e073b4e09a1c0df3b18"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a019e8c73d7084e073b4e09a1c0df3b18">EvalBodySpatialVelocityInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body_B) const</td></tr>
<tr class="memdesc:a019e8c73d7084e073b4e09a1c0df3b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">See MultibodyPlantMethod.  <a href="#a019e8c73d7084e073b4e09a1c0df3b18">More...</a><br /></td></tr>
<tr class="separator:a019e8c73d7084e073b4e09a1c0df3b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to compute multibody Jacobians.</div></td></tr>
<tr class="memitem:ae28789d38fa6e3e0fc382fa3b0b0b882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ae28789d38fa6e3e0fc382fa3b0b0b882">CalcPointsGeometricJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;p_FP_list, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; p_WP_list, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jv_WFp) const</td></tr>
<tr class="memdesc:ae28789d38fa6e3e0fc382fa3b0b0b882"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ae28789d38fa6e3e0fc382fa3b0b0b882">More...</a><br /></td></tr>
<tr class="separator:ae28789d38fa6e3e0fc382fa3b0b0b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4978894bc930fdb65827c03214ac9103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a4978894bc930fdb65827c03214ac9103">CalcPointsGeometricJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;p_WP_list, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jv_WFp) const</td></tr>
<tr class="memdesc:a4978894bc930fdb65827c03214ac9103"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a4978894bc930fdb65827c03214ac9103">More...</a><br /></td></tr>
<tr class="separator:a4978894bc930fdb65827c03214ac9103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeef1250479b5a8b519e99de4f920bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aeeef1250479b5a8b519e99de4f920bb5">CalcBiasForPointsGeometricJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;p_FP_list) const</td></tr>
<tr class="memdesc:aeeef1250479b5a8b519e99de4f920bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#aeeef1250479b5a8b519e99de4f920bb5">More...</a><br /></td></tr>
<tr class="separator:aeeef1250479b5a8b519e99de4f920bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08a137307614d55094430b858f0e8cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aa08a137307614d55094430b858f0e8cb">CalcPointsAnalyticalJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;p_FP_list, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; p_WP_list, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jq_WFp) const</td></tr>
<tr class="memdesc:aa08a137307614d55094430b858f0e8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#aa08a137307614d55094430b858f0e8cb">More...</a><br /></td></tr>
<tr class="separator:aa08a137307614d55094430b858f0e8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45405f29fd8ad82a7459fd05642b329e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a45405f29fd8ad82a7459fd05642b329e">CalcFrameGeometricJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;p_FP, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jv_WFp) const</td></tr>
<tr class="memdesc:a45405f29fd8ad82a7459fd05642b329e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a45405f29fd8ad82a7459fd05642b329e">More...</a><br /></td></tr>
<tr class="separator:a45405f29fd8ad82a7459fd05642b329e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9852a710b6fdd9e08d3bbc328485734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ad9852a710b6fdd9e08d3bbc328485734">CalcRelativeFrameGeometricJacobian</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;p_BP, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jv_ABp_E) const</td></tr>
<tr class="memdesc:ad9852a710b6fdd9e08d3bbc328485734"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ad9852a710b6fdd9e08d3bbc328485734">More...</a><br /></td></tr>
<tr class="separator:ad9852a710b6fdd9e08d3bbc328485734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de2905e3f4541d4714e0a63a442e650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a9de2905e3f4541d4714e0a63a442e650">CalcBiasForFrameGeometricJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;p_FP) const</td></tr>
<tr class="memdesc:a9de2905e3f4541d4714e0a63a442e650"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a9de2905e3f4541d4714e0a63a442e650">More...</a><br /></td></tr>
<tr class="separator:a9de2905e3f4541d4714e0a63a442e650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c0dbd7529fadcbf1fd550a9fd2e80b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a78c0dbd7529fadcbf1fd550a9fd2e80b">CalcJacobianSpatialVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;p_BP, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jw_ABp_E) const</td></tr>
<tr class="memdesc:a78c0dbd7529fadcbf1fd550a9fd2e80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a78c0dbd7529fadcbf1fd550a9fd2e80b">More...</a><br /></td></tr>
<tr class="separator:a78c0dbd7529fadcbf1fd550a9fd2e80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computational methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods expose the computational capabilities of <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html" title="MultibodyTree provides a representation for a physical system consisting of a collection of interconn...">MultibodyTree</a> to compute kinematics, forward and inverse dynamics, and Jacobian matrices, among others.</p>
<p>These methods follow Drake's naming scheme for methods performing a computation and therefore are named <code>CalcXXX()</code>, where <code>XXX</code> corresponds to the quantity or object of interest to be computed. They all take a <code><a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">systems::Context</a></code> as an input argument storing the state of the multibody system. A <code>std::bad_cast</code> exception is thrown if the passed context is not a <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree_context.html" title="MultibodyTreeContext is an object that contains all the information needed to uniquely determine the ...">MultibodyTreeContext</a>. </p>
</div></td></tr>
<tr class="memitem:a8567e741678adde3a08c0b317d908d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8567e741678adde3a08c0b317d908d72">CalcPositionKinematicsCache</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; *pc) const</td></tr>
<tr class="memdesc:a8567e741678adde3a08c0b317d908d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes into the position kinematics <code>pc</code> all the kinematic quantities that depend on the generalized positions only.  <a href="#a8567e741678adde3a08c0b317d908d72">More...</a><br /></td></tr>
<tr class="separator:a8567e741678adde3a08c0b317d908d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7201e5e8f39b3f08f934f0bca3108b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a7d7201e5e8f39b3f08f934f0bca3108b">CalcVelocityKinematicsCache</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;pc, <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_velocity_kinematics_cache.html">VelocityKinematicsCache</a>&lt; T &gt; *vc) const</td></tr>
<tr class="memdesc:a7d7201e5e8f39b3f08f934f0bca3108b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all the kinematic quantities that depend on the generalized velocities and stores them in the velocity kinematics cache <code>vc</code>.  <a href="#a7d7201e5e8f39b3f08f934f0bca3108b">More...</a><br /></td></tr>
<tr class="separator:a7d7201e5e8f39b3f08f934f0bca3108b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade29d7e9d45e33e20c1521cc0130a096"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ade29d7e9d45e33e20c1521cc0130a096">CalcAccelerationKinematicsCache</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;pc, const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_velocity_kinematics_cache.html">VelocityKinematicsCache</a>&lt; T &gt; &amp;vc, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;known_vdot, <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_acceleration_kinematics_cache.html">AccelerationKinematicsCache</a>&lt; T &gt; *ac) const</td></tr>
<tr class="memdesc:ade29d7e9d45e33e20c1521cc0130a096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all the kinematic quantities that depend on the generalized accelerations that is, the generalized velocities' time derivatives, and stores them in the acceleration kinematics cache <code>ac</code>.  <a href="#ade29d7e9d45e33e20c1521cc0130a096">More...</a><br /></td></tr>
<tr class="separator:ade29d7e9d45e33e20c1521cc0130a096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5044683fbf851576698f97ddc2e5de2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a5044683fbf851576698f97ddc2e5de2f">CalcSpatialAccelerationsFromVdot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;pc, const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_velocity_kinematics_cache.html">VelocityKinematicsCache</a>&lt; T &gt; &amp;vc, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;known_vdot, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&gt; *A_WB_array) const</td></tr>
<tr class="memdesc:a5044683fbf851576698f97ddc2e5de2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a5044683fbf851576698f97ddc2e5de2f">More...</a><br /></td></tr>
<tr class="separator:a5044683fbf851576698f97ddc2e5de2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d9f1dfe387a173b84c49a5bbe5a4c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af3d9f1dfe387a173b84c49a5bbe5a4c2">CalcInverseDynamics</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;known_vdot, const <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; &amp;external_forces) const</td></tr>
<tr class="memdesc:af3d9f1dfe387a173b84c49a5bbe5a4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#af3d9f1dfe387a173b84c49a5bbe5a4c2">More...</a><br /></td></tr>
<tr class="separator:af3d9f1dfe387a173b84c49a5bbe5a4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868db3695aaead74e12f38a0f40c442d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a868db3695aaead74e12f38a0f40c442d">CalcInverseDynamics</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;pc, const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_velocity_kinematics_cache.html">VelocityKinematicsCache</a>&lt; T &gt; &amp;vc, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;known_vdot, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html">SpatialForce</a>&lt; T &gt;&gt; &amp;Fapplied_Bo_W_array, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;tau_applied_array, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&gt; *A_WB_array, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html">SpatialForce</a>&lt; T &gt;&gt; *F_BMo_W_array, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; tau_array) const</td></tr>
<tr class="memdesc:a868db3695aaead74e12f38a0f40c442d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Given the state of <code>this</code> MultibodyTree in <code>context</code> and a known vector of generalized accelerations <code>vdot</code>, this method computes the set of generalized forces <code>tau</code> that would need to be applied at each <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html" title="Mobilizer is a fundamental object within Drake&#39;s multibody engine used to specify the allowed motions...">Mobilizer</a> in order to attain the specified generalized accelerations.  <a href="#a868db3695aaead74e12f38a0f40c442d">More...</a><br /></td></tr>
<tr class="separator:a868db3695aaead74e12f38a0f40c442d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e03fb7982f08defb30afa2cced922c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a25e03fb7982f08defb30afa2cced922c">CalcForceElementsContribution</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;pc, const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_velocity_kinematics_cache.html">VelocityKinematicsCache</a>&lt; T &gt; &amp;vc, <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; *forces) const</td></tr>
<tr class="memdesc:a25e03fb7982f08defb30afa2cced922c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a25e03fb7982f08defb30afa2cced922c">More...</a><br /></td></tr>
<tr class="separator:a25e03fb7982f08defb30afa2cced922c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35681a2d7d9d4026b6bc61f08da861f8"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a35681a2d7d9d4026b6bc61f08da861f8">CalcPotentialEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a35681a2d7d9d4026b6bc61f08da861f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a35681a2d7d9d4026b6bc61f08da861f8">More...</a><br /></td></tr>
<tr class="separator:a35681a2d7d9d4026b6bc61f08da861f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d32c695cacd92615cb9b3773a17eb9"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af5d32c695cacd92615cb9b3773a17eb9">CalcConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:af5d32c695cacd92615cb9b3773a17eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#af5d32c695cacd92615cb9b3773a17eb9">More...</a><br /></td></tr>
<tr class="separator:af5d32c695cacd92615cb9b3773a17eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3238273c2c927101e4515147bed17f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ac3238273c2c927101e4515147bed17f6">CalcMassMatrixViaInverseDynamics</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; H) const</td></tr>
<tr class="memdesc:ac3238273c2c927101e4515147bed17f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ac3238273c2c927101e4515147bed17f6">More...</a><br /></td></tr>
<tr class="separator:ac3238273c2c927101e4515147bed17f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843e1ba389c017c706df10935784b4e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a843e1ba389c017c706df10935784b4e5">CalcBiasTerm</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; Cv) const</td></tr>
<tr class="memdesc:a843e1ba389c017c706df10935784b4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a843e1ba389c017c706df10935784b4e5">More...</a><br /></td></tr>
<tr class="separator:a843e1ba389c017c706df10935784b4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1293f0e09ec2d3df0a9eaeab6baa9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a0b1293f0e09ec2d3df0a9eaeab6baa9a">CalcGravityGeneralizedForces</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a0b1293f0e09ec2d3df0a9eaeab6baa9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a0b1293f0e09ec2d3df0a9eaeab6baa9a">More...</a><br /></td></tr>
<tr class="separator:a0b1293f0e09ec2d3df0a9eaeab6baa9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb24fed19f16a76450eece1857b92dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a7bb24fed19f16a76450eece1857b92dc">MapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;v, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; qdot) const</td></tr>
<tr class="memdesc:a7bb24fed19f16a76450eece1857b92dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#a7bb24fed19f16a76450eece1857b92dc">More...</a><br /></td></tr>
<tr class="separator:a7bb24fed19f16a76450eece1857b92dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab128a8bba10523922358bc35df103753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ab128a8bba10523922358bc35df103753">MapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;qdot, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; v) const</td></tr>
<tr class="memdesc:ab128a8bba10523922358bc35df103753"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method.  <a href="#ab128a8bba10523922358bc35df103753">More...</a><br /></td></tr>
<tr class="separator:ab128a8bba10523922358bc35df103753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77db3ff9323ef1ed77769a11420024c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ab77db3ff9323ef1ed77769a11420024c">CalcArticulatedBodyInertiaCache</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;pc, <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_articulated_body_inertia_cache.html">ArticulatedBodyInertiaCache</a>&lt; T &gt; *abc) const</td></tr>
<tr class="memdesc:ab77db3ff9323ef1ed77769a11420024c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all the quantities that are required in the final pass of the articulated body algorithm and stores them in the articulated body cache <code>abc</code>.  <a href="#ab77db3ff9323ef1ed77769a11420024c">More...</a><br /></td></tr>
<tr class="separator:ab77db3ff9323ef1ed77769a11420024c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to retrieve multibody element variants</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Given two variants of the same MultibodyTree, these methods map an element in one variant, to its corresponding element in the other variant.</p>
<p>A concrete case is the call to <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af043fd921c9543fc70c3e903295a9e87" title="Creates a deep copy of this MultibodyTree templated on AutoDiffXd. ">ToAutoDiffXd()</a> to obtain a MultibodyTree variant templated on AutoDiffXd from a MultibodyTree templated on <code>double</code>. Typically, a user holding a <code><a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a>&lt;double&gt;</code> (or any other multibody element in the original variant templated on <code>double</code>) would like to retrieve the corresponding <code><a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a>&lt;AutoDiffXd&gt;</code> variant from the new AutoDiffXd tree variant.</p>
<p>Consider the following code example: </p><div class="fragment"><div class="line"><span class="comment">// The user creates a model.</span></div><div class="line">MultibodyTree&lt;double&gt; model;</div><div class="line"><span class="comment">// User adds a body and keeps a reference to it.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="class_rigid_body.html">RigidBody&lt;double&gt;</a>&amp; body = model.AddBody&lt;<a class="code" href="class_rigid_body.html">RigidBody</a>&gt;(...);</div><div class="line"><span class="comment">// User creates an AutoDiffXd variant. Variants on other scalar types</span></div><div class="line"><span class="comment">// can be created with a call to CloneToScalar().</span></div><div class="line">std::unique_ptr&lt;MultibodyTree&lt;Tvariant&gt;&gt; variant_model =</div><div class="line">    model.ToAutoDiffXd();</div><div class="line"><span class="comment">// User retrieves the AutoDiffXd variant corresponding to the original</span></div><div class="line"><span class="comment">// body added above.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="class_rigid_body.html">RigidBody&lt;AutoDiffXd&gt;</a>&amp;</div><div class="line">    variant_body = variant_model.get_variant(body);</div></div><!-- fragment --><p><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a23174e772fb8c1b19c0af3b74a11ab28" title="SFINAE overload for Frame&lt;T&gt; elements. ">MultibodyTree::get_variant()</a> is templated on the multibody element type which is deduced from its only input argument. The returned element is templated on the scalar type T of the MultibodyTree on which this method is invoked. </p>
</div></td></tr>
<tr class="memitem:a23174e772fb8c1b19c0af3b74a11ab28"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class MultibodyElement, typename Scalar &gt; </td></tr>
<tr class="memitem:a23174e772fb8c1b19c0af3b74a11ab28"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt;, MultibodyElement&lt; T &gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const MultibodyElement&lt; T &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a23174e772fb8c1b19c0af3b74a11ab28">get_variant</a> (const MultibodyElement&lt; Scalar &gt; &amp;element) const</td></tr>
<tr class="memdesc:a23174e772fb8c1b19c0af3b74a11ab28"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE overload for Frame&lt;T&gt; elements.  <a href="#a23174e772fb8c1b19c0af3b74a11ab28">More...</a><br /></td></tr>
<tr class="separator:a23174e772fb8c1b19c0af3b74a11ab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2707c103cfdfef93d0e75241ff9c019"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class MultibodyElement, typename Scalar &gt; </td></tr>
<tr class="memitem:af2707c103cfdfef93d0e75241ff9c019"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt;, MultibodyElement&lt; T &gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const MultibodyElement&lt; T &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af2707c103cfdfef93d0e75241ff9c019">get_variant</a> (const MultibodyElement&lt; Scalar &gt; &amp;element) const</td></tr>
<tr class="memdesc:af2707c103cfdfef93d0e75241ff9c019"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE overload for Body&lt;T&gt; elements.  <a href="#af2707c103cfdfef93d0e75241ff9c019">More...</a><br /></td></tr>
<tr class="separator:af2707c103cfdfef93d0e75241ff9c019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae259eef7ffd400141b97760fc6a78e58"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class MultibodyElement, typename Scalar &gt; </td></tr>
<tr class="memitem:ae259eef7ffd400141b97760fc6a78e58"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html">Mobilizer</a>&lt; T &gt;, MultibodyElement&lt; T &gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const MultibodyElement&lt; T &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ae259eef7ffd400141b97760fc6a78e58">get_variant</a> (const MultibodyElement&lt; Scalar &gt; &amp;element) const</td></tr>
<tr class="memdesc:ae259eef7ffd400141b97760fc6a78e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE overload for Mobilizer&lt;T&gt; elements.  <a href="#ae259eef7ffd400141b97760fc6a78e58">More...</a><br /></td></tr>
<tr class="separator:ae259eef7ffd400141b97760fc6a78e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ac839314967d0e8c8d129d64758fd5"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class MultibodyElement, typename Scalar &gt; </td></tr>
<tr class="memitem:a21ac839314967d0e8c8d129d64758fd5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html">Mobilizer</a>&lt; T &gt;, MultibodyElement&lt; T &gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, MultibodyElement&lt; T &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a21ac839314967d0e8c8d129d64758fd5">get_mutable_variant</a> (const MultibodyElement&lt; Scalar &gt; &amp;element)</td></tr>
<tr class="memdesc:a21ac839314967d0e8c8d129d64758fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE overload for Mobilizer&lt;T&gt; elements.  <a href="#a21ac839314967d0e8c8d129d64758fd5">More...</a><br /></td></tr>
<tr class="separator:a21ac839314967d0e8c8d129d64758fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f846f56e2839012b9796c1e2986f56"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class MultibodyElement, typename Scalar &gt; </td></tr>
<tr class="memitem:a00f846f56e2839012b9796c1e2986f56"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt;, MultibodyElement&lt; T &gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const MultibodyElement&lt; T &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a00f846f56e2839012b9796c1e2986f56">get_variant</a> (const MultibodyElement&lt; Scalar &gt; &amp;element) const</td></tr>
<tr class="memdesc:a00f846f56e2839012b9796c1e2986f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE overload for Joint&lt;T&gt; elements.  <a href="#a00f846f56e2839012b9796c1e2986f56">More...</a><br /></td></tr>
<tr class="separator:a00f846f56e2839012b9796c1e2986f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:adb8a77d72df5944a21169f726e4a1ec6"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:adb8a77d72df5944a21169f726e4a1ec6"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#adb8a77d72df5944a21169f726e4a1ec6">MultibodyTree</a></td></tr>
<tr class="memdesc:adb8a77d72df5944a21169f726e4a1ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public alias to internal <code><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html" title="MultibodyTree provides a representation for a physical system consisting of a collection of interconn...">MultibodyTree</a></code>.  <a href="#adb8a77d72df5944a21169f726e4a1ec6">More...</a><br /></td></tr>
<tr class="separator:adb8a77d72df5944a21169f726e4a1ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7a471a0143b2d9317e8d57ac9b9786"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a0f7a471a0143b2d9317e8d57ac9b9786">MultibodyTreeTester</a></td></tr>
<tr class="separator:a0f7a471a0143b2d9317e8d57ac9b9786"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::internal::MultibodyTree&lt; T &gt;</h3>

<p>MultibodyTree provides a representation for a physical system consisting of a collection of interconnected rigid and deformable bodies. </p>
<p>As such, it owns and manages each of the elements that belong to this physical system. Multibody dynamics elements include bodies, joints, force elements and constraints.</p>
<dl class="section warning"><dt>Warning</dt><dd>This class will be eventually deprecated; up until that point, most methods will be forwarded to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type. Must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar.</td></tr>
  </table>
  </dd>
</dl>
<p>Instantiated templates for the following kinds of T's are provided:</p>
<ul>
<li>double</li>
<li>AutoDiffXd</li>
</ul>
<p>They are already available to link against in the containing library. No other values for T are currently supported. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0f5fa5e7cd808af3f302ece79ef798bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5fa5e7cd808af3f302ece79ef798bb">&#9670;&nbsp;</a></span>MultibodyTree() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56dbe8fe859cf4fe29d66a92ac86aac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dbe8fe859cf4fe29d66a92ac86aac1">&#9670;&nbsp;</a></span>MultibodyTree() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad678b6cb49a8bf1b988f8f19d0881980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad678b6cb49a8bf1b988f8f19d0881980">&#9670;&nbsp;</a></span>MultibodyTree() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html" title="MultibodyTree provides a representation for a physical system consisting of a collection of interconn...">MultibodyTree</a> containing only a <b>world</b> body. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aad2a8b4067faf5cff8b2bc380dc698be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2a8b4067faf5cff8b2bc380dc698be">&#9670;&nbsp;</a></span>AddBody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const BodyType&lt;T&gt;&amp; AddBody </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; BodyType&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of <code>body</code> and adds it to <code>this</code> MultibodyTree. </p>
<p>Returns a constant reference to the body just added, which will remain valid for the lifetime of <code>this</code> MultibodyTree.</p>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyTree&lt;T&gt; model;</div><div class="line"><span class="comment">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="class_rigid_body.html">RigidBody&lt;T&gt;</a>&amp; body =</div><div class="line">    model.AddBody(std::make_unique&lt;<a class="code" href="class_rigid_body.html">RigidBody&lt;T&gt;</a>&gt;(spatial_inertia));</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>body</code> is a nullptr. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> was already called on <code>this</code> tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td>A unique pointer to a body to add to <code>this</code> MultibodyTree. The body class must be specialized on the same scalar type T as this MultibodyTree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference of type <code>BodyType</code> to the created body. This reference which will remain valid for the lifetime of <code>this</code> MultibodyTree.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BodyType</td><td>The type of the specific sub-class of <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> to add. The template needs to be specialized on the same scalar type T of this MultibodyTree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a252677addd073f9b045b1e6cc2b750aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252677addd073f9b045b1e6cc2b750aa">&#9670;&nbsp;</a></span>AddBody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const BodyType&lt;T&gt;&amp; AddBody </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new body with type <code>BodyType</code> with the given <code>args</code>, and adds it to <code>this</code> MultibodyTree, which retains ownership. </p>
<p>The <code>BodyType</code> will be specialized on the scalar type T of this MultibodyTree.</p>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyTree&lt;T&gt; model;</div><div class="line"><span class="comment">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span></div><div class="line"><span class="comment">// Notice RigidBody is a template on a scalar type.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="class_rigid_body.html">RigidBody&lt;T&gt;</a>&amp; body = model.AddBody&lt;<a class="code" href="class_rigid_body.html">RigidBody</a>&gt;(spatial_inertia);</div></div><!-- fragment --><p>Note that for dependent names you must use the template keyword (say for instance you have a MultibodyTree&lt;T&gt; member within your custom class):</p>
<div class="fragment"><div class="line">MultibodyTree&lt;T&gt; model;</div><div class="line"><span class="keyword">auto</span> body = model.template AddBody&lt;RigidBody&gt;(Args...);</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> was already called on <code>this</code> tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The arguments needed to construct a valid <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> of type <code>BodyType</code>. <code>BodyType</code> must provide a public constructor that takes these arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference of type <code>BodyType</code> to the created body. This reference which will remain valid for the lifetime of <code>this</code> MultibodyTree.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BodyType</td><td>A template for the type of <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> to construct. The template will be specialized on the scalar type T of this MultibodyTree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8eb63d2130f743dab6cda576e8f3c56d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb63d2130f743dab6cda576e8f3c56d">&#9670;&nbsp;</a></span>AddForceElement() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ForceElementType&lt;T&gt;&amp; AddForceElement </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; ForceElementType&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>force_element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and adds to <code>this</code> MultibodyTree (which retains ownership) a new <code><a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a></code> member with the specific type <code>ForceElementType</code>. </p>
<p>The arguments to this method <code>args</code> are forwarded to <code>ForceElementType</code>'s constructor.</p>
<p>The newly created <code>ForceElementType</code> object will be specialized on the scalar type T of this MultibodyTree. </p>

</div>
</div>
<a id="a48009c793b01c5a6dd079d33265435a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48009c793b01c5a6dd079d33265435a3">&#9670;&nbsp;</a></span>AddForceElement() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ForceElementType&lt;T&gt;&amp; AddForceElement </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new force element model of type <code>ForceElementType</code> to <code>this</code> MultibodyTree. </p>
<p>The arguments to this method <code>args</code> are forwarded to <code>ForceElementType</code>'s constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Zero or more parameters provided to the constructor of the new force element. It must be the case that <code>JointType&lt;T&gt;(args)</code> is a valid constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForceElementType</td><td>The type of the <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> to add. This method can only be called once for elements of type <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html" title="This ForceElement allows modeling the effect of a uniform gravity field as felt by bodies on the surf...">UniformGravityFieldElement</a>. That is, gravity can only be specified once and std::runtime_error is thrown if the model already contains a gravity field element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> just added, of type <code>ForceElementType&lt;T&gt;</code> specialized on the scalar type T of <code>this</code> MultibodyTree. It will remain valid for the lifetime of <code>this</code> MultibodyTree. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>The <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> class'<a class="el" href="geometry__properties__test_8cc.html#aa8270a1ba8295884567e0a0c93135f05">s</a> documentation for further details on how a <a class="el" href="system__identification__test_8cc.html#aab6099c236e628500314462a9b259d66">force</a> element is defined. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if gravity was already added to the model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cff198ad9234fff817bef3f25b98345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cff198ad9234fff817bef3f25b98345">&#9670;&nbsp;</a></span>AddForceElement() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt; ForceElementType&lt;T&gt;, <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html">UniformGravityFieldElement</a>&lt;T&gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const ForceElementType&lt;T&gt;&amp;&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> AddForceElement </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a474c90a0b3e4f9349533207026413186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474c90a0b3e4f9349533207026413186">&#9670;&nbsp;</a></span>AddFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const FrameType&lt;T&gt;&amp; AddFrame </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; FrameType&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of <code>frame</code> and adds it to <code>this</code> MultibodyTree. </p>
<p>Returns a constant reference to the frame just added, which will remain valid for the lifetime of <code>this</code> MultibodyTree.</p>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyTree&lt;T&gt; model;</div><div class="line"><span class="comment">// ... Define body and X_BF ...</span></div><div class="line"><span class="keyword">const</span> FixedOffsetFrame&lt;T&gt;&amp; frame =</div><div class="line">    model.AddFrame(std::make_unique&lt;FixedOffsetFrame&lt;T&gt;&gt;(body, X_BF));</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>frame</code> is a nullptr. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> was already called on <code>this</code> tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td>A unique pointer to a frame to be added to <code>this</code> MultibodyTree. The frame class must be specialized on the same scalar type T as this MultibodyTree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference of type <code>FrameType</code> to the created frame. This reference which will remain valid for the lifetime of <code>this</code> MultibodyTree.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FrameType</td><td>The type of the specific sub-class of <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> to add. The template needs to be specialized on the same scalar type T of this MultibodyTree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e119424a5a8fdf49e5fa611086d8321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e119424a5a8fdf49e5fa611086d8321">&#9670;&nbsp;</a></span>AddFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const FrameType&lt;T&gt;&amp; AddFrame </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new frame with type <code>FrameType</code> with the given <code>args</code>, and adds it to <code>this</code> MultibodyTree, which retains ownership. </p>
<p>The <code>FrameType</code> will be specialized on the scalar type T of this MultibodyTree.</p>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyTree&lt;T&gt; model;</div><div class="line"><span class="comment">// ... Define body and X_BF ...</span></div><div class="line"><span class="comment">// Notice FixedOffsetFrame is a template an a scalar type.</span></div><div class="line"><span class="keyword">const</span> FixedOffsetFrame&lt;T&gt;&amp; frame =</div><div class="line">    model.AddFrame&lt;FixedOffsetFrame&gt;(body, X_BF);</div></div><!-- fragment --><p>Note that for dependent names you must use the template keyword (say for instance you have a MultibodyTree&lt;T&gt; member within your custom class):</p>
<div class="fragment"><div class="line">MultibodyTree&lt;T&gt; model;</div><div class="line"><span class="comment">// ... Define body and X_BF ...</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; frame =</div><div class="line">    model.template AddFrame&lt;FixedOffsetFrame&gt;(body, X_BF);</div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> was already called on <code>this</code> tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The arguments needed to construct a valid <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> of type <code>FrameType</code>. <code>FrameType</code> must provide a public constructor that takes these arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference of type <code>FrameType</code> to the created frame. This reference which will remain valid for the lifetime of <code>this</code> MultibodyTree.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FrameType</td><td>A template for the type of <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> to construct. The template will be specialized on the scalar type T of this MultibodyTree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a437f86026a2268c0fb06936b899ba8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437f86026a2268c0fb06936b899ba8d7">&#9670;&nbsp;</a></span>AddJoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const JointType&lt;T&gt;&amp; AddJoint </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; JointType&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>joint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <code>JointType</code> between the frames specified by the joint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joint</td><td><a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JointType</td><td>The type of the new joint to add, which must be a subclass of Joint&lt;T&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const lvalue reference to the added joint.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>The <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class'<a class="el" href="geometry__properties__test_8cc.html#aa8270a1ba8295884567e0a0c93135f05">s</a> documentation for further details on how a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> is defined, or the semi-emplace <code><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a437f86026a2268c0fb06936b899ba8d7" title="This method adds a Joint of type JointType between the frames specified by the joint. ">AddJoint</a>&lt;&gt;</code> overload below. </dd></dl>

</div>
</div>
<a id="ac828f1c818a0ed3f47ff5f342fa0ee0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac828f1c818a0ed3f47ff5f342fa0ee0c">&#9670;&nbsp;</a></span>AddJoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const JointType&lt;T&gt;&amp; AddJoint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X_PF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method helps to create a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <code>JointType</code> between two bodies. </p>
<p>The two bodies connected by this <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> object are referred to as the <em>parent</em> and <em>child</em> bodies. Although the terms <em>parent</em> and <em>child</em> are sometimes used synonymously to describe the relationship between inboard and outboard bodies in multibody models, this usage is wholly unrelated and implies nothing about the inboard-outboard relationship between the bodies. As explained in the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class's documentation, in Drake we define a frame F attached to the parent body P with pose <code>X_PF</code> and a frame M attached to the child body B with pose <code>X_BM</code>. This method helps create a joint between two bodies with fixed poses <code>X_PF</code> and <code>X_BM</code>. Refer to the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class's documentation for more details.</p>
<p>The arguments to this method <code>args</code> are forwarded to <code>JointType</code>'s constructor. The newly created <code>JointType</code> object will be specialized on the scalar type T of this MultibodyTree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the joint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The parent body connected by the new joint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_PF</td><td>The fixed pose of frame F attached to the parent body, measured in the frame P of that body. <code>X_PF</code> is an optional parameter; empty curly braces <code>{}</code> imply that frame F <b>is</b> the same body frame P. If instead your intention is to make a frame F with pose <code>X_PF</code>, provide <code>Isometry3&lt;double&gt;::Identity()</code> as your input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child</td><td>The child body connected by the new joint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_BM</td><td>The fixed pose of frame M attached to the child body, measured in the frame B of that body. <code>X_BM</code> is an optional parameter; empty curly braces <code>{}</code> imply that frame M <b>is</b> the same body frame B. If instead your intention is to make a frame F with pose <code>X_PF</code>, provide <code>Isometry3&lt;double&gt;::Identity()</code> as your input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JointType</td><td>The type of the new joint to add, which must be a subclass of Joint&lt;T&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new joint just added, of type <code>JointType&lt;T&gt;</code> specialized on the scalar type T of <code>this</code> MultibodyTree. It will remain valid for the lifetime of <code>this</code> MultibodyTree.</dd></dl>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyTree&lt;T&gt; model;</div><div class="line"><span class="comment">// ... Code to define a parent body P and a child body B.</span></div><div class="line"><span class="keyword">const</span> Body&lt;double&gt;&amp; parent_body =</div><div class="line">  model.AddBody&lt;<a class="code" href="class_rigid_body.html">RigidBody</a>&gt;(SpatialInertia&lt;double&gt;(...));</div><div class="line"><span class="keyword">const</span> Body&lt;double&gt;&amp; child_body =</div><div class="line">  model.AddBody&lt;<a class="code" href="class_rigid_body.html">RigidBody</a>&gt;(SpatialInertia&lt;double&gt;(...));</div><div class="line"><span class="comment">// Define the pose X_BM of a frame M rigidly atached to child body B.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="class_revolute_joint.html">RevoluteJoint&lt;double&gt;</a>&amp; elbow =</div><div class="line">  model.AddJoint&lt;<a class="code" href="class_revolute_joint.html">RevoluteJoint</a>&gt;(</div><div class="line">    <span class="stringliteral">&quot;Elbow&quot;</span>,                <span class="comment">/* joint name */</span></div><div class="line">    model.world_body(),     <span class="comment">/* parent body */</span></div><div class="line">    {},                     <span class="comment">/* frame F IS the parent body frame P */</span></div><div class="line">    pendulum,               <span class="comment">/* child body, the pendulum */</span></div><div class="line">    X_BM,                   <span class="comment">/* pose of frame M in the body frame B */</span></div><div class="line">    Vector3d::UnitZ());     <span class="comment">/* revolute axis in this case */</span></div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>this</code> model already contains a joint with the given <code>name</code>. See <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a02c811258a0d93dd116d61648334a392" title="See MultibodyPlant method. ">HasJointNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_joint.html#ad8227ba86a01f26e4f173cd5e219d5d1" title="Returns the name of this joint. ">Joint::name()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>The <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class'<a class="el" href="geometry__properties__test_8cc.html#aa8270a1ba8295884567e0a0c93135f05">s</a> documentation for further details on how a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> is defined. </dd></dl>

</div>
</div>
<a id="a5096160ffb18ddc72e2e29c0edfc5064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5096160ffb18ddc72e2e29c0edfc5064">&#9670;&nbsp;</a></span>AddJointActuator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt;T&gt;&amp; AddJointActuator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and adds a <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> model for an actuator acting on a given <code>joint</code>. </p>
<p>This method returns a constant reference to the actuator just added, which will remain valid for the lifetime of <code>this</code> MultibodyTree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that identifies the new actuator to be added to <code>this</code> model. An exception is thrown if an actuator with the same name already exists in the same model instance as <code>joint</code>. See <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a30dd7e61bafa3221193e7d68e4be7cbc" title="See MultibodyPlant method. ">HasJointActuatorNamed()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">joint</td><td>The <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> to be actuated by the new <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> just added, which will remain valid for the lifetime of <code>this</code> MultibodyTree. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>this</code> model already contains a joint actuator with the given <code>name</code>. See <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a30dd7e61bafa3221193e7d68e4be7cbc" title="See MultibodyPlant method. ">HasJointActuatorNamed()</a>, JointActuator::get_name(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8886c79b1a00896934a25d70317f1033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8886c79b1a00896934a25d70317f1033">&#9670;&nbsp;</a></span>AddMobilizer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MobilizerType&lt;T&gt;&amp; AddMobilizer </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; MobilizerType&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>mobilizer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of <code>mobilizer</code> and adds it to <code>this</code> MultibodyTree. </p>
<p>Returns a constant reference to the mobilizer just added, which will remain valid for the lifetime of <code>this</code> MultibodyTree.</p>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyTree&lt;T&gt; model;</div><div class="line"><span class="comment">// ... Code to define inboard and outboard frames by calling</span></div><div class="line"><span class="comment">// MultibodyTree::AddFrame() ...</span></div><div class="line"><span class="keyword">const</span> RevoluteMobilizer&lt;T&gt;&amp; pin =</div><div class="line">  model.AddMobilizer(std::make_unique&lt;RevoluteMobilizer&lt;T&gt;&gt;(</div><div class="line">    inboard_frame, outboard_frame,</div><div class="line">    Vector3d::UnitZ() <span class="comment">/*revolute axis*/</span>));</div></div><!-- fragment --><p>A Mobilizer effectively connects the two bodies to which the inboard and outboard frames belong.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>mobilizer</code> is a nullptr. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> was already called on <code>this</code> tree. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the new mobilizer attempts to connect a frame with itself. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if attempting to connect two bodies with more than one mobilizer between them.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mobilizer</td><td>A unique pointer to a mobilizer to add to <code>this</code> MultibodyTree. The mobilizer class must be specialized on the same scalar type T as this MultibodyTree. Notice this is a requirement of this method's signature and therefore an input mobilzer specialized on a different scalar type than that of this MultibodyTree's T will fail to compile. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference of type <code>MobilizerType</code> to the created mobilizer. This reference which will remain valid for the lifetime of <code>this</code> MultibodyTree.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MobilizerType</td><td>The type of the specific sub-class of <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html" title="Mobilizer is a fundamental object within Drake&#39;s multibody engine used to specify the allowed motions...">Mobilizer</a> to add. The template needs to be specialized on the same scalar type T of this MultibodyTree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cc1a892b1280cd50ad8ad4b3d43cd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc1a892b1280cd50ad8ad4b3d43cd7a">&#9670;&nbsp;</a></span>AddMobilizer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MobilizerType&lt;T&gt;&amp; AddMobilizer </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new mobilizer with type <code>MobilizerType</code> with the given <code>args</code>, and adds it to <code>this</code> MultibodyTree, which retains ownership. </p>
<p>The <code>MobilizerType</code> will be specialized on the scalar type T of this MultibodyTree.</p>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyTree&lt;T&gt; model;</div><div class="line"><span class="comment">// ... Code to define inboard and outboard frames by calling</span></div><div class="line"><span class="comment">// MultibodyTree::AddFrame() ...</span></div><div class="line"><span class="comment">// Notice RevoluteMobilizer is a template an a scalar type.</span></div><div class="line"><span class="keyword">const</span> RevoluteMobilizer&lt;T&gt;&amp; pin =</div><div class="line">  model.template AddMobilizer&lt;RevoluteMobilizer&gt;(</div><div class="line">    inboard_frame, outboard_frame,</div><div class="line">    Vector3d::UnitZ() <span class="comment">/*revolute axis*/</span>);</div></div><!-- fragment --><p>Note that for dependent names <em>only</em> you must use the template keyword (say for instance you have a MultibodyTree&lt;T&gt; member within your custom class).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> was already called on <code>this</code> tree. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the new mobilizer attempts to connect a frame with itself. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if attempting to connect two bodies with more than one mobilizer between them.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The arguments needed to construct a valid <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html" title="Mobilizer is a fundamental object within Drake&#39;s multibody engine used to specify the allowed motions...">Mobilizer</a> of type <code>MobilizerType</code>. <code>MobilizerType</code> must provide a public constructor that takes these arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference of type <code>MobilizerType</code> to the created mobilizer. This reference which will remain valid for the lifetime of <code>this</code> MultibodyTree.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MobilizerType</td><td>A template for the type of <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html" title="Mobilizer is a fundamental object within Drake&#39;s multibody engine used to specify the allowed motions...">Mobilizer</a> to construct. The template will be specialized on the scalar type T of <code>this</code> MultibodyTree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4edf1daa65069a26255c903b02bce4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edf1daa65069a26255c903b02bce4c6">&#9670;&nbsp;</a></span>AddModelInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> AddModelInstance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new model instance. </p>
<p>Returns the index for a new model instance (as there is no concrete object beyond the index).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that uniquely identifies the new instance to be added to <code>this</code> model. An exception is thrown if an instance with the same name already exists in the model. See <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a05b71664c8e2e91bc3fc92fef222a9bf" title="See MultibodyMethod. ">HasModelInstanceNamed()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> was already called on <code>this</code> tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f6a68c31772eaa0c855ebb44eeaa0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6a68c31772eaa0c855ebb44eeaa0b7">&#9670;&nbsp;</a></span>AddRigidBody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; AddRigidBody </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_BBo_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rigid body with the provided name, model instance, and spatial inertia. </p>
<p>This method returns a constant reference to the body just added, which will remain valid for the lifetime of <code>this</code> MultibodyTree.</p>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyTree&lt;T&gt; model;</div><div class="line"><span class="comment">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span></div><div class="line"><a class="code" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance = model.AddModelInstance(<span class="stringliteral">&quot;instance&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="class_rigid_body.html">RigidBody&lt;T&gt;</a>&amp; body =</div><div class="line">  model.AddRigidBody(<span class="stringliteral">&quot;BodyName&quot;</span>, model_instance, spatial_inertia);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that identifies the new body to be added to <code>this</code> model. A std::runtime_error is thrown if a body named <code>name</code> already is part of <code>model_instance</code>. See <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_body.html#ad8227ba86a01f26e4f173cd5e219d5d1" title="Gets the name associated with this body. ">Body::name()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instance</td><td>A model instance index which this body is part of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M_BBo_B</td><td>The <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia. ">SpatialInertia</a> of the new rigid body to be added to <code>this</code> model, computed about the body frame origin <code>Bo</code> and expressed in the body frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> just added, which will remain valid for the lifetime of <code>this</code> MultibodyTree. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a body named <code>name</code> already exists in this model instance. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the model instance does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a461a59b672f8c3f7c0dcc5caed56d245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461a59b672f8c3f7c0dcc5caed56d245">&#9670;&nbsp;</a></span>AddRigidBody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; AddRigidBody </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_BBo_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rigid body with the provided name, model instance, and spatial inertia. </p>
<p>The newly created body will be placed in the default model instance. This method returns a constant reference to the body just added, which will remain valid for the lifetime of <code>this</code> MultibodyTree.</p>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyTree&lt;T&gt; model;</div><div class="line"><span class="comment">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="class_rigid_body.html">RigidBody&lt;T&gt;</a>&amp; body =</div><div class="line">  model.AddRigidBody(<span class="stringliteral">&quot;BodyName&quot;</span>, spatial_inertia);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that identifies the new body to be added to <code>this</code> model. A std::runtime_error is thrown if a body named <code>name</code> already is part of the model in the default model instance. See <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_body.html#ad8227ba86a01f26e4f173cd5e219d5d1" title="Gets the name associated with this body. ">Body::name()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M_BBo_B</td><td>The <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia. ">SpatialInertia</a> of the new rigid body to be added to <code>this</code> model, computed about the body frame origin <code>Bo</code> and expressed in the body frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> just added, which will remain valid for the lifetime of <code>this</code> MultibodyTree. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a body named <code>name</code> already exists. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if additional model instances have been created beyond the world and default instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade29d7e9d45e33e20c1521cc0130a096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade29d7e9d45e33e20c1521cc0130a096">&#9670;&nbsp;</a></span>CalcAccelerationKinematicsCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcAccelerationKinematicsCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_velocity_kinematics_cache.html">VelocityKinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>known_vdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_acceleration_kinematics_cache.html">AccelerationKinematicsCache</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>ac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes all the kinematic quantities that depend on the generalized accelerations that is, the generalized velocities' time derivatives, and stores them in the acceleration kinematics cache <code>ac</code>. </p>
<p>These include:</p><ul>
<li>Spatial acceleration <code>A_WB</code> for each body B in the model as measured and expressed in the world frame W.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the MultibodyTree model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>A position kinematics cache object already updated to be in sync with <code>context</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vc</td><td>A velocity kinematics cache object already updated to be in sync with <code>context</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">known_vdot</td><td>A vector with the generalized accelerations for the full MultibodyTree model. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ac</td><td>A pointer to a valid, non nullptr, acceleration kinematics cache. This method aborts if <code>ac</code> is nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The position kinematics <code>pc</code> must have been previously updated with a call to <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8567e741678adde3a08c0b317d908d72" title="Computes into the position kinematics pc all the kinematic quantities that depend on the generalized ...">CalcPositionKinematicsCache()</a>. </dd>
<dd>
The velocity kinematics <code>vc</code> must have been previously updated with a call to <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a7d7201e5e8f39b3f08f934f0bca3108b" title="Computes all the kinematic quantities that depend on the generalized velocities and stores them in th...">CalcVelocityKinematicsCache()</a>. </dd></dl>

</div>
</div>
<a id="aad9ccb27e7c45be210dad2156344bb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9ccb27e7c45be210dad2156344bb32">&#9670;&nbsp;</a></span>CalcAcrossNodeGeometricJacobianExpressedInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcAcrossNodeGeometricJacobianExpressedInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a>&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>H_PB_W_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal) Computes the cache entry associated with the geometric Jacobian H_PB_W for each node. </p>
<p>The geometric Jacobian <code>H_PB_W</code> relates to the spatial velocity of B in P by <code>V_PB_W = H_PB_W(q)⋅v_B</code>, where <code>v_B</code> corresponds to the generalized velocities associated to body B. <code>H_PB_W</code> has size <code>6 x nm</code> with <code>nm</code> the number of mobilities associated with body B. <code>H_PB_W_cache</code> stores the Jacobian matrices for all nodes in the tree as a vector of the columns of these matrices. Therefore <code>H_PB_W_cache</code> has as many entries as number of generalized velocities in the tree. </p>

</div>
</div>
<a id="aaeadfd9964b1aee6282b5be5938e267b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeadfd9964b1aee6282b5be5938e267b">&#9670;&nbsp;</a></span>CalcAllBodyPosesInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcAllBodyPosesInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>X_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ac29481c9f2a7aa54ce05ce374ad6f359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29481c9f2a7aa54ce05ce374ad6f359">&#9670;&nbsp;</a></span>CalcAllBodySpatialVelocitiesInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcAllBodySpatialVelocitiesInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>V_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ab77db3ff9323ef1ed77769a11420024c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77db3ff9323ef1ed77769a11420024c">&#9670;&nbsp;</a></span>CalcArticulatedBodyInertiaCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcArticulatedBodyInertiaCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_articulated_body_inertia_cache.html">ArticulatedBodyInertiaCache</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>abc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes all the quantities that are required in the final pass of the articulated body algorithm and stores them in the articulated body cache <code>abc</code>. </p>
<p>These include:</p><ul>
<li>Articulated body inertia <code>Pplus_PB_W</code>, which can be thought of as the articulated body inertia of parent body P as though it were inertialess, but taken about Bo and expressed in W.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the MultibodyTree model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>A position kinematics cache object already updated to be in sync with <code>context</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">abc</td><td>A pointer to a valid, non nullptr, articulated body cache. This method throws an exception if <code>abc</code> is a nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The position kinematics <code>pc</code> must have been previously updated with a call to <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8567e741678adde3a08c0b317d908d72" title="Computes into the position kinematics pc all the kinematic quantities that depend on the generalized ...">CalcPositionKinematicsCache()</a> using the same <code>context</code> . </dd></dl>

</div>
</div>
<a id="a9de2905e3f4541d4714e0a63a442e650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de2905e3f4541d4714e0a63a442e650">&#9670;&nbsp;</a></span>CalcBiasForFrameGeometricJacobianExpressedInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a>&lt; T &gt; CalcBiasForFrameGeometricJacobianExpressedInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="aeeef1250479b5a8b519e99de4f920bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeef1250479b5a8b519e99de4f920bb5">&#9670;&nbsp;</a></span>CalcBiasForPointsGeometricJacobianExpressedInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; CalcBiasForPointsGeometricJacobianExpressedInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FP_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a843e1ba389c017c706df10935784b4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843e1ba389c017c706df10935784b4e5">&#9670;&nbsp;</a></span>CalcBiasTerm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcBiasTerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Cv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="af5d32c695cacd92615cb9b3773a17eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d32c695cacd92615cb9b3773a17eb9">&#9670;&nbsp;</a></span>CalcConservativePower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T CalcConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a25e03fb7982f08defb30afa2cced922c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e03fb7982f08defb30afa2cced922c">&#9670;&nbsp;</a></span>CalcForceElementsContribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcForceElementsContribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_velocity_kinematics_cache.html">VelocityKinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>forces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a45405f29fd8ad82a7459fd05642b329e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45405f29fd8ad82a7459fd05642b329e">&#9670;&nbsp;</a></span>CalcFrameGeometricJacobianExpressedInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcFrameGeometricJacobianExpressedInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jv_WFp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a0b1293f0e09ec2d3df0a9eaeab6baa9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1293f0e09ec2d3df0a9eaeab6baa9a">&#9670;&nbsp;</a></span>CalcGravityGeneralizedForces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; CalcGravityGeneralizedForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="af3d9f1dfe387a173b84c49a5bbe5a4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d9f1dfe387a173b84c49a5bbe5a4c2">&#9670;&nbsp;</a></span>CalcInverseDynamics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; CalcInverseDynamics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>known_vdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>external_forces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a868db3695aaead74e12f38a0f40c442d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868db3695aaead74e12f38a0f40c442d">&#9670;&nbsp;</a></span>CalcInverseDynamics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcInverseDynamics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_velocity_kinematics_cache.html">VelocityKinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>known_vdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html">SpatialForce</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Fapplied_Bo_W_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tau_applied_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>A_WB_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html">SpatialForce</a>&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>F_BMo_W_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>tau_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Given the state of <code>this</code> MultibodyTree in <code>context</code> and a known vector of generalized accelerations <code>vdot</code>, this method computes the set of generalized forces <code>tau</code> that would need to be applied at each <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html" title="Mobilizer is a fundamental object within Drake&#39;s multibody engine used to specify the allowed motions...">Mobilizer</a> in order to attain the specified generalized accelerations. </p>
<p>Mathematically, this method computes: </p><pre>
  tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W
</pre><p> where <code>M(q)</code> is the MultibodyTree mass matrix, <code>C(q, v)v</code> is the bias term containing Coriolis and gyroscopic effects and <code>tau_app</code> consists of a vector applied generalized forces. The last term is a summation over all bodies in the model where <code>Fapp_Bo_W</code> is an applied spatial force on body B at <code>Bo</code> which gets projected into the space of generalized forces with the geometric Jacobian <code>J_WB(q)</code> which maps generalized velocities into body B spatial velocity as <code>V_WB = J_WB(q)v</code>. This method does not compute explicit expressions for the mass matrix nor for the bias term, which would be of at least <code>O(n²)</code> complexity, but it implements an <code>O(n)</code> Newton-Euler recursive algorithm, where n is the number of bodies in the MultibodyTree. The explicit formation of the mass matrix <code>M(q)</code> would require the calculation of <code>O(n²)</code> entries while explicitly forming the product <code>C(q, v) * v</code> could require up to <code>O(n³)</code> operations (see [Featherstone 1987, §4]), depending on the implementation. The recursive Newton-Euler algorithm is the most efficient currently known general method for solving inverse dynamics [Featherstone 2008].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the MultibodyTree model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>A position kinematics cache object already updated to be in sync with <code>context</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vc</td><td>A velocity kinematics cache object already updated to be in sync with <code>context</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">known_vdot</td><td>A vector with the known generalized accelerations <code>vdot</code> for the full MultibodyTree model. Use <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html#a9d5ce8400c799f11a008add02545d26f" title="Returns a const Eigen expression of the vector of generalized accelerations for this mobilizer from a...">Mobilizer::get_accelerations_from_array()</a> to access entries into this array for a particular <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html" title="Mobilizer is a fundamental object within Drake&#39;s multibody engine used to specify the allowed motions...">Mobilizer</a>. You can use the mutable version of this method to write into this array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Fapplied_Bo_W_array</td><td>A vector containing the spatial force <code>Fapplied_Bo_W</code> applied on each body at the body's frame origin <code>Bo</code> and expressed in the world frame W. <code>Fapplied_Bo_W_array</code> can have zero size which means there are no applied forces. To apply non-zero forces, <code>Fapplied_Bo_W_array</code> must be of size equal to the number of bodies in <code>this</code> MultibodyTree model. This array must be ordered by BodyNodeIndex, which for a given body can be retrieved with <a class="el" href="classdrake_1_1multibody_1_1_body.html#a987c2048db19c7cabc1c5161a75e4814" title="Returns the index of the node in the underlying tree structure of the parent MultibodyTree to which t...">Body::node_index()</a>. This method will abort if provided with an array that does not have a size of either <code><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af92b53211e54243aff4490a700168eb4" title="Returns the number of bodies in the MultibodyTree including the world body. ">num_bodies()</a></code> or zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau_applied_array</td><td>An array of applied generalized forces for the entire model. For a given mobilizer, entries in this array can be accessed using the method <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html#ae5bf9d5b5a16c2de21bd26a066d31c20" title="Returns a const Eigen expression of the vector of generalized forces for this mobilizer from a vector...">Mobilizer::get_generalized_forces_from_array()</a> while its mutable counterpart, <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html#aae9561ae218bbd64bace25f031673ea8" title="Mutable version of get_generalized_forces_from_array(). ">Mobilizer::get_mutable_generalized_forces_from_array()</a>, allows writing into this array. <code>tau_applied_array</code> can have zero size, which means there are no applied forces. To apply non-zero forces, <code>tau_applied_array</code> must be of size equal to the number to the number of generalized velocities in the model, see <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ae0163ac0976659d811e3337647ff0313" title="Returns the number of generalized velocities of the model. ">MultibodyTree::num_velocities()</a>. This method will abort if provided with an array that does not have a size of either <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ae0163ac0976659d811e3337647ff0313" title="Returns the number of generalized velocities of the model. ">MultibodyTree::num_velocities()</a> or zero. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_WB_array</td><td>A pointer to a valid, non nullptr, vector of spatial accelerations containing the spatial acceleration <code>A_WB</code> for each body. It must be of size equal to the number of bodies. This method will abort if the the pointer is null or if <code>A_WB_array</code> is not of size <code><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af92b53211e54243aff4490a700168eb4" title="Returns the number of bodies in the MultibodyTree including the world body. ">num_bodies()</a></code>. On output, entries will be ordered by BodyNodeIndex. To access the acceleration <code>A_WB</code> of given body B in this array, use the index returned by <a class="el" href="classdrake_1_1multibody_1_1_body.html#a987c2048db19c7cabc1c5161a75e4814" title="Returns the index of the node in the underlying tree structure of the parent MultibodyTree to which t...">Body::node_index()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F_BMo_W_array</td><td>A pointer to a valid, non nullptr, vector of spatial forces containing, for each body B, the spatial force <code>F_BMo_W</code> corresponding to its inboard mobilizer reaction forces on body B applied at the origin <code>Mo</code> of the inboard mobilizer, expressed in the world frame W. It must be of size equal to the number of bodies in the <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html" title="MultibodyTree provides a representation for a physical system consisting of a collection of interconn...">MultibodyTree</a>. This method will abort if the the pointer is null or if <code>F_BMo_W_array</code> is not of size <code><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af92b53211e54243aff4490a700168eb4" title="Returns the number of bodies in the MultibodyTree including the world body. ">num_bodies()</a></code>. On output, entries will be ordered by BodyNodeIndex. To access a mobilizer's reaction force on given body B in this array, use the index returned by <a class="el" href="classdrake_1_1multibody_1_1_body.html#a987c2048db19c7cabc1c5161a75e4814" title="Returns the index of the node in the underlying tree structure of the parent MultibodyTree to which t...">Body::node_index()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tau_array</td><td>On output this array will contain the generalized forces that must be applied in order to achieve the desired generalized accelerations given by the input argument <code>known_vdot</code>. It must not be nullptr and it must be of size <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ae0163ac0976659d811e3337647ff0313" title="Returns the number of generalized velocities of the model. ">MultibodyTree::num_velocities()</a>. Generalized forces for each <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html" title="Mobilizer is a fundamental object within Drake&#39;s multibody engine used to specify the allowed motions...">Mobilizer</a> can be accessed with <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html#ae5bf9d5b5a16c2de21bd26a066d31c20" title="Returns a const Eigen expression of the vector of generalized forces for this mobilizer from a vector...">Mobilizer::get_generalized_forces_from_array()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>There is no mechanism to assert that either <code>A_WB_array</code> nor <code>F_BMo_W_array</code> are ordered by BodyNodeIndex. You can use <a class="el" href="classdrake_1_1multibody_1_1_body.html#a987c2048db19c7cabc1c5161a75e4814" title="Returns the index of the node in the underlying tree structure of the parent MultibodyTree to which t...">Body::node_index()</a> to obtain the node index for a given body.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method uses <code>F_BMo_W_array</code> and <code>tau_array</code> as the only local temporaries and therefore no additional dynamic memory allocation is performed.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><code>F_BMo_W_array</code> (<code>tau_array</code>) and <code>Fapplied_Bo_W_array</code> (<code>tau_applied_array</code>) can actually be the same array in order to reduce memory footprint and/or dynamic memory allocations. However the information in <code>Fapplied_Bo_W_array</code> (<code>tau_applied_array</code>) would be overwritten through <code>F_BMo_W_array</code> (<code>tau_array</code>). Make a copy if data must be preserved.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The position kinematics <code>pc</code> must have been previously updated with a call to <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8567e741678adde3a08c0b317d908d72" title="Computes into the position kinematics pc all the kinematic quantities that depend on the generalized ...">CalcPositionKinematicsCache()</a>. </dd>
<dd>
The velocity kinematics <code>vc</code> must have been previously updated with a call to <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a7d7201e5e8f39b3f08f934f0bca3108b" title="Computes all the kinematic quantities that depend on the generalized velocities and stores them in th...">CalcVelocityKinematicsCache()</a>. </dd></dl>

</div>
</div>
<a id="a78c0dbd7529fadcbf1fd550a9fd2e80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c0dbd7529fadcbf1fd550a9fd2e80b">&#9670;&nbsp;</a></span>CalcJacobianSpatialVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcJacobianSpatialVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a>&#160;</td>
          <td class="paramname"><em>with_respect_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jw_ABp_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ac3238273c2c927101e4515147bed17f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3238273c2c927101e4515147bed17f6">&#9670;&nbsp;</a></span>CalcMassMatrixViaInverseDynamics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcMassMatrixViaInverseDynamics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="aa08a137307614d55094430b858f0e8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08a137307614d55094430b858f0e8cb">&#9670;&nbsp;</a></span>CalcPointsAnalyticalJacobianExpressedInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcPointsAnalyticalJacobianExpressedInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FP_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>p_WP_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jq_WFp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ae28789d38fa6e3e0fc382fa3b0b0b882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28789d38fa6e3e0fc382fa3b0b0b882">&#9670;&nbsp;</a></span>CalcPointsGeometricJacobianExpressedInWorld() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcPointsGeometricJacobianExpressedInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FP_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>p_WP_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jv_WFp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a4978894bc930fdb65827c03214ac9103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4978894bc930fdb65827c03214ac9103">&#9670;&nbsp;</a></span>CalcPointsGeometricJacobianExpressedInWorld() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcPointsGeometricJacobianExpressedInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_WP_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jv_WFp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a27bce36db6170b2ed1ee53481f8017a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bce36db6170b2ed1ee53481f8017a5">&#9670;&nbsp;</a></span>CalcPointsPositions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcPointsPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BQi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>p_AQi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a8567e741678adde3a08c0b317d908d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8567e741678adde3a08c0b317d908d72">&#9670;&nbsp;</a></span>CalcPositionKinematicsCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcPositionKinematicsCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes into the position kinematics <code>pc</code> all the kinematic quantities that depend on the generalized positions only. </p>
<p>These include:</p>
<ul>
<li>For each body B, the pose <code>X_BF</code> of each of the frames F attached to body B.</li>
<li>Pose <code>X_WB</code> of each body B in the model as measured and expressed in the world frame W.</li>
<li>Across-mobilizer Jacobian matrices <code>H_FM</code> and <code>H_PB_W</code>.</li>
<li><a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> specific quantities such as <code>com_W</code> and <code>M_Bo_W</code>.</li>
</ul>
<p>Aborts if <code>pc</code> is nullptr. </p>

</div>
</div>
<a id="a35681a2d7d9d4026b6bc61f08da861f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35681a2d7d9d4026b6bc61f08da861f8">&#9670;&nbsp;</a></span>CalcPotentialEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T CalcPotentialEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ad9852a710b6fdd9e08d3bbc328485734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9852a710b6fdd9e08d3bbc328485734">&#9670;&nbsp;</a></span>CalcRelativeFrameGeometricJacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcRelativeFrameGeometricJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jv_ABp_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a5f8d1363712b6824a1490b4a6ff16fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8d1363712b6824a1490b4a6ff16fbe">&#9670;&nbsp;</a></span>CalcRelativeTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; CalcRelativeTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a5044683fbf851576698f97ddc2e5de2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5044683fbf851576698f97ddc2e5de2f">&#9670;&nbsp;</a></span>CalcSpatialAccelerationsFromVdot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcSpatialAccelerationsFromVdot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_velocity_kinematics_cache.html">VelocityKinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>known_vdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>A_WB_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>
<dl class="section warning"><dt>Warning</dt><dd>The output parameter <code>A_WB_array</code> is indexed by BodyNodeIndex, while <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>'s method returns accelerations indexed by BodyIndex. </dd></dl>

</div>
</div>
<a id="a7d7201e5e8f39b3f08f934f0bca3108b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7201e5e8f39b3f08f934f0bca3108b">&#9670;&nbsp;</a></span>CalcVelocityKinematicsCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcVelocityKinematicsCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_velocity_kinematics_cache.html">VelocityKinematicsCache</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>vc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes all the kinematic quantities that depend on the generalized velocities and stores them in the velocity kinematics cache <code>vc</code>. </p>
<p>These include:</p><ul>
<li>Spatial velocity <code>V_WB</code> for each body B in the model as measured and expressed in the world frame W.</li>
<li>Spatial velocity <code>V_PB</code> for each body B in the model as measured and expressed in the inboard (or parent) body frame P.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The position kinematics <code>pc</code> must have been previously updated with a call to <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8567e741678adde3a08c0b317d908d72" title="Computes into the position kinematics pc all the kinematic quantities that depend on the generalized ...">CalcPositionKinematicsCache()</a>.</dd></dl>
<p>Aborts if <code>vc</code> is nullptr. </p>

</div>
</div>
<a id="a785245d5f0f534300a31f9c7cc1b70c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785245d5f0f534300a31f9c7cc1b70c0">&#9670;&nbsp;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt;T&gt; &gt; Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of <code>this</code> MultibodyTree templated on the same scalar type T as <code>this</code> tree. </p>

</div>
</div>
<a id="aa867ed6fe063cc08113ff54918da55a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa867ed6fe063cc08113ff54918da55a7">&#9670;&nbsp;</a></span>CloneToScalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt;ToScalar&gt; &gt; CloneToScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of <code>this</code> MultibodyTree templated on the scalar type <code>ToScalar</code>. </p>
<p>The new deep copy is guaranteed to have exactly the same <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree_topology.html" title="Data structure to store the topological information associated with an entire MultibodyTree. ">MultibodyTreeTopology</a> as the original tree the method is called on. This method ensures the following cloning order:</p>
<ul>
<li><a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> objects, and their corresponding <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html" title="A BodyFrame is a material Frame that serves as the unique reference frame for a Body. ">BodyFrame</a> objects.</li>
<li><a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> objects.</li>
<li>If a <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> is attached to another frame, its parent frame is guaranteed to be created first.</li>
<li><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html" title="Mobilizer is a fundamental object within Drake&#39;s multibody engine used to specify the allowed motions...">Mobilizer</a> objects are created last and therefore clones of the original <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> objects are guaranteed to already be part of the cloned tree.</li>
</ul>
<p>Consider the following code example: </p><div class="fragment"><div class="line"><span class="comment">// The user creates a model.</span></div><div class="line">MultibodyTree&lt;double&gt; model;</div><div class="line"><span class="comment">// User adds a body and keeps a reference to it.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="class_rigid_body.html">RigidBody&lt;double&gt;</a>&amp; body = model.AddBody&lt;<a class="code" href="class_rigid_body.html">RigidBody</a>&gt;(...);</div><div class="line"><span class="comment">// User creates an AutoDiffXd variant, where ToScalar = AutoDiffXd.</span></div><div class="line">std::unique_ptr&lt;MultibodyTree&lt;AutoDiffXd&gt;&gt; model_autodiff =</div><div class="line">    model.CloneToScalar&lt;<a class="code" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>&gt;();</div><div class="line"><span class="comment">// User retrieves the AutoDiffXd variant corresponding to the original</span></div><div class="line"><span class="comment">// body added above.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="class_rigid_body.html">RigidBody&lt;AutoDiffXd&gt;</a>&amp;</div><div class="line">    body_autodiff = model_autodiff.get_variant(body);</div></div><!-- fragment --><p><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a23174e772fb8c1b19c0af3b74a11ab28" title="SFINAE overload for Frame&lt;T&gt; elements. ">MultibodyTree::get_variant()</a> is templated on the multibody element type which is deduced from its only input argument. The returned element is templated on the scalar type T of the MultibodyTree on which this method is invoked. In the example above, the user could have also invoked the method <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#af043fd921c9543fc70c3e903295a9e87" title="Creates a deep copy of this MultibodyTree templated on AutoDiffXd. ">ToAutoDiffXd()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> must have already been called on this MultibodyTree. </dd></dl>

</div>
</div>
<a id="a3979ee6b095e61009a536caac365297b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3979ee6b095e61009a536caac365297b">&#9670;&nbsp;</a></span>CreateDefaultContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_leaf_context.html">systems::LeafContext</a>&lt;T&gt; &gt; CreateDefaultContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Allocates a new context for this MultibodyTree uniquely identifying the state of the multibody system. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this is not owned by a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> / <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree_system.html" title="This is a bare Drake System providing just enough functionality to allow standalone exercise of a Mul...">MultibodyTreeSystem</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27053b1ed343ccd9640259fd442d8e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27053b1ed343ccd9640259fd442d8e14">&#9670;&nbsp;</a></span>EvalBodyPoseInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp; EvalBodyPoseInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a019e8c73d7084e073b4e09a1c0df3b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019e8c73d7084e073b4e09a1c0df3b18">&#9670;&nbsp;</a></span>EvalBodySpatialVelocityInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp; EvalBodySpatialVelocityInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See MultibodyPlantMethod. </p>

</div>
</div>
<a id="aed59e6f62bfe30a418ba8d8c611580af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed59e6f62bfe30a418ba8d8c611580af">&#9670;&nbsp;</a></span>EvalPositionKinematics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt;T&gt;&amp; EvalPositionKinematics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates position kinematics cached in context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>A Context whose position kinematics cache will be updated and returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_position_kinematics_cache.html" title="This class is one of the cache entries in MultibodyTreeContext. ">PositionKinematicsCache</a> of context. </dd></dl>

</div>
</div>
<a id="a4d0adc712bc2d51f9aa758e8d726276d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0adc712bc2d51f9aa758e8d726276d">&#9670;&nbsp;</a></span>EvalVelocityKinematics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_velocity_kinematics_cache.html">VelocityKinematicsCache</a>&lt;T&gt;&amp; EvalVelocityKinematics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates velocity kinematics cached in context. </p>
<p>This will also force position kinematics to be updated if it hasn't already. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>A Context whose velocity kinematics cache will be updated and returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_velocity_kinematics_cache.html" title="This class is one of the cache entries in MultibodyTreeContext. ">VelocityKinematicsCache</a> of context. </dd></dl>

</div>
</div>
<a id="a8fee61d7a783cade1a3d07fe86284d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fee61d7a783cade1a3d07fe86284d27">&#9670;&nbsp;</a></span>Finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. </p>
<p>It essentially compiles all the necessary "topological information", i.e. how bodies, joints and, any other elements connect with each other, and performs all the required pre-processing to perform computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this MultibodyTree is validated, meaning that the topology is up-to-date after this call. No more multibody tree elements can be added after a call to <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called post-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada9547075b5a67b2354f3dabf0f2f787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9547075b5a67b2354f3dabf0f2f787">&#9670;&nbsp;</a></span>get_body()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;&amp; get_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a95cafdc0efac53fe097f9380b955e396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cafdc0efac53fe097f9380b955e396">&#9670;&nbsp;</a></span>get_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;T&gt;&amp; get_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a>&#160;</td>
          <td class="paramname"><em>frame_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ad293b63a81a28c455fdfb7e5f04c35b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad293b63a81a28c455fdfb7e5f04c35b0">&#9670;&nbsp;</a></span>get_joint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt;T&gt;&amp; get_joint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a>&#160;</td>
          <td class="paramname"><em>joint_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="abb237ffaadc7323d817ba0e07e78a8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb237ffaadc7323d817ba0e07e78a8f4">&#9670;&nbsp;</a></span>get_joint_actuator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt;T&gt;&amp; get_joint_actuator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a>&#160;</td>
          <td class="paramname"><em>actuator_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="aff1fdaf43db3e9f6327a78b6f34e4410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1fdaf43db3e9f6327a78b6f34e4410">&#9670;&nbsp;</a></span>get_mobilizer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html">Mobilizer</a>&lt;T&gt;&amp; get_mobilizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody_1_1internal.html#a5296da869e93358c7ea8fd7e15a8757c">MobilizerIndex</a>&#160;</td>
          <td class="paramname"><em>mobilizer_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ab56a3621a122cdff1729f71b756a75d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56a3621a122cdff1729f71b756a75d0">&#9670;&nbsp;</a></span>get_mutable_joint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt;T&gt;&amp; get_mutable_joint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a>&#160;</td>
          <td class="paramname"><em>joint_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a21ac839314967d0e8c8d129d64758fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ac839314967d0e8c8d129d64758fd5">&#9670;&nbsp;</a></span>get_mutable_variant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html">Mobilizer</a>&lt;T&gt;, MultibodyElement&lt;T&gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, MultibodyElement&lt;T&gt;&amp;&gt; get_mutable_variant </td>
          <td>(</td>
          <td class="paramtype">const MultibodyElement&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SFINAE overload for Mobilizer&lt;T&gt; elements. </p>

</div>
</div>
<a id="a37389ac2ca2dbdc0bef040c6554565e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37389ac2ca2dbdc0bef040c6554565e3">&#9670;&nbsp;</a></span>get_topology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a>&amp; get_topology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the topology information for this multibody tree. </p>
<p>Users should not need to call this method since <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree_topology.html" title="Data structure to store the topological information associated with an entire MultibodyTree. ">MultibodyTreeTopology</a> is an internal bookkeeping detail. Used at <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> stage by multibody elements to retrieve a local copy of their topology. </p>

</div>
</div>
<a id="a23174e772fb8c1b19c0af3b74a11ab28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23174e772fb8c1b19c0af3b74a11ab28">&#9670;&nbsp;</a></span>get_variant() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;T&gt;, MultibodyElement&lt;T&gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const MultibodyElement&lt;T&gt;&amp;&gt; get_variant </td>
          <td>(</td>
          <td class="paramtype">const MultibodyElement&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SFINAE overload for Frame&lt;T&gt; elements. </p>

</div>
</div>
<a id="af2707c103cfdfef93d0e75241ff9c019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2707c103cfdfef93d0e75241ff9c019">&#9670;&nbsp;</a></span>get_variant() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;, MultibodyElement&lt;T&gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const MultibodyElement&lt;T&gt;&amp;&gt; get_variant </td>
          <td>(</td>
          <td class="paramtype">const MultibodyElement&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SFINAE overload for Body&lt;T&gt; elements. </p>

</div>
</div>
<a id="ae259eef7ffd400141b97760fc6a78e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae259eef7ffd400141b97760fc6a78e58">&#9670;&nbsp;</a></span>get_variant() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html">Mobilizer</a>&lt;T&gt;, MultibodyElement&lt;T&gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const MultibodyElement&lt;T&gt;&amp;&gt; get_variant </td>
          <td>(</td>
          <td class="paramtype">const MultibodyElement&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SFINAE overload for Mobilizer&lt;T&gt; elements. </p>

</div>
</div>
<a id="a00f846f56e2839012b9796c1e2986f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f846f56e2839012b9796c1e2986f56">&#9670;&nbsp;</a></span>get_variant() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_base_of&lt;<a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt;T&gt;, MultibodyElement&lt;T&gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const MultibodyElement&lt;T&gt;&amp;&gt; get_variant </td>
          <td>(</td>
          <td class="paramtype">const MultibodyElement&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SFINAE overload for Joint&lt;T&gt; elements. </p>

</div>
</div>
<a id="af3b40d661d83759731ad9a54553fc13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b40d661d83759731ad9a54553fc13f">&#9670;&nbsp;</a></span>GetBodyByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;&amp; GetBodyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a3d93818409f0144bb63248dc64a9130f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d93818409f0144bb63248dc64a9130f">&#9670;&nbsp;</a></span>GetBodyByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;&amp; GetBodyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a4b557087f117859fd5246112f0d829cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b557087f117859fd5246112f0d829cd">&#9670;&nbsp;</a></span>GetFrameByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;T&gt;&amp; GetFrameByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="af4d552a24e1ad06c0b16004cec20fe94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d552a24e1ad06c0b16004cec20fe94">&#9670;&nbsp;</a></span>GetFrameByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;T&gt;&amp; GetFrameByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ab835365a3c40185b23454f7e08cad083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab835365a3c40185b23454f7e08cad083">&#9670;&nbsp;</a></span>GetJointActuatorByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt;T&gt;&amp; GetJointActuatorByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a760fbe4384415d8cfd39c9e7e4f31422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760fbe4384415d8cfd39c9e7e4f31422">&#9670;&nbsp;</a></span>GetJointActuatorByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt;T&gt;&amp; GetJointActuatorByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a19361c135196cb155e2c8bca02dcbc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19361c135196cb155e2c8bca02dcbc78">&#9670;&nbsp;</a></span>GetJointByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const JointType&lt;T&gt;&amp; GetJointByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>model_instance</em> = <code><a class="el" href="namespacedrake.html#acd293644b847dc4549de80a090d66625">nullopt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a2a177e855cc5efe12d15adc4c697930f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a177e855cc5efe12d15adc4c697930f">&#9670;&nbsp;</a></span>GetModelInstanceByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> GetModelInstanceByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ab99be499eb59f00037b05ec60b51e177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99be499eb59f00037b05ec60b51e177">&#9670;&nbsp;</a></span>GetModelInstanceName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; GetModelInstanceName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a392df3335cb46b0c87f943bdd9fd5279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392df3335cb46b0c87f943bdd9fd5279">&#9670;&nbsp;</a></span>GetMutableJointByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JointType&lt;T&gt;&amp; GetMutableJointByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>model_instance</em> = <code><a class="el" href="namespacedrake.html#acd293644b847dc4549de80a090d66625">nullopt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="aca225909f1909f8a37b0b3f89884f29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca225909f1909f8a37b0b3f89884f29b">&#9670;&nbsp;</a></span>GetMutablePositionsAndVelocities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; GetMutablePositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable <a class="el" href="namespace_eigen.html">Eigen</a> vector containing the vector <code>[q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr or if it does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>

</div>
</div>
<a id="a61c4037d7f25d2e511f86e9102772290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c4037d7f25d2e511f86e9102772290">&#9670;&nbsp;</a></span>GetPositionsAndVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; GetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const <a class="el" href="namespace_eigen.html">Eigen</a> vector reference containing the vector <code>[q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities. </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ed3389732867302278b87d4605509a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed3389732867302278b87d4605509a2">&#9670;&nbsp;</a></span>GetPositionsAndVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; GetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="namespace_eigen.html">Eigen</a> vector containing the multibody state <code>x = [q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities for model instance <code>model_instance</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> does not correspond to the context for a multibody model or <code>model_instance</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns a dense vector of dimension <code>q.size() + v.size()</code> associated with <code>model_instance</code> in O(<code>q.size()</code>) time. </dd></dl>

</div>
</div>
<a id="acd88fc59ef9748edd8e6824f029c38f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd88fc59ef9748edd8e6824f029c38f1">&#9670;&nbsp;</a></span>GetPositionsFromArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; GetPositionsFromArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a1ef21c2455a83e7a086df24f8411e26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef21c2455a83e7a086df24f8411e26b">&#9670;&nbsp;</a></span>GetRigidBodyByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; GetRigidBodyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a0b1b9a39c20706b20221ea2c142d2cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1b9a39c20706b20221ea2c142d2cfd">&#9670;&nbsp;</a></span>GetRigidBodyByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; GetRigidBodyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a312d791d9b130cd29d5e0587777f2472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312d791d9b130cd29d5e0587777f2472">&#9670;&nbsp;</a></span>GetVelocitiesFromArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; GetVelocitiesFromArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a89a198b6549e543018c7c9873d4e6dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a198b6549e543018c7c9873d4e6dc1">&#9670;&nbsp;</a></span>HasBodyNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasBodyNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a body named <code>name</code> was added to the model. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a9f6a68c31772eaa0c855ebb44eeaa0b7" title="Creates a rigid body with the provided name, model instance, and spatial inertia. ...">AddRigidBody()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the body name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c5aa85a70a9f0f196091ed298266c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5aa85a70a9f0f196091ed298266c57">&#9670;&nbsp;</a></span>HasBodyNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasBodyNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a body named <code>name</code> was added to <code>model_instance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a9f6a68c31772eaa0c855ebb44eeaa0b7" title="Creates a rigid body with the provided name, model instance, and spatial inertia. ...">AddRigidBody()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3530f8f6747cb603a24accba5901bd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3530f8f6747cb603a24accba5901bd00">&#9670;&nbsp;</a></span>HasFrameNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasFrameNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a7ab3a66ab482037c12c4d556800c550a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab3a66ab482037c12c4d556800c550a">&#9670;&nbsp;</a></span>HasFrameNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasFrameNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a30dd7e61bafa3221193e7d68e4be7cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30dd7e61bafa3221193e7d68e4be7cbc">&#9670;&nbsp;</a></span>HasJointActuatorNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasJointActuatorNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a0f6ad707643bf5220e76678e71291175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6ad707643bf5220e76678e71291175">&#9670;&nbsp;</a></span>HasJointActuatorNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasJointActuatorNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a02c811258a0d93dd116d61648334a392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c811258a0d93dd116d61648334a392">&#9670;&nbsp;</a></span>HasJointNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasJointNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ac7ebee03109f4cb8990124949e97caa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ebee03109f4cb8990124949e97caa1">&#9670;&nbsp;</a></span>HasJointNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasJointNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a05b71664c8e2e91bc3fc92fef222a9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b71664c8e2e91bc3fc92fef222a9bf">&#9670;&nbsp;</a></span>HasModelInstanceNamed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasModelInstanceNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See MultibodyMethod. </p>

</div>
</div>
<a id="a91d9ba2b26eb3887a1e277875a5af127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d9ba2b26eb3887a1e277875a5af127">&#9670;&nbsp;</a></span>MakeActuatorSelectorMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; MakeActuatorSelectorMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>user_to_actuator_index_map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="af90a2eb58b242d1a85176e32435004c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90a2eb58b242d1a85176e32435004c9">&#9670;&nbsp;</a></span>MakeActuatorSelectorMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; MakeActuatorSelectorMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>user_to_joint_index_map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ae1c9973e5bec9022fa46dfcedb34df84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c9973e5bec9022fa46dfcedb34df84">&#9670;&nbsp;</a></span>MakeStateSelectorMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; MakeStateSelectorMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>user_to_joint_index_map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a28384608fd90b16df01c2f9ff029e458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28384608fd90b16df01c2f9ff029e458">&#9670;&nbsp;</a></span>MakeStateSelectorMatrixFromJointNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; MakeStateSelectorMatrixFromJointNames </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_joints</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternative signature to build a state selector matrix from a std::vector of joint names. </p>
<p>See MakeStateSelectorMatrixFromJointNames(const std::vector&lt;JointIndex&gt;&amp;) for details. <code>selected_joints</code> must not contain any duplicates.</p>
<p>A user specifies the preferred order in the selected states vector xₛ via <code>selected_joints</code>. The selected state is built such that selected positions are followed by selected velocities, as in <code>xₛ = [qₛ, vₛ]</code>. The positions in qₛ are a concatenation of the positions for each joint in the order they appear in <code>selected_joints</code>. That is, the positions for <code>selected_joints[0]</code> are first, followed by the positions for <code>selected_joints[1]</code>, etc. Similarly for the selected velocities vₛ.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there are any duplicates in <code>selected_joints</code>. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if there is no joint in the model with a name specified in <code>selected_joints</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab128a8bba10523922358bc35df103753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab128a8bba10523922358bc35df103753">&#9670;&nbsp;</a></span>MapQDotToVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MapQDotToVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a7bb24fed19f16a76450eece1857b92dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb24fed19f16a76450eece1857b92dc">&#9670;&nbsp;</a></span>MapVelocityToQDot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MapVelocityToQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ae3fc8de8de8eaf2d37a24c79d6be8e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fc8de8de8eaf2d37a24c79d6be8e97">&#9670;&nbsp;</a></span>num_actuated_dofs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_actuated_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a279e31367e76849d4a45fd7db0f116f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279e31367e76849d4a45fd7db0f116f1">&#9670;&nbsp;</a></span>num_actuated_dofs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_actuated_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a8601c026e9807127b4dd41e7585d2cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8601c026e9807127b4dd41e7585d2cfc">&#9670;&nbsp;</a></span>num_actuators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_actuators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of actuators in the model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a5096160ffb18ddc72e2e29c0edfc5064" title="Creates and adds a JointActuator model for an actuator acting on a given joint. ">AddJointActuator()</a>. </dd></dl>

</div>
</div>
<a id="af92b53211e54243aff4490a700168eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92b53211e54243aff4490a700168eb4">&#9670;&nbsp;</a></span>num_bodies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_bodies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bodies in the MultibodyTree including the <em>world</em> body. </p>
<p>Therefore the minimum number of bodies in a <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html" title="MultibodyTree provides a representation for a physical system consisting of a collection of interconn...">MultibodyTree</a> is one. </p>

</div>
</div>
<a id="a6b7f0267d163693025fa04f78bb18333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7f0267d163693025fa04f78bb18333">&#9670;&nbsp;</a></span>num_force_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_force_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ada7f02e861a8f89fc0b575b2f30333d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7f02e861a8f89fc0b575b2f30333d3">&#9670;&nbsp;</a></span>num_frames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_frames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a636804b6c40e538d83d5c2dfefb7929e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636804b6c40e538d83d5c2dfefb7929e">&#9670;&nbsp;</a></span>num_joints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_joints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of joints added with <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a437f86026a2268c0fb06936b899ba8d7" title="This method adds a Joint of type JointType between the frames specified by the joint. ">AddJoint()</a> to the MultibodyTree. </p>

</div>
</div>
<a id="ad4534e419e421208e87433f3e7243752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4534e419e421208e87433f3e7243752">&#9670;&nbsp;</a></span>num_mobilizers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_mobilizers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="ac89140adb93cb9e507f71c30eb783198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89140adb93cb9e507f71c30eb783198">&#9670;&nbsp;</a></span>num_model_instances()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_model_instances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of model instances in the <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html" title="MultibodyTree provides a representation for a physical system consisting of a collection of interconn...">MultibodyTree</a>. </p>

</div>
</div>
<a id="aba2887f0ca1fbbdfb49cf6b0ee21e553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">&#9670;&nbsp;</a></span>num_positions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_positions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of generalized positions of the model. </p>

</div>
</div>
<a id="ab669e070e6178c4aeeb067a1f4b6122e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab669e070e6178c4aeeb067a1f4b6122e">&#9670;&nbsp;</a></span>num_positions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_positions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of generalized positions in a specific model instance. </p>

</div>
</div>
<a id="a3cbd3e24f7648ab7712c803ca8a63f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cbd3e24f7648ab7712c803ca8a63f3e">&#9670;&nbsp;</a></span>num_states() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_states </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total size of the state vector in the model. </p>

</div>
</div>
<a id="af73b2e9e79342ca3ca8195ecd5daf01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73b2e9e79342ca3ca8195ecd5daf01e">&#9670;&nbsp;</a></span>num_states() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total size of the state vector in a specific model instance. </p>

</div>
</div>
<a id="ae0163ac0976659d811e3337647ff0313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0163ac0976659d811e3337647ff0313">&#9670;&nbsp;</a></span>num_velocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_velocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of generalized velocities of the model. </p>

</div>
</div>
<a id="a0a686a8389beffdc5fb8a7690967e741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a686a8389beffdc5fb8a7690967e741">&#9670;&nbsp;</a></span>num_velocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_velocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of generalized velocities in a specific model instance. </p>

</div>
</div>
<a id="afa14b83a5d66b905376d7654ef7cf7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa14b83a5d66b905376d7654ef7cf7a2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba7d88ffae63ddf3c6c81b23fe3d7a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7d88ffae63ddf3c6c81b23fe3d7a89">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1640dac294e20deb224eec1f6496c316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1640dac294e20deb224eec1f6496c316">&#9670;&nbsp;</a></span>set_tree_system()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_tree_system </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree_system.html">MultibodyTreeSystem</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>tree_system</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) Informs the <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html" title="MultibodyTree provides a representation for a physical system consisting of a collection of interconn...">MultibodyTree</a> how to access its resources within a Context. </p>

</div>
</div>
<a id="aec851e17ae2c34da1b87a03ce85f460a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec851e17ae2c34da1b87a03ce85f460a">&#9670;&nbsp;</a></span>SetActuationInArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetActuationInArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>u_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="af8bd33a2e8520eccde63ffbd423c056a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bd33a2e8520eccde63ffbd423c056a">&#9670;&nbsp;</a></span>SetDefaultState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a80fd0f1de1971c578083e42d0b2705cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fd0f1de1971c578083e42d0b2705cf">&#9670;&nbsp;</a></span>SetFreeBodyPoseOrThrow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPoseOrThrow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_WB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a2afeb2fce8493fe177dd3cd155819bb9" title="Sets context to store the pose X_WB of a given body B in the world frame W. ">MultibodyPlant::SetFreeBodyPose</a>. </p>

</div>
</div>
<a id="ac5c546a708bac99c2819bd2b3a83f49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c546a708bac99c2819bd2b3a83f49a">&#9670;&nbsp;</a></span>SetFreeBodyPoseOrThrow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPoseOrThrow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_WB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a2afeb2fce8493fe177dd3cd155819bb9" title="Sets context to store the pose X_WB of a given body B in the world frame W. ">MultibodyPlant::SetFreeBodyPose</a>. </p>

</div>
</div>
<a id="aa98c91d6aa10a8320efbc8c6d428b9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98c91d6aa10a8320efbc8c6d428b9ad">&#9670;&nbsp;</a></span>SetFreeBodySpatialVelocityOrThrow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodySpatialVelocityOrThrow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_WB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae4c3b2ef66032df5f2a377c47e90ccb7" title="Sets context to store the spatial velocity V_WB of a given body B in the world frame W...">MultibodyPlant::SetFreeBodySpatialVelocity</a>. </p>

</div>
</div>
<a id="a4b286640b1245f8c2df6212e628e1c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b286640b1245f8c2df6212e628e1c9c">&#9670;&nbsp;</a></span>SetFreeBodySpatialVelocityOrThrow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodySpatialVelocityOrThrow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_WB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See MutibodyPlant::SetFreeBodySpatialVelocity. </p>

</div>
</div>
<a id="ab1e3715f67d9c2abd27454522c85322a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e3715f67d9c2abd27454522c85322a">&#9670;&nbsp;</a></span>SetPositionsAndVelocities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>instance_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>context</code> to store the vector <code>[q; v]</code> with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities for model instance <code>model_instance</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> does not correspond to the context for a multibody model, <code>context</code> is nullptr, <code>model_instance</code> is invalid, or <code>instance_state.size()</code> does not equal <code>num_positions(model_instance)</code><ul>
<li><code>num_velocities(model_instance)</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de72c319632f5a263fe6c9e96c70614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de72c319632f5a263fe6c9e96c70614">&#9670;&nbsp;</a></span>SetPositionsInArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPositionsInArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>q_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="a438d233107845df9ea2ee0321094946c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438d233107845df9ea2ee0321094946c">&#9670;&nbsp;</a></span>SetRandomState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetRandomState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#ab262f8e82f09d8df2990d0dc5869c34f">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> method. </p>

</div>
</div>
<a id="aa3e24d7263c7886bdf1adab111e34f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e24d7263c7886bdf1adab111e34f33">&#9670;&nbsp;</a></span>SetVelocitiesInArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetVelocitiesInArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>model_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>v_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vector of generalized velocities for <code>model_instance</code> in <code>v</code> using <code>v_instance</code>, leaving all other elements in the array untouched. </p>
<p>This method throws an exception if <code>v</code> is not of size <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ae0163ac0976659d811e3337647ff0313" title="Returns the number of generalized velocities of the model. ">MultibodyTree::num_velocities()</a> or <code>v_instance</code> is not of size <code>MultibodyTree::num_positions(model_instance)</code>. </p>

</div>
</div>
<a id="af043fd921c9543fc70c3e903295a9e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af043fd921c9543fc70c3e903295a9e87">&#9670;&nbsp;</a></span>ToAutoDiffXd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt;<a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>&gt; &gt; ToAutoDiffXd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of <code>this</code> MultibodyTree templated on AutoDiffXd. </p>

</div>
</div>
<a id="ae53169605aca35402fdc495db8150d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53169605aca35402fdc495db8150d98">&#9670;&nbsp;</a></span>topology_is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> topology_is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this MultibodyTree was finalized with <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> after all multibody elements were added, and <code>false</code> otherwise. </p>
<p>When a MultibodyTree is instantiated, its topology remains invalid until <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a> is called, which validates the topology. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">Finalize()</a>. </dd></dl>

</div>
</div>
<a id="a7cf904af9e2715a5a2db668d207173c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf904af9e2715a5a2db668d207173c8">&#9670;&nbsp;</a></span>tree_height()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> tree_height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the height of the tree data structure of <code>this</code> MultibodyTree. </p>
<p>That is, the number of bodies in the longest kinematic path between the world and any other leaf body. For a model that only contains the <em>world</em> body, the height of the tree is one. Kinematic paths are created by <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_mobilizer.html" title="Mobilizer is a fundamental object within Drake&#39;s multibody engine used to specify the allowed motions...">Mobilizer</a> objects connecting a chain of frames. Therefore, this method does not count kinematic cycles, which could only be considered in the model using constraints. </p>

</div>
</div>
<a id="a29ef779ddfeea96c5d80c27d68a4f864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ef779ddfeea96c5d80c27d68a4f864">&#9670;&nbsp;</a></span>world_body()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; world_body </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the <em>world</em> body. </p>

</div>
</div>
<a id="ac95da38020c32452f62a8cf973057c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95da38020c32452f62a8cf973057c7a">&#9670;&nbsp;</a></span>world_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html">BodyFrame</a>&lt;T&gt;&amp; world_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the <em>world</em> frame. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="adb8a77d72df5944a21169f726e4a1ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8a77d72df5944a21169f726e4a1ec6">&#9670;&nbsp;</a></span>MultibodyTree</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Public alias to internal <code><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html" title="MultibodyTree provides a representation for a physical system consisting of a collection of interconn...">MultibodyTree</a></code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>This alias will soon be deprecated. </dd></dl>

</div>
</div>
<a id="a0f7a471a0143b2d9317e8d57ac9b9786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7a471a0143b2d9317e8d57ac9b9786">&#9670;&nbsp;</a></span>MultibodyTreeTester</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class MultibodyTreeTester</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/multibody/tree/<a class="el" href="multibody__tree_8h.html">multibody_tree.h</a></li>
<li>drake/multibody/tree/<a class="el" href="multibody__tree_8cc.html">multibody_tree.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
