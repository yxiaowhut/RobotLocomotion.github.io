<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: MultibodyTreeTopology Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_multibody_tree_topology.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1_multibody_tree_topology-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MultibodyTreeTopology Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Data structure to store the topological information associated with an entire MultibodyTree.  
 <a href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#details">More...</a></p>

<p><code>#include &lt;drake/multibody/tree/multibody_tree_topology.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2efc155e8b5dc5d4b0ca82bde2c36386"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a2efc155e8b5dc5d4b0ca82bde2c36386">MultibodyTreeTopology</a> ()</td></tr>
<tr class="memdesc:a2efc155e8b5dc5d4b0ca82bde2c36386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor creates an empty, invalid topology.  <a href="#a2efc155e8b5dc5d4b0ca82bde2c36386">More...</a><br /></td></tr>
<tr class="separator:a2efc155e8b5dc5d4b0ca82bde2c36386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9b54b723ec2a4856c36e0d74322353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#ade9b54b723ec2a4856c36e0d74322353">operator==</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> &amp;other) const</td></tr>
<tr class="memdesc:ade9b54b723ec2a4856c36e0d74322353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if all members of <code>this</code> topology are exactly equal to the members of <code>other</code>.  <a href="#ade9b54b723ec2a4856c36e0d74322353">More...</a><br /></td></tr>
<tr class="separator:ade9b54b723ec2a4856c36e0d74322353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92b53211e54243aff4490a700168eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#af92b53211e54243aff4490a700168eb4">num_bodies</a> () const</td></tr>
<tr class="memdesc:af92b53211e54243aff4490a700168eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bodies in the multibody tree.  <a href="#af92b53211e54243aff4490a700168eb4">More...</a><br /></td></tr>
<tr class="separator:af92b53211e54243aff4490a700168eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7f02e861a8f89fc0b575b2f30333d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#ada7f02e861a8f89fc0b575b2f30333d3">num_frames</a> () const</td></tr>
<tr class="memdesc:ada7f02e861a8f89fc0b575b2f30333d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of physical frames in the multibody tree.  <a href="#ada7f02e861a8f89fc0b575b2f30333d3">More...</a><br /></td></tr>
<tr class="separator:ada7f02e861a8f89fc0b575b2f30333d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4534e419e421208e87433f3e7243752"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#ad4534e419e421208e87433f3e7243752">num_mobilizers</a> () const</td></tr>
<tr class="memdesc:ad4534e419e421208e87433f3e7243752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of mobilizers in the multibody tree.  <a href="#ad4534e419e421208e87433f3e7243752">More...</a><br /></td></tr>
<tr class="separator:ad4534e419e421208e87433f3e7243752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0344635beed93d968ec7bd4fa97d06ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a0344635beed93d968ec7bd4fa97d06ca">get_num_body_nodes</a> () const</td></tr>
<tr class="memdesc:a0344635beed93d968ec7bd4fa97d06ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of tree nodes. This must equal the number of bodies.  <a href="#a0344635beed93d968ec7bd4fa97d06ca">More...</a><br /></td></tr>
<tr class="separator:a0344635beed93d968ec7bd4fa97d06ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7f0267d163693025fa04f78bb18333"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a6b7f0267d163693025fa04f78bb18333">num_force_elements</a> () const</td></tr>
<tr class="memdesc:a6b7f0267d163693025fa04f78bb18333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of force elements in the topology.  <a href="#a6b7f0267d163693025fa04f78bb18333">More...</a><br /></td></tr>
<tr class="separator:a6b7f0267d163693025fa04f78bb18333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea2bac24332c67eb657bdca27eb864e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a0ea2bac24332c67eb657bdca27eb864e">num_joint_actuators</a> () const</td></tr>
<tr class="memdesc:a0ea2bac24332c67eb657bdca27eb864e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of joint actuators in the topology.  <a href="#a0ea2bac24332c67eb657bdca27eb864e">More...</a><br /></td></tr>
<tr class="separator:a0ea2bac24332c67eb657bdca27eb864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf904af9e2715a5a2db668d207173c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a7cf904af9e2715a5a2db668d207173c8">tree_height</a> () const</td></tr>
<tr class="memdesc:a7cf904af9e2715a5a2db668d207173c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of tree levels in the topology.  <a href="#a7cf904af9e2715a5a2db668d207173c8">More...</a><br /></td></tr>
<tr class="separator:a7cf904af9e2715a5a2db668d207173c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9b204ff6368b7085ae78caf2fd1f54"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdrake_1_1multibody_1_1_frame_topology.html">FrameTopology</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a7f9b204ff6368b7085ae78caf2fd1f54">get_frame</a> (<a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> index) const</td></tr>
<tr class="memdesc:a7f9b204ff6368b7085ae78caf2fd1f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the corresponding <a class="el" href="structdrake_1_1multibody_1_1_frame_topology.html" title="Data structure to store the topological information associated with a Frame. ">FrameTopology</a> given the FrameIndex.  <a href="#a7f9b204ff6368b7085ae78caf2fd1f54">More...</a><br /></td></tr>
<tr class="separator:a7f9b204ff6368b7085ae78caf2fd1f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa92c43bfe1350d08a33d5f11e285168"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdrake_1_1multibody_1_1_body_topology.html">BodyTopology</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#aaa92c43bfe1350d08a33d5f11e285168">get_body</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> index) const</td></tr>
<tr class="memdesc:aaa92c43bfe1350d08a33d5f11e285168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the corresponding <a class="el" href="structdrake_1_1multibody_1_1_body_topology.html" title="Data structure to store the topological information associated with a Body. ">BodyTopology</a> given a BodyIndex.  <a href="#aaa92c43bfe1350d08a33d5f11e285168">More...</a><br /></td></tr>
<tr class="separator:aaa92c43bfe1350d08a33d5f11e285168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab612b438482a71fb20f09df2c80d0a96"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdrake_1_1multibody_1_1_mobilizer_topology.html">MobilizerTopology</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#ab612b438482a71fb20f09df2c80d0a96">get_mobilizer</a> (<a class="el" href="namespacedrake_1_1multibody.html#a5296da869e93358c7ea8fd7e15a8757c">MobilizerIndex</a> index) const</td></tr>
<tr class="memdesc:ab612b438482a71fb20f09df2c80d0a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the corresponding <a class="el" href="structdrake_1_1multibody_1_1_body_topology.html" title="Data structure to store the topological information associated with a Body. ">BodyTopology</a> given a BodyIndex.  <a href="#ab612b438482a71fb20f09df2c80d0a96">More...</a><br /></td></tr>
<tr class="separator:ab612b438482a71fb20f09df2c80d0a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e2584cc06f289df64efcf3c9a1703c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdrake_1_1multibody_1_1_joint_actuator_topology.html">JointActuatorTopology</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#ae7e2584cc06f289df64efcf3c9a1703c">get_joint_actuator</a> (<a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> index) const</td></tr>
<tr class="memdesc:ae7e2584cc06f289df64efcf3c9a1703c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the corresponding <a class="el" href="structdrake_1_1multibody_1_1_joint_actuator_topology.html" title="Data structure to store the topological information associated with a JointActuator. ">JointActuatorTopology</a> given a JointActuatorIndex.  <a href="#ae7e2584cc06f289df64efcf3c9a1703c">More...</a><br /></td></tr>
<tr class="separator:ae7e2584cc06f289df64efcf3c9a1703c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be097ab023651f8d742b56f4b37fa65"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdrake_1_1multibody_1_1_body_node_topology.html">BodyNodeTopology</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a0be097ab023651f8d742b56f4b37fa65">get_body_node</a> (<a class="el" href="namespacedrake_1_1multibody.html#a29cdcf85f1a6abd167e7517b4a264ef1">BodyNodeIndex</a> index) const</td></tr>
<tr class="memdesc:a0be097ab023651f8d742b56f4b37fa65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the corresponding <a class="el" href="structdrake_1_1multibody_1_1_body_node_topology.html" title="Data structure to store the topological information associated with a tree node. ">BodyNodeTopology</a> given a BodyNodeIndex.  <a href="#a0be097ab023651f8d742b56f4b37fa65">More...</a><br /></td></tr>
<tr class="separator:a0be097ab023651f8d742b56f4b37fa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a43b0da6616069d8e8614461560a3ef"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>, <a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a0a43b0da6616069d8e8614461560a3ef">add_body</a> ()</td></tr>
<tr class="memdesc:a0a43b0da6616069d8e8614461560a3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and adds a new <a class="el" href="structdrake_1_1multibody_1_1_body_topology.html" title="Data structure to store the topological information associated with a Body. ">BodyTopology</a> to this <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html" title="Data structure to store the topological information associated with an entire MultibodyTree. ">MultibodyTreeTopology</a>.  <a href="#a0a43b0da6616069d8e8614461560a3ef">More...</a><br /></td></tr>
<tr class="separator:a0a43b0da6616069d8e8614461560a3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152daac09ea8a09e37f77a838800776a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a152daac09ea8a09e37f77a838800776a">add_frame</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index)</td></tr>
<tr class="memdesc:a152daac09ea8a09e37f77a838800776a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and adds a new <a class="el" href="structdrake_1_1multibody_1_1_frame_topology.html" title="Data structure to store the topological information associated with a Frame. ">FrameTopology</a>, associated with the given body_index, to this <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html" title="Data structure to store the topological information associated with an entire MultibodyTree. ">MultibodyTreeTopology</a>.  <a href="#a152daac09ea8a09e37f77a838800776a">More...</a><br /></td></tr>
<tr class="separator:a152daac09ea8a09e37f77a838800776a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3be8f34a459d4726eade24ef2b13d9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#a5296da869e93358c7ea8fd7e15a8757c">MobilizerIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#ae3be8f34a459d4726eade24ef2b13d9f">add_mobilizer</a> (<a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> in_frame, <a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> out_frame, <a class="el" href="classint.html">int</a> <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#aba2887f0ca1fbbdfb49cf6b0ee21e553">num_positions</a>, <a class="el" href="classint.html">int</a> <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#ae0163ac0976659d811e3337647ff0313">num_velocities</a>)</td></tr>
<tr class="memdesc:ae3be8f34a459d4726eade24ef2b13d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and adds a new <a class="el" href="structdrake_1_1multibody_1_1_mobilizer_topology.html" title="Data structure to store the topological information associated with a Mobilizer object. ">MobilizerTopology</a> connecting the inboard and outboard multibody frames identified by indexes <code>in_frame</code> and <code>out_frame</code>, respectively.  <a href="#ae3be8f34a459d4726eade24ef2b13d9f">More...</a><br /></td></tr>
<tr class="separator:ae3be8f34a459d4726eade24ef2b13d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b428a61ca6e0267b6db518bafdf6cc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#add80e949328b179d78312d1455319868">ForceElementIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a2b428a61ca6e0267b6db518bafdf6cc1">add_force_element</a> ()</td></tr>
<tr class="memdesc:a2b428a61ca6e0267b6db518bafdf6cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and adds a new <a class="el" href="structdrake_1_1multibody_1_1_force_element_topology.html" title="Data structure to store the topological information associated with a ForceElement. ">ForceElementTopology</a>, associated with the given force_index, to this <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html" title="Data structure to store the topological information associated with an entire MultibodyTree. ">MultibodyTreeTopology</a>.  <a href="#a2b428a61ca6e0267b6db518bafdf6cc1">More...</a><br /></td></tr>
<tr class="separator:a2b428a61ca6e0267b6db518bafdf6cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd186743d02a0768760323975d366cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a3fd186743d02a0768760323975d366cf">add_joint_actuator</a> (<a class="el" href="classint.html">int</a> num_dofs)</td></tr>
<tr class="memdesc:a3fd186743d02a0768760323975d366cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and adds a new <a class="el" href="structdrake_1_1multibody_1_1_joint_actuator_topology.html" title="Data structure to store the topological information associated with a JointActuator. ">JointActuatorTopology</a> for a joint with <code>num_dofs</code> degrees of freedom.  <a href="#a3fd186743d02a0768760323975d366cf">More...</a><br /></td></tr>
<tr class="separator:a3fd186743d02a0768760323975d366cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fee61d7a783cade1a3d07fe86284d27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a8fee61d7a783cade1a3d07fe86284d27">Finalize</a> ()</td></tr>
<tr class="memdesc:a8fee61d7a783cade1a3d07fe86284d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be called by <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">MultibodyTree::Finalize()</a> after all topological elements in the tree (corresponding to joints, bodies, force elements, constraints) were added and before any computations are performed.  <a href="#a8fee61d7a783cade1a3d07fe86284d27">More...</a><br /></td></tr>
<tr class="separator:a8fee61d7a783cade1a3d07fe86284d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca0e76fa665125f1e50bd1ed8dbd213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a8ca0e76fa665125f1e50bd1ed8dbd213">is_valid</a> () const</td></tr>
<tr class="memdesc:a8ca0e76fa665125f1e50bd1ed8dbd213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called by MultibodyTree::Finalize() after all topological elements in the tree (c...">Finalize()</a> was already called on <code>this</code> topology.  <a href="#a8ca0e76fa665125f1e50bd1ed8dbd213">More...</a><br /></td></tr>
<tr class="separator:a8ca0e76fa665125f1e50bd1ed8dbd213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#aba2887f0ca1fbbdfb49cf6b0ee21e553">num_positions</a> () const</td></tr>
<tr class="memdesc:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of generalized positions in the model.  <a href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">More...</a><br /></td></tr>
<tr class="separator:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0163ac0976659d811e3337647ff0313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#ae0163ac0976659d811e3337647ff0313">num_velocities</a> () const</td></tr>
<tr class="memdesc:ae0163ac0976659d811e3337647ff0313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of generalized velocities in the model.  <a href="#ae0163ac0976659d811e3337647ff0313">More...</a><br /></td></tr>
<tr class="separator:ae0163ac0976659d811e3337647ff0313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbd3e24f7648ab7712c803ca8a63f3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a3cbd3e24f7648ab7712c803ca8a63f3e">num_states</a> () const</td></tr>
<tr class="memdesc:a3cbd3e24f7648ab7712c803ca8a63f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total size of the state vector in the model.  <a href="#a3cbd3e24f7648ab7712c803ca8a63f3e">More...</a><br /></td></tr>
<tr class="separator:a3cbd3e24f7648ab7712c803ca8a63f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#ae3fc8de8de8eaf2d37a24c79d6be8e97">num_actuated_dofs</a> () const</td></tr>
<tr class="memdesc:ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of actuated joint dofs in the model.  <a href="#ae3fc8de8de8eaf2d37a24c79d6be8e97">More...</a><br /></td></tr>
<tr class="separator:ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d587fe12a77f802d3827b59b85e3f8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a5d587fe12a77f802d3827b59b85e3f8d">GetKinematicPathToWorld</a> (<a class="el" href="namespacedrake_1_1multibody.html#a29cdcf85f1a6abd167e7517b4a264ef1">BodyNodeIndex</a> from, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#a29cdcf85f1a6abd167e7517b4a264ef1">BodyNodeIndex</a> &gt; *path_to_world) const</td></tr>
<tr class="memdesc:a5d587fe12a77f802d3827b59b85e3f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a node in <code>this</code> topology, specified by its BodyNodeIndex <code>from</code>, this method computes the kinematic path formed by all the nodes in the tree that connect <code>from</code> with the root (corresponding to the world).  <a href="#a5d587fe12a77f802d3827b59b85e3f8d">More...</a><br /></td></tr>
<tr class="separator:a5d587fe12a77f802d3827b59b85e3f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30d75bef808b82a12b1ac5d9e22ef87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#ad30d75bef808b82a12b1ac5d9e22ef87">IsBodyAnchored</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:ad30d75bef808b82a12b1ac5d9e22ef87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the body with index <code>body_index</code> is anchored to the world.  <a href="#ad30d75bef808b82a12b1ac5d9e22ef87">More...</a><br /></td></tr>
<tr class="separator:ad30d75bef808b82a12b1ac5d9e22ef87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f292d91ce94a7f84139f6acf2957622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; std::set&lt; <a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a9f292d91ce94a7f84139f6acf2957622">CreateListOfWeldedBodies</a> () const</td></tr>
<tr class="memdesc:a9f292d91ce94a7f84139f6acf2957622"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method partitions the tree topology into sub-graphs such that two bodies are in the same sub-graph if there is a path between them which includes only welded-mobilizer.  <a href="#a9f292d91ce94a7f84139f6acf2957622">More...</a><br /></td></tr>
<tr class="separator:a9f292d91ce94a7f84139f6acf2957622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a6900ac614a7b17ea781ff1c45b0bedf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a6900ac614a7b17ea781ff1c45b0bedf8">MultibodyTreeTopology</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> &amp;)=default</td></tr>
<tr class="separator:a6900ac614a7b17ea781ff1c45b0bedf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c16e7ae475654c0559a454ab0caea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#ab2c16e7ae475654c0559a454ab0caea2">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> &amp;)=default</td></tr>
<tr class="separator:ab2c16e7ae475654c0559a454ab0caea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b27f4324db1769bf5075141994da3d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a7b27f4324db1769bf5075141994da3d9">MultibodyTreeTopology</a> (<a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a7b27f4324db1769bf5075141994da3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc48151d829ada9e37d95c25ea993a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a4cc48151d829ada9e37d95c25ea993a8">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a4cc48151d829ada9e37d95c25ea993a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data structure to store the topological information associated with an entire MultibodyTree. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6900ac614a7b17ea781ff1c45b0bedf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6900ac614a7b17ea781ff1c45b0bedf8">&#9670;&nbsp;</a></span>MultibodyTreeTopology() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b27f4324db1769bf5075141994da3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b27f4324db1769bf5075141994da3d9">&#9670;&nbsp;</a></span>MultibodyTreeTopology() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2efc155e8b5dc5d4b0ca82bde2c36386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efc155e8b5dc5d4b0ca82bde2c36386">&#9670;&nbsp;</a></span>MultibodyTreeTopology() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor creates an empty, invalid topology. </p>
<p>The minimum valid topology for a minimum valid MultibodyTree contains at least the <a class="el" href="structdrake_1_1multibody_1_1_body_topology.html" title="Data structure to store the topological information associated with a Body. ">BodyTopology</a> for the world. The topology for the <em>world</em> body does not get added until MultibodyTree construction, which creates a <em>world</em> body and adds it to the tree. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0a43b0da6616069d8e8614461560a3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a43b0da6616069d8e8614461560a3ef">&#9670;&nbsp;</a></span>add_body()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>, <a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a>&gt; add_body </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and adds a new <a class="el" href="structdrake_1_1multibody_1_1_body_topology.html" title="Data structure to store the topological information associated with a Body. ">BodyTopology</a> to this <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html" title="Data structure to store the topological information associated with an entire MultibodyTree. ">MultibodyTreeTopology</a>. </p>
<p>The <a class="el" href="structdrake_1_1multibody_1_1_body_topology.html" title="Data structure to store the topological information associated with a Body. ">BodyTopology</a> will be assigned a new, unique BodyIndex and FrameIndex values.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called by MultibodyTree::Finalize() after all topological elements in the tree (c...">Finalize()</a> was already called on <code>this</code> topology.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::pair&lt;BodyIndex, FrameIndex&gt; containing the indexes assigned to the new <a class="el" href="structdrake_1_1multibody_1_1_body_topology.html" title="Data structure to store the topological information associated with a Body. ">BodyTopology</a>. </dd></dl>

</div>
</div>
<a id="a2b428a61ca6e0267b6db518bafdf6cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b428a61ca6e0267b6db518bafdf6cc1">&#9670;&nbsp;</a></span>add_force_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#add80e949328b179d78312d1455319868">ForceElementIndex</a> add_force_element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and adds a new <a class="el" href="structdrake_1_1multibody_1_1_force_element_topology.html" title="Data structure to store the topological information associated with a ForceElement. ">ForceElementTopology</a>, associated with the given force_index, to this <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html" title="Data structure to store the topological information associated with an entire MultibodyTree. ">MultibodyTreeTopology</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called by MultibodyTree::Finalize() after all topological elements in the tree (c...">Finalize()</a> was already called on <code>this</code> topology.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ForceElementIndex assigned to the new <a class="el" href="structdrake_1_1multibody_1_1_force_element_topology.html" title="Data structure to store the topological information associated with a ForceElement. ">ForceElementTopology</a>. </dd></dl>

</div>
</div>
<a id="a152daac09ea8a09e37f77a838800776a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152daac09ea8a09e37f77a838800776a">&#9670;&nbsp;</a></span>add_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> add_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and adds a new <a class="el" href="structdrake_1_1multibody_1_1_frame_topology.html" title="Data structure to store the topological information associated with a Frame. ">FrameTopology</a>, associated with the given body_index, to this <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html" title="Data structure to store the topological information associated with an entire MultibodyTree. ">MultibodyTreeTopology</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called by MultibodyTree::Finalize() after all topological elements in the tree (c...">Finalize()</a> was already called on <code>this</code> topology.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The FrameIndex assigned to the new <a class="el" href="structdrake_1_1multibody_1_1_frame_topology.html" title="Data structure to store the topological information associated with a Frame. ">FrameTopology</a>. </dd></dl>

</div>
</div>
<a id="a3fd186743d02a0768760323975d366cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd186743d02a0768760323975d366cf">&#9670;&nbsp;</a></span>add_joint_actuator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> add_joint_actuator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_dofs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and adds a new <a class="el" href="structdrake_1_1multibody_1_1_joint_actuator_topology.html" title="Data structure to store the topological information associated with a JointActuator. ">JointActuatorTopology</a> for a joint with <code>num_dofs</code> degrees of freedom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_dofs</td><td>The number of joint dofs actuated by this actuator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called by MultibodyTree::Finalize() after all topological elements in the tree (c...">Finalize()</a> was already called on <code>this</code> topology.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The JointActuatorIndex assigned to the new <a class="el" href="structdrake_1_1multibody_1_1_joint_actuator_topology.html" title="Data structure to store the topological information associated with a JointActuator. ">JointActuatorTopology</a>. </dd></dl>

</div>
</div>
<a id="ae3be8f34a459d4726eade24ef2b13d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3be8f34a459d4726eade24ef2b13d9f">&#9670;&nbsp;</a></span>add_mobilizer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#a5296da869e93358c7ea8fd7e15a8757c">MobilizerIndex</a> add_mobilizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a>&#160;</td>
          <td class="paramname"><em>in_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a>&#160;</td>
          <td class="paramname"><em>out_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_velocities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and adds a new <a class="el" href="structdrake_1_1multibody_1_1_mobilizer_topology.html" title="Data structure to store the topological information associated with a Mobilizer object. ">MobilizerTopology</a> connecting the inboard and outboard multibody frames identified by indexes <code>in_frame</code> and <code>out_frame</code>, respectively. </p>
<p>The created topology will correspond to that of a <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html" title="Mobilizer is a fundamental object within Drake&#39;s multibody engine used to specify the allowed motions...">Mobilizer</a> with <code>num_positions</code> and <code>num_velocities</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if either <code>in_frame</code> or <code>out_frame</code> do not index frame topologies in <code>this</code> MultibodyTreeTopology. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>in_frame == out_frame</code>. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>in_frame</code> and <code>out_frame</code> already are connected by another mobilizer. More than one mobilizer between two frames is not allowed. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called by MultibodyTree::Finalize() after all topological elements in the tree (c...">Finalize()</a> was already called on <code>this</code> topology.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MobilizerIndex assigned to the new <a class="el" href="structdrake_1_1multibody_1_1_mobilizer_topology.html" title="Data structure to store the topological information associated with a Mobilizer object. ">MobilizerTopology</a>. </dd></dl>

</div>
</div>
<a id="a9f292d91ce94a7f84139f6acf2957622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f292d91ce94a7f84139f6acf2957622">&#9670;&nbsp;</a></span>CreateListOfWeldedBodies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;std::set&lt;<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&gt; &gt; CreateListOfWeldedBodies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method partitions the tree topology into sub-graphs such that two bodies are in the same sub-graph if there is a path between them which includes only welded-mobilizer. </p>
<p>Each sub-graph of welded bodies is represented as a set of body indices. By definition, these sub-graphs will be disconnected by any non-weld mobilizers that may be inboard or outboard of any given body. The first sub-graph will have all of the bodies welded to the world; all subsequent sub-graphs will be in no particular order. A few more notes:</p>
<ul>
<li>Each body in the topology is included in one set and one set only.</li>
<li>The maximum size of the list equals the number of bodies in the topology (<a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#af92b53211e54243aff4490a700168eb4" title="Returns the number of bodies in the multibody tree. ">num_bodies()</a>). This corresponds to a topology with no weld mobilizers.</li>
<li>The world body is also included in a welded-bodies set, and this set is element zero in the returned vector.</li>
<li>The minimum size of the list is one. This corresponds to a topology with all bodies welded to the world. </li>
</ul>

</div>
</div>
<a id="a8fee61d7a783cade1a3d07fe86284d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fee61d7a783cade1a3d07fe86284d27">&#9670;&nbsp;</a></span>Finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method must be called by <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">MultibodyTree::Finalize()</a> after all topological elements in the tree (corresponding to joints, bodies, force elements, constraints) were added and before any computations are performed. </p>
<p>It essentially compiles all the necessary "topological information", i.e. how bodies, joints and, any other elements connect with each other, and performs all the required pre-processing to perform computations at a later stage. This preprocessing includes:</p>
<ul>
<li>sorting in BFT order for fast recursions through the tree,</li>
<li>computation of state sizes and of pool sizes within cache entries,</li>
<li>computation of index maps to retrieve either state or cache entries for each multibody element.</li>
</ul>
<p>If the finalize stage is successful, the <code>this</code> topology is validated, meaning it is up-to-date after this call. No more multibody tree elements can be added after a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called by MultibodyTree::Finalize() after all topological elements in the tree (c...">Finalize()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If users attempt to call this method on an already finalized topology. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a8ca0e76fa665125f1e50bd1ed8dbd213" title="Returns true if Finalize() was already called on this topology. ">is_valid()</a> </dd></dl>

</div>
</div>
<a id="aaa92c43bfe1350d08a33d5f11e285168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa92c43bfe1350d08a33d5f11e285168">&#9670;&nbsp;</a></span>get_body()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdrake_1_1multibody_1_1_body_topology.html">BodyTopology</a>&amp; get_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the corresponding <a class="el" href="structdrake_1_1multibody_1_1_body_topology.html" title="Data structure to store the topological information associated with a Body. ">BodyTopology</a> given a BodyIndex. </p>

</div>
</div>
<a id="a0be097ab023651f8d742b56f4b37fa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be097ab023651f8d742b56f4b37fa65">&#9670;&nbsp;</a></span>get_body_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdrake_1_1multibody_1_1_body_node_topology.html">BodyNodeTopology</a>&amp; get_body_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a29cdcf85f1a6abd167e7517b4a264ef1">BodyNodeIndex</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the corresponding <a class="el" href="structdrake_1_1multibody_1_1_body_node_topology.html" title="Data structure to store the topological information associated with a tree node. ">BodyNodeTopology</a> given a BodyNodeIndex. </p>

</div>
</div>
<a id="a7f9b204ff6368b7085ae78caf2fd1f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9b204ff6368b7085ae78caf2fd1f54">&#9670;&nbsp;</a></span>get_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdrake_1_1multibody_1_1_frame_topology.html">FrameTopology</a>&amp; get_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the corresponding <a class="el" href="structdrake_1_1multibody_1_1_frame_topology.html" title="Data structure to store the topological information associated with a Frame. ">FrameTopology</a> given the FrameIndex. </p>

</div>
</div>
<a id="ae7e2584cc06f289df64efcf3c9a1703c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e2584cc06f289df64efcf3c9a1703c">&#9670;&nbsp;</a></span>get_joint_actuator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdrake_1_1multibody_1_1_joint_actuator_topology.html">JointActuatorTopology</a>&amp; get_joint_actuator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the corresponding <a class="el" href="structdrake_1_1multibody_1_1_joint_actuator_topology.html" title="Data structure to store the topological information associated with a JointActuator. ">JointActuatorTopology</a> given a JointActuatorIndex. </p>

</div>
</div>
<a id="ab612b438482a71fb20f09df2c80d0a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab612b438482a71fb20f09df2c80d0a96">&#9670;&nbsp;</a></span>get_mobilizer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdrake_1_1multibody_1_1_mobilizer_topology.html">MobilizerTopology</a>&amp; get_mobilizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a5296da869e93358c7ea8fd7e15a8757c">MobilizerIndex</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the corresponding <a class="el" href="structdrake_1_1multibody_1_1_body_topology.html" title="Data structure to store the topological information associated with a Body. ">BodyTopology</a> given a BodyIndex. </p>

</div>
</div>
<a id="a0344635beed93d968ec7bd4fa97d06ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0344635beed93d968ec7bd4fa97d06ca">&#9670;&nbsp;</a></span>get_num_body_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> get_num_body_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of tree nodes. This must equal the number of bodies. </p>

</div>
</div>
<a id="a5d587fe12a77f802d3827b59b85e3f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d587fe12a77f802d3827b59b85e3f8d">&#9670;&nbsp;</a></span>GetKinematicPathToWorld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetKinematicPathToWorld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a29cdcf85f1a6abd167e7517b4a264ef1">BodyNodeIndex</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#a29cdcf85f1a6abd167e7517b4a264ef1">BodyNodeIndex</a> &gt; *&#160;</td>
          <td class="paramname"><em>path_to_world</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a node in <code>this</code> topology, specified by its BodyNodeIndex <code>from</code>, this method computes the kinematic path formed by all the nodes in the tree that connect <code>from</code> with the root (corresponding to the world). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>A node in the tree topology to which the path to the root (world) is to be computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">path_to_world</td><td>A std::vector of body node indexes that on output will contain the path to the root of the tree. Forward iteration (from element 0 to element <a class="el" href="lcm__image__array__to__images_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size()</a>-1) of <code>path_to_world</code> will traverse all nodes in the tree starting at the root along the path to <code>from</code>. That is, forward iteration starts with the root of the tree at <code>path_to_world[0]</code> and ends with <code>from</code> at <code>path_to_world.back()</code>. On input, <code>path_to_world</code> must be a valid pointer. On output this vector will be resized, only if needed, to store as many elements as the level (<a class="el" href="structdrake_1_1multibody_1_1_body_node_topology.html#acf4d33ee4cff36f69b924471174dcb11" title="Depth level in the MultibodyTree, level = 0 for the world. ">BodyNodeTopology::level</a>) of body node <code>from</code> plus one (so that we can include the root node in the path). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ca0e76fa665125f1e50bd1ed8dbd213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca0e76fa665125f1e50bd1ed8dbd213">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called by MultibodyTree::Finalize() after all topological elements in the tree (c...">Finalize()</a> was already called on <code>this</code> topology. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called by MultibodyTree::Finalize() after all topological elements in the tree (c...">Finalize()</a> </dd></dl>

</div>
</div>
<a id="ad30d75bef808b82a12b1ac5d9e22ef87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30d75bef808b82a12b1ac5d9e22ef87">&#9670;&nbsp;</a></span>IsBodyAnchored()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IsBodyAnchored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the body with index <code>body_index</code> is anchored to the world. </p>
<p>A body is said to be "anchored" if its kinematics path to the world only contains weld mobilizers. The complexity of this operation is O(depth), where "depth" refers to the depth in the tree of the body node associated with <code>body_index</code>. </p>

</div>
</div>
<a id="ae3fc8de8de8eaf2d37a24c79d6be8e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fc8de8de8eaf2d37a24c79d6be8e97">&#9670;&nbsp;</a></span>num_actuated_dofs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_actuated_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of actuated joint dofs in the model. </p>

</div>
</div>
<a id="af92b53211e54243aff4490a700168eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92b53211e54243aff4490a700168eb4">&#9670;&nbsp;</a></span>num_bodies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_bodies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bodies in the multibody tree. </p>
<p>This includes the "world" body and therefore the minimum number of bodies after <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">MultibodyTree::Finalize()</a> will always be one, not zero. </p>

</div>
</div>
<a id="a6b7f0267d163693025fa04f78bb18333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7f0267d163693025fa04f78bb18333">&#9670;&nbsp;</a></span>num_force_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_force_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of force elements in the topology. </p>

</div>
</div>
<a id="ada7f02e861a8f89fc0b575b2f30333d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7f02e861a8f89fc0b575b2f30333d3">&#9670;&nbsp;</a></span>num_frames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_frames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of physical frames in the multibody tree. </p>

</div>
</div>
<a id="a0ea2bac24332c67eb657bdca27eb864e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea2bac24332c67eb657bdca27eb864e">&#9670;&nbsp;</a></span>num_joint_actuators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_joint_actuators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of joint actuators in the topology. </p>

</div>
</div>
<a id="ad4534e419e421208e87433f3e7243752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4534e419e421208e87433f3e7243752">&#9670;&nbsp;</a></span>num_mobilizers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_mobilizers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of mobilizers in the multibody tree. </p>
<p>Since the "world" body does not have a mobilizer, the number of mobilizers will always equal the number of bodies minus one. </p>

</div>
</div>
<a id="aba2887f0ca1fbbdfb49cf6b0ee21e553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">&#9670;&nbsp;</a></span>num_positions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_positions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of generalized positions in the model. </p>

</div>
</div>
<a id="a3cbd3e24f7648ab7712c803ca8a63f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cbd3e24f7648ab7712c803ca8a63f3e">&#9670;&nbsp;</a></span>num_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_states </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total size of the state vector in the model. </p>

</div>
</div>
<a id="ae0163ac0976659d811e3337647ff0313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0163ac0976659d811e3337647ff0313">&#9670;&nbsp;</a></span>num_velocities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_velocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of generalized velocities in the model. </p>

</div>
</div>
<a id="ab2c16e7ae475654c0559a454ab0caea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c16e7ae475654c0559a454ab0caea2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cc48151d829ada9e37d95c25ea993a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc48151d829ada9e37d95c25ea993a8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade9b54b723ec2a4856c36e0d74322353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9b54b723ec2a4856c36e0d74322353">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if all members of <code>this</code> topology are exactly equal to the members of <code>other</code>. </p>

</div>
</div>
<a id="a7cf904af9e2715a5a2db668d207173c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf904af9e2715a5a2db668d207173c8">&#9670;&nbsp;</a></span>tree_height()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> tree_height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of tree levels in the topology. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/tree/<a class="el" href="multibody__tree__topology_8h.html">multibody_tree_topology.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_topology.html">MultibodyTreeTopology</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
