<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: ConstraintSolver&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConstraintSolver&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Solves constraint problems for constraint forces.  
 <a href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#details">More...</a></p>

<p><code>#include &lt;drake/multibody/constraint/constraint_solver.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_solver_1_1_mlcp_to_lcp_data.html">MlcpToLcpData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to convert a mixed linear complementarity problem to a pure linear complementarity problem (by solving for free variables).  <a href="structdrake_1_1multibody_1_1constraint_1_1_constraint_solver_1_1_mlcp_to_lcp_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acbec3c4a62fd0a5e2e73661b798c592f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#acbec3c4a62fd0a5e2e73661b798c592f">ConstraintSolver</a> ()=default</td></tr>
<tr class="separator:acbec3c4a62fd0a5e2e73661b798c592f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b251619a272379f3ae9fe69a013900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#aa8b251619a272379f3ae9fe69a013900">SolveConstraintProblem</a> (const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html">ConstraintAccelProblemData</a>&lt; T &gt; &amp;problem_data, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *cf) const</td></tr>
<tr class="memdesc:aa8b251619a272379f3ae9fe69a013900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the appropriate constraint problem at the acceleration level.  <a href="#aa8b251619a272379f3ae9fe69a013900">More...</a><br /></td></tr>
<tr class="separator:aa8b251619a272379f3ae9fe69a013900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a85084244787bd75e958fe3b9e0d2f1a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a85084244787bd75e958fe3b9e0d2f1a5">ConstraintSolver</a> (const <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a> &amp;)=delete</td></tr>
<tr class="separator:a85084244787bd75e958fe3b9e0d2f1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9286ebdfce97073939e2662ad8f20b97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a9286ebdfce97073939e2662ad8f20b97">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a> &amp;)=delete</td></tr>
<tr class="separator:a9286ebdfce97073939e2662ad8f20b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ed733e31417b47c349b97c856bfba3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a73ed733e31417b47c349b97c856bfba3">ConstraintSolver</a> (<a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a73ed733e31417b47c349b97c856bfba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176c6c58212547ca575752691d1bc5b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a176c6c58212547ca575752691d1bc5b1">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a176c6c58212547ca575752691d1bc5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af9282b3e4653a8f4ee1bea3fa8f630f0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#af9282b3e4653a8f4ee1bea3fa8f630f0">ComputeGeneralizedForceFromConstraintForces</a> (const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html">ConstraintAccelProblemData</a>&lt; T &gt; &amp;problem_data, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;cf, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *generalized_force)</td></tr>
<tr class="memdesc:af9282b3e4653a8f4ee1bea3fa8f630f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the generalized force on the system from the constraint forces given in packed storage.  <a href="#af9282b3e4653a8f4ee1bea3fa8f630f0">More...</a><br /></td></tr>
<tr class="separator:af9282b3e4653a8f4ee1bea3fa8f630f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6797b9431da1151cf103a0860107c4c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ad6797b9431da1151cf103a0860107c4c">ComputeGeneralizedForceFromConstraintForces</a> (const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;problem_data, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;cf, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *generalized_force)</td></tr>
<tr class="memdesc:ad6797b9431da1151cf103a0860107c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the generalized force on the system from the constraint forces given in packed storage.  <a href="#ad6797b9431da1151cf103a0860107c4c">More...</a><br /></td></tr>
<tr class="separator:ad6797b9431da1151cf103a0860107c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7295303ef0fca0c5f1e52c374cebb9d0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a7295303ef0fca0c5f1e52c374cebb9d0">ComputeGeneralizedAcceleration</a> (const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html">ConstraintAccelProblemData</a>&lt; T &gt; &amp;problem_data, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;cf, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *generalized_acceleration)</td></tr>
<tr class="memdesc:a7295303ef0fca0c5f1e52c374cebb9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the system generalized acceleration due to both external forces and constraint forces.  <a href="#a7295303ef0fca0c5f1e52c374cebb9d0">More...</a><br /></td></tr>
<tr class="separator:a7295303ef0fca0c5f1e52c374cebb9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5dd274ca8dd26487628144ed12c3ed5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ac5dd274ca8dd26487628144ed12c3ed5">ComputeGeneralizedAcceleration</a> (const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;problem_data, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;v, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;cf, <a class="el" href="classdouble.html">double</a> dt, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *generalized_acceleration)</td></tr>
<tr class="memdesc:ac5dd274ca8dd26487628144ed12c3ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a first-order approximation of generalized acceleration due <em>only</em> to constraint forces.  <a href="#ac5dd274ca8dd26487628144ed12c3ed5">More...</a><br /></td></tr>
<tr class="separator:ac5dd274ca8dd26487628144ed12c3ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51621613160f28980982bdb554a1ebc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ad51621613160f28980982bdb554a1ebc">ComputeGeneralizedAccelerationFromConstraintForces</a> (const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html">ConstraintAccelProblemData</a>&lt; T &gt; &amp;problem_data, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;cf, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *generalized_acceleration)</td></tr>
<tr class="memdesc:ad51621613160f28980982bdb554a1ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the system generalized acceleration due <em>only</em> to constraint forces.  <a href="#ad51621613160f28980982bdb554a1ebc">More...</a><br /></td></tr>
<tr class="separator:ad51621613160f28980982bdb554a1ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61817ddd8c8c51eaa8c96893e696eeaf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a61817ddd8c8c51eaa8c96893e696eeaf">ComputeGeneralizedAccelerationFromConstraintForces</a> (const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;problem_data, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;cf, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *generalized_acceleration)</td></tr>
<tr class="memdesc:a61817ddd8c8c51eaa8c96893e696eeaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the system generalized acceleration due <em>only</em> to constraint forces.  <a href="#a61817ddd8c8c51eaa8c96893e696eeaf">More...</a><br /></td></tr>
<tr class="separator:a61817ddd8c8c51eaa8c96893e696eeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b61262e32fed7e36b0bd52d5857c14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a76b61262e32fed7e36b0bd52d5857c14">ComputeGeneralizedVelocityChange</a> (const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;problem_data, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;cf, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *generalized_delta_v)</td></tr>
<tr class="memdesc:a76b61262e32fed7e36b0bd52d5857c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the change to the system generalized velocity from constraint impulses.  <a href="#a76b61262e32fed7e36b0bd52d5857c14">More...</a><br /></td></tr>
<tr class="separator:a76b61262e32fed7e36b0bd52d5857c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed17652ed0aaed188638503a891b287"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a4ed17652ed0aaed188638503a891b287">CalcContactForcesInContactFrames</a> (const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;cf, const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html">ConstraintAccelProblemData</a>&lt; T &gt; &amp;problem_data, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; T &gt;&gt; &amp;contact_frames, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a>&lt; T &gt;&gt; *contact_forces)</td></tr>
<tr class="memdesc:a4ed17652ed0aaed188638503a891b287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the contact forces expressed in each contact frame <em>for 2D contact problems</em> from the "packed" solution returned by <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#aa8b251619a272379f3ae9fe69a013900" title="Solves the appropriate constraint problem at the acceleration level. ">SolveConstraintProblem()</a>.  <a href="#a4ed17652ed0aaed188638503a891b287">More...</a><br /></td></tr>
<tr class="separator:a4ed17652ed0aaed188638503a891b287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183e4d3b692beca68dda08e2c21d798b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a183e4d3b692beca68dda08e2c21d798b">CalcContactForcesInContactFrames</a> (const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;cf, const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;problem_data, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; T &gt;&gt; &amp;contact_frames, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a>&lt; T &gt;&gt; *contact_forces)</td></tr>
<tr class="memdesc:a183e4d3b692beca68dda08e2c21d798b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the contact forces expressed in each contact frame <em>for 2D contact problems</em> from a "packed" solution returned by, e.g., <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ab43d865b128c33404e5880ea6736ff16" title="Solves the impact problem described above. ">SolveImpactProblem()</a>.  <a href="#a183e4d3b692beca68dda08e2c21d798b">More...</a><br /></td></tr>
<tr class="separator:a183e4d3b692beca68dda08e2c21d798b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Velocity-level constraint problems formulated as MLCPs.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd4d41a74a6b0f584bf104c0b6d7fd48c"></a><a class="anchor" id="Velocity-level-MLCPs"></a>Constraint problems can be posed as mixed linear complementarity problems (MLCP), which are problems that take the form:</p><pre>
(a)    Au + X₁y + a = 0
(b)  X₂u + X₃y + x₄ ≥ 0
(c)               y ≥ 0
(d) vᵀ(x₄ + X₂u + X₃y) = 0
</pre><p> where <code>u</code> are "free" variables, <code>y</code> are constrained variables, <code>A</code>, <code>X₁</code>, <code>X₂</code>, and <code>X₃</code> are given matrices (we label only the most important variables without subscripts to make them stand out) and <code>a</code> and <code>x₄</code> are given vectors. If <code>A</code> is nonsingular, <code>u</code> can be solved for:</p><pre>
(e) u = -A⁻¹ (a + X₁y)
</pre><p> allowing the mixed LCP to be converted to a "pure" LCP <code>(qq, MM)</code> by:</p><pre>
(f) qq = x₄ - X₂A⁻¹a
(g) MM = X₃ - X₂A⁻¹X₁
</pre><p> This pure LCP can then be solved for <code>y</code> such that:</p><pre>
(h)     MMv + qq ≥ 0
(i)            y ≥ 0
(j) yᵀ(MMv + qq) = 0
</pre><p> and this value for <code>y</code> can be substituted into (e) to obtain the value for <code>u</code>.</p>
<h3>An MLCP-based impact model:</h3>
<p>Consider the following problem formulation of a multibody dynamics impact model (taken from [Anitescu 1997]). In a simulator, one could use this model when a collision is detected in order to compute an instantaneous change in velocity. </p><pre>
(1) | M  -Gᵀ  -Nᵀ  -Dᵀ  0  -Lᵀ | | v⁺ | + |-Mv⁻ | = | 0  |
    | G   0    0    0   0   0  | | fG | + |  kᴳ | = | 0  |
    | N   0    0    0   0   0  | | fN | + |  kᴺ | = | x₅ |
    | D   0    0    0   E   0  | | fD | + |  kᴰ | = | x₆ |
    | 0   0    μ   -Eᵀ  0   0  | |  λ | + |   0 | = | x₇ |
    | L   0    0    0   0   0  | | fL | + |  kᴸ | = | x₈ |
(2) 0 ≤ fN  ⊥  x₅ ≥ 0
(3) 0 ≤ fD  ⊥  x₆ ≥ 0
(4) 0 ≤ λ   ⊥  x₇ ≥ 0
(5) 0 ≤ fL  ⊥  x₈ ≥ 0
</pre><p> Here, the velocity variables v⁻ ∈ ℝⁿᵛ, v ∈ ℝⁿᵛ⁺ correspond to the velocity of the system before and after impulses are applied, respectively. More details will be forthcoming but key variables are <code>M ∈ ℝⁿᵛˣⁿᵛ</code>, the generalized inertia matrix; <code>G ∈ ℝⁿᵇˣⁿᵛ</code>, <code>N ∈ ℝⁿᶜˣⁿᵛ</code>, <code>D ∈ ℝⁿᶜᵏˣⁿᵛ</code>, and <code>L ∈ ℝⁿᵘˣⁿᵛ</code> correspond to Jacobian matrices for various constraints (joints, contact, friction, generic unilateral constraints, respectively); <code>μ ∈ ℝⁿᶜˣⁿᶜ</code> is a diagonal matrix comprised of Coulomb friction coefficients; <code>E ∈ ℝⁿᶜᵏˣⁿᶜ</code> is a binary matrix used to linearize the friction cone (necessary to make this into a <em>linear</em> complementarity problem); <code>fG ∈ ℝⁿᵇ</code>, <code>fN ∈ ℝⁿᶜ</code>, <code>fD ∈ ℝⁿᶜᵏ</code>, and <code>fL ∈ ℝⁿᵘ</code> are constraint impulses; <code>λ ∈ ℝⁿᶜ</code>, <code>x₅</code>, <code>x₆</code>, <code>x₇</code>, and <code>x₈</code> can be viewed as mathematical programming "slack" variables; and <code>kᴳ ∈ ℝⁿᵇ</code>, <code>kᴺ ∈ ℝⁿᶜ</code>, <code>kᴰ ∈ ℝⁿᶜᵏ</code>, <code>kᴸ ∈ ℝⁿᵘ</code> allow customizing the problem to, e.g., correct constraint violations and simulate restitution. See <a class="el" href="group__constraint__variable__defs.html">Variable definitions</a> for complete definitions of <code>nv</code>, <code>nc</code>, <code>nb</code>, etc.</p>
<p>From the notation above in Equations (a)-(d), we can convert the MLCP to a "pure" linear complementarity problem (LCP), which is easier to solve, at least for active-set-type mathematical programming approaches:</p><pre>
 A ≡ | M  -Ĝᵀ|   a ≡ |-Mv⁻ |   X₁ ≡ |-Nᵀ  -Dᵀ  0  -Lᵀ |
     | Ĝ   0 |       |  kᴳ |        | 0    0   0   0  |</pre><pre>X₂ ≡ | N   0 |   b ≡ |  kᴺ |   X₃ ≡ | 0    0   0   0  |
     | D   0 |       |  kᴰ |        | 0    0   E   0  |
     | 0   0 |       |  0  |        | μ   -Eᵀ  0   0  |
     | L   0 |       |  kᴸ |        | 0    0   0   0  |</pre><pre> u ≡ | v⁺ |      y ≡ | fN  |
     | fG |          | fD  |
                     |  λ  |
                     | fL  |
</pre><p> Where applicable, <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html" title="Solves constraint problems for constraint forces. ">ConstraintSolver</a> computes solutions to linear equations with rank-deficient <code>A</code> (e.g., <code>AX₅ = x₆</code>) using a least squares approach (the complete orthogonal factorization). Now, using Equations (f) and (g) and defining <code>C</code> as the nv × nv-dimensional upper left block of <code>A⁻¹</code> (<code>nv</code> is the dimension of the generalized velocities) the pure LCP <code>(qq,MM)</code> is defined as:</p><pre>
MM ≡ | NCNᵀ  NCDᵀ   0   NCLᵀ |
     | DCNᵀ  DCDᵀ   E   DCLᵀ |
     | μ      -Eᵀ   0   0    |
     | LCNᵀ  LCDᵀ   0   LCLᵀ |</pre><pre>qq ≡ | kᴺ - |N 0ⁿᵛ⁺ⁿᵇ|A⁻¹a |
     | kᴰ - |D 0ⁿᵛ⁺ⁿᵇ|A⁻¹a |
     |       0             |
     | kᴸ - |L 0ⁿᵛ⁺ⁿᵇ|A⁻¹a |
</pre><p> where <code>nb</code> is the number of bilateral constraint equations. The solution <code>y</code> will then take the form:</p><pre>
y ≡ | fN |
    | fD |
    | λ  |
    | fL |
</pre><p> The key variables for using the MLCP-based formulations are the matrix <code>A</code> and vector <code>a</code>, as seen in documentation of <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_solver_1_1_mlcp_to_lcp_data.html" title="Structure used to convert a mixed linear complementarity problem to a pure linear complementarity pro...">MlcpToLcpData</a> and the following methods. During its operation, <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ad6927b208cf73c0b0fad40c64bcd77e9" title="Computes the base time-discretization of the system using the problem data, resulting in the MM and q...">ConstructBaseDiscretizedTimeLcp()</a> constructs (and returns) functions for solving <code>AX=B</code>, where <code>B</code> is a given matrix and <code>X</code> is an unknown matrix. <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#acb75f1755aa6a56c9be6eb004f8d5b02" title="Updates the time-discretization of the LCP initially computed in ConstructBaseDiscretizedTimeLcp() us...">UpdateDiscretizedTimeLcp()</a> computes and returns <code>a</code> during its operation.</p>
<h3>Another use of the MLCP formulation (discretized multi-body dynamics with contact and friction):</h3>
<p>Without reconstructing the entire MLCP, we now show a very similar formulation to solve the problem of discretizing the multi-body dynamics equations with contact and friction. This particular formulation provides several nice features: 1) the formulation is semi-implicit and models compliant contact efficiently, including both sticking contact and contact between very stiff surfaces; 2) all constraint forces are computed in Newtons (typical "time stepping
methods" require considerable care to correctly compare constraint forces, which are impulsive, and non-constraint forces, which are non-impulsive); and 3) can be made almost symplectic by choosing a representation and computational coordinate frame that minimize velocity-dependent forces (thereby explaining the extreme stability of software like ODE and Bullet that computes dynamics in body frames (minimizing the magnitudes of velocity-dependent forces) and provides the ability to disable gyroscopic forces.</p>
<p>The discretization problem replaces the meaning of v⁻ and v⁺ in the MLCP to mean the generalized velocity at time t and the generalized velocity at time t+h, respectively, for discretization quantum h (or, equivalently, integration step size h). The LCP is adjusted to the form:</p><pre>
MM ≡ | hNCNᵀ+γᴺ  hNCDᵀ   0   hNCLᵀ    |
     | hDCNᵀ     hDCDᵀ   E   hDCLᵀ    |
     | μ         -Eᵀ     0   0        |
     | hLCNᵀ     hLCDᵀ   0   hLCLᵀ+γᴸ |</pre><pre>qq ≡ | kᴺ - |N 0ⁿᵛ⁺ⁿᵇ|A⁻¹a |
     | kᴰ - |D 0ⁿᵛ⁺ⁿᵇ|A⁻¹a |
     |       0             |
     | kᴸ - |L 0ⁿᵛ⁺ⁿᵇ|A⁻¹a |</pre><p> where <code>γᴺ</code>, <code>γᴸ</code>, <code>kᴺ</code>, <code>kᴸ</code>, and <code>a</code> are all functions of <code>h</code>; documentation that describes how to update these (and dependent) problem data to attain desired constraint stiffness and dissipation is forthcoming.</p>
<p>The procedure one uses to formulate and solve this discretization problem is:</p><ol type="1">
<li>Call <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ad6927b208cf73c0b0fad40c64bcd77e9" title="Computes the base time-discretization of the system using the problem data, resulting in the MM and q...">ConstructBaseDiscretizedTimeLcp()</a></li>
<li>Select an integration step size, dt</li>
<li>Compute `kᴺ' and <code>kᴸ</code> in the problem data, accounting for dt as necessary</li>
<li>Call <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#acb75f1755aa6a56c9be6eb004f8d5b02" title="Updates the time-discretization of the LCP initially computed in ConstructBaseDiscretizedTimeLcp() us...">UpdateDiscretizedTimeLcp()</a>, obtaining MM and qq that encode the linear complementarity problem</li>
<li>Solve the linear complementarity problem</li>
<li>If LCP solved, quit.</li>
<li>Reduce dt and repeat the process from 3. until success.</li>
</ol>
<p>The solution to the LCP can be used to obtain the constraint forces via <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a10078a950716e9baa641e7b11b30a0b7" title="Populates the packed constraint force vector from the solution to the linear complementarity problem ...">PopulatePackedConstraintForcesFromLcpSolution()</a>.</p>
<h3>Obtaining the generalized constraint forces:</h3>
<p>Given the constraint forces, which have been obtained either through <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ab43d865b128c33404e5880ea6736ff16" title="Solves the impact problem described above. ">SolveImpactProblem()</a> (in which case the forces are impulsive) or through direct solution of the LCP corresponding to the discretized multibody dynamics problem, followed by <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a10078a950716e9baa641e7b11b30a0b7" title="Populates the packed constraint force vector from the solution to the linear complementarity problem ...">PopulatePackedConstraintForcesFromLcpSolution()</a> (in which cases the forces are non-impulsive), the generalized forces/impulses due to the constraints can then be acquired via <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#af9282b3e4653a8f4ee1bea3fa8f630f0" title="Computes the generalized force on the system from the constraint forces given in packed storage...">ComputeGeneralizedForceFromConstraintForces()</a>. </p>
</td></tr>
<tr class="memitem:ab43d865b128c33404e5880ea6736ff16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ab43d865b128c33404e5880ea6736ff16">SolveImpactProblem</a> (const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;problem_data, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *cf) const</td></tr>
<tr class="memdesc:ab43d865b128c33404e5880ea6736ff16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the impact problem described above.  <a href="#ab43d865b128c33404e5880ea6736ff16">More...</a><br /></td></tr>
<tr class="separator:ab43d865b128c33404e5880ea6736ff16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6927b208cf73c0b0fad40c64bcd77e9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ad6927b208cf73c0b0fad40c64bcd77e9">ConstructBaseDiscretizedTimeLcp</a> (const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;problem_data, <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_solver_1_1_mlcp_to_lcp_data.html">MlcpToLcpData</a> *mlcp_to_lcp_data, <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; *MM, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *qq)</td></tr>
<tr class="memdesc:ad6927b208cf73c0b0fad40c64bcd77e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the base time-discretization of the system using the problem data, resulting in the <code>MM</code> and <code>qq</code> described in velocity-level-MLCPs; if <code>MM</code> and <code>qq</code> are modified no further, the LCP corresponds to an impact problem (i.e., the multibody dynamics problem would not be discretized).  <a href="#ad6927b208cf73c0b0fad40c64bcd77e9">More...</a><br /></td></tr>
<tr class="separator:ad6927b208cf73c0b0fad40c64bcd77e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb75f1755aa6a56c9be6eb004f8d5b02"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#acb75f1755aa6a56c9be6eb004f8d5b02">UpdateDiscretizedTimeLcp</a> (const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;problem_data, <a class="el" href="classdouble.html">double</a> h, <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_solver_1_1_mlcp_to_lcp_data.html">MlcpToLcpData</a> *mlcp_to_lcp_data, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *a, <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; *MM, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *qq)</td></tr>
<tr class="memdesc:acb75f1755aa6a56c9be6eb004f8d5b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the time-discretization of the LCP initially computed in <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ad6927b208cf73c0b0fad40c64bcd77e9" title="Computes the base time-discretization of the system using the problem data, resulting in the MM and q...">ConstructBaseDiscretizedTimeLcp()</a> using the problem data and time step <code>h</code>.  <a href="#acb75f1755aa6a56c9be6eb004f8d5b02">More...</a><br /></td></tr>
<tr class="separator:acb75f1755aa6a56c9be6eb004f8d5b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10078a950716e9baa641e7b11b30a0b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a10078a950716e9baa641e7b11b30a0b7">PopulatePackedConstraintForcesFromLcpSolution</a> (const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;problem_data, const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_solver_1_1_mlcp_to_lcp_data.html">MlcpToLcpData</a> &amp;mlcp_to_lcp_data, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;zz, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;a, <a class="el" href="classdouble.html">double</a> dt, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *cf)</td></tr>
<tr class="memdesc:a10078a950716e9baa641e7b11b30a0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the packed constraint force vector from the solution to the linear complementarity problem (LCP) constructed using <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ad6927b208cf73c0b0fad40c64bcd77e9" title="Computes the base time-discretization of the system using the problem data, resulting in the MM and q...">ConstructBaseDiscretizedTimeLcp()</a> and <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#acb75f1755aa6a56c9be6eb004f8d5b02" title="Updates the time-discretization of the LCP initially computed in ConstructBaseDiscretizedTimeLcp() us...">UpdateDiscretizedTimeLcp()</a>.  <a href="#a10078a950716e9baa641e7b11b30a0b7">More...</a><br /></td></tr>
<tr class="separator:a10078a950716e9baa641e7b11b30a0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::constraint::ConstraintSolver&lt; T &gt;</h3>

<p>Solves constraint problems for constraint forces. </p>
<p>Specifically, given problem data corresponding to a rigid or multi-body system constrained bilaterally and/or unilaterally and acted upon by friction, this class computes the constraint forces.</p>
<p>This problem can be formulated as a mixed linear complementarity problem (MLCP)- for 2D problems with Coulomb friction or 3D problems without Coulomb friction- or a mixed complementarity problem (for 3D problems with Coulomb friction). We use a polygonal approximation (of selectable accuracy) to the friction cone, which yields a MLCP in all cases.</p>
<p>Existing algorithms for solving MLCPs, which are based upon algorithms for solving "pure" linear complementarity problems (LCPs), solve smaller classes of problems than the corresponding LCP versions. For example, Lemke's Algorithm, which is provably able to solve the impacting problems covered by this class, can solve LCPs with copositive matrices [Cottle 1992] but MLCPs with only positive semi-definite matrices (the latter is a strict subset of the former) [Sargent 1978].</p>
<p>Rather than using one of these MLCP algorithms, we instead transform the problem into a pure LCP by first solving for the bilateral constraint forces. This method yields an implication of which the user should be aware. Bilateral constraint forces are computed before unilateral constraint forces: the constraint forces will not be evenly distributed between bilateral and unilateral constraints (assuming such a distribution were even possible).</p>
<p>For the normal case of unilateral constraints admitting degrees of freedom, the solution methods in this class support "softening" of the constraints, as described in [Lacoursiere 2007] via the constraint force mixing (CFM) and error reduction parameter (ERP) parameters that are now ubiquitous in game multi-body dynamics simulation libraries.</p>
<ul>
<li>[Cottle 1992] R. W. Cottle, J.-S. Pang, and R. E. Stone. The Linear Complementarity Problem. SIAM Classics in Applied Mathematics, 1992.</li>
<li>[Judice 1992] J. J. Judice, J. Machado, and A. Faustino. An extension of the Lemke's method for the solution of a generalized linear complementarity problem. In System Modeling and Optimization (Lecture Notes in Control and Information Sciences), Springer-Verlag, 1992.</li>
<li>[Lacoursiere 2007] C. Lacoursiere. Ghosts and Machines: Regularized Variational Methods for Interactive Simulations of Multibodies with Dry Frictional Contacts. Ph. D. thesis (Umea University), 2007.</li>
<li>[Sargent 1978] R. W. H. Sargent. An efficient implementation of the Lemke Algorithm and its extension to deal with upper and lower bounds. Mathematical Programming Study, 7, 1978.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The vector element type, which must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar.</td></tr>
  </table>
  </dd>
</dl>
<p>Instantiated templates for the following scalar types <code>T</code> are provided:</p>
<ul>
<li>double</li>
</ul>
<p>They are already available to link against in the containing library. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acbec3c4a62fd0a5e2e73661b798c592f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbec3c4a62fd0a5e2e73661b798c592f">&#9670;&nbsp;</a></span>ConstraintSolver() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85084244787bd75e958fe3b9e0d2f1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85084244787bd75e958fe3b9e0d2f1a5">&#9670;&nbsp;</a></span>ConstraintSolver() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73ed733e31417b47c349b97c856bfba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ed733e31417b47c349b97c856bfba3">&#9670;&nbsp;</a></span>ConstraintSolver() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4ed17652ed0aaed188638503a891b287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed17652ed0aaed188638503a891b287">&#9670;&nbsp;</a></span>CalcContactForcesInContactFrames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcContactForcesInContactFrames </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html">ConstraintAccelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>contact_frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a>&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>contact_forces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the contact forces expressed in each contact frame <em>for 2D contact problems</em> from the "packed" solution returned by <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#aa8b251619a272379f3ae9fe69a013900" title="Solves the appropriate constraint problem at the acceleration level. ">SolveConstraintProblem()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cf</td><td>the output from <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#aa8b251619a272379f3ae9fe69a013900" title="Solves the appropriate constraint problem at the acceleration level. ">SolveConstraintProblem()</a> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">problem_data</td><td>the problem data input to <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#aa8b251619a272379f3ae9fe69a013900" title="Solves the appropriate constraint problem at the acceleration level. ">SolveConstraintProblem()</a> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">contact_frames</td><td>the contact frames corresponding to the contacts. The first column of each matrix should give the contact normal, while the second column gives a contact tangent. For sliding contacts, the contact tangent should point along the direction of sliding. For non-sliding contacts, the tangent direction should be that used to determine <code>problem_data.F</code>. All vectors should be expressed in the global frame. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">contact_forces</td><td>a non-null vector of a doublet of values, where the iᵗʰ element represents the force along each basis vector in the iᵗʰ contact frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>contact_forces</code> is null, if <code>contact_forces</code> is not empty, if <code>cf</code> is not the proper size, if the number of tangent directions is not one per non-sliding contact (indicating that the contact problem might not be 2D), if the number of contact frames is not equal to the number of contacts, or if a contact frame does not appear to be orthonormal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On return, the contact force at the iᵗʰ contact point expressed in the world frame is <code>contact_frames[i]</code> * <code>contact_forces[i]</code>. </dd></dl>

</div>
</div>
<a id="a183e4d3b692beca68dda08e2c21d798b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183e4d3b692beca68dda08e2c21d798b">&#9670;&nbsp;</a></span>CalcContactForcesInContactFrames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcContactForcesInContactFrames </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>contact_frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a>&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>contact_forces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the contact forces expressed in each contact frame <em>for 2D contact problems</em> from a "packed" solution returned by, e.g., <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ab43d865b128c33404e5880ea6736ff16" title="Solves the impact problem described above. ">SolveImpactProblem()</a>. </p>
<p>If the constraint forces are impulsive, the contact forces are impulsive (with units of Ns); similarly, if the constraint forces are non-impulsive, the contact forces will be non-impulsive (with units of N). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cf</td><td>the constraint forces in packed format. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">problem_data</td><td>the problem data input to <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ab43d865b128c33404e5880ea6736ff16" title="Solves the impact problem described above. ">SolveImpactProblem()</a> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">contact_frames</td><td>the contact frames corresponding to the contacts. The first column of each matrix should give the contact normal, while the second column gives a contact tangent (specifically, the tangent direction used to determine <code>problem_data.F</code>). All vectors should be expressed in the global frame. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">contact_forces</td><td>a non-null vector of a doublet of values, where the iᵗʰ element represents the force along each basis vector in the iᵗʰ contact frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>contact_forces</code> is null, if <code>contact_forces</code> is not empty, if <code>cf</code> is not the proper size, if the number of tangent directions is not one per contact (indicating that the contact problem might not be 2D), if the number of contact frames is not equal to the number of contacts, or if a contact frame does not appear to be orthonormal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On return, the contact force at the iᵗʰ contact point expressed in the world frame is <code>contact_frames[i]</code> * <code>contact_forces[i]</code>. </dd></dl>

</div>
</div>
<a id="a7295303ef0fca0c5f1e52c374cebb9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7295303ef0fca0c5f1e52c374cebb9d0">&#9670;&nbsp;</a></span>ComputeGeneralizedAcceleration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ComputeGeneralizedAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html">ConstraintAccelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>generalized_acceleration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the system generalized acceleration due to both external forces and constraint forces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">problem_data</td><td>The acceleration-level constraint data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cf</td><td>The computed constraint forces, in the packed storage format described in documentation for SolveConstraintProblem. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">generalized_acceleration</td><td>The generalized acceleration, on return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>generalized_acceleration</code> is null or <code>cf</code> vector is incorrectly sized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5dd274ca8dd26487628144ed12c3ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5dd274ca8dd26487628144ed12c3ed5">&#9670;&nbsp;</a></span>ComputeGeneralizedAcceleration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ComputeGeneralizedAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>generalized_acceleration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a first-order approximation of generalized acceleration due <em>only</em> to constraint forces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">problem_data</td><td>The velocity-level constraint data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cf</td><td>The computed constraint forces, in the packed storage format described in documentation for SolveConstraintProblem. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>The system generalized velocity at time t. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dt</td><td>The discretization time constant (i.e., the "time step" for simulations) used to take the system's generalized velocities from time t to time t + <code>dt</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">generalized_acceleration</td><td>The generalized acceleration, on return. The original will be resized (if necessary) and overwritten. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This method uses the method <code>problem_data.solve_inertia()</code> in order to compute <code>v(t+dt)</code>, so the computational demands may be significant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>generalized_acceleration</code> is null or <code>cf</code> vector is incorrectly sized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>dt</code> is positive. </dd></dl>

</div>
</div>
<a id="ad51621613160f28980982bdb554a1ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51621613160f28980982bdb554a1ebc">&#9670;&nbsp;</a></span>ComputeGeneralizedAccelerationFromConstraintForces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ComputeGeneralizedAccelerationFromConstraintForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html">ConstraintAccelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>generalized_acceleration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the system generalized acceleration due <em>only</em> to constraint forces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cf</td><td>The computed constraint forces, in the packed storage format described in documentation for SolveConstraintProblem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>generalized_acceleration</code> is null or <code>cf</code> vector is incorrectly sized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61817ddd8c8c51eaa8c96893e696eeaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61817ddd8c8c51eaa8c96893e696eeaf">&#9670;&nbsp;</a></span>ComputeGeneralizedAccelerationFromConstraintForces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ComputeGeneralizedAccelerationFromConstraintForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>generalized_acceleration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the system generalized acceleration due <em>only</em> to constraint forces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cf</td><td>The computed constraint forces, in the packed storage format described in documentation for SolveConstraintProblem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>generalized_acceleration</code> is null or <code>cf</code> vector is incorrectly sized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9282b3e4653a8f4ee1bea3fa8f630f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9282b3e4653a8f4ee1bea3fa8f630f0">&#9670;&nbsp;</a></span>ComputeGeneralizedForceFromConstraintForces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ComputeGeneralizedForceFromConstraintForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html">ConstraintAccelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>generalized_force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the generalized force on the system from the constraint forces given in packed storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">problem_data</td><td>The data used to compute the contact forces. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cf</td><td>The computed constraint forces, in the packed storage format described in documentation for SolveConstraintProblem. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">generalized_force</td><td>The generalized force acting on the system from the total constraint wrench is stored here, on return. This method will resize <code>generalized_force</code> as necessary. The indices of <code>generalized_force</code> will exactly match the indices of <code>problem_data.f</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>generalized_force</code> is null or <code>cf</code> vector is incorrectly sized. </td></tr>
  </table>
  </dd>
</dl>
<p>Get the normal and non-sliding contact forces.</p>
<p>Get the limit forces.</p>
<p>Compute the generalized force. </p>

</div>
</div>
<a id="ad6797b9431da1151cf103a0860107c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6797b9431da1151cf103a0860107c4c">&#9670;&nbsp;</a></span>ComputeGeneralizedForceFromConstraintForces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ComputeGeneralizedForceFromConstraintForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>generalized_force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the generalized force on the system from the constraint forces given in packed storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">problem_data</td><td>The data used to compute the contact forces. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cf</td><td>The computed constraint forces, in the packed storage format described in documentation for <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a10078a950716e9baa641e7b11b30a0b7" title="Populates the packed constraint force vector from the solution to the linear complementarity problem ...">PopulatePackedConstraintForcesFromLcpSolution()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">generalized_force</td><td>The generalized force acting on the system from the total constraint wrench is stored here, on return. This method will resize <code>generalized_force</code> as necessary. The indices of <code>generalized_force</code> will exactly match the indices of <code>problem_data.f</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>generalized_force</code> is null or <code>cf</code> vector is incorrectly sized. </td></tr>
  </table>
  </dd>
</dl>
<p>Get the normal and tangential contact forces.</p>
<p>Get the limit forces.</p>
<p>Compute the generalized forces. </p>

</div>
</div>
<a id="a76b61262e32fed7e36b0bd52d5857c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b61262e32fed7e36b0bd52d5857c14">&#9670;&nbsp;</a></span>ComputeGeneralizedVelocityChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ComputeGeneralizedVelocityChange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>generalized_delta_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the change to the system generalized velocity from constraint impulses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cf</td><td>The computed constraint impulses, in the packed storage format described in documentation for SolveImpactProblem. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>generalized_delta_v</code> is null or <code>cf</code> vector is incorrectly sized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6927b208cf73c0b0fad40c64bcd77e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6927b208cf73c0b0fad40c64bcd77e9">&#9670;&nbsp;</a></span>ConstructBaseDiscretizedTimeLcp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ConstructBaseDiscretizedTimeLcp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_solver_1_1_mlcp_to_lcp_data.html">MlcpToLcpData</a> *&#160;</td>
          <td class="paramname"><em>mlcp_to_lcp_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>MM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>qq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the base time-discretization of the system using the problem data, resulting in the <code>MM</code> and <code>qq</code> described in velocity-level-MLCPs; if <code>MM</code> and <code>qq</code> are modified no further, the LCP corresponds to an impact problem (i.e., the multibody dynamics problem would not be discretized). </p>
<p>The data output (<code>mlcp_to_lcp_data</code>, <code>MM</code>, and <code>qq</code>) can be updated using a particular time step in <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#acb75f1755aa6a56c9be6eb004f8d5b02" title="Updates the time-discretization of the LCP initially computed in ConstructBaseDiscretizedTimeLcp() us...">UpdateDiscretizedTimeLcp()</a>, resulting in a non-impulsive problem formulation. In that case, the multibody dynamics equations <em>are</em> discretized, as described in <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#acb75f1755aa6a56c9be6eb004f8d5b02" title="Updates the time-discretization of the LCP initially computed in ConstructBaseDiscretizedTimeLcp() us...">UpdateDiscretizedTimeLcp()</a>. </p><dl class="section note"><dt>Note</dt><dd>If you really do wish to solve an impact problem, you should use <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ab43d865b128c33404e5880ea6736ff16" title="Solves the impact problem described above. ">SolveImpactProblem()</a> instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">problem_data</td><td>the constraint problem data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mlcp_to_lcp_data</td><td>a pointer to a valid <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_solver_1_1_mlcp_to_lcp_data.html" title="Structure used to convert a mixed linear complementarity problem to a pure linear complementarity pro...">MlcpToLcpData</a> object; the caller must ensure that this pointer remains valid through the constraint solution process. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MM</td><td>a pointer to a matrix that will contain the parts of the LCP matrix not dependent upon the time step on return. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qq</td><td>a pointer to a vector that will contain the parts of the LCP vector not dependent upon the time step on return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>mlcp_to_lcp_data</code>, <code>MM</code>, and <code>qq</code> are non-null on entry. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#acb75f1755aa6a56c9be6eb004f8d5b02" title="Updates the time-discretization of the LCP initially computed in ConstructBaseDiscretizedTimeLcp() us...">UpdateDiscretizedTimeLcp()</a> </dd></dl>

</div>
</div>
<a id="a176c6c58212547ca575752691d1bc5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176c6c58212547ca575752691d1bc5b1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9286ebdfce97073939e2662ad8f20b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9286ebdfce97073939e2662ad8f20b97">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10078a950716e9baa641e7b11b30a0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10078a950716e9baa641e7b11b30a0b7">&#9670;&nbsp;</a></span>PopulatePackedConstraintForcesFromLcpSolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PopulatePackedConstraintForcesFromLcpSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_solver_1_1_mlcp_to_lcp_data.html">MlcpToLcpData</a> &amp;&#160;</td>
          <td class="paramname"><em>mlcp_to_lcp_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>zz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>cf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populates the packed constraint force vector from the solution to the linear complementarity problem (LCP) constructed using <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ad6927b208cf73c0b0fad40c64bcd77e9" title="Computes the base time-discretization of the system using the problem data, resulting in the MM and q...">ConstructBaseDiscretizedTimeLcp()</a> and <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#acb75f1755aa6a56c9be6eb004f8d5b02" title="Updates the time-discretization of the LCP initially computed in ConstructBaseDiscretizedTimeLcp() us...">UpdateDiscretizedTimeLcp()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">problem_data</td><td>the constraint problem data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mlcp_to_lcp_data</td><td>a reference to a <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_solver_1_1_mlcp_to_lcp_data.html" title="Structure used to convert a mixed linear complementarity problem to a pure linear complementarity pro...">MlcpToLcpData</a> object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">zz</td><td>the solution to the LCP resulting from <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#acb75f1755aa6a56c9be6eb004f8d5b02" title="Updates the time-discretization of the LCP initially computed in ConstructBaseDiscretizedTimeLcp() us...">UpdateDiscretizedTimeLcp()</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>the vector <code>a</code> output from <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#acb75f1755aa6a56c9be6eb004f8d5b02" title="Updates the time-discretization of the LCP initially computed in ConstructBaseDiscretizedTimeLcp() us...">UpdateDiscretizedTimeLcp()</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dt</td><td>the time step used to discretize the problem. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cf</td><td>the constraint forces, on return. The first <code>nc</code> elements of <code>cf</code> correspond to the magnitudes of the contact forces applied along the normals of the <code>nc</code> contact points. The next elements of <code>cf</code> correspond to the frictional forces along the <code>r</code> spanning directions at each point of contact. The first <code>r</code> values (after the initial <code>nc</code> elements) correspond to the first contact, the next <code>r</code> values correspond to the second contact, etc. The next <code>ℓ</code> values of <code>cf</code> correspond to the impulsive forces applied to enforce unilateral constraint functions. The final <code>b</code> values of <code>cf</code> correspond to the forces applied to enforce generic bilateral constraints. This packed storage format can be turned into more useful representations through <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#af9282b3e4653a8f4ee1bea3fa8f630f0" title="Computes the generalized force on the system from the constraint forces given in packed storage...">ComputeGeneralizedForceFromConstraintForces()</a> and <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a4ed17652ed0aaed188638503a891b287" title="Gets the contact forces expressed in each contact frame for 2D contact problems from the &quot;packed&quot; sol...">CalcContactForcesInContactFrames()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>cf is non-null. </dd></dl>

</div>
</div>
<a id="aa8b251619a272379f3ae9fe69a013900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b251619a272379f3ae9fe69a013900">&#9670;&nbsp;</a></span>SolveConstraintProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SolveConstraintProblem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html">ConstraintAccelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>cf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the appropriate constraint problem at the acceleration level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">problem_data</td><td>The data used to compute the constraint forces. </td></tr>
    <tr><td class="paramname">cf</td><td>The computed constraint forces, on return, in a packed storage format. The first <code>nc</code> elements of <code>cf</code> correspond to the magnitudes of the contact forces applied along the normals of the <code>nc</code> contact points. The next elements of <code>cf</code> correspond to the frictional forces along the <code>r</code> spanning directions at each non-sliding point of contact. The first <code>r</code> values (after the initial <code>nc</code> elements) correspond to the first non-sliding contact, the next <code>r</code> values correspond to the second non-sliding contact, etc. The next <code>ℓ</code> values of <code>cf</code> correspond to the forces applied to enforce generic unilateral constraints. The final <code>b</code> values of <code>cf</code> correspond to the forces applied to enforce generic bilateral constraints. This packed storage format can be turned into more useful representations through <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#af9282b3e4653a8f4ee1bea3fa8f630f0" title="Computes the generalized force on the system from the constraint forces given in packed storage...">ComputeGeneralizedForceFromConstraintForces()</a> and <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a4ed17652ed0aaed188638503a891b287" title="Gets the contact forces expressed in each contact frame for 2D contact problems from the &quot;packed&quot; sol...">CalcContactForcesInContactFrames()</a>. <code>cf</code> will be resized as necessary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Constraint data has been computed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the constraint forces cannot be computed (due to, e.g., an "inconsistent" rigid contact configuration). </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if <code>cf</code> is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab43d865b128c33404e5880ea6736ff16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43d865b128c33404e5880ea6736ff16">&#9670;&nbsp;</a></span>SolveImpactProblem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SolveImpactProblem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>cf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the impact problem described above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">problem_data</td><td>The data used to compute the impulsive constraint forces. </td></tr>
    <tr><td class="paramname">cf</td><td>The computed impulsive forces, on return, in a packed storage format. The first <code>nc</code> elements of <code>cf</code> correspond to the magnitudes of the contact impulses applied along the normals of the <code>nc</code> contact points. The next elements of <code>cf</code> correspond to the frictional impulses along the <code>r</code> spanning directions at each point of contact. The first <code>r</code> values (after the initial <code>nc</code> elements) correspond to the first contact, the next <code>r</code> values correspond to the second contact, etc. The next <code>ℓ</code> values of <code>cf</code> correspond to the impulsive forces applied to enforce unilateral constraint functions. The final <code>b</code> values of <code>cf</code> correspond to the forces applied to enforce generic bilateral constraints. This packed storage format can be turned into more useful representations through <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#af9282b3e4653a8f4ee1bea3fa8f630f0" title="Computes the generalized force on the system from the constraint forces given in packed storage...">ComputeGeneralizedForceFromConstraintForces()</a> and <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a4ed17652ed0aaed188638503a891b287" title="Gets the contact forces expressed in each contact frame for 2D contact problems from the &quot;packed&quot; sol...">CalcContactForcesInContactFrames()</a>. <code>cf</code> will be resized as necessary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Constraint data has been computed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the constraint forces cannot be computed (due to, e.g., the effects of roundoff error in attempting to solve a complementarity problem); in such cases, it is recommended to increase regularization and attempt again. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if <code>cf</code> is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb75f1755aa6a56c9be6eb004f8d5b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb75f1755aa6a56c9be6eb004f8d5b02">&#9670;&nbsp;</a></span>UpdateDiscretizedTimeLcp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UpdateDiscretizedTimeLcp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_vel_problem_data.html">ConstraintVelProblemData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>problem_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_solver_1_1_mlcp_to_lcp_data.html">MlcpToLcpData</a> *&#160;</td>
          <td class="paramname"><em>mlcp_to_lcp_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>MM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>qq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the time-discretization of the LCP initially computed in <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ad6927b208cf73c0b0fad40c64bcd77e9" title="Computes the base time-discretization of the system using the problem data, resulting in the MM and q...">ConstructBaseDiscretizedTimeLcp()</a> using the problem data and time step <code>h</code>. </p>
<p>Solving the resulting pure LCP yields non-impulsive constraint forces that can be obtained from <a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#a10078a950716e9baa641e7b11b30a0b7" title="Populates the packed constraint force vector from the solution to the linear complementarity problem ...">PopulatePackedConstraintForcesFromLcpSolution()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">problem_data</td><td>the constraint problem data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mlcp_to_lcp_data</td><td>a pointer to a valid <a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_solver_1_1_mlcp_to_lcp_data.html" title="Structure used to convert a mixed linear complementarity problem to a pure linear complementarity pro...">MlcpToLcpData</a> object; the caller must ensure that this pointer remains valid through the constraint solution process. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>the vector corresponding to the MLCP vector <code>a</code>, on return. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MM</td><td>a pointer to the updated LCP matrix on return. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qq</td><td>a pointer to the updated LCP vector on return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>mlcp_to_lcp_data</code>, <code>a</code>, <code>MM</code>, and <code>qq</code> are non-null on entry. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html#ad6927b208cf73c0b0fad40c64bcd77e9" title="Computes the base time-discretization of the system using the problem data, resulting in the MM and q...">ConstructBaseDiscretizedTimeLcp()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/constraint/<a class="el" href="constraint__solver_8h.html">constraint_solver.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody_1_1constraint.html">constraint</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1constraint_1_1_constraint_solver.html">ConstraintSolver</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
