<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: IntegratorBase&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1systems_1_1_integrator_base.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classdrake_1_1systems_1_1_integrator_base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IntegratorBase&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An abstract class for an integrator for ODEs and DAEs as represented by a Drake <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  
 <a href="classdrake_1_1systems_1_1_integrator_base.html#details">More...</a></p>

<p><code>#include &lt;drake/systems/analysis/integrator_base.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a95ae527571e3f25c4415b93d12cb0ad9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95ae527571e3f25c4415b93d12cb0ad9">StepResult</a> { <br />
&#160;&#160;<a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95ae527571e3f25c4415b93d12cb0ad9a1eb5c205e3572ba9946f3c86f093c845">kReachedPublishTime</a> = 1, 
<a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95ae527571e3f25c4415b93d12cb0ad9a1d1f7136371fa0489571cddeb08084e8">kReachedZeroCrossing</a> = 2, 
<a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95ae527571e3f25c4415b93d12cb0ad9a804060ac669eb47e5d384d3800e59d9c">kReachedUpdateTime</a> = 3, 
<a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95ae527571e3f25c4415b93d12cb0ad9a8d552f806d347dcd4031fbce86195737">kTimeHasAdvanced</a> = 4, 
<br />
&#160;&#160;<a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95ae527571e3f25c4415b93d12cb0ad9ab50d451e0bcc5385a4bdfd6b3bf5482c">kReachedBoundaryTime</a> = 5, 
<a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95ae527571e3f25c4415b93d12cb0ad9a7ea4dacf674c208f87e90fa976d0829f">kReachedStepLimit</a> = 6
<br />
 }<tr class="memdesc:a95ae527571e3f25c4415b93d12cb0ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status returned by StepOnceAtMost().  <a href="classdrake_1_1systems_1_1_integrator_base.html#a95ae527571e3f25c4415b93d12cb0ad9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a95ae527571e3f25c4415b93d12cb0ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a447030379c5091a36af0c158a0945c6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a447030379c5091a36af0c158a0945c6e">IntegratorBase</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;system, <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context=nullptr)</td></tr>
<tr class="memdesc:a447030379c5091a36af0c158a0945c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains references to the system being integrated and the context used to specify the initial conditions for that system (if any).  <a href="#a447030379c5091a36af0c158a0945c6e">More...</a><br /></td></tr>
<tr class="separator:a447030379c5091a36af0c158a0945c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88b1b96e061ad4e07a71561bf95fad4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#af88b1b96e061ad4e07a71561bf95fad4">~IntegratorBase</a> ()=default</td></tr>
<tr class="memdesc:af88b1b96e061ad4e07a71561bf95fad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af88b1b96e061ad4e07a71561bf95fad4">More...</a><br /></td></tr>
<tr class="separator:af88b1b96e061ad4e07a71561bf95fad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa66573f5abb1dc153098d2920c32b7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a5fa66573f5abb1dc153098d2920c32b7">supports_error_estimation</a> () const =0</td></tr>
<tr class="memdesc:a5fa66573f5abb1dc153098d2920c32b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether an integrator supports error estimation.  <a href="#a5fa66573f5abb1dc153098d2920c32b7">More...</a><br /></td></tr>
<tr class="separator:a5fa66573f5abb1dc153098d2920c32b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f8dced020f4fa9c3ccfc2eb6982a86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a53f8dced020f4fa9c3ccfc2eb6982a86">set_fixed_step_mode</a> (<a class="el" href="classbool.html">bool</a> flag)</td></tr>
<tr class="memdesc:a53f8dced020f4fa9c3ccfc2eb6982a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an integrator with error control to fixed step mode.  <a href="#a53f8dced020f4fa9c3ccfc2eb6982a86">More...</a><br /></td></tr>
<tr class="separator:a53f8dced020f4fa9c3ccfc2eb6982a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35b01e013bbfa64d9cdccfa01f034fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ae35b01e013bbfa64d9cdccfa01f034fe">get_fixed_step_mode</a> () const</td></tr>
<tr class="memdesc:ae35b01e013bbfa64d9cdccfa01f034fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether an integrator is running in fixed step mode.  <a href="#ae35b01e013bbfa64d9cdccfa01f034fe">More...</a><br /></td></tr>
<tr class="separator:ae35b01e013bbfa64d9cdccfa01f034fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbb07017a30541d06b2b597d1e4f30f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a6dbb07017a30541d06b2b597d1e4f30f">set_target_accuracy</a> (<a class="el" href="classdouble.html">double</a> accuracy)</td></tr>
<tr class="memdesc:a6dbb07017a30541d06b2b597d1e4f30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that the integrator attempt to achieve a particular accuracy for the continuous portions of the simulation.  <a href="#a6dbb07017a30541d06b2b597d1e4f30f">More...</a><br /></td></tr>
<tr class="separator:a6dbb07017a30541d06b2b597d1e4f30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ba1d30cec20bb83e5a678945ffaa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a630ba1d30cec20bb83e5a678945ffaa2">get_target_accuracy</a> () const</td></tr>
<tr class="memdesc:a630ba1d30cec20bb83e5a678945ffaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the target accuracy.  <a href="#a630ba1d30cec20bb83e5a678945ffaa2">More...</a><br /></td></tr>
<tr class="separator:a630ba1d30cec20bb83e5a678945ffaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecfd0a8cbb76b7f43921e284b2a6980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a4ecfd0a8cbb76b7f43921e284b2a6980">get_accuracy_in_use</a> () const</td></tr>
<tr class="memdesc:a4ecfd0a8cbb76b7f43921e284b2a6980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the accuracy in use by the integrator.  <a href="#a4ecfd0a8cbb76b7f43921e284b2a6980">More...</a><br /></td></tr>
<tr class="separator:a4ecfd0a8cbb76b7f43921e284b2a6980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae878ce4cdab7a01165423d8a902df452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ae878ce4cdab7a01165423d8a902df452">set_maximum_step_size</a> (const T &amp;max_step_size)</td></tr>
<tr class="memdesc:ae878ce4cdab7a01165423d8a902df452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum step size that may be taken by this integrator.  <a href="#ae878ce4cdab7a01165423d8a902df452">More...</a><br /></td></tr>
<tr class="separator:ae878ce4cdab7a01165423d8a902df452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dafbc057f2a5a4828813e7ea5e3f99e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0dafbc057f2a5a4828813e7ea5e3f99e">get_maximum_step_size</a> () const</td></tr>
<tr class="memdesc:a0dafbc057f2a5a4828813e7ea5e3f99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum step size that may be taken by this integrator.  <a href="#a0dafbc057f2a5a4828813e7ea5e3f99e">More...</a><br /></td></tr>
<tr class="separator:a0dafbc057f2a5a4828813e7ea5e3f99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372de693ad40b3f42839c8ec6ac845f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a372de693ad40b3f42839c8ec6ac845f4">Reset</a> ()</td></tr>
<tr class="memdesc:a372de693ad40b3f42839c8ec6ac845f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the integrator to initial values, i.e., default construction values.  <a href="#a372de693ad40b3f42839c8ec6ac845f4">More...</a><br /></td></tr>
<tr class="separator:a372de693ad40b3f42839c8ec6ac845f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b1050f09da390896f964fb7a892391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391">Initialize</a> ()</td></tr>
<tr class="memdesc:a98b1050f09da390896f964fb7a892391"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integrator must be initialized before being used.  <a href="#a98b1050f09da390896f964fb7a892391">More...</a><br /></td></tr>
<tr class="separator:a98b1050f09da390896f964fb7a892391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa818a52a133131208f51b1c0a3a906c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aaa818a52a133131208f51b1c0a3a906c">request_initial_step_size_target</a> (const T &amp;step_size)</td></tr>
<tr class="memdesc:aaa818a52a133131208f51b1c0a3a906c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that the first attempted integration step have a particular size.  <a href="#aaa818a52a133131208f51b1c0a3a906c">More...</a><br /></td></tr>
<tr class="separator:aaa818a52a133131208f51b1c0a3a906c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19919024e6d4d17453e610f57e53eba"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ac19919024e6d4d17453e610f57e53eba">get_initial_step_size_target</a> () const</td></tr>
<tr class="memdesc:ac19919024e6d4d17453e610f57e53eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the target size of the first integration step.  <a href="#ac19919024e6d4d17453e610f57e53eba">More...</a><br /></td></tr>
<tr class="separator:ac19919024e6d4d17453e610f57e53eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed535a106827b243e5da116944e72ae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95ae527571e3f25c4415b93d12cb0ad9">StepResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aed535a106827b243e5da116944e72ae9">IntegrateAtMost</a> (const T &amp;publish_dt, const T &amp;update_dt, const T &amp;boundary_dt)</td></tr>
<tr class="memdesc:aed535a106827b243e5da116944e72ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates the system forward in time by a single step with step size subject to integration error tolerances (assuming that the integrator supports error estimation).  <a href="#aed535a106827b243e5da116944e72ae9">More...</a><br /></td></tr>
<tr class="separator:aed535a106827b243e5da116944e72ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab693dd7dd1da02154fc0f0ff6ef20692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ab693dd7dd1da02154fc0f0ff6ef20692">get_stretch_factor</a> () const</td></tr>
<tr class="memdesc:ab693dd7dd1da02154fc0f0ff6ef20692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the stretch factor (&gt; 1), which is multiplied by the maximum (typically user-designated) integration step size to obtain the amount that the integrator is able to stretch the maximum time step toward hitting an upcoming publish or update event in <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aed535a106827b243e5da116944e72ae9" title="Integrates the system forward in time by a single step with step size subject to integration error to...">IntegrateAtMost()</a>.  <a href="#ab693dd7dd1da02154fc0f0ff6ef20692">More...</a><br /></td></tr>
<tr class="separator:ab693dd7dd1da02154fc0f0ff6ef20692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daa6300fb73f70d4f9ad60c098cee41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a5daa6300fb73f70d4f9ad60c098cee41">IntegrateWithMultipleSteps</a> (const T &amp;dt)</td></tr>
<tr class="memdesc:a5daa6300fb73f70d4f9ad60c098cee41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stepping function for integrators operating outside of <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> that advances the continuous state exactly by <code>dt</code>.  <a href="#a5daa6300fb73f70d4f9ad60c098cee41">More...</a><br /></td></tr>
<tr class="separator:a5daa6300fb73f70d4f9ad60c098cee41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e4fa279a917c0ebb7995fce7b97a6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aa6e4fa279a917c0ebb7995fce7b97a6b">IntegrateWithSingleFixedStep</a> (const T &amp;dt)</td></tr>
<tr class="memdesc:aa6e4fa279a917c0ebb7995fce7b97a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stepping function for integrators operating outside of <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> that advances the continuous state exactly by <code>dt</code> <em>and using a single fixed step</em>.  <a href="#aa6e4fa279a917c0ebb7995fce7b97a6b">More...</a><br /></td></tr>
<tr class="separator:aa6e4fa279a917c0ebb7995fce7b97a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06585bb16e4b92bb3c8f3c005fb6071"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aa06585bb16e4b92bb3c8f3c005fb6071">get_ideal_next_step_size</a> () const</td></tr>
<tr class="memdesc:aa06585bb16e4b92bb3c8f3c005fb6071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the step size the integrator would like to take next, based primarily on the integrator's accuracy prediction.  <a href="#aa06585bb16e4b92bb3c8f3c005fb6071">More...</a><br /></td></tr>
<tr class="separator:aa06585bb16e4b92bb3c8f3c005fb6071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca73e48fb4c24fcf1893459f57eb86a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0ca73e48fb4c24fcf1893459f57eb86a">get_context</a> () const</td></tr>
<tr class="memdesc:a0ca73e48fb4c24fcf1893459f57eb86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> holding the most recent state in the trajectory.  <a href="#a0ca73e48fb4c24fcf1893459f57eb86a">More...</a><br /></td></tr>
<tr class="separator:a0ca73e48fb4c24fcf1893459f57eb86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d03f8fbbd6a4bce39d8fed752a5d446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a2d03f8fbbd6a4bce39d8fed752a5d446">get_mutable_context</a> ()</td></tr>
<tr class="memdesc:a2d03f8fbbd6a4bce39d8fed752a5d446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable pointer to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> holding the most recent state in the trajectory.  <a href="#a2d03f8fbbd6a4bce39d8fed752a5d446">More...</a><br /></td></tr>
<tr class="separator:a2d03f8fbbd6a4bce39d8fed752a5d446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ec42d998ad39014c3dc64c50cfbc4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ae9ec42d998ad39014c3dc64c50cfbc4d">reset_context</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context)</td></tr>
<tr class="memdesc:ae9ec42d998ad39014c3dc64c50cfbc4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the pointer to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> with a different one.  <a href="#ae9ec42d998ad39014c3dc64c50cfbc4d">More...</a><br /></td></tr>
<tr class="separator:ae9ec42d998ad39014c3dc64c50cfbc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c403016877fd5f6291208aeb9a8063c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a5c403016877fd5f6291208aeb9a8063c">get_system</a> () const</td></tr>
<tr class="memdesc:a5c403016877fd5f6291208aeb9a8063c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a constant reference to the system that is being integrated (and was provided to the constructor of the integrator).  <a href="#a5c403016877fd5f6291208aeb9a8063c">More...</a><br /></td></tr>
<tr class="separator:a5c403016877fd5f6291208aeb9a8063c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2108348656c73efe1d72702c96d5c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a7a2108348656c73efe1d72702c96d5c5">is_initialized</a> () const</td></tr>
<tr class="memdesc:a7a2108348656c73efe1d72702c96d5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the integrator has been initialized.  <a href="#a7a2108348656c73efe1d72702c96d5c5">More...</a><br /></td></tr>
<tr class="separator:a7a2108348656c73efe1d72702c96d5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09a2cc2db0a776ca7bb11c8d8fe4831"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ab09a2cc2db0a776ca7bb11c8d8fe4831">get_error_estimate_order</a> () const =0</td></tr>
<tr class="memdesc:ab09a2cc2db0a776ca7bb11c8d8fe4831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes must override this function to return the order of the integrator's error estimate.  <a href="#ab09a2cc2db0a776ca7bb11c8d8fe4831">More...</a><br /></td></tr>
<tr class="separator:ab09a2cc2db0a776ca7bb11c8d8fe4831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9442cfd0320da3227579970a3ea0b506"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a9442cfd0320da3227579970a3ea0b506">get_previous_integration_step_size</a> () const</td></tr>
<tr class="memdesc:a9442cfd0320da3227579970a3ea0b506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the last (previous) integration step.  <a href="#a9442cfd0320da3227579970a3ea0b506">More...</a><br /></td></tr>
<tr class="separator:a9442cfd0320da3227579970a3ea0b506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c0da3a86a705e44833ec423e513971"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a91c0da3a86a705e44833ec423e513971">get_error_estimate</a> () const</td></tr>
<tr class="memdesc:a91c0da3a86a705e44833ec423e513971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the error estimate (used only for integrators that support error estimation).  <a href="#a91c0da3a86a705e44833ec423e513971">More...</a><br /></td></tr>
<tr class="separator:a91c0da3a86a705e44833ec423e513971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a3ecc7a468ab5fc69c4dd0beefd4aab08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a> (const <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a> &amp;)=delete</td></tr>
<tr class="separator:a3ecc7a468ab5fc69c4dd0beefd4aab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5d79c4be26ab9ff12fac51584dd3f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0e5d79c4be26ab9ff12fac51584dd3f5">operator=</a> (const <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a> &amp;)=delete</td></tr>
<tr class="separator:a0e5d79c4be26ab9ff12fac51584dd3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d908b973947061eaa9041e6a2b1442"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aa0d908b973947061eaa9041e6a2b1442">IntegratorBase</a> (<a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aa0d908b973947061eaa9041e6a2b1442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00778f31642c811fde02c61333aa5a25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a00778f31642c811fde02c61333aa5a25">operator=</a> (<a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a00778f31642c811fde02c61333aa5a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for minimum integration step size selection and behavior</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="Minstep"></a></p>
<p>Variable step integrators reduce their step sizes as needed to achieve requirements such as specified accuracy or step convergence. However, it is not possible to take an arbitrarily small step. Normally integrators choose an appropriate minimum step and throw an exception if the requirements can't be achieved without going below that. Methods in this section allow you to influence two aspects of this procedure:</p>
<ul>
<li>you can increase the minimum step size, and</li>
<li>you can control whether an exception is thrown if a smaller step would have been needed to achieve the aforementioned integrator requirements.</li>
</ul>
<p>By default, integrators allow a very small minimum step which can result in long run times. Setting a larger minimum can be helpful as a diagnostic to figure out what aspect of your simulation is requiring small steps. You can set the minimum to what should be a "reasonable" minimum based on what you know about the physical system. You will then get an std::runtime_error exception thrown at any point in time where your model behaves unexpectedly (due to, e.g., a discontinuity in the derivative evaluation function).</p>
<p>If you disable the exception (via <code>set_throw_on_minimum_step_size_violation(false)</code>), the integrator will simply proceed with a step of the minimum size: accuracy is guaranteed only when the minimum step size is not violated. Beware that there can be no guarantee about the magnitude of any errors introduced by violating the accuracy "requirements" in this manner, so disabling the exception should be done warily.</p>
<h4>Details</h4>
<p>Because time is maintained to finite precision, there is an absolute minimum step size <code>h_floor</code> required to avoid roundoff error. The integrator will never take a step smaller than <code>h_floor</code>. We calculate <code>h_floor=max(ε,ε⋅t)</code>, where t is the current time and ε is a small multiple of machine precision, typically a number like 1e-14. Note that <code>h_floor</code> necessarily grows with time; if that is a concern you should limit how long your simulations are allowed to run without resetting time.</p>
<p>You may request a larger minimum step size <code>h_min</code>. Then at every time t, the integrator determines a "working" minimum <code>h_work=max(h_min,h_floor)</code>. If the step size selection algorithm determines that a step smaller than <code>h_work</code> is needed to meet accuracy or other needs, then a std::runtime_error exception will be thrown and the simulation halted. On the other hand, if you have suppressed the exception (again, via <code>set_throw_on_minimum_step_size_violation(false)</code>), the integration will continue, taking a step of size <code>h_work</code>.</p>
<p>Under some circumstances the integrator may legitimately take a step of size <code>h</code> smaller than your specified <code>h_min</code>, although never smaller than <code>h_floor</code>. For example, occasionally the integrator may reach an event or time limit that occurs a very short time after the end of a previous step, necessitating that a tiny "sliver" of a step be taken to complete the interval. That does not indicate an error, and required accuracy and convergence goals are achieved. Larger steps can resume immediately afterwards. Another circumstance is when one of the integrator's stepping methods is called directly requesting a very small step, for example <code>IntegrateWithMultipleSteps(h)</code>. No exception will be thrown in either of these cases. </p>
</div></td></tr>
<tr class="memitem:a0f186af10e0fc1fc8f32fafa4fed7ba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0f186af10e0fc1fc8f32fafa4fed7ba7">set_requested_minimum_step_size</a> (const T &amp;min_step_size)</td></tr>
<tr class="memdesc:a0f186af10e0fc1fc8f32fafa4fed7ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the requested minimum step size <code>h_min</code> that may be taken by this integrator.  <a href="#a0f186af10e0fc1fc8f32fafa4fed7ba7">More...</a><br /></td></tr>
<tr class="separator:a0f186af10e0fc1fc8f32fafa4fed7ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59add268d553fd546ffb04eca70b693b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a59add268d553fd546ffb04eca70b693b">get_requested_minimum_step_size</a> () const</td></tr>
<tr class="memdesc:a59add268d553fd546ffb04eca70b693b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested minimum step size <code>h_min</code> for this integrator.  <a href="#a59add268d553fd546ffb04eca70b693b">More...</a><br /></td></tr>
<tr class="separator:a59add268d553fd546ffb04eca70b693b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78773e63a07381351e18380040f5fc13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a78773e63a07381351e18380040f5fc13">set_throw_on_minimum_step_size_violation</a> (<a class="el" href="classbool.html">bool</a> throws)</td></tr>
<tr class="memdesc:a78773e63a07381351e18380040f5fc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the integrator should throw a std::runtime_error exception when the integrator's step size selection algorithm determines that it must take a step smaller than the minimum step size (for, e.g., purposes of error control).  <a href="#a78773e63a07381351e18380040f5fc13">More...</a><br /></td></tr>
<tr class="separator:a78773e63a07381351e18380040f5fc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b89a6384ec3f94a33c8fd2f4c384369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a5b89a6384ec3f94a33c8fd2f4c384369">get_throw_on_minimum_step_size_violation</a> () const</td></tr>
<tr class="memdesc:a5b89a6384ec3f94a33c8fd2f4c384369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the current setting of the throw_on_minimum_step_size_violation flag.  <a href="#a5b89a6384ec3f94a33c8fd2f4c384369">More...</a><br /></td></tr>
<tr class="separator:a5b89a6384ec3f94a33c8fd2f4c384369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47399e48a6a661ce1b8252d86a305b54"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a47399e48a6a661ce1b8252d86a305b54">get_working_minimum_step_size</a> () const</td></tr>
<tr class="memdesc:a47399e48a6a661ce1b8252d86a305b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current value of the working minimum step size <code>h_work(t)</code> for this integrator, which may vary with the current time t as stored in the integrator's context.  <a href="#a47399e48a6a661ce1b8252d86a305b54">More...</a><br /></td></tr>
<tr class="separator:a47399e48a6a661ce1b8252d86a305b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Integrator statistics methods.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods allow the caller to manipulate and query integrator statistics.</p>
<p>Generally speaking, the larger the integration step taken, the faster a simulation will run. These methods allow querying (and resetting) the integrator statistics as one means of determining how to make a simulation run faster. </p>
</div></td></tr>
<tr class="memitem:a64a01ac56f8a0086cc6ed335ee9e5caa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a64a01ac56f8a0086cc6ed335ee9e5caa">ResetStatistics</a> ()</td></tr>
<tr class="memdesc:a64a01ac56f8a0086cc6ed335ee9e5caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forget accumulated statistics.  <a href="#a64a01ac56f8a0086cc6ed335ee9e5caa">More...</a><br /></td></tr>
<tr class="separator:a64a01ac56f8a0086cc6ed335ee9e5caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1597c69b7f633624a3693142ad3f04"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#afa1597c69b7f633624a3693142ad3f04">get_num_substep_failures</a> () const</td></tr>
<tr class="memdesc:afa1597c69b7f633624a3693142ad3f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of failed sub-steps (implying one or more step size reductions was required to permit solving the necessary nonlinear system of equations).  <a href="#afa1597c69b7f633624a3693142ad3f04">More...</a><br /></td></tr>
<tr class="separator:afa1597c69b7f633624a3693142ad3f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64333e8ed51bb6a29af25c2c4da153aa"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a64333e8ed51bb6a29af25c2c4da153aa">get_num_step_shrinkages_from_substep_failures</a> () const</td></tr>
<tr class="memdesc:a64333e8ed51bb6a29af25c2c4da153aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of step size shrinkages due to sub-step failures (e.g., integrator convergence failures) since the last call to <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics. ">ResetStatistics()</a> or <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a>.  <a href="#a64333e8ed51bb6a29af25c2c4da153aa">More...</a><br /></td></tr>
<tr class="separator:a64333e8ed51bb6a29af25c2c4da153aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b588edb71f956edad8a88d5c8b86479"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a2b588edb71f956edad8a88d5c8b86479">get_num_step_shrinkages_from_error_control</a> () const</td></tr>
<tr class="memdesc:a2b588edb71f956edad8a88d5c8b86479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of step size shrinkages due to failure to meet targeted error tolerances, since the last call to ResetStatistics or <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a>.  <a href="#a2b588edb71f956edad8a88d5c8b86479">More...</a><br /></td></tr>
<tr class="separator:a2b588edb71f956edad8a88d5c8b86479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3152b858f89491817273d05fa518289"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ac3152b858f89491817273d05fa518289">get_num_derivative_evaluations</a> () const</td></tr>
<tr class="memdesc:ac3152b858f89491817273d05fa518289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ODE function evaluations (calls to <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a6e8e4ee866da0e4ce7790986884b4f7b" title="Evaluates the derivative function (and updates call statistics). ">CalcTimeDerivatives()</a>) since the last call to <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics. ">ResetStatistics()</a> or <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a>.  <a href="#ac3152b858f89491817273d05fa518289">More...</a><br /></td></tr>
<tr class="separator:ac3152b858f89491817273d05fa518289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ada2c620af585fefd269bbf0a7ff1e9"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0ada2c620af585fefd269bbf0a7ff1e9">get_actual_initial_step_size_taken</a> () const</td></tr>
<tr class="memdesc:a0ada2c620af585fefd269bbf0a7ff1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual size of the successful first step.  <a href="#a0ada2c620af585fefd269bbf0a7ff1e9">More...</a><br /></td></tr>
<tr class="separator:a0ada2c620af585fefd269bbf0a7ff1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245008509fc19d0282b2dfe9171740f1"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a245008509fc19d0282b2dfe9171740f1">get_smallest_adapted_step_size_taken</a> () const</td></tr>
<tr class="memdesc:a245008509fc19d0282b2dfe9171740f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the smallest step taken <em>as the result of a controlled integration step adjustment</em> since the last <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a> or <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics. ">ResetStatistics()</a> call.  <a href="#a245008509fc19d0282b2dfe9171740f1">More...</a><br /></td></tr>
<tr class="separator:a245008509fc19d0282b2dfe9171740f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2e467101cf8c82f53ee1688227cf16"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a4d2e467101cf8c82f53ee1688227cf16">get_largest_step_size_taken</a> () const</td></tr>
<tr class="memdesc:a4d2e467101cf8c82f53ee1688227cf16"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the largest step taken since the last <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a> or <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics. ">ResetStatistics()</a> call.  <a href="#a4d2e467101cf8c82f53ee1688227cf16">More...</a><br /></td></tr>
<tr class="separator:a4d2e467101cf8c82f53ee1688227cf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215741958afe19af17a62470f883878b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a215741958afe19af17a62470f883878b">get_num_steps_taken</a> () const</td></tr>
<tr class="memdesc:a215741958afe19af17a62470f883878b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of integration steps taken since the last <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a> or <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics. ">ResetStatistics()</a> call.  <a href="#a215741958afe19af17a62470f883878b">More...</a><br /></td></tr>
<tr class="separator:a215741958afe19af17a62470f883878b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for dense output computation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="dense_output_computation"></a></p>
<p>In general, dense output computations entail both CPU load and memory footprint increases during numerical integration. For some applications, the performance penalty may be prohibitive. As such, these computations are only carried out by explicit user request. The API to start and stop a <em>dense integration</em> process (i.e. a numerical integration process that also computes dense output) is consistent with this design choice.</p>
<p>Once dense integration is started, and until it is stopped, all subsequent integration steps taken will update the allocated dense output. </p>
</div></td></tr>
<tr class="memitem:a0cdd4796b7f98a09da058b9764f13b86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0cdd4796b7f98a09da058b9764f13b86">StartDenseIntegration</a> ()</td></tr>
<tr class="memdesc:a0cdd4796b7f98a09da058b9764f13b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts dense integration, allocating a new dense output for this integrator to use.  <a href="#a0cdd4796b7f98a09da058b9764f13b86">More...</a><br /></td></tr>
<tr class="separator:a0cdd4796b7f98a09da058b9764f13b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6db8946d109961ca7516a4bb19c8378"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_dense_output.html">DenseOutput</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ae6db8946d109961ca7516a4bb19c8378">get_dense_output</a> () const</td></tr>
<tr class="memdesc:ae6db8946d109961ca7516a4bb19c8378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the integrator's current <a class="el" href="classdrake_1_1systems_1_1_dense_output.html" title="An interface for dense output of ODE solutions, to efficiently approximate them at arbitrarily many p...">DenseOutput</a> instance, holding a representation of the continuous state trajectory since the last <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use. ">StartDenseIntegration()</a> call.  <a href="#ae6db8946d109961ca7516a4bb19c8378">More...</a><br /></td></tr>
<tr class="separator:ae6db8946d109961ca7516a4bb19c8378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127218e2c5251398b7a0740a32e2350c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_dense_output.html">DenseOutput</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a127218e2c5251398b7a0740a32e2350c">StopDenseIntegration</a> ()</td></tr>
<tr class="memdesc:a127218e2c5251398b7a0740a32e2350c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops dense integration, yielding ownership of the current dense output to the caller.  <a href="#a127218e2c5251398b7a0740a32e2350c">More...</a><br /></td></tr>
<tr class="separator:a127218e2c5251398b7a0740a32e2350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for weighting state variable errors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>This group of methods describes how errors for state variables with heterogeneous units are weighted in the context of error-controlled integration.</p>
<p>This is an advanced topic and most users can simply specify desired accuracy and accept the default state variable weights.</p>
<p>A collection of state variables is generally defined in heterogeneous units (e.g. length, angles, velocities, energy). Some of the state variables cannot even be expressed in meaningful units, like quaternions. Certain integrators provide an estimate of the absolute error made in each state variable during an integration step. These errors must be properly weighted to obtain an "accuracy" <em>with respect to each particular variable</em>. These per-variable accuracy determinations can be compared against the user's requirements and used to select an appropriate size for the next step [Sherman 2011]. The weights are normally determined automatically using the system's characteristic dimensions, so <em>most users can stop reading now!</em> Custom weighting is primarily useful for performance improvement; an optimal weighting would allow an error-controlled integrator to provide the desired level of accuracy across all state variables without wasting computation achieving superfluous accuracy for some of those variables.</p>
<p>Users interested in more precise control over state variable weighting may use the methods in this group to access and modify weighting factors for individual state variables. Changes to these weights can only be made prior to integrator initialization or as a result of an event being triggered and then followed by re-initialization.</p>
<h4>Relative versus absolute accuracy</h4>
<p>State variable integration error, as estimated by an integrator, is an absolute quantity with the same units as the variable. At each time step we therefore need to determine an absolute error that would be deemed "good enough", i.e. satisfies the user's accuracy requirement. If a variable is maintained to a <em>relative</em> accuracy then that "good enough" value is defined to be the required accuracy <code>a</code> (a fraction like 0.001) times the current value of the variable, as long as that value is far from zero. For variables maintained to an <em>absolute</em> accuracy, or relative variables that are at or near zero (where relative accuracy would be undefined or too strict, respectively), we need a different way to determine the "good enough" absolute error. The methods in this section control how that absolute error value is calculated.</p>
<h4>How to choose weights</h4>
<p>The weight <code>wᵢ</code> for a state variable <code>xᵢ</code> should be chosen so that the product <code>wᵢ * dxᵢ</code> is unitless, and in particular is 1 when <code>dxᵢ</code> represents a "unit effect" of state variable <code>xᵢ</code>; that is, the change in <code>xᵢ</code> that produces a unit change in some quantity of interest in the system being simulated. Why unity (1)? Aside from normalizing the values, unity "grounds" the weighted error to the user-specified accuracy. A weighting can be applied individually to each state variable, but typically it is done approximately by combining the known type of the variable (e.g. length, angle) with a "characteristic scale" for that quantity. For example, if a "characteristic length" for the system being simulated is 0.1 meters, and <code>x₀</code> is a length variable measured in meters, then <code>w₀</code> should be 10 so that <code>w₀*dx₀=1</code> when <code>dx₀=0.1</code>. For angles representing pointing accuracy (say a camera direction) we typically assume a "characteristic angle" is one radian (about 60 degrees), so if x₁ is a pointing direction then w₁=1 is an appropriate weight. We can now scale an error vector <code>e=[dx₀ dx₁]</code> to a unitless fractional error vector <code>f=[w₀*dx₀ w₁*dx₁]</code>. Now to achieve a given accuracy <code>a</code>, say <code>a=.0001</code>, we need only check that <code>|fᵢ|&lt;=a</code> for each element <code>i</code> of <code>f</code>. Further, this gives us a quantitative measure of "worst accuracy" that we can use to increase or reduce size of the next attempted step, so that we will just achieve the required accuracy but not much more. We'll be more precise about this below.</p>
<p><a class="anchor" id="quasi_coordinates"></a></p><h4>Some subtleties for second-order dynamic systems</h4>
<p>Systems governed by 2nd-order differential equations are typically split into second order (configuration) variables q, and rate (velocity) variables v, where the time derivatives qdot of q are linearly related to v by the kinematic differential equation <code>qdot = dq/dt = N(q)*v</code>. Velocity variables are chosen to be physically significant, but configuration variables may be chosen for convenience and do not necessarily have direct physical interpretation. For examples, quaternions are chosen as a numerically stable orientation representation. This is problematic for choosing weights which must be done by physical reasoning as sketched above. We resolve this by introducing the notion of "quasi-coordinates" ꝗ (pronounced "qbar") which are defined by the equation <code>ꝗdot = dꝗ/dt = v</code>. Other than time scaling, quasi-coordinates have the same units as their corresponding velocity variables. That is, for weighting we need to think of the configuration coordinates in the same physical space as the velocity variables; weight those by their physical significance; and then map back to an instantaneous weighting on the actual configuration variables q. This mapping is performed automatically; you need only to be concerned about physical weightings.</p>
<p>Note that generalized quasi-coordinates <code>ꝗ</code> can only be defined locally for a particular configuration <code>q</code>. There is in general no meaningful set of <code>n</code> generalized coordinates which can be differentiated with respect to time to yield <code>v</code>. For example, the Hairy Ball Theorem implies that it is not possible for three orientation variables to represent all 3D rotations without singularities, yet three velocity variables can represent angular velocity in 3D without singularities.</p>
<p>To summarize, separate weights can be provided for each of</p><ul>
<li><code>n</code> generalized quasi-coordinates <code>ꝗ</code> (configuration variables in the velocity variable space), and</li>
<li><code>nz</code> miscellaneous continuous state variables <code>z</code>.</li>
</ul>
<p>Weights on the generalized velocity variables <code>v (= dꝗ/dt)</code> are derived directly from the weights on <code>ꝗ</code>, weighted by a characteristic time. Weights on the actual <code>nq</code> generalized coordinates can be calculated efficiently from weights on the quasi-coordinates (details below).</p>
<h4>How the weights are used</h4>
<p>The errors in the <code>ꝗ</code> and <code>z</code> variables are weighted by the diagonal elements of diagonal weighting matrices Wꝗ and Wz, respectively. (The block-diagonal weighting matrix <code>Wq</code> on the original generalized coordinates <code>q</code> is calculated from <code>N</code> and <code>Wꝗ</code>; see below.) In the absence of other information, the default for all weighting values is one, so <code>Wꝗ</code> and <code>Wz</code> are <code>n × n</code> and <code>nz × nz</code> identity matrices. The weighting matrix <code>Wv</code> for the velocity variables is just <code>Wv = τ*Wꝗ</code> where <code>τ</code> is a "characteristic time" for the system, that is, a quantity in time units that represents a significant evolution of the trajectory. This serves to control the accuracy with which velocity is determined relative to configuration. Note that larger values of <code>τ</code> are more conservative since they increase the velocity weights. Typically we use <code>τ=1.0</code> or <code>0.1</code> seconds for human-scale mechanical systems.</p>
<p>The weighting matrices <code>Wq</code>, <code>Wv</code>, and <code>Wz</code> are used to compute a weighted infinity norm as follows. Although <code>Wv</code> and <code>Wz</code> are constant, the actual weightings may be state dependent for relative-error calculations. Define block diagonal error weighting matrix <code>E=diag(Eq,Ev,Ez)</code> as follows: </p><pre>
  Eq = Wq
  Ev: Ev(i,i) = { min(Wv(i,i), 1/|vᵢ|)     if vᵢ is relative
                { Wv(i,i)                  if vᵢ is absolute
  Ez: Ez(i,i) = { min(Wz(i,i), 1/|zᵢ|)     if zᵢ is relative
                { Wz(i,i)                  if zᵢ is absolute
</pre><p> (<code>Ev</code> and <code>Ez</code> are diagonal.) A <code>v</code> or <code>z</code> will be maintained to relative accuracy unless (a) it is "close" to zero (less than 1), or (b) the variable has been defined as requiring absolute accuracy. Position variables <code>q</code> are always maintained to absolute accuracy (see [Sherman 2011] for rationale).</p>
<p>Now given an error estimate vector <code>e=[eq ev ez]</code>, the vector <code>f=E*e</code> can be considered to provide a unitless fractional error for each of the state variables. To achieve a given user-specified accuracy <code>a</code>, we require that norm_inf(<code>f</code>) &lt;= <code>a</code>. That is, no element of <code>f</code> can have absolute value larger than <code>a</code>. We also use <code>f</code> to determine an ideal next step size using an appropriate integrator-specific computation.</p>
<h4>Determining weights for q</h4>
<p>The kinematic differential equations <code>qdot=N(q)*v</code> employ an <code>nq × n</code> matrix <code>N</code>. By construction, this relationship is invertible using <code>N</code>'s left pseudo-inverse <code>N⁺</code> so that <code>v=N⁺ qdot</code> and <code>N⁺ N = I</code> (the identity matrix); however, <code>N N⁺ != I</code>, as <code>N</code> has more rows than columns generally. [Nikravesh 1988] shows how such a matrix <code>N</code> can be determined and provides more information. Given this relationship between <code>N</code> and <code>N⁺</code>, we can relate weighted errors in configuration coordinates <code>q</code> to weighted errors in generalized quasi-coordinates <code>ꝗ</code>, as the following derivation shows: </p><pre>
           v = N⁺ qdot         Inverse kinematic differential equation
       dꝗ/dt = N⁺ dq/dt        Use synonyms for v and qdot
          dꝗ = N⁺ dq           Change time derivatives to differentials
       Wꝗ dꝗ = Wꝗ N⁺ dq        Pre-multiply both sides by Wꝗ
     N Wꝗ dꝗ = N Wꝗ N⁺ dq      Pre-multiply both sides by N
     N Wꝗ dꝗ = Wq dq           Define Wq := N Wꝗ N⁺
      N Wꝗ v = Wq qdot         Back to time derivatives.
</pre><p> The last two equations show that <code>Wq</code> as defined above provides the expected relationship between the weighted <code>ꝗ</code> or <code>v</code> variables in velocity space and the weighted <code>q</code> or <code>qdot</code> (resp.) variables in configuration space.</p>
<p>Finally, note that a diagonal entry of one of the weighting matrices can be set to zero to disable error estimation for that state variable (i.e., auxiliary variable or configuration/velocity variable pair), but that setting an entry to a negative value will cause an exception to be thrown when the integrator is initialized.</p>
<ul>
<li>[Nikravesh 1988] P. Nikravesh. Computer-Aided Analysis of Mechanical Systems. Prentice Hall, 1988. Sec. 6.3.</li>
<li><p class="startli">[Sherman 2011] M. Sherman, et al. Procedia IUTAM 2:241-261 (2011), Section 3.3. <a href="http://dx.doi.org/10.1016/j.piutam.2011.04.023">http://dx.doi.org/10.1016/j.piutam.2011.04.023</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a251c75be3ec4f5b14aeaf5ca2467416f" title="Computes the infinity norm of a change in continuous state. ">CalcStateChangeNorm()</a> </dd></dl>
</li>
</ul>
</div></td></tr>
<tr class="memitem:a1286e54624e71a19fa28e3564d2d9c75"><td class="memItemLeft" align="right" valign="top">const Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a1286e54624e71a19fa28e3564d2d9c75">get_generalized_state_weight_vector</a> () const</td></tr>
<tr class="memdesc:a1286e54624e71a19fa28e3564d2d9c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the weighting vector (equivalent to a diagonal matrix) applied to weighting both generalized coordinate and velocity state variable errors, as described in the group documentation.  <a href="#a1286e54624e71a19fa28e3564d2d9c75">More...</a><br /></td></tr>
<tr class="separator:a1286e54624e71a19fa28e3564d2d9c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a94ee74ec3449ce6a3e4601d7459e4e"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a1a94ee74ec3449ce6a3e4601d7459e4e">get_mutable_generalized_state_weight_vector</a> ()</td></tr>
<tr class="memdesc:a1a94ee74ec3449ce6a3e4601d7459e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a mutable weighting vector (equivalent to a diagonal matrix) applied to weighting both generalized coordinate and velocity state variable errors, as described in the group documentation.  <a href="#a1a94ee74ec3449ce6a3e4601d7459e4e">More...</a><br /></td></tr>
<tr class="separator:a1a94ee74ec3449ce6a3e4601d7459e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ccdda880715d682c035e1264441303"><td class="memItemLeft" align="right" valign="top">const Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ac3ccdda880715d682c035e1264441303">get_misc_state_weight_vector</a> () const</td></tr>
<tr class="memdesc:ac3ccdda880715d682c035e1264441303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the weighting vector (equivalent to a diagonal matrix) for weighting errors in miscellaneous continuous state variables <code>z</code>.  <a href="#ac3ccdda880715d682c035e1264441303">More...</a><br /></td></tr>
<tr class="separator:ac3ccdda880715d682c035e1264441303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ee60f8a8a649e684340a9d19133098"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a80ee60f8a8a649e684340a9d19133098">get_mutable_misc_state_weight_vector</a> ()</td></tr>
<tr class="memdesc:a80ee60f8a8a649e684340a9d19133098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a mutable weighting vector (equivalent to a diagonal matrix) for weighting errors in miscellaneous continuous state variables <code>z</code>.  <a href="#a80ee60f8a8a649e684340a9d19133098">More...</a><br /></td></tr>
<tr class="separator:a80ee60f8a8a649e684340a9d19133098"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac5f5259be2ac9352879b53f559cbd567"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ac5f5259be2ac9352879b53f559cbd567">DoResetStatistics</a> ()</td></tr>
<tr class="memdesc:ac5f5259be2ac9352879b53f559cbd567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets any statistics particular to a specific integrator.  <a href="#ac5f5259be2ac9352879b53f559cbd567">More...</a><br /></td></tr>
<tr class="separator:ac5f5259be2ac9352879b53f559cbd567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8e4ee866da0e4ce7790986884b4f7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a6e8e4ee866da0e4ce7790986884b4f7b">CalcTimeDerivatives</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *dxdt)</td></tr>
<tr class="memdesc:a6e8e4ee866da0e4ce7790986884b4f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the derivative function (and updates call statistics).  <a href="#a6e8e4ee866da0e4ce7790986884b4f7b">More...</a><br /></td></tr>
<tr class="separator:a6e8e4ee866da0e4ce7790986884b4f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae67aca69c96bd3d1f84c97f96ddf02"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a4ae67aca69c96bd3d1f84c97f96ddf02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a4ae67aca69c96bd3d1f84c97f96ddf02">CalcTimeDerivatives</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; U &gt; &amp;system, const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; U &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; U &gt; *dxdt)</td></tr>
<tr class="memdesc:a4ae67aca69c96bd3d1f84c97f96ddf02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the derivative function (and updates call statistics).  <a href="#a4ae67aca69c96bd3d1f84c97f96ddf02">More...</a><br /></td></tr>
<tr class="separator:a4ae67aca69c96bd3d1f84c97f96ddf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5296d2467ea109300a687233eb159a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a5296d2467ea109300a687233eb159a46">set_accuracy_in_use</a> (<a class="el" href="classdouble.html">double</a> accuracy)</td></tr>
<tr class="memdesc:a5296d2467ea109300a687233eb159a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the working ("in use") accuracy for this integrator.  <a href="#a5296d2467ea109300a687233eb159a46">More...</a><br /></td></tr>
<tr class="separator:a5296d2467ea109300a687233eb159a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaec34b208033abe28e8cb8e63c9974b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#adaec34b208033abe28e8cb8e63c9974b">InitializeAccuracy</a> (<a class="el" href="classdouble.html">double</a> default_accuracy, <a class="el" href="classdouble.html">double</a> loosest_accuracy, <a class="el" href="classdouble.html">double</a> max_step_fraction)</td></tr>
<tr class="memdesc:adaec34b208033abe28e8cb8e63c9974b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic code for validating (and resetting, if need be) the integrator working accuracy for error controlled integrators.  <a href="#adaec34b208033abe28e8cb8e63c9974b">More...</a><br /></td></tr>
<tr class="separator:adaec34b208033abe28e8cb8e63c9974b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511fcd8f6468ddea15317190f14cf860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a511fcd8f6468ddea15317190f14cf860">StepOnceErrorControlledAtMost</a> (const T &amp;dt_max)</td></tr>
<tr class="memdesc:a511fcd8f6468ddea15317190f14cf860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default code for advancing the continuous state of the system by a single step of <code>dt_max</code> (or smaller, depending on error control).  <a href="#a511fcd8f6468ddea15317190f14cf860">More...</a><br /></td></tr>
<tr class="separator:a511fcd8f6468ddea15317190f14cf860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251c75be3ec4f5b14aeaf5ca2467416f"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a251c75be3ec4f5b14aeaf5ca2467416f">CalcStateChangeNorm</a> (const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;dx_state) const</td></tr>
<tr class="memdesc:a251c75be3ec4f5b14aeaf5ca2467416f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the infinity norm of a change in continuous state.  <a href="#a251c75be3ec4f5b14aeaf5ca2467416f">More...</a><br /></td></tr>
<tr class="separator:a251c75be3ec4f5b14aeaf5ca2467416f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673eb33420503190006ca91d01ec779e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classbool.html">bool</a>, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a673eb33420503190006ca91d01ec779e">CalcAdjustedStepSize</a> (const T &amp;err, const T &amp;attempted_step_size, <a class="el" href="classbool.html">bool</a> *at_minimum_step_size) const</td></tr>
<tr class="memdesc:a673eb33420503190006ca91d01ec779e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates adjusted integrator step sizes toward keeping state variables within error bounds on the next integration step.  <a href="#a673eb33420503190006ca91d01ec779e">More...</a><br /></td></tr>
<tr class="separator:a673eb33420503190006ca91d01ec779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1949ad54a9dc1dc95f632a066aa12e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ae1949ad54a9dc1dc95f632a066aa12e6">DoInitialize</a> ()</td></tr>
<tr class="memdesc:ae1949ad54a9dc1dc95f632a066aa12e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes can override this method to perform special initialization.  <a href="#ae1949ad54a9dc1dc95f632a066aa12e6">More...</a><br /></td></tr>
<tr class="separator:ae1949ad54a9dc1dc95f632a066aa12e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d9215849b8b5dfbdfce1cf00ce3221"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a22d9215849b8b5dfbdfce1cf00ce3221">DoReset</a> ()</td></tr>
<tr class="memdesc:a22d9215849b8b5dfbdfce1cf00ce3221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes can override this method to perform routines when <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a372de693ad40b3f42839c8ec6ac845f4" title="Resets the integrator to initial values, i.e., default construction values. ">Reset()</a> is called.  <a href="#a22d9215849b8b5dfbdfce1cf00ce3221">More...</a><br /></td></tr>
<tr class="separator:a22d9215849b8b5dfbdfce1cf00ce3221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3484691218495df4f7e5867a9acf8c38"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_stepwise_dense_output.html">StepwiseDenseOutput</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a3484691218495df4f7e5867a9acf8c38">DoStartDenseIntegration</a> ()</td></tr>
<tr class="memdesc:a3484691218495df4f7e5867a9acf8c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes can override this method to provide a continuous extension of their own when <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use. ">StartDenseIntegration()</a> is called.  <a href="#a3484691218495df4f7e5867a9acf8c38">More...</a><br /></td></tr>
<tr class="separator:a3484691218495df4f7e5867a9acf8c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5486345efbe28218f193275ef26896f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_stepwise_dense_output.html">StepwiseDenseOutput</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#af5486345efbe28218f193275ef26896f">get_mutable_dense_output</a> ()</td></tr>
<tr class="memdesc:af5486345efbe28218f193275ef26896f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable pointer to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_stepwise_dense_output.html" title="A DenseOutput class interface extension, geared towards step-wise construction procedures. ">StepwiseDenseOutput</a> instance, holding a representation of the continuous state trajectory since the last time <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use. ">StartDenseIntegration()</a> was called.  <a href="#af5486345efbe28218f193275ef26896f">More...</a><br /></td></tr>
<tr class="separator:af5486345efbe28218f193275ef26896f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72100b015e62dc3c007c73cafdfd2ed7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a72100b015e62dc3c007c73cafdfd2ed7">DoStep</a> (const T &amp;dt)=0</td></tr>
<tr class="memdesc:a72100b015e62dc3c007c73cafdfd2ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes must implement this method to (1) integrate the continuous portion of this system forward by a single step of size <code>dt</code> and (2) set the error estimate (via <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95119340ec2f55ffe46e52252ef45855" title="Gets an error estimate of the state variables recorded by the last call to StepOnceFixedSize(). ">get_mutable_error_estimate()</a>).  <a href="#a72100b015e62dc3c007c73cafdfd2ed7">More...</a><br /></td></tr>
<tr class="separator:a72100b015e62dc3c007c73cafdfd2ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fc321896adb6729b2e9f82a647019f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a07fc321896adb6729b2e9f82a647019f">DoDenseStep</a> (const T &amp;dt)</td></tr>
<tr class="memdesc:a07fc321896adb6729b2e9f82a647019f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes may implement this method to (1) integrate the continuous portion of this system forward by a single step of size <code>dt</code>, (2) set the error estimate (via <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95119340ec2f55ffe46e52252ef45855" title="Gets an error estimate of the state variables recorded by the last call to StepOnceFixedSize(). ">get_mutable_error_estimate()</a>) and (3) update their own dense output implementation (via <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#af5486345efbe28218f193275ef26896f" title="Returns a mutable pointer to the internally-maintained StepwiseDenseOutput instance, holding a representation of the continuous state trajectory since the last time StartDenseIntegration() was called. ">get_mutable_dense_output()</a>).  <a href="#a07fc321896adb6729b2e9f82a647019f">More...</a><br /></td></tr>
<tr class="separator:a07fc321896adb6729b2e9f82a647019f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95119340ec2f55ffe46e52252ef45855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95119340ec2f55ffe46e52252ef45855">get_mutable_error_estimate</a> ()</td></tr>
<tr class="memdesc:a95119340ec2f55ffe46e52252ef45855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an error estimate of the state variables recorded by the last call to StepOnceFixedSize().  <a href="#a95119340ec2f55ffe46e52252ef45855">More...</a><br /></td></tr>
<tr class="separator:a95119340ec2f55ffe46e52252ef45855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5677b9c7efe7d9a3e9547dd5e3ef5a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ae5677b9c7efe7d9a3e9547dd5e3ef5a4">set_actual_initial_step_size_taken</a> (const T &amp;dt)</td></tr>
<tr class="separator:ae5677b9c7efe7d9a3e9547dd5e3ef5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ea35d1b2a56ca9f9eebb7764ca9dfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a07ea35d1b2a56ca9f9eebb7764ca9dfa">set_smallest_adapted_step_size_taken</a> (const T &amp;dt)</td></tr>
<tr class="memdesc:a07ea35d1b2a56ca9f9eebb7764ca9dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the smallest-step-taken statistic as the result of a controlled integration step adjustment.  <a href="#a07ea35d1b2a56ca9f9eebb7764ca9dfa">More...</a><br /></td></tr>
<tr class="separator:a07ea35d1b2a56ca9f9eebb7764ca9dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac61498c3a3ddfbf626ea0bea29884df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aac61498c3a3ddfbf626ea0bea29884df">set_largest_step_size_taken</a> (const T &amp;dt)</td></tr>
<tr class="separator:aac61498c3a3ddfbf626ea0bea29884df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2e65cf13be95165017e7363bf7944d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a4a2e65cf13be95165017e7363bf7944d">set_ideal_next_step_size</a> (const T &amp;dt)</td></tr>
<tr class="separator:a4a2e65cf13be95165017e7363bf7944d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class drake::systems::IntegratorBase&lt; T &gt;</h3>

<p>An abstract class for an integrator for ODEs and DAEs as represented by a Drake <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>. </p>
<p>Integrators solve initial value problems of the form:</p><pre>
ẋ(t) = f(t, x(t)) with f : ℝ × ℝⁿ → ℝⁿ
</pre><p> (i.e., <code>f()</code> is an ordinary differential equation) given initial conditions (t₀, x₀). Thus, integrators advance the continuous state of a dynamical system forward in time.</p>
<p>Apart from solving initial value problems, for which the integrator is a key component of a simulator, integrators can also be used to solve boundary value problems (via numerical methods like the Multiple Shooting Method) and trajectory optimization problems (via numerical methods like direct transcription). This class and its derivatives were developed primarily toward the former application (through <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aed535a106827b243e5da116944e72ae9" title="Integrates the system forward in time by a single step with step size subject to integration error to...">IntegrateAtMost()</a> and the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> class). However, the <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html" title="An abstract class for an integrator for ODEs and DAEs as represented by a Drake System. ">IntegratorBase</a> architecture was developed to support these ancillary applications as well using the <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a5daa6300fb73f70d4f9ad60c098cee41" title="Stepping function for integrators operating outside of Simulator that advances the continuous state e...">IntegrateWithMultipleSteps()</a> and <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aa6e4fa279a917c0ebb7995fce7b97a6b" title="Stepping function for integrators operating outside of Simulator that advances the continuous state e...">IntegrateWithSingleFixedStep()</a> methods; the latter permits the caller to advance time using fixed steps in applications where variable stepping would be deleterious (e.g., direct transcription).</p>
<p>For applications that require a more dense sampling of the system continuous state than what would be available through either fixed or error-controlled step integration (for a given accuracy), dense output support is available (through <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use. ">StartDenseIntegration()</a> and <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a127218e2c5251398b7a0740a32e2350c" title="Stops dense integration, yielding ownership of the current dense output to the caller. ">StopDenseIntegration()</a> methods). The accuracy and performance of these outputs may vary with each integration scheme implementation. Unless specified otherwise, an <a class="el" href="classdrake_1_1systems_1_1_hermitian_dense_output.html" title="A StepwiseDenseOutput class implementation using Hermitian interpolators, and therefore a continuous ...">HermitianDenseOutput</a> is provided by default.</p>
<p>A natural question for a user to ask of an integrator is: Which scheme (method) should be applied to a particular problem? The answer is whichever one most quickly computes the solution to the desired accuracy! Selecting an integration scheme for a particular problem is presently an artform. As examples of some selection criteria: multistep methods (none of which are currently implemented in Drake) generally work poorly when events (that require state reinitializations) are common, symplectic methods generally work well at maintaining stability for large integration steps, and stiff integrators are often best for computationally stiff systems. If ignorant as to the characteristics of a particular problem, it is often best to start with an explicit, Runge-Kutta type method. Statistics collected by the integrator can help diagnose performance issues and possibly point to the use of a different integration scheme.</p>
<p>Some systems are known to exhibit "computational stiffness", by which it is meant that (excessively) small integration steps are necessary for purposes of stability: in other words, steps must be taken smaller than that required to achieve a desired accuracy <em>over a particular interval</em>. Thus, the nature of computationally stiff problems is that the solution to the ODE is <em>smooth</em> in the interval of stiffness (in contrast, some problems possess such high frequency dynamics that very small steps are simply necessary to capture the solution accurately). Implicit integrators are the go-to approach for solving computationally stiff problems, but careful consideration is warranted. Implicit integrators typically require much more computation than non-implicit (explicit) integrators, stiffness might be an issue on only a very small time interval, and some problems might be only "moderately stiff". Put another way, applying an implicit integrator to a potentially stiff problem might not yield faster computation. The first chapter of [Hairer, 1996] illustrates the issues broached in this paragraph using various examples.</p>
<p>Established methods for integrating ordinary differential equations invariably make provisions for estimating the "local error" (i.e., the error over a small time interval) of a solution. Although the relationship between local error and global error (i.e., the accumulated error over multiple time steps) can be tenuous, such error estimates can allow integrators to work adaptively, subdividing time intervals as necessary (if, e.g., the system is particularly dynamic or stationary in an interval). Even for applications that do not recommend such adaptive integration- like direct transcription methods for trajectory optimization- error estimation allows the user to assess the accuracy of the solution.</p>
<p><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html" title="An abstract class for an integrator for ODEs and DAEs as represented by a Drake System. ">IntegratorBase</a> provides numerous settings and flags that can leverage problem-specific information to speed integration and/or improve integration accuracy. As an example, <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ae878ce4cdab7a01165423d8a902df452" title="Sets the maximum step size that may be taken by this integrator. ">set_maximum_step_size()</a> allows the user to prevent overly large integration steps (that integration error control alone might be insufficient to detect). As noted previously, <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html" title="An abstract class for an integrator for ODEs and DAEs as represented by a Drake System. ">IntegratorBase</a> also collects a plethora of statistics that can be used to diagnose poor integration performance. For example, a large number of shrinkages due to error control could indicate that a system is computationally stiff.</p>
<ul>
<li>[Hairer, 1996] E. Hairer and G. Wanner. Solving Ordinary Differential Equations II (Stiff and Differential-Algebraic Problems). Springer, 1996.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The vector element type, which must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a95ae527571e3f25c4415b93d12cb0ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ae527571e3f25c4415b93d12cb0ad9">&#9670;&nbsp;</a></span>StepResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95ae527571e3f25c4415b93d12cb0ad9">StepResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status returned by StepOnceAtMost(). </p>
<p>When a step is successful, it will return an indication of what caused it to stop where it did. When unsuccessful it will throw an exception so you won't see any return value. When return of control is due ONLY to reaching a publish time, (status is kReachedPublishTime) the context may return an interpolated value at an earlier time.</p>
<dl class="section note"><dt>Note</dt><dd>the simulation step must always end at an update time but can end after a publish time. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a95ae527571e3f25c4415b93d12cb0ad9a1eb5c205e3572ba9946f3c86f093c845"></a>kReachedPublishTime&#160;</td><td class="fielddoc"><p>Indicates a publish time has been reached but not an update time. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95ae527571e3f25c4415b93d12cb0ad9a1d1f7136371fa0489571cddeb08084e8"></a>kReachedZeroCrossing&#160;</td><td class="fielddoc"><p>Localized an event; this is the <em>before</em> state (interpolated). </p>
</td></tr>
<tr><td class="fieldname"><a id="a95ae527571e3f25c4415b93d12cb0ad9a804060ac669eb47e5d384d3800e59d9c"></a>kReachedUpdateTime&#160;</td><td class="fielddoc"><p>Indicates that integration terminated at an update time. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95ae527571e3f25c4415b93d12cb0ad9a8d552f806d347dcd4031fbce86195737"></a>kTimeHasAdvanced&#160;</td><td class="fielddoc"><p>User requested control whenever an internal step is successful. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95ae527571e3f25c4415b93d12cb0ad9ab50d451e0bcc5385a4bdfd6b3bf5482c"></a>kReachedBoundaryTime&#160;</td><td class="fielddoc"><p>Reached the desired integration time without reaching an update time. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95ae527571e3f25c4415b93d12cb0ad9a7ea4dacf674c208f87e90fa976d0829f"></a>kReachedStepLimit&#160;</td><td class="fielddoc"><p>Took maximum number of steps without finishing integrating over the interval. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3ecc7a468ab5fc69c4dd0beefd4aab08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">&#9670;&nbsp;</a></span>IntegratorBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0d908b973947061eaa9041e6a2b1442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d908b973947061eaa9041e6a2b1442">&#9670;&nbsp;</a></span>IntegratorBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a447030379c5091a36af0c158a0945c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447030379c5091a36af0c158a0945c6e">&#9670;&nbsp;</a></span>IntegratorBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maintains references to the system being integrated and the context used to specify the initial conditions for that system (if any). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system</td><td>A reference to the system to be integrated; the integrator will maintain a reference to the system in perpetuity, so the integrator must not outlive the system. </td></tr>
    <tr><td class="paramname">context</td><td>A pointer to a writeable context (nullptr is ok, but a non-null pointer must be set before <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a> is called). The integrator will advance the system state using the pointer to this context. The pointer to the context will be maintained internally. The integrator must not outlive the context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af88b1b96e061ad4e07a71561bf95fad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88b1b96e061ad4e07a71561bf95fad4">&#9670;&nbsp;</a></span>~IntegratorBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a673eb33420503190006ca91d01ec779e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673eb33420503190006ca91d01ec779e">&#9670;&nbsp;</a></span>CalcAdjustedStepSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classbool.html">bool</a>, T &gt; CalcAdjustedStepSize </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>attempted_step_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *&#160;</td>
          <td class="paramname"><em>at_minimum_step_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates adjusted integrator step sizes toward keeping state variables within error bounds on the next integration step. </p>
<p>Note that it is not guaranteed that the (possibly) reduced step size will keep state variables within error bounds; however, the process of (1) taking a trial integration step, (2) calculating the error, and (3) adjusting the step size can be repeated until convergence. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">err</td><td>The norm of the integrator error that was computed using <code>attempted_step_size</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">attempted_step_size</td><td>The step size that was attempted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">at_minimum_step_size</td><td>If <code>true</code> on entry, the error control mechanism is not allowed to shrink the step because the integrator is stepping at the minimum step size (note that this condition will only occur if <code><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a5b89a6384ec3f94a33c8fd2f4c384369" title="Reports the current setting of the throw_on_minimum_step_size_violation flag. ">get_throw_on_minimum_step_size_violation()</a> == false</code>- an exception would be thrown otherwise). If <code>true</code> on entry and <code>false</code> on exit, the error control mechanism has managed to increase the step size above the working minimum; if <code>true</code> on entry and <code>true</code> on exit, error control would like to shrink the step size but cannot. If <code>false</code> on entry and <code>true</code> on exit, error control shrank the step to the working minimum step size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of types bool and T; the bool will be set to <code>true</code> if the integration step was to be considered successful and <code>false</code> otherwise. The value of the T type will be set to the recommended next step size. </dd></dl>

</div>
</div>
<a id="a251c75be3ec4f5b14aeaf5ca2467416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251c75be3ec4f5b14aeaf5ca2467416f">&#9670;&nbsp;</a></span>CalcStateChangeNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CalcStateChangeNorm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dx_state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the infinity norm of a change in continuous state. </p>
<p>We use the infinity norm to capture the idea that, by providing accuracy requirements, the user can indirectly specify error tolerances that act to limit the largest error in any state vector component. </p><dl class="section return"><dt>Returns</dt><dd>the norm (a non-negative value) </dd></dl>

</div>
</div>
<a id="a6e8e4ee866da0e4ce7790986884b4f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8e4ee866da0e4ce7790986884b4f7b">&#9670;&nbsp;</a></span>CalcTimeDerivatives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcTimeDerivatives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>dxdt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the derivative function (and updates call statistics). </p>
<p>Subclasses should call this function rather than calling system.CalcTimeDerivatives() directly. </p>

</div>
</div>
<a id="a4ae67aca69c96bd3d1f84c97f96ddf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae67aca69c96bd3d1f84c97f96ddf02">&#9670;&nbsp;</a></span>CalcTimeDerivatives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcTimeDerivatives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; U &gt; *&#160;</td>
          <td class="paramname"><em>dxdt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the derivative function (and updates call statistics). </p>
<p>Subclasses should call this function rather than calling system.CalcTimeDerivatives() directly. This version of this function exists to allow integrators to count AutoDiff'd systems in derivative function evaluations. </p>

</div>
</div>
<a id="a07fc321896adb6729b2e9f82a647019f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fc321896adb6729b2e9f82a647019f">&#9670;&nbsp;</a></span>DoDenseStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> DoDenseStep </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes may implement this method to (1) integrate the continuous portion of this system forward by a single step of size <code>dt</code>, (2) set the error estimate (via <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95119340ec2f55ffe46e52252ef45855" title="Gets an error estimate of the state variables recorded by the last call to StepOnceFixedSize(). ">get_mutable_error_estimate()</a>) and (3) update their own dense output implementation (via <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#af5486345efbe28218f193275ef26896f" title="Returns a mutable pointer to the internally-maintained StepwiseDenseOutput instance, holding a representation of the continuous state trajectory since the last time StartDenseIntegration() was called. ">get_mutable_dense_output()</a>). </p>
<p>This method is called during the default Step() method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The integration step to take. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful, <code>false</code> if either the integrator was unable to take a single step of size <code>dt</code> or to advance its dense output an equal step. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a72100b015e62dc3c007c73cafdfd2ed7" title="Derived classes must implement this method to (1) integrate the continuous portion of this system for...">DoStep()</a> </dd></dl>

</div>
</div>
<a id="ae1949ad54a9dc1dc95f632a066aa12e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1949ad54a9dc1dc95f632a066aa12e6">&#9670;&nbsp;</a></span>DoInitialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoInitialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes can override this method to perform special initialization. </p>
<p>This method is called during the <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a> method. This default method does nothing. </p>

</div>
</div>
<a id="a22d9215849b8b5dfbdfce1cf00ce3221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d9215849b8b5dfbdfce1cf00ce3221">&#9670;&nbsp;</a></span>DoReset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes can override this method to perform routines when <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a372de693ad40b3f42839c8ec6ac845f4" title="Resets the integrator to initial values, i.e., default construction values. ">Reset()</a> is called. </p>
<p>This default method does nothing. </p>

</div>
</div>
<a id="ac5f5259be2ac9352879b53f559cbd567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f5259be2ac9352879b53f559cbd567">&#9670;&nbsp;</a></span>DoResetStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoResetStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets any statistics particular to a specific integrator. </p>
<p>The default implementation of this function does nothing. If your integrator collects its own statistics, you should re-implement this method and reset them there. </p>

</div>
</div>
<a id="a3484691218495df4f7e5867a9acf8c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3484691218495df4f7e5867a9acf8c38">&#9670;&nbsp;</a></span>DoStartDenseIntegration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_stepwise_dense_output.html">StepwiseDenseOutput</a>&lt;T&gt; &gt; DoStartDenseIntegration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes can override this method to provide a continuous extension of their own when <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use. ">StartDenseIntegration()</a> is called. </p>

</div>
</div>
<a id="a72100b015e62dc3c007c73cafdfd2ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72100b015e62dc3c007c73cafdfd2ed7">&#9670;&nbsp;</a></span>DoStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> DoStep </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes must implement this method to (1) integrate the continuous portion of this system forward by a single step of size <code>dt</code> and (2) set the error estimate (via <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95119340ec2f55ffe46e52252ef45855" title="Gets an error estimate of the state variables recorded by the last call to StepOnceFixedSize(). ">get_mutable_error_estimate()</a>). </p>
<p>This method is called during the default Step() method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The integration step to take. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful, <code>false</code> if the integrator was unable to take a single step of size <code>dt</code> (due to, e.g., an integrator convergence failure). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If the time on entry is denoted <code>t</code>, the time and state will be advanced to <code>t+dt</code> if the method returns <code>true</code>; otherwise, the time and state should be reset to those at <code>t</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is expected that <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a72100b015e62dc3c007c73cafdfd2ed7" title="Derived classes must implement this method to (1) integrate the continuous portion of this system for...">DoStep()</a> will return <code>true</code> for some, albeit possibly very small, positive value of <code>dt</code>. The derived integrator's stepping algorithm can make this guarantee, for example, by switching to an algorithm not subject to convergence failures (e.g., explicit Euler) for very small step sizes. </dd></dl>

</div>
</div>
<a id="a4ecfd0a8cbb76b7f43921e284b2a6980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecfd0a8cbb76b7f43921e284b2a6980">&#9670;&nbsp;</a></span>get_accuracy_in_use()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_accuracy_in_use </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the accuracy in use by the integrator. </p>
<p>This number may differ from the target accuracy if, for example, the user has requested an accuracy not attainable or not recommended for the particular integrator. </p>

</div>
</div>
<a id="a0ada2c620af585fefd269bbf0a7ff1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ada2c620af585fefd269bbf0a7ff1e9">&#9670;&nbsp;</a></span>get_actual_initial_step_size_taken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; get_actual_initial_step_size_taken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The actual size of the successful first step. </p>

</div>
</div>
<a id="a0ca73e48fb4c24fcf1893459f57eb86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca73e48fb4c24fcf1893459f57eb86a">&#9670;&nbsp;</a></span>get_context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt;T&gt;&amp; get_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> holding the most recent state in the trajectory. </p>
<p>This is suitable for publishing or extracting information about this trajectory step. </p>

</div>
</div>
<a id="ae6db8946d109961ca7516a4bb19c8378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6db8946d109961ca7516a4bb19c8378">&#9670;&nbsp;</a></span>get_dense_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_dense_output.html">DenseOutput</a>&lt;T&gt;* get_dense_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const pointer to the integrator's current <a class="el" href="classdrake_1_1systems_1_1_dense_output.html" title="An interface for dense output of ODE solutions, to efficiently approximate them at arbitrarily many p...">DenseOutput</a> instance, holding a representation of the continuous state trajectory since the last <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use. ">StartDenseIntegration()</a> call. </p>
<p>This is suitable to query the integrator's current dense output, if any (may be nullptr). </p>

</div>
</div>
<a id="a91c0da3a86a705e44833ec423e513971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c0da3a86a705e44833ec423e513971">&#9670;&nbsp;</a></span>get_error_estimate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt;T&gt;* get_error_estimate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the error estimate (used only for integrators that support error estimation). </p>
<p>If the integrator does not support error estimation, nullptr is returned. </p>

</div>
</div>
<a id="ab09a2cc2db0a776ca7bb11c8d8fe4831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09a2cc2db0a776ca7bb11c8d8fe4831">&#9670;&nbsp;</a></span>get_error_estimate_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classint.html">int</a> get_error_estimate_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes must override this function to return the order of the integrator's error estimate. </p>
<p>If the integrator does not provide an error estimate, the derived class implementation should return 0. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_implicit_euler_integrator.html#a7932e0cc0f116b8a625cb025616d73ab">ImplicitEulerIntegrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_semi_explicit_euler_integrator.html#a7932e0cc0f116b8a625cb025616d73ab">SemiExplicitEulerIntegrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_runge_kutta3_integrator.html#a7932e0cc0f116b8a625cb025616d73ab">RungeKutta3Integrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_explicit_euler_integrator.html#a7932e0cc0f116b8a625cb025616d73ab">ExplicitEulerIntegrator&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_runge_kutta2_integrator.html#a7932e0cc0f116b8a625cb025616d73ab">RungeKutta2Integrator&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ae35b01e013bbfa64d9cdccfa01f034fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35b01e013bbfa64d9cdccfa01f034fe">&#9670;&nbsp;</a></span>get_fixed_step_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> get_fixed_step_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether an integrator is running in fixed step mode. </p>
<p>If the integrator does not support error estimation, this function will always return <code>true</code>. If the integrator runs in fixed step mode, it will always take the maximum step size directed (which may be that determined by <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0dafbc057f2a5a4828813e7ea5e3f99e" title="Gets the maximum step size that may be taken by this integrator. ">get_maximum_step_size()</a> or may be smaller, as directed by, e.g., <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> for event handling purposes). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a53f8dced020f4fa9c3ccfc2eb6982a86" title="Sets an integrator with error control to fixed step mode. ">set_fixed_step_mode()</a> </dd></dl>

</div>
</div>
<a id="a1286e54624e71a19fa28e3564d2d9c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1286e54624e71a19fa28e3564d2d9c75">&#9670;&nbsp;</a></span>get_generalized_state_weight_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::VectorXd&amp; get_generalized_state_weight_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the weighting vector (equivalent to a diagonal matrix) applied to weighting both generalized coordinate and velocity state variable errors, as described in the group documentation. </p>
<p>Only used for integrators that support error estimation. </p>

</div>
</div>
<a id="aa06585bb16e4b92bb3c8f3c005fb6071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06585bb16e4b92bb3c8f3c005fb6071">&#9670;&nbsp;</a></span>get_ideal_next_step_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; get_ideal_next_step_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the step size the integrator would like to take next, based primarily on the integrator's accuracy prediction. </p>
<p>This value will not be computed for integrators that do not support error estimation and NaN will be returned. </p>

</div>
</div>
<a id="ac19919024e6d4d17453e610f57e53eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19919024e6d4d17453e610f57e53eba">&#9670;&nbsp;</a></span>get_initial_step_size_target()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; get_initial_step_size_target </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the target size of the first integration step. </p>
<p>You can find out what step size was <em>actually</em> used for the first integration step with <code><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0ada2c620af585fefd269bbf0a7ff1e9" title="The actual size of the successful first step. ">get_actual_initial_step_size_taken()</a></code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aaa818a52a133131208f51b1c0a3a906c" title="Request that the first attempted integration step have a particular size. ">request_initial_step_size_target()</a> </dd></dl>

</div>
</div>
<a id="a4d2e467101cf8c82f53ee1688227cf16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2e467101cf8c82f53ee1688227cf16">&#9670;&nbsp;</a></span>get_largest_step_size_taken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; get_largest_step_size_taken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the largest step taken since the last <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a> or <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics. ">ResetStatistics()</a> call. </p>

</div>
</div>
<a id="a0dafbc057f2a5a4828813e7ea5e3f99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dafbc057f2a5a4828813e7ea5e3f99e">&#9670;&nbsp;</a></span>get_maximum_step_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; get_maximum_step_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum step size that may be taken by this integrator. </p>
<p>This is a soft maximum: the integrator may stretch it by as much as 1% to hit a discrete event. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0f186af10e0fc1fc8f32fafa4fed7ba7" title="Sets the requested minimum step size h_min that may be taken by this integrator. ">set_requested_minimum_step_size()</a> </dd></dl>

</div>
</div>
<a id="ac3ccdda880715d682c035e1264441303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ccdda880715d682c035e1264441303">&#9670;&nbsp;</a></span>get_misc_state_weight_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::VectorXd&amp; get_misc_state_weight_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the weighting vector (equivalent to a diagonal matrix) for weighting errors in miscellaneous continuous state variables <code>z</code>. </p>
<p>Only used for integrators that support error estimation. </p>

</div>
</div>
<a id="a2d03f8fbbd6a4bce39d8fed752a5d446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d03f8fbbd6a4bce39d8fed752a5d446">&#9670;&nbsp;</a></span>get_mutable_context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt;T&gt;* get_mutable_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable pointer to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> holding the most recent state in the trajectory. </p>

</div>
</div>
<a id="af5486345efbe28218f193275ef26896f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5486345efbe28218f193275ef26896f">&#9670;&nbsp;</a></span>get_mutable_dense_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_stepwise_dense_output.html">StepwiseDenseOutput</a>&lt;T&gt;* get_mutable_dense_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable pointer to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_stepwise_dense_output.html" title="A DenseOutput class interface extension, geared towards step-wise construction procedures. ">StepwiseDenseOutput</a> instance, holding a representation of the continuous state trajectory since the last time <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use. ">StartDenseIntegration()</a> was called. </p>
<p>This is useful for derived classes to update the integrator's current dense output, if any (may be nullptr). </p>

</div>
</div>
<a id="a95119340ec2f55ffe46e52252ef45855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95119340ec2f55ffe46e52252ef45855">&#9670;&nbsp;</a></span>get_mutable_error_estimate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt;T&gt;* get_mutable_error_estimate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an error estimate of the state variables recorded by the last call to StepOnceFixedSize(). </p>
<p>If the integrator does not support error estimation, this function will return nullptr. </p>

</div>
</div>
<a id="a1a94ee74ec3449ce6a3e4601d7459e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a94ee74ec3449ce6a3e4601d7459e4e">&#9670;&nbsp;</a></span>get_mutable_generalized_state_weight_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;Eigen::VectorXd&gt; get_mutable_generalized_state_weight_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a mutable weighting vector (equivalent to a diagonal matrix) applied to weighting both generalized coordinate and velocity state variable errors, as described in the group documentation. </p>
<p>Only used for integrators that support error estimation. Returns a VectorBlock to make the values mutable without permitting changing the size of the vector. Requires re-initializing the integrator after calling this method; if <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a> is not called afterward, an exception will be thrown when attempting to call StepOnceAtMost(). If the caller sets one of the entries to a negative value, an exception will be thrown when the integrator is initialized. </p>

</div>
</div>
<a id="a80ee60f8a8a649e684340a9d19133098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ee60f8a8a649e684340a9d19133098">&#9670;&nbsp;</a></span>get_mutable_misc_state_weight_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;Eigen::VectorXd&gt; get_mutable_misc_state_weight_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a mutable weighting vector (equivalent to a diagonal matrix) for weighting errors in miscellaneous continuous state variables <code>z</code>. </p>
<p>Only used for integrators that support error estimation. Returns a VectorBlock to make the values mutable without permitting changing the size of the vector. Requires re-initializing the integrator after calling this method. If <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a> is not called afterward, an exception will be thrown when attempting to call StepOnceAtMost(). If the caller sets one of the entries to a negative value, an exception will be thrown when the integrator is initialized. </p>

</div>
</div>
<a id="ac3152b858f89491817273d05fa518289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3152b858f89491817273d05fa518289">&#9670;&nbsp;</a></span>get_num_derivative_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t get_num_derivative_evaluations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of ODE function evaluations (calls to <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a6e8e4ee866da0e4ce7790986884b4f7b" title="Evaluates the derivative function (and updates call statistics). ">CalcTimeDerivatives()</a>) since the last call to <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics. ">ResetStatistics()</a> or <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a>. </p>
<p>This count includes <em>all</em> such calls including (1) those necessary to compute Jacobian matrices; (2) those used in rejected integrated steps (for, e.g., purposes of error control); (3) those used strictly for integrator error estimation; and (4) calls that exhibit little cost (due to results being cached). </p>

</div>
</div>
<a id="a2b588edb71f956edad8a88d5c8b86479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b588edb71f956edad8a88d5c8b86479">&#9670;&nbsp;</a></span>get_num_step_shrinkages_from_error_control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t get_num_step_shrinkages_from_error_control </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of step size shrinkages due to failure to meet targeted error tolerances, since the last call to ResetStatistics or <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a>. </p>

</div>
</div>
<a id="a64333e8ed51bb6a29af25c2c4da153aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64333e8ed51bb6a29af25c2c4da153aa">&#9670;&nbsp;</a></span>get_num_step_shrinkages_from_substep_failures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t get_num_step_shrinkages_from_substep_failures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of step size shrinkages due to sub-step failures (e.g., integrator convergence failures) since the last call to <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics. ">ResetStatistics()</a> or <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a>. </p>

</div>
</div>
<a id="a215741958afe19af17a62470f883878b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215741958afe19af17a62470f883878b">&#9670;&nbsp;</a></span>get_num_steps_taken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t get_num_steps_taken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of integration steps taken since the last <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a> or <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics. ">ResetStatistics()</a> call. </p>

</div>
</div>
<a id="afa1597c69b7f633624a3693142ad3f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1597c69b7f633624a3693142ad3f04">&#9670;&nbsp;</a></span>get_num_substep_failures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t get_num_substep_failures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of failed sub-steps (implying one or more step size reductions was required to permit solving the necessary nonlinear system of equations). </p>

</div>
</div>
<a id="a9442cfd0320da3227579970a3ea0b506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9442cfd0320da3227579970a3ea0b506">&#9670;&nbsp;</a></span>get_previous_integration_step_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; get_previous_integration_step_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the last (previous) integration step. </p>
<p>If no integration steps have been taken, value will be NaN. </p>

</div>
</div>
<a id="a59add268d553fd546ffb04eca70b693b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59add268d553fd546ffb04eca70b693b">&#9670;&nbsp;</a></span>get_requested_minimum_step_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; get_requested_minimum_step_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the requested minimum step size <code>h_min</code> for this integrator. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0f186af10e0fc1fc8f32fafa4fed7ba7" title="Sets the requested minimum step size h_min that may be taken by this integrator. ">set_requested_minimum_step_size()</a> </dd>
<dd>
get_working_minimum_step_size(T) </dd></dl>

</div>
</div>
<a id="a245008509fc19d0282b2dfe9171740f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245008509fc19d0282b2dfe9171740f1">&#9670;&nbsp;</a></span>get_smallest_adapted_step_size_taken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; get_smallest_adapted_step_size_taken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the smallest step taken <em>as the result of a controlled integration step adjustment</em> since the last <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a> or <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics. ">ResetStatistics()</a> call. </p>
<p>This value will be NaN for integrators without error estimation. </p>

</div>
</div>
<a id="ab693dd7dd1da02154fc0f0ff6ef20692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab693dd7dd1da02154fc0f0ff6ef20692">&#9670;&nbsp;</a></span>get_stretch_factor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_stretch_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the stretch factor (&gt; 1), which is multiplied by the maximum (typically user-designated) integration step size to obtain the amount that the integrator is able to stretch the maximum time step toward hitting an upcoming publish or update event in <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aed535a106827b243e5da116944e72ae9" title="Integrates the system forward in time by a single step with step size subject to integration error to...">IntegrateAtMost()</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aed535a106827b243e5da116944e72ae9" title="Integrates the system forward in time by a single step with step size subject to integration error to...">IntegrateAtMost()</a> </dd></dl>

</div>
</div>
<a id="a5c403016877fd5f6291208aeb9a8063c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c403016877fd5f6291208aeb9a8063c">&#9670;&nbsp;</a></span>get_system()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt;T&gt;&amp; get_system </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a constant reference to the system that is being integrated (and was provided to the constructor of the integrator). </p>

</div>
</div>
<a id="a630ba1d30cec20bb83e5a678945ffaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630ba1d30cec20bb83e5a678945ffaa2">&#9670;&nbsp;</a></span>get_target_accuracy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_target_accuracy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the target accuracy. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a4ecfd0a8cbb76b7f43921e284b2a6980" title="Gets the accuracy in use by the integrator. ">get_accuracy_in_use()</a> </dd></dl>

</div>
</div>
<a id="a5b89a6384ec3f94a33c8fd2f4c384369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b89a6384ec3f94a33c8fd2f4c384369">&#9670;&nbsp;</a></span>get_throw_on_minimum_step_size_violation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> get_throw_on_minimum_step_size_violation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the current setting of the throw_on_minimum_step_size_violation flag. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a78773e63a07381351e18380040f5fc13" title="Sets whether the integrator should throw a std::runtime_error exception when the integrator&#39;s step si...">set_throw_on_minimum_step_size_violation()</a>. </dd></dl>

</div>
</div>
<a id="a47399e48a6a661ce1b8252d86a305b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47399e48a6a661ce1b8252d86a305b54">&#9670;&nbsp;</a></span>get_working_minimum_step_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T get_working_minimum_step_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current value of the working minimum step size <code>h_work(t)</code> for this integrator, which may vary with the current time t as stored in the integrator's context. </p>
<p>See <a class="el" href="#Minstep">this section </a> for more detail. </p>

</div>
</div>
<a id="a98b1050f09da390896f964fb7a892391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b1050f09da390896f964fb7a892391">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An integrator must be initialized before being used. </p>
<p>The pointer to the context must be set before <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a> is called (or an std::logic_error will be thrown). If <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a> is not called, an exception will be thrown when attempting to call StepOnceAtMost(). To reinitialize the integrator, <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a372de693ad40b3f42839c8ec6ac845f4" title="Resets the integrator to initial values, i.e., default construction values. ">Reset()</a> should be called followed by <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If the context has not been set or a user-set parameter has been set illogically (i.e., one of the weighting matrix coefficients is set to a negative value- this check is only performed for integrators that support error estimation; the maximum step size is smaller than the minimum step size; the requested initial step size is outside of the interval [minimum step size, maximum step size]). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a372de693ad40b3f42839c8ec6ac845f4" title="Resets the integrator to initial values, i.e., default construction values. ">Reset()</a> </dd></dl>

</div>
</div>
<a id="adaec34b208033abe28e8cb8e63c9974b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaec34b208033abe28e8cb8e63c9974b">&#9670;&nbsp;</a></span>InitializeAccuracy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void InitializeAccuracy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>default_accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>loosest_accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>max_step_fraction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic code for validating (and resetting, if need be) the integrator working accuracy for error controlled integrators. </p>
<p>This method is intended to be called from an integrator's <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ae1949ad54a9dc1dc95f632a066aa12e6" title="Derived classes can override this method to perform special initialization. ">DoInitialize()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_accuracy</td><td>a reasonable default accuracy setting for this integrator. </td></tr>
    <tr><td class="paramname">loosest_accuracy</td><td>the loosest accuracy that this integrator should support. </td></tr>
    <tr><td class="paramname">max_step_fraction</td><td>a fraction of the maximum step size to use when setting the integrator accuracy and the user has not specified accuracy directly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if neither the initial step size target nor the maximum step size has been set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed535a106827b243e5da116944e72ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed535a106827b243e5da116944e72ae9">&#9670;&nbsp;</a></span>IntegrateAtMost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt; T &gt;::<a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a95ae527571e3f25c4415b93d12cb0ad9">StepResult</a> IntegrateAtMost </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>publish_dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>update_dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>boundary_dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrates the system forward in time by a single step with step size subject to integration error tolerances (assuming that the integrator supports error estimation). </p>
<p>The integrator must already have been initialized or an exception will be thrown. The context will be integrated forward by an amount that will never exceed the minimum of <code>publish_dt</code>, <code>update_dt</code>, and <code>1.01 * <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0dafbc057f2a5a4828813e7ea5e3f99e" title="Gets the maximum step size that may be taken by this integrator. ">get_maximum_step_size()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">publish_dt</td><td>The step size, &gt;= 0.0 (exception will be thrown if this is not the case) at which the next publish will occur. </td></tr>
    <tr><td class="paramname">update_dt</td><td>The step size, &gt;= 0.0 (exception will be thrown if this is not the case) at which the next update will occur. </td></tr>
    <tr><td class="paramname">boundary_dt</td><td>The step size, &gt;= 0.0 (exception will be thrown if this is not the case) marking the end of the user-designated simulated interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If the integrator has not been initialized or one of publish_dt, update_dt, or boundary_dt is negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reason for the integration step ending. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Users should generally not call this function directly; within simulation circumstances, users will typically call <code><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa62a8142a25d9902f0f220e35f3123aa" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">Simulator::StepTo()</a></code>. In other circumstances, users will typically call <code><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a5daa6300fb73f70d4f9ad60c098cee41" title="Stepping function for integrators operating outside of Simulator that advances the continuous state e...">IntegratorBase::IntegrateWithMultipleSteps()</a></code>.</dd></dl>
<p>This method at a glance:</p>
<ul>
<li>For integrating ODEs/DAEs via <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a></li>
<li>Supports fixed step and variable step integration schemes</li>
<li>Takes only a single step forward. </li>
</ul>

</div>
</div>
<a id="a5daa6300fb73f70d4f9ad60c098cee41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5daa6300fb73f70d4f9ad60c098cee41">&#9670;&nbsp;</a></span>IntegrateWithMultipleSteps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IntegrateWithMultipleSteps </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stepping function for integrators operating outside of <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> that advances the continuous state exactly by <code>dt</code>. </p>
<p>This method is designed for integrator users that do not wish to consider publishing or discontinuous, mid-interval updates. This method will step the integrator multiple times, as necessary, to attain requested error tolerances and to ensure the integrator converges. </p><dl class="section warning"><dt>Warning</dt><dd>Users should simulate systems using <code><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa62a8142a25d9902f0f220e35f3123aa" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">Simulator::StepTo()</a></code> in place of this function (which was created for off-simulation purposes), generally. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The non-negative integration step to take. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If the integrator has not been initialized or dt is negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aed535a106827b243e5da116944e72ae9" title="Integrates the system forward in time by a single step with step size subject to integration error to...">IntegrateAtMost()</a>, which is designed to be operated by <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> and accounts for publishing and state reinitialization. </dd>
<dd>
IntegrateWithSingleStep(), which is also designed to be operated <em>outside of</em> <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a>, but throws an exception if the integrator cannot advance <a class="el" href="robot__plan__interpolator__test_8cc.html#a97f443479343d27ae6800e77d16ae3f1">time</a> by <code>dt</code> in a single step.</dd></dl>
<p>This method at a glance:</p>
<ul>
<li>For integrating ODEs/DAEs not using <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a></li>
<li>Supports fixed step and variable step integration schemes</li>
<li>Takes as many steps as necessary until time has advanced by <code>dt</code> </li>
</ul>

</div>
</div>
<a id="aa6e4fa279a917c0ebb7995fce7b97a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e4fa279a917c0ebb7995fce7b97a6b">&#9670;&nbsp;</a></span>IntegrateWithSingleFixedStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IntegrateWithSingleFixedStep </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stepping function for integrators operating outside of <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> that advances the continuous state exactly by <code>dt</code> <em>and using a single fixed step</em>. </p>
<p>This method is designed for integrator users that do not wish to consider publishing or discontinuous, mid-interval updates. One such example application is that of direct transcription for trajectory optimization, for which the integration process should be <em>consistent</em>: it should execute the same sequence of arithmetic operations for all values of the nonlinear programming variables. In keeping with the naming semantics of this function, error controlled integration is not supported (though error estimates will be computed for integrators that support that feature), which is a minimal requirement for "consistency". </p><dl class="section warning"><dt>Warning</dt><dd>Users should simulate systems using <code><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa62a8142a25d9902f0f220e35f3123aa" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">Simulator::StepTo()</a></code> in place of this function (which was created for off-simulation purposes), generally. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The non-negative integration step to take. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If the integrator has not been initialized or dt is negative <b>or</b> if the integrator is not operating in fixed step mode. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>If the integrator was unable to take a step of the requested size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#aed535a106827b243e5da116944e72ae9" title="Integrates the system forward in time by a single step with step size subject to integration error to...">IntegrateAtMost()</a>, which is designed to be operated by <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> and accounts for publishing and state reinitialization. </dd>
<dd>
<a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a5daa6300fb73f70d4f9ad60c098cee41" title="Stepping function for integrators operating outside of Simulator that advances the continuous state e...">IntegrateWithMultipleSteps()</a>, which is also designed to be operated <em>outside of</em> <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a>, but will take as many integration steps as necessary until <a class="el" href="robot__plan__interpolator__test_8cc.html#a97f443479343d27ae6800e77d16ae3f1">time</a> has been stepped forward by <code>dt</code>.</dd></dl>
<p>This method at a glance:</p>
<ul>
<li>For integrating ODEs/DAEs not using <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a></li>
<li>Fixed step integration (no step size reductions for error control or integrator convergence)</li>
<li>Takes only a single step forward. </li>
</ul>

</div>
</div>
<a id="a7a2108348656c73efe1d72702c96d5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2108348656c73efe1d72702c96d5c5">&#9670;&nbsp;</a></span>is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the integrator has been initialized. </p>

</div>
</div>
<a id="a0e5d79c4be26ab9ff12fac51584dd3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5d79c4be26ab9ff12fac51584dd3f5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00778f31642c811fde02c61333aa5a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00778f31642c811fde02c61333aa5a25">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa818a52a133131208f51b1c0a3a906c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa818a52a133131208f51b1c0a3a906c">&#9670;&nbsp;</a></span>request_initial_step_size_target()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void request_initial_step_size_target </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>step_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request that the first attempted integration step have a particular size. </p>
<p>If no request is made, the integrator will estimate a suitable size for the initial step attempt. <em>If the integrator does not support error control</em>, this method will throw a std::logic_error (call <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a5fa66573f5abb1dc153098d2920c32b7" title="Indicates whether an integrator supports error estimation. ">supports_error_estimation()</a> to verify before calling this method). For variable-step integration, the initial target will be treated as a maximum step size subject to accuracy requirements and event occurrences. You can find out what size <em>actually</em> worked with <code><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0ada2c620af585fefd269bbf0a7ff1e9" title="The actual size of the successful first step. ">get_actual_initial_step_size_taken()</a></code>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If the integrator does not support error estimation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a372de693ad40b3f42839c8ec6ac845f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372de693ad40b3f42839c8ec6ac845f4">&#9670;&nbsp;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the integrator to initial values, i.e., default construction values. </p>

</div>
</div>
<a id="ae9ec42d998ad39014c3dc64c50cfbc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ec42d998ad39014c3dc64c50cfbc4d">&#9670;&nbsp;</a></span>reset_context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reset_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the pointer to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> with a different one. </p>
<p>This is useful for supplying a new set of initial conditions or wiping out the current context (by passing in a null pointer). You should invoke <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a> after replacing the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> unless the context is null. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the new context or nullptr to wipe out the current context without replacing it with another. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64a01ac56f8a0086cc6ed335ee9e5caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a01ac56f8a0086cc6ed335ee9e5caa">&#9670;&nbsp;</a></span>ResetStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ResetStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forget accumulated statistics. </p>
<p>These are reset to the values they have post construction or immediately after <code><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used. ">Initialize()</a></code>. </p>

</div>
</div>
<a id="a5296d2467ea109300a687233eb159a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5296d2467ea109300a687233eb159a46">&#9670;&nbsp;</a></span>set_accuracy_in_use()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_accuracy_in_use </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>accuracy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the working ("in use") accuracy for this integrator. </p>
<p>The working accuracy may not be equivalent to the target accuracy when the latter is too loose or tight for an integrator's capabilities. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a4ecfd0a8cbb76b7f43921e284b2a6980" title="Gets the accuracy in use by the integrator. ">get_accuracy_in_use()</a> </dd>
<dd>
<a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a630ba1d30cec20bb83e5a678945ffaa2" title="Gets the target accuracy. ">get_target_accuracy()</a> </dd></dl>

</div>
</div>
<a id="ae5677b9c7efe7d9a3e9547dd5e3ef5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5677b9c7efe7d9a3e9547dd5e3ef5a4">&#9670;&nbsp;</a></span>set_actual_initial_step_size_taken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_actual_initial_step_size_taken </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53f8dced020f4fa9c3ccfc2eb6982a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f8dced020f4fa9c3ccfc2eb6982a86">&#9670;&nbsp;</a></span>set_fixed_step_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_fixed_step_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets an integrator with error control to fixed step mode. </p>
<p>If the integrator runs in fixed step mode, it will always take the maximum step size directed (which may be that determined by <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0dafbc057f2a5a4828813e7ea5e3f99e" title="Gets the maximum step size that may be taken by this integrator. ">get_maximum_step_size()</a>, or may be smaller, as directed by, e.g., <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> for event handling purposes). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if integrator does not support error estimation and <code>flag</code> is set to <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a2e65cf13be95165017e7363bf7944d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2e65cf13be95165017e7363bf7944d">&#9670;&nbsp;</a></span>set_ideal_next_step_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_ideal_next_step_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac61498c3a3ddfbf626ea0bea29884df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac61498c3a3ddfbf626ea0bea29884df">&#9670;&nbsp;</a></span>set_largest_step_size_taken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_largest_step_size_taken </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae878ce4cdab7a01165423d8a902df452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae878ce4cdab7a01165423d8a902df452">&#9670;&nbsp;</a></span>set_maximum_step_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_maximum_step_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max_step_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum step size that may be taken by this integrator. </p>
<p>The integrator may stretch the maximum step size by as much as 1% to reach a discrete event. For fixed step integrators, all steps will be taken at the maximum step size <em>unless</em> an event would be missed. </p>

</div>
</div>
<a id="a0f186af10e0fc1fc8f32fafa4fed7ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f186af10e0fc1fc8f32fafa4fed7ba7">&#9670;&nbsp;</a></span>set_requested_minimum_step_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_requested_minimum_step_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>min_step_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the requested minimum step size <code>h_min</code> that may be taken by this integrator. </p>
<p>No step smaller than this will be taken except under circumstances as described <a class="el" href="#Minstep">above. </a> This setting will be ignored if it is smaller than the absolute minimum <code>h_floor</code> also described above. Default value is zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_step_size</td><td>a non-negative value. Setting this value to zero will cause the integrator to use a reasonable value instead (see <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a47399e48a6a661ce1b8252d86a305b54" title="Gets the current value of the working minimum step size h_work(t) for this integrator, which may vary with the current time t as stored in the integrator&#39;s context. ">get_working_minimum_step_size()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a59add268d553fd546ffb04eca70b693b" title="Gets the requested minimum step size h_min for this integrator. ">get_requested_minimum_step_size()</a> </dd>
<dd>
<a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a47399e48a6a661ce1b8252d86a305b54" title="Gets the current value of the working minimum step size h_work(t) for this integrator, which may vary with the current time t as stored in the integrator&#39;s context. ">get_working_minimum_step_size()</a> </dd></dl>

</div>
</div>
<a id="a07ea35d1b2a56ca9f9eebb7764ca9dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ea35d1b2a56ca9f9eebb7764ca9dfa">&#9670;&nbsp;</a></span>set_smallest_adapted_step_size_taken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_smallest_adapted_step_size_taken </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the size of the smallest-step-taken statistic as the result of a controlled integration step adjustment. </p>

</div>
</div>
<a id="a6dbb07017a30541d06b2b597d1e4f30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dbb07017a30541d06b2b597d1e4f30f">&#9670;&nbsp;</a></span>set_target_accuracy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_target_accuracy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>accuracy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request that the integrator attempt to achieve a particular accuracy for the continuous portions of the simulation. </p>
<p>Otherwise a default accuracy is chosen for you. This may be ignored for fixed-step integration since accuracy control requires variable step sizes. You should call <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a5fa66573f5abb1dc153098d2920c32b7" title="Indicates whether an integrator supports error estimation. ">supports_error_estimation()</a> to ensure that the integrator supports this capability before calling this function; if the integrator does not support it, this method will throw an exception.</p>
<p>Integrators vary in the range of accuracy (loosest to tightest) that they can support. If you request accuracy outside the supported range for the chosen integrator it will be quietly adjusted to be in range. You can find out the accuracy setting actually being used using <code><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a4ecfd0a8cbb76b7f43921e284b2a6980" title="Gets the accuracy in use by the integrator. ">get_accuracy_in_use()</a></code>.</p>
<p>The precise meaning of <em>accuracy</em> is a complicated discussion, but translates roughly to the number of significant digits you want in the results. By convention it is supplied as <code>10^-digits</code>, meaning that an accuracy of 1e-3 provides about three significant digits. For more information, see [Sherman 2011].</p><ul>
<li>M. Sherman, et al. Procedia IUTAM 2:241-261 (2011), Section 3.3. <a href="http://dx.doi.org/10.1016/j.piutam.2011.04.023">http://dx.doi.org/10.1016/j.piutam.2011.04.023</a> <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if integrator does not support error estimation. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a78773e63a07381351e18380040f5fc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78773e63a07381351e18380040f5fc13">&#9670;&nbsp;</a></span>set_throw_on_minimum_step_size_violation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_throw_on_minimum_step_size_violation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>throws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the integrator should throw a std::runtime_error exception when the integrator's step size selection algorithm determines that it must take a step smaller than the minimum step size (for, e.g., purposes of error control). </p>
<p>Default is <code>true</code>. If <code>false</code>, the integrator will advance time and state using the minimum specified step size in such situations. See <a class="el" href="#Minstep">this section </a> for more detail. </p>

</div>
</div>
<a id="a0cdd4796b7f98a09da058b9764f13b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdd4796b7f98a09da058b9764f13b86">&#9670;&nbsp;</a></span>StartDenseIntegration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StartDenseIntegration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts dense integration, allocating a new dense output for this integrator to use. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The integrator has been initialized. </dd>
<dd>
The system being integrated has continuous state. </dd>
<dd>
No dense integration is in progress (no dense output is held by the integrator) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if any of the preconditions is not met. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Dense integration may incur significant overhead. </dd></dl>

</div>
</div>
<a id="a511fcd8f6468ddea15317190f14cf860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511fcd8f6468ddea15317190f14cf860">&#9670;&nbsp;</a></span>StepOnceErrorControlledAtMost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> StepOnceErrorControlledAtMost </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dt_max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default code for advancing the continuous state of the system by a single step of <code>dt_max</code> (or smaller, depending on error control). </p>
<p>This particular function is designed to be called directly by an error estimating integrator's <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a72100b015e62dc3c007c73cafdfd2ed7" title="Derived classes must implement this method to (1) integrate the continuous portion of this system for...">DoStep()</a> method to effect error-controlled integration. The integrator can effect error controlled integration without calling this method, if the implementer so chooses, but this default method is expected to function well in most circumstances. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt_max</td><td>The maximum step size to be taken. The integrator may take a smaller step than specified to satisfy accuracy requirements, to resolve integrator convergence problems, or to respect the integrator's maximum step size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if integrator does not support error estimation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will shrink the integration step as necessary whenever the integrator's <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a72100b015e62dc3c007c73cafdfd2ed7" title="Derived classes must implement this method to (1) integrate the continuous portion of this system for...">DoStep()</a> fails to take the requested step e.g., due to integrator convergence failure. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the full step of size <code>dt_max</code> is taken and <code>false</code> otherwise (i.e., a smaller step than <code>dt_max</code> was taken). </dd></dl>

</div>
</div>
<a id="a127218e2c5251398b7a0740a32e2350c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127218e2c5251398b7a0740a32e2350c">&#9670;&nbsp;</a></span>StopDenseIntegration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_dense_output.html">DenseOutput</a>&lt;T&gt; &gt; StopDenseIntegration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops dense integration, yielding ownership of the current dense output to the caller. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This process is irreversible. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classdrake_1_1systems_1_1_dense_output.html" title="An interface for dense output of ODE solutions, to efficiently approximate them at arbitrarily many p...">DenseOutput</a> instance, i.e. a representation of the continuous state trajectory of the system being integrated that can be evaluated at any time within its extension. This representation is defined starting at the context time of the last <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use. ">StartDenseIntegration()</a> call and finishing at the current context time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Dense integration is in progress (a dense output is held by this integrator, after a call to <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use. ">StartDenseIntegration()</a>). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Previously held dense output is not updated nor referenced by the integrator anymore. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if any of the preconditions is not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fa66573f5abb1dc153098d2920c32b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa66573f5abb1dc153098d2920c32b7">&#9670;&nbsp;</a></span>supports_error_estimation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> supports_error_estimation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether an integrator supports error estimation. </p>
<p>Without error estimation, target accuracy will be unused. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_implicit_euler_integrator.html#a52ddb8ce13134e8e8afdfcfde6fd75ec">ImplicitEulerIntegrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_semi_explicit_euler_integrator.html#a52ddb8ce13134e8e8afdfcfde6fd75ec">SemiExplicitEulerIntegrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_runge_kutta3_integrator.html#a52ddb8ce13134e8e8afdfcfde6fd75ec">RungeKutta3Integrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_explicit_euler_integrator.html#a52ddb8ce13134e8e8afdfcfde6fd75ec">ExplicitEulerIntegrator&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_runge_kutta2_integrator.html#a52ddb8ce13134e8e8afdfcfde6fd75ec">RungeKutta2Integrator&lt; T &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/systems/analysis/<a class="el" href="integrator__base_8h.html">integrator_base.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1systems.html">systems</a></li><li class="navelem"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
