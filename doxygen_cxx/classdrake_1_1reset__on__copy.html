<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: reset_on_copy&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1reset__on__copy.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1reset__on__copy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reset_on_copy&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Type wrapper that performs value-initialization on copy construction or assignment.  
 <a href="classdrake_1_1reset__on__copy.html#details">More...</a></p>

<p><code>#include &lt;drake/common/reset_on_copy.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac4c2f4aff329cb5d4311f7a5a04b0020"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__on__copy.html#ac4c2f4aff329cb5d4311f7a5a04b0020">reset_on_copy</a> () noexcept(std::is_nothrow_default_constructible&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>)</td></tr>
<tr class="memdesc:ac4c2f4aff329cb5d4311f7a5a04b0020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a reset_on_copy&lt;T&gt; with a value-initialized wrapped value.  <a href="#ac4c2f4aff329cb5d4311f7a5a04b0020">More...</a><br /></td></tr>
<tr class="separator:ac4c2f4aff329cb5d4311f7a5a04b0020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f27171aa2680bdb513d67212f0d8713"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__on__copy.html#a4f27171aa2680bdb513d67212f0d8713">reset_on_copy</a> (const T &amp;<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>) noexcept(std::is_nothrow_copy_constructible&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>)</td></tr>
<tr class="memdesc:a4f27171aa2680bdb513d67212f0d8713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a reset_on_copy&lt;T&gt; with a copy of the given value.  <a href="#a4f27171aa2680bdb513d67212f0d8713">More...</a><br /></td></tr>
<tr class="separator:a4f27171aa2680bdb513d67212f0d8713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af387627cc9bea3825e5b15a2d8e7f6b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__on__copy.html#af387627cc9bea3825e5b15a2d8e7f6b7">reset_on_copy</a> (T &amp;&amp;<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>) noexcept(std::is_nothrow_move_constructible&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>)</td></tr>
<tr class="memdesc:af387627cc9bea3825e5b15a2d8e7f6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a reset_on_copy&lt;T&gt; with the given wrapped value, by move construction if possible.  <a href="#af387627cc9bea3825e5b15a2d8e7f6b7">More...</a><br /></td></tr>
<tr class="separator:af387627cc9bea3825e5b15a2d8e7f6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements copy/move construction and assignment.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These make reset_on_copy objects CopyConstructible, CopyAssignable, MoveConstructible, and MoveAssignable.</p>
</div></td></tr>
<tr class="memitem:ab8b1be347012bdfab8e461085598f51b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__on__copy.html#ab8b1be347012bdfab8e461085598f51b">reset_on_copy</a> (const <a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a> &amp;) noexcept(std::is_nothrow_default_constructible&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>)</td></tr>
<tr class="memdesc:ab8b1be347012bdfab8e461085598f51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor just value-initializes instead; the source is ignored.  <a href="#ab8b1be347012bdfab8e461085598f51b">More...</a><br /></td></tr>
<tr class="separator:ab8b1be347012bdfab8e461085598f51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2fe58dab3f89ed510b00e6c87dd807"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__on__copy.html#a1d2fe58dab3f89ed510b00e6c87dd807">operator=</a> (const <a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a> &amp;source) noexcept(std::is_nothrow_destructible&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_nothrow_default_constructible&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>)</td></tr>
<tr class="memdesc:a1d2fe58dab3f89ed510b00e6c87dd807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment just destructs the contained value and then value-initializes it, <em>except</em> for self-assignment which does nothing.  <a href="#a1d2fe58dab3f89ed510b00e6c87dd807">More...</a><br /></td></tr>
<tr class="separator:a1d2fe58dab3f89ed510b00e6c87dd807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b9d58cd7ec58ee8c08daa452c73332"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__on__copy.html#a66b9d58cd7ec58ee8c08daa452c73332">reset_on_copy</a> (<a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a> &amp;&amp;source) noexcept(std::is_nothrow_move_constructible&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_nothrow_destructible&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_nothrow_default_constructible&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>)</td></tr>
<tr class="memdesc:a66b9d58cd7ec58ee8c08daa452c73332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construction uses T's move constructor, then destructs and value initializes the source.  <a href="#a66b9d58cd7ec58ee8c08daa452c73332">More...</a><br /></td></tr>
<tr class="separator:a66b9d58cd7ec58ee8c08daa452c73332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4446b27ca27362773c2e92839f3553b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__on__copy.html#a4446b27ca27362773c2e92839f3553b1">operator=</a> (<a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a> &amp;&amp;source) noexcept(std::is_nothrow_move_assignable&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_nothrow_destructible&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_nothrow_default_constructible&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>)</td></tr>
<tr class="memdesc:a4446b27ca27362773c2e92839f3553b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment uses T's move assignment, then destructs and value initializes the source, <em>except</em> for self-assignment which does nothing.  <a href="#a4446b27ca27362773c2e92839f3553b1">More...</a><br /></td></tr>
<tr class="separator:a4446b27ca27362773c2e92839f3553b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implicit conversion operators to make reset_on_copy&lt;T&gt; act</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>as the wrapped type.</p>
</div></td></tr>
<tr class="memitem:a6ceeab0526636cedb9ccf57adf1ce379"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__on__copy.html#a6ceeab0526636cedb9ccf57adf1ce379">operator T &amp;</a> () noexcept</td></tr>
<tr class="separator:a6ceeab0526636cedb9ccf57adf1ce379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21e380b520fb649d3d8c0403f98f48a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__on__copy.html#aa21e380b520fb649d3d8c0403f98f48a">operator const T &amp;</a> () const noexcept</td></tr>
<tr class="separator:aa21e380b520fb649d3d8c0403f98f48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dereference operators if T is a pointer type.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>If type T is a pointer, these exist and return the pointed-to object.</p>
<p>For non-pointer types these methods are not instantiated. </p>
</div></td></tr>
<tr class="memitem:a8bc1ed702a031203e0a7caa1ab6b544d"><td class="memTemplParams" colspan="2">template&lt;typename T1  = T&gt; </td></tr>
<tr class="memitem:a8bc1ed702a031203e0a7caa1ab6b544d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_pointer&lt; T1 &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__on__copy.html#a8bc1ed702a031203e0a7caa1ab6b544d">operator-&gt;</a> () const noexcept</td></tr>
<tr class="separator:a8bc1ed702a031203e0a7caa1ab6b544d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae427702dac375af45ad8272fb8424102"><td class="memTemplParams" colspan="2">template&lt;typename T1  = T&gt; </td></tr>
<tr class="memitem:ae427702dac375af45ad8272fb8424102"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_pointer&lt; T1 &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, std::add_lvalue_reference_t&lt; std::remove_pointer_t&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__on__copy.html#ae427702dac375af45ad8272fb8424102">operator*</a> () const noexcept</td></tr>
<tr class="separator:ae427702dac375af45ad8272fb8424102"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::reset_on_copy&lt; T &gt;</h3>

<p>Type wrapper that performs value-initialization on copy construction or assignment. </p>
<p>Rather than copying the source supplied for copy construction or copy assignment, this wrapper instead value-initializes the destination object. Move assignment and construction preserve contents in the destination as usual, but reset the source to its value-initialized value.</p>
<p>Only types T that satisfy <code>std::is_scalar&lt;T&gt;</code> are currently permitted: integral and floating point types, enums, and pointers. Value initialization means the initialization performed when a variable is constructed with an empty initializer <code>{}</code>. For the restricted set of types we support, that just means that numeric types are set to zero and pointer types are set to nullptr. Also, all the methods here are noexcept due to the <code>std::is_scalar&lt;T&gt;</code> restriction. See <a href="http://en.cppreference.com/w/cpp/language/value_initialization">http://en.cppreference.com/w/cpp/language/value_initialization</a>.</p>
<p>Background:</p>
<p>It is preferable to use default copy construction for classes whenever possible because it avoids difficult-to-maintain enumeration of member fields in bespoke copy constructors. The presence of fields that must be reset to zero in the copy (counters, for example) prevents use of default copy construction. Similarly, pointers that would be invalid in the copy need to be set to null to avoid stale references. By wrapping those problematic data members in this adapter, default copy construction can continue to be used, with all data members copied properly except the designated ones, which are value-initialized instead. The resetting of the source on move doesn't change semantics since the condition of the source after a move is generally undefined. It is instead opportunistic good hygiene for early detection of bugs, taking advantage of the fact that we know type T can be value-initialized. See <a class="el" href="classdrake_1_1reset__after__move.html" title="Type wrapper that performs value-initialization on the wrapped type, and guarantees that when moving ...">reset_after_move</a> for more discussion.</p>
<p>Example:</p>
<pre>
class Foo {
 public:
  <a class="el" href="drake__copyable_8h.html#ae6322b9e40935343a422cbdfb41e310e" title="DRAKE_DEFAULT_COPY_AND_MOVE_AND_ASSIGN defaults the special member functions for copy-construction, copy-assignment, move-construction, and move-assignment. ">DRAKE_DEFAULT_COPY_AND_MOVE_AND_ASSIGN(Foo)</a>
  <a class="el" href="never__destroyed__test_8cc.html#aa621f6f849ec2327dabfc4392fd59a70">Foo()</a> = default;</pre><pre> private:
  std::vector&lt;int&gt; items_;
  reset_on_copy&lt;int&gt; use_count_;
};
</pre><p>When copying from <code>Foo</code>, the new object will contain a copy of <code>items_</code> but <code>use_count_</code> will be zero. If <code>Foo</code> had not used the <code><a class="el" href="classdrake_1_1reset__on__copy.html" title="Type wrapper that performs value-initialization on copy construction or assignment. ">reset_on_copy</a></code> wrapper, <code>use_count_</code> would have been copied also, which we're assuming is not the desired behavior here.</p>
<dl class="section warning"><dt>Warning</dt><dd>Even if you initialize a reset_on_copy member to a non-zero value using an initializer like <code><a class="el" href="classdrake_1_1reset__on__copy.html" title="Type wrapper that performs value-initialization on copy construction or assignment. ">reset_on_copy</a>&lt;int&gt; some_member_{5}</code> it will be <em>reset</em> to zero, not <em>reinitialized</em> to 5 when copied.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Enum types T are permitted, but be aware that they will be reset to zero, regardless of whether 0 is one of the specified enumeration values.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>must satisfy <code>std::is_scalar&lt;T&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1reset__after__move.html" title="Type wrapper that performs value-initialization on the wrapped type, and guarantees that when moving ...">reset_after_move</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac4c2f4aff329cb5d4311f7a5a04b0020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c2f4aff329cb5d4311f7a5a04b0020">&#9670;&nbsp;</a></span>reset_on_copy() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a reset_on_copy&lt;T&gt; with a value-initialized wrapped value. </p>

</div>
</div>
<a id="a4f27171aa2680bdb513d67212f0d8713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f27171aa2680bdb513d67212f0d8713">&#9670;&nbsp;</a></span>reset_on_copy() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a reset_on_copy&lt;T&gt; with a copy of the given value. </p>
<p>This is an implicit conversion, so that reset_on_copy&lt;T&gt; behaves more like the unwrapped type. </p>

</div>
</div>
<a id="af387627cc9bea3825e5b15a2d8e7f6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af387627cc9bea3825e5b15a2d8e7f6b7">&#9670;&nbsp;</a></span>reset_on_copy() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a reset_on_copy&lt;T&gt; with the given wrapped value, by move construction if possible. </p>
<p>This is an implicit conversion, so that reset_on_copy&lt;T&gt; behaves more like the unwrapped type. </p>

</div>
</div>
<a id="ab8b1be347012bdfab8e461085598f51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b1be347012bdfab8e461085598f51b">&#9670;&nbsp;</a></span>reset_on_copy() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor just value-initializes instead; the source is ignored. </p>

</div>
</div>
<a id="a66b9d58cd7ec58ee8c08daa452c73332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b9d58cd7ec58ee8c08daa452c73332">&#9670;&nbsp;</a></span>reset_on_copy() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move construction uses T's move constructor, then destructs and value initializes the source. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa21e380b520fb649d3d8c0403f98f48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21e380b520fb649d3d8c0403f98f48a">&#9670;&nbsp;</a></span>operator const T &()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operator const T &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ceeab0526636cedb9ccf57adf1ce379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ceeab0526636cedb9ccf57adf1ce379">&#9670;&nbsp;</a></span>operator T &()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operator T&amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae427702dac375af45ad8272fb8424102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae427702dac375af45ad8272fb8424102">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_pointer&lt;T1&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, std::add_lvalue_reference_t&lt;std::remove_pointer_t&lt;T&gt; &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bc1ed702a031203e0a7caa1ab6b544d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc1ed702a031203e0a7caa1ab6b544d">&#9670;&nbsp;</a></span>operator->()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_pointer&lt;T1&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, T&gt; operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d2fe58dab3f89ed510b00e6c87dd807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2fe58dab3f89ed510b00e6c87dd807">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment just destructs the contained value and then value-initializes it, <em>except</em> for self-assignment which does nothing. </p>
<p>The source argument is otherwise ignored. </p>

</div>
</div>
<a id="a4446b27ca27362773c2e92839f3553b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4446b27ca27362773c2e92839f3553b1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment uses T's move assignment, then destructs and value initializes the source, <em>except</em> for self-assignment which does nothing. </p>
<p>The source argument is otherwise ignored. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/common/<a class="el" href="reset__on__copy_8h.html">reset_on_copy.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
