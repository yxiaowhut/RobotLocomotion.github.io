<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Identifier&lt; Tag &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1geometry_1_1_identifier.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classdrake_1_1geometry_1_1_identifier-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Identifier&lt; Tag &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple identifier class.  
 <a href="classdrake_1_1geometry_1_1_identifier.html#details">More...</a></p>

<p><code>#include &lt;drake/geometry/identifier.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f186fd19e7abd111fcb3c1446175220"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html#a6f186fd19e7abd111fcb3c1446175220">Identifier</a> ()</td></tr>
<tr class="memdesc:a6f186fd19e7abd111fcb3c1446175220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor; the result is an <em>invalid</em> identifier.  <a href="#a6f186fd19e7abd111fcb3c1446175220">More...</a><br /></td></tr>
<tr class="separator:a6f186fd19e7abd111fcb3c1446175220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad945f7a3cc39caafc0527fcf2f7d4a46"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html#ad945f7a3cc39caafc0527fcf2f7d4a46">get_value</a> () const</td></tr>
<tr class="memdesc:ad945f7a3cc39caafc0527fcf2f7d4a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the underlying representation from the identifier.  <a href="#ad945f7a3cc39caafc0527fcf2f7d4a46">More...</a><br /></td></tr>
<tr class="separator:ad945f7a3cc39caafc0527fcf2f7d4a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca0e76fa665125f1e50bd1ed8dbd213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html#a8ca0e76fa665125f1e50bd1ed8dbd213">is_valid</a> () const</td></tr>
<tr class="memdesc:a8ca0e76fa665125f1e50bd1ed8dbd213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports if the id is valid.  <a href="#a8ca0e76fa665125f1e50bd1ed8dbd213">More...</a><br /></td></tr>
<tr class="separator:a8ca0e76fa665125f1e50bd1ed8dbd213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424e4bc2112c2f23ca3015ae6a35360e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html#a424e4bc2112c2f23ca3015ae6a35360e">operator==</a> (<a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a> other) const</td></tr>
<tr class="memdesc:a424e4bc2112c2f23ca3015ae6a35360e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares one identifier with another of the same type for equality.  <a href="#a424e4bc2112c2f23ca3015ae6a35360e">More...</a><br /></td></tr>
<tr class="separator:a424e4bc2112c2f23ca3015ae6a35360e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0093b69f6226e8b6a60500c794853ede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html#a0093b69f6226e8b6a60500c794853ede">operator!=</a> (<a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a> other) const</td></tr>
<tr class="memdesc:a0093b69f6226e8b6a60500c794853ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares one identifier with another of the same type for inequality.  <a href="#a0093b69f6226e8b6a60500c794853ede">More...</a><br /></td></tr>
<tr class="separator:a0093b69f6226e8b6a60500c794853ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1947275fb04e36d9eae9372158af126"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html#ae1947275fb04e36d9eae9372158af126">operator&lt;</a> (<a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a> other) const</td></tr>
<tr class="memdesc:ae1947275fb04e36d9eae9372158af126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two identifiers in order to define a total ordering among identifiers.  <a href="#ae1947275fb04e36d9eae9372158af126">More...</a><br /></td></tr>
<tr class="separator:ae1947275fb04e36d9eae9372158af126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a2868815a784be55d42a1074934c866e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html#a2868815a784be55d42a1074934c866e4">Identifier</a> (const <a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a> &amp;)=default</td></tr>
<tr class="separator:a2868815a784be55d42a1074934c866e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146cc3b18b5ead81a09a8d8b1c7f1ada"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html#a146cc3b18b5ead81a09a8d8b1c7f1ada">operator=</a> (const <a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a> &amp;)=default</td></tr>
<tr class="separator:a146cc3b18b5ead81a09a8d8b1c7f1ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0856a45cd63825cbbed8772b158c64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html#a2c0856a45cd63825cbbed8772b158c64">Identifier</a> (<a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a2c0856a45cd63825cbbed8772b158c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a4774e8a555b95429bf5700567b130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html#a28a4774e8a555b95429bf5700567b130">operator=</a> (<a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a28a4774e8a555b95429bf5700567b130"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a875fb8cf881e4660633619843c7edd0d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html#a875fb8cf881e4660633619843c7edd0d">get_new_id</a> ()</td></tr>
<tr class="memdesc:a875fb8cf881e4660633619843c7edd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a new identifier for this id type.  <a href="#a875fb8cf881e4660633619843c7edd0d">More...</a><br /></td></tr>
<tr class="separator:a875fb8cf881e4660633619843c7edd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a6f77603aea6d719b71744d902e66a84d"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a6f77603aea6d719b71744d902e66a84d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html#a6f77603aea6d719b71744d902e66a84d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a>&lt; Tag &gt; &amp;<a class="el" href="multilane_2loader_8cc.html#afd0d68c6d31ff249f3ae8662162663c3">id</a>)</td></tr>
<tr class="memdesc:a6f77603aea6d719b71744d902e66a84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming output operator.  <a href="#a6f77603aea6d719b71744d902e66a84d">More...</a><br /></td></tr>
<tr class="separator:a6f77603aea6d719b71744d902e66a84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Tag&gt;<br />
class drake::geometry::Identifier&lt; Tag &gt;</h3>

<p>A simple identifier class. </p>
<dl class="section note"><dt>Note</dt><dd>This is <em>purposely</em> a separate class from <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>. For more explanatation, see <a class="el" href="classdrake_1_1geometry_1_1_identifier.html#TypeSafeIndexVsIndentifier">this section</a>.</dd></dl>
<p>This class serves as an upgrade to the standard practice of passing <code>int</code>s around as unique identifiers (or, as in this case, <code>int64_t</code>s). In the common practice, a method that takes identifiers to different types of objects would have an interface like:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(int64_t bar_id, int64_t thing_id);</div></div><!-- fragment --><p>It is possible for a programmer to accidentally switch the two ids in an invocation. This mistake would still be <em>syntactically</em> correct; it will successfully compile but lead to inscrutable run-time errors. This identifier class provides the same speed and efficiency of passing <code>int64_t</code>s, but enforces unique types and limits the valid operations, providing compile-time checking. The function would now look like:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(BarId bar_id, ThingId thing_id)</div></div><!-- fragment --><p>and the compiler will catch instances where the order is reversed.</p>
<p>The identifier is a <em>stripped down</em> 64-bit int. Each uniquely declared identifier type has the following properties:</p>
<ul>
<li>The identifier's default constructor produces <em>invalid</em> identifiers.</li>
<li>Valid identifiers must be constructed via the copy constructor or through <a class="el" href="classdrake_1_1geometry_1_1_identifier.html#a875fb8cf881e4660633619843c7edd0d" title="Generates a new identifier for this id type. ">Identifier::get_new_id()</a>.</li>
<li>The identifier is immutable.</li>
<li>The identifier can only be tested for equality/inequality with other identifiers of the <em>same</em> type.</li>
<li>Identifiers of different types are <em>not</em> interconvertible.</li>
<li>The identifier can be queried for its underlying <code>int64_t</code> value.</li>
<li>The identifier can be written to an output stream; its underlying <code>int64_t</code> value gets written.</li>
<li>Identifiers are not guaranteed to possess <em>meaningful</em> ordering. I.e., identifiers for two objects created sequentially may not have sequential identifier values.</li>
<li>Identifiers can only be generated from the static method <a class="el" href="classdrake_1_1geometry_1_1_identifier.html#a875fb8cf881e4660633619843c7edd0d" title="Generates a new identifier for this id type. ">get_new_id()</a>.</li>
</ul>
<p>While there <em>is</em> the concept of an invalid identifier, this only exists to facilitate use with STL containers that require default constructors. Using an invalid identifier in any operation is considered an error. In Debug build, attempts to compare, get the value of, hash, or write an invalid identifier to a stream will cause program failure.</p>
<p>Functions that query for identifiers should not return invalid identifiers. We prefer the practice of returning std::optional&lt;Identifier&gt; instead.</p>
<p>It is the designed intent of this class, that ids derived from this class can be passed and returned by value. Passing ids by const reference should be considered a misuse.</p>
<p>The following alias will create a unique identifier type for class <code>Foo</code>: </p><div class="fragment"><div class="line"><span class="keyword">using</span> FooId = Identifier&lt;class FooTag&gt;;</div></div><!-- fragment --><p><b>Examples of valid and invalid operations</b></p>
<p>The Identifier guarantees that id instances of different types can't be compared or combined. Efforts to do so will cause a compile-time failure. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> AId = Identifier&lt;class ATag&gt;;</div><div class="line"><span class="keyword">using</span> BId = Identifier&lt;class BTag&gt;;</div><div class="line">AId a1;                              <span class="comment">// Compiler error; there is no</span></div><div class="line">                                     <span class="comment">//   default constructor.</span></div><div class="line">AId a2 = AId::get_new_id();          <span class="comment">// Ok.</span></div><div class="line">AId a3(a2);                          <span class="comment">// Ok.</span></div><div class="line">AId a4 = AId::get_new_id();          <span class="comment">// Ok.</span></div><div class="line">BId b = BId::get_new_id();           <span class="comment">// Ok.</span></div><div class="line"><span class="keywordflow">if</span> ( a2 == 1 ) { ... }               <span class="comment">// Compiler error.</span></div><div class="line"><span class="keywordflow">if</span> ( a2 == a4 ) { ... }              <span class="comment">// Ok, evaluates to false.</span></div><div class="line"><span class="keywordflow">if</span> ( a2 == a3 ) { ... }              <span class="comment">// Ok, evaluates to true.</span></div><div class="line"><span class="keywordflow">if</span> ( a2 == b ) { ... }               <span class="comment">// Compiler error.</span></div><div class="line">a4 = a2;                             <span class="comment">// Ok.</span></div><div class="line">a3 = 7;                              <span class="comment">// Compiler error.</span></div></div><!-- fragment --><p><a class="anchor" id="TypeSafeIndexVsIndentifier"></a><b><a class="el" href="classdrake_1_1_type_safe_index.html" title="A type-safe non-negative index class. ">TypeSafeIndex</a> vs <a class="el" href="classdrake_1_1geometry_1_1_identifier.html" title="A simple identifier class. ">Identifier</a></b></p>
<p>In principle, the <em>identifier</em> is related to the <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>. In some sense, both are "type-safe" <code>int</code>s. They differ in their semantics. We can consider <code>ints</code>, indices, and identifiers as a list of <code>int</code> types with <em>decreasing</em> functionality.</p>
<ul>
<li>The int, obviously, has the full range of C++ ints.</li>
<li>The <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a> can be implicitly cast <em>to</em> an int, but there are a limited number of operations <em>on</em> the index that produce other instances of the index (e.g., increment, in-place addition, etc.) They can be compared with <code>int</code> and other indices of the same type. This behavior arises from the intention of having them serve as an <em>index</em> in an ordered set (e.g., <code>std::vector</code>).</li>
<li>The Identifier is the most restricted. They exist solely to serve as a unique identifier. They are immutable when created. Very few operations exist on them (comparison for <em>equality</em> with other identifiers of the same type, hashing, writing to output stream). These <em>cannot</em> be used as indices.</li>
</ul>
<p>Ultimately, indices <em>can</em> serve as identifiers (within the scope of the object they index into). Although, their mutability could make this a dangerous practice for a public API. Identifiers are more general in that they don't reflect an object's position in memory (hence the inability to transform to or compare with an <code>int</code>). This decouples details of implementation from the idea of the object. Combined with its immutability, it would serve well as a element of a public API.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1_type_safe_index.html" title="A type-safe non-negative index class. ">TypeSafeIndex</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>The name of the tag that uniquely segregates one instantiation from another. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2868815a784be55d42a1074934c866e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2868815a784be55d42a1074934c866e4">&#9670;&nbsp;</a></span>Identifier() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c0856a45cd63825cbbed8772b158c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0856a45cd63825cbbed8772b158c64">&#9670;&nbsp;</a></span>Identifier() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a>&lt; Tag &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f186fd19e7abd111fcb3c1446175220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f186fd19e7abd111fcb3c1446175220">&#9670;&nbsp;</a></span>Identifier() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor; the result is an <em>invalid</em> identifier. </p>
<p>This only exists to satisfy demands of working with various container classes. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a875fb8cf881e4660633619843c7edd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875fb8cf881e4660633619843c7edd0d">&#9670;&nbsp;</a></span>get_new_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a> get_new_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a new identifier for this id type. </p>
<p>This new identifier will be different from all previous identifiers created. This method does <em>not</em> make any guarantees about the values of ids from successive invocations. This method is guaranteed to be thread safe. </p>

</div>
</div>
<a id="ad945f7a3cc39caafc0527fcf2f7d4a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad945f7a3cc39caafc0527fcf2f7d4a46">&#9670;&nbsp;</a></span>get_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t get_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the underlying representation from the identifier. </p>
<p>This is considered invalid for invalid ids and is strictly enforced in Debug builds. </p>

</div>
</div>
<a id="a8ca0e76fa665125f1e50bd1ed8dbd213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca0e76fa665125f1e50bd1ed8dbd213">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports if the id is valid. </p>

</div>
</div>
<a id="a0093b69f6226e8b6a60500c794853ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0093b69f6226e8b6a60500c794853ede">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a>&lt; Tag &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares one identifier with another of the same type for inequality. </p>
<p>This is considered invalid for invalid ids and is strictly enforced in Debug builds. </p>

</div>
</div>
<a id="ae1947275fb04e36d9eae9372158af126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1947275fb04e36d9eae9372158af126">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a>&lt; Tag &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two identifiers in order to define a total ordering among identifiers. </p>
<p>This makes identifiers compatible with data structures which require total ordering (e.g., std::set). </p>

</div>
</div>
<a id="a28a4774e8a555b95429bf5700567b130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a4774e8a555b95429bf5700567b130">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a>&lt; Tag &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a146cc3b18b5ead81a09a8d8b1c7f1ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146cc3b18b5ead81a09a8d8b1c7f1ada">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a424e4bc2112c2f23ca3015ae6a35360e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424e4bc2112c2f23ca3015ae6a35360e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a>&lt; Tag &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares one identifier with another of the same type for equality. </p>
<p>This is considered invalid for invalid ids and is strictly enforced in Debug builds. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6f77603aea6d719b71744d902e66a84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f77603aea6d719b71744d902e66a84d">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Streaming output operator. </p>
<p>This is considered invalid for invalid ids and is strictly enforced in Debug builds. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/<a class="el" href="identifier_8h.html">identifier.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="classdrake_1_1geometry_1_1_identifier.html">Identifier</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
