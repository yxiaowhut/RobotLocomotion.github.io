<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: RigidBodyTree&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_rigid_body_tree.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_rigid_body_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RigidBodyTree&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Maintains a vector of <a class="el" href="class_rigid_body.html">RigidBody</a> objects that are arranged into a kinematic tree via <a class="el" href="class_drake_joint.html" title="A joint defines a spatial relationship between two rigid bodies. ">DrakeJoint</a> objects.  
 <a href="class_rigid_body_tree.html#details">More...</a></p>

<p><code>#include &lt;drake/attic/systems/controllers/rbt_inverse_dynamics_controller.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac3ccd2f24194ee7ea436d2a7faffe013"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ac3ccd2f24194ee7ea436d2a7faffe013">BodyToWrenchMap</a> = <a class="el" href="namespacedrake.html#afcadf96d397f45d041d01bf17061bc32">drake::eigen_aligned_std_unordered_map</a>&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; const  *, <a class="el" href="namespacedrake.html#af98fed5f98c376f4d45fff56bb96c8e1">drake::WrenchVector</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ac3ccd2f24194ee7ea436d2a7faffe013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for rigid body to external wrench map, for use with inverseDynamics and dynamicsBiasTerm.  <a href="#ac3ccd2f24194ee7ea436d2a7faffe013">More...</a><br /></td></tr>
<tr class="separator:ac3ccd2f24194ee7ea436d2a7faffe013"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5f304ab2f7b5bca3e19cc2da40d9eece"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a5f304ab2f7b5bca3e19cc2da40d9eece">RigidBodyTree</a> ()</td></tr>
<tr class="memdesc:a5f304ab2f7b5bca3e19cc2da40d9eece"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor that initializes the gravity vector to be [0, 0, -9.81] and a single <a class="el" href="class_rigid_body.html">RigidBody</a> named "world".  <a href="#a5f304ab2f7b5bca3e19cc2da40d9eece">More...</a><br /></td></tr>
<tr class="separator:a5f304ab2f7b5bca3e19cc2da40d9eece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2829e9624e9492cc108a5e4d7d1b18"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a6d2829e9624e9492cc108a5e4d7d1b18">~RigidBodyTree</a> ()</td></tr>
<tr class="separator:a6d2829e9624e9492cc108a5e4d7d1b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90af483256d82685ec8c57af985fd13e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a90af483256d82685ec8c57af985fd13e">Clone</a> () const</td></tr>
<tr class="memdesc:a90af483256d82685ec8c57af985fd13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a deep clone of this <a class="el" href="class_rigid_body_tree.html">RigidBodyTree&lt;double&gt;</a>.  <a href="#a90af483256d82685ec8c57af985fd13e">More...</a><br /></td></tr>
<tr class="separator:a90af483256d82685ec8c57af985fd13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12447ed4fd0c7c2225d393669a836471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a12447ed4fd0c7c2225d393669a836471">print_joint_welding_diagnostics</a> (<a class="el" href="classbool.html">bool</a> wants_to_print)</td></tr>
<tr class="memdesc:a12447ed4fd0c7c2225d393669a836471"><td class="mdescLeft">&#160;</td><td class="mdescRight">When <code>val</code> is true, diagnostics in <a class="el" href="class_rigid_body_tree.html#acafe5ede9412674127cd08795647f26a">compile()</a> will be printed with <a class="el" href="namespacedrake.html#aa157c1d75c2e52df3370e5f458022ee9" title="Retrieve an instance of a logger to use for logging; for example: ">drake::log()</a>-&gt;info().  <a href="#a12447ed4fd0c7c2225d393669a836471">More...</a><br /></td></tr>
<tr class="separator:a12447ed4fd0c7c2225d393669a836471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452a564b0d6d35750f8eafcb561cdfb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a452a564b0d6d35750f8eafcb561cdfb1">add_model_instance</a> ()</td></tr>
<tr class="memdesc:a452a564b0d6d35750f8eafcb561cdfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new model instance to this <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code>.  <a href="#a452a564b0d6d35750f8eafcb561cdfb1">More...</a><br /></td></tr>
<tr class="separator:a452a564b0d6d35750f8eafcb561cdfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943cea1f9b2568fa6ca812089d9bf78c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a943cea1f9b2568fa6ca812089d9bf78c">get_next_clique_id</a> ()</td></tr>
<tr class="separator:a943cea1f9b2568fa6ca812089d9bf78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31919012770675ceedb50e5d120cc2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ac31919012770675ceedb50e5d120cc2d">get_num_model_instances</a> () const</td></tr>
<tr class="memdesc:ac31919012770675ceedb50e5d120cc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of model instances in the tree, not including the world.  <a href="#ac31919012770675ceedb50e5d120cc2d">More...</a><br /></td></tr>
<tr class="separator:ac31919012770675ceedb50e5d120cc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34037cd15b3b78dfb4119658e5817a58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a34037cd15b3b78dfb4119658e5817a58">get_number_of_model_instances</a> () const</td></tr>
<tr class="separator:a34037cd15b3b78dfb4119658e5817a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012bf4217daf3167cd6328d5ddd97785"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a012bf4217daf3167cd6328d5ddd97785">addFrame</a> (std::shared_ptr&lt; <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt;&gt; frame)</td></tr>
<tr class="memdesc:a012bf4217daf3167cd6328d5ddd97785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a frame.  <a href="#a012bf4217daf3167cd6328d5ddd97785">More...</a><br /></td></tr>
<tr class="separator:a012bf4217daf3167cd6328d5ddd97785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0227c8f2ea7c5d4fac5c3dfafc3b9a0"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ae0227c8f2ea7c5d4fac5c3dfafc3b9a0">computePositionNameToIndexMap</a> () const</td></tr>
<tr class="memdesc:ae0227c8f2ea7c5d4fac5c3dfafc3b9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map from DOF position name to DOF index within the output vector of this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>.  <a href="#ae0227c8f2ea7c5d4fac5c3dfafc3b9a0">More...</a><br /></td></tr>
<tr class="separator:ae0227c8f2ea7c5d4fac5c3dfafc3b9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb7ce71c2d436a3c63ea2e2d2149865"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a0eb7ce71c2d436a3c63ea2e2d2149865">surfaceTangents</a> (Eigen::Map&lt; Eigen::Matrix3Xd &gt; const &amp;normals, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Map&lt; Eigen::Matrix3Xd &gt;&gt; &amp;tangents) const</td></tr>
<tr class="separator:a0eb7ce71c2d436a3c63ea2e2d2149865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa527aaa5e2aa17fc46efb5b14c608701"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aa527aaa5e2aa17fc46efb5b14c608701">transformCollisionFrame</a> (<a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *body, const Eigen::Isometry3d &amp;displace_transform)</td></tr>
<tr class="memdesc:aa527aaa5e2aa17fc46efb5b14c608701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given transform to the given <code>body's</code> collision elements, displacing them from their current configurations.  <a href="#aa527aaa5e2aa17fc46efb5b14c608701">More...</a><br /></td></tr>
<tr class="separator:aa527aaa5e2aa17fc46efb5b14c608701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafe5ede9412674127cd08795647f26a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#acafe5ede9412674127cd08795647f26a">compile</a> ()</td></tr>
<tr class="separator:acafe5ede9412674127cd08795647f26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0affd497911ca3154107ea425b81702"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ad0affd497911ca3154107ea425b81702">getZeroConfiguration</a> () const</td></tr>
<tr class="separator:ad0affd497911ca3154107ea425b81702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dac5378b14d06c84f487ed21bd1335f"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a7dac5378b14d06c84f487ed21bd1335f">getRandomConfiguration</a> (std::default_random_engine &amp;generator) const</td></tr>
<tr class="separator:a7dac5378b14d06c84f487ed21bd1335f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94b66bc740f806794618ad439c0dcc9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#af94b66bc740f806794618ad439c0dcc9">get_position_name</a> (<a class="el" href="classint.html">int</a> position_num) const</td></tr>
<tr class="memdesc:af94b66bc740f806794618ad439c0dcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the position state at index <code>position_num</code> within this <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code>'s state vector.  <a href="#af94b66bc740f806794618ad439c0dcc9">More...</a><br /></td></tr>
<tr class="separator:af94b66bc740f806794618ad439c0dcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac818dfc39fe0e26797ba59f46a443b8f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ac818dfc39fe0e26797ba59f46a443b8f">get_velocity_name</a> (<a class="el" href="classint.html">int</a> velocity_num) const</td></tr>
<tr class="memdesc:ac818dfc39fe0e26797ba59f46a443b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the velocity state at index <code>velocity_num</code> within this <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code>'s state vector.  <a href="#ac818dfc39fe0e26797ba59f46a443b8f">More...</a><br /></td></tr>
<tr class="separator:ac818dfc39fe0e26797ba59f46a443b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed68fa92e7d3a34b676cf871ec65da8e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aed68fa92e7d3a34b676cf871ec65da8e">getPositionName</a> (<a class="el" href="classint.html">int</a> position_num) const</td></tr>
<tr class="separator:aed68fa92e7d3a34b676cf871ec65da8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5b3900dcd190b88974883b1e0271ec"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a7d5b3900dcd190b88974883b1e0271ec">getVelocityName</a> (<a class="el" href="classint.html">int</a> velocity_num) const</td></tr>
<tr class="separator:a7d5b3900dcd190b88974883b1e0271ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8899470dfea29c51a4deeba97b8da0c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#af8899470dfea29c51a4deeba97b8da0c">getStateName</a> (<a class="el" href="classint.html">int</a> state_num) const</td></tr>
<tr class="separator:af8899470dfea29c51a4deeba97b8da0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8d5b9822df97355629b16ccac175ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a0f8d5b9822df97355629b16ccac175ea">drawKinematicTree</a> (std::string graphviz_dotfile_filename) const</td></tr>
<tr class="separator:a0f8d5b9822df97355629b16ccac175ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63e4fe558184619cea7b347a10c2816"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af63e4fe558184619cea7b347a10c2816"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#af63e4fe558184619cea7b347a10c2816">CheckCacheValidity</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache) const</td></tr>
<tr class="memdesc:af63e4fe558184619cea7b347a10c2816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>cache</code> is valid for use with this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>.  <a href="#af63e4fe558184619cea7b347a10c2816">More...</a><br /></td></tr>
<tr class="separator:af63e4fe558184619cea7b347a10c2816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a71eca20b58c55688bd643b29e18cc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a6a71eca20b58c55688bd643b29e18cc3">CreateKinematicsCache</a> () const</td></tr>
<tr class="memdesc:a6a71eca20b58c55688bd643b29e18cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> to perform computations with this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>.  <a href="#a6a71eca20b58c55688bd643b29e18cc3">More...</a><br /></td></tr>
<tr class="separator:a6a71eca20b58c55688bd643b29e18cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da5b42598002045e53728b112834aba"><td class="memTemplParams" colspan="2">template&lt;typename CacheT &gt; </td></tr>
<tr class="memitem:a0da5b42598002045e53728b112834aba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; CacheT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a0da5b42598002045e53728b112834aba">CreateKinematicsCacheWithType</a> () const</td></tr>
<tr class="memdesc:a0da5b42598002045e53728b112834aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper template method used to create a <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> templated on <code>CacheT</code> from a <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> templated on <code>T</code>, with <code>CacheT</code> and <code>T</code> not necessarily the same scalar type.  <a href="#a0da5b42598002045e53728b112834aba">More...</a><br /></td></tr>
<tr class="separator:a0da5b42598002045e53728b112834aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443ff641d739d2512e28449c6132a4ce"><td class="memTemplParams" colspan="2">template&lt;typename DerivedQ &gt; </td></tr>
<tr class="memitem:a443ff641d739d2512e28449c6132a4ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename DerivedQ::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a443ff641d739d2512e28449c6132a4ce">doKinematics</a> (const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;q) const</td></tr>
<tr class="memdesc:a443ff641d739d2512e28449c6132a4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="class_kinematics_cache.html">KinematicsCache</a></code> with the given configuration <code>q</code>, computes the kinematics, and returns the cache.  <a href="#a443ff641d739d2512e28449c6132a4ce">More...</a><br /></td></tr>
<tr class="separator:a443ff641d739d2512e28449c6132a4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedff6d96b0ba888cefaf4a2b0fddcae8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedQ , typename DerivedV &gt; </td></tr>
<tr class="memitem:aedff6d96b0ba888cefaf4a2b0fddcae8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename DerivedQ::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aedff6d96b0ba888cefaf4a2b0fddcae8">doKinematics</a> (const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;q, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;v, <a class="el" href="classbool.html">bool</a> compute_JdotV=true) const</td></tr>
<tr class="memdesc:aedff6d96b0ba888cefaf4a2b0fddcae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a <code><a class="el" href="class_kinematics_cache.html">KinematicsCache</a></code> with the given configuration <code>q</code> and velocity <code>v</code>, computes the kinematics, and returns the cache.  <a href="#aedff6d96b0ba888cefaf4a2b0fddcae8">More...</a><br /></td></tr>
<tr class="separator:aedff6d96b0ba888cefaf4a2b0fddcae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0374b8587d2bba4c7e1a520f3b3160ec"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a0374b8587d2bba4c7e1a520f3b3160ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a0374b8587d2bba4c7e1a520f3b3160ec">doKinematics</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classbool.html">bool</a> compute_JdotV=false) const</td></tr>
<tr class="memdesc:a0374b8587d2bba4c7e1a520f3b3160ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the kinematics on the given <code>cache</code>.  <a href="#a0374b8587d2bba4c7e1a520f3b3160ec">More...</a><br /></td></tr>
<tr class="separator:a0374b8587d2bba4c7e1a520f3b3160ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489c40ff74c5683873d1557a15c836bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a489c40ff74c5683873d1557a15c836bc">is_part_of_model_instances</a> (const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set) const</td></tr>
<tr class="memdesc:a489c40ff74c5683873d1557a15c836bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>body</code> is part of a model instance whose ID is in <code>model_instance_id_set</code>.  <a href="#a489c40ff74c5683873d1557a15c836bc">More...</a><br /></td></tr>
<tr class="separator:a489c40ff74c5683873d1557a15c836bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee5854d54c562df2e21dca5f5d3624c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a9ee5854d54c562df2e21dca5f5d3624c">getMass</a> (const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set=<a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a>) const</td></tr>
<tr class="memdesc:a9ee5854d54c562df2e21dca5f5d3624c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the total combined mass of a set of model instances.  <a href="#a9ee5854d54c562df2e21dca5f5d3624c">More...</a><br /></td></tr>
<tr class="separator:a9ee5854d54c562df2e21dca5f5d3624c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f75a7ae6524f91ee8e85e4887399bf"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a21f75a7ae6524f91ee8e85e4887399bf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, <a class="el" href="namespacedrake.html#af869092c52ed7cc9d2db40ce56050c7c">drake::kSpaceDimension</a>, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a21f75a7ae6524f91ee8e85e4887399bf">centerOfMass</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set=<a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a>) const</td></tr>
<tr class="separator:a21f75a7ae6524f91ee8e85e4887399bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54928c367e4abdd1d9116282ae73a1a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">drake::Matrix6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a54928c367e4abdd1d9116282ae73a1a8">LumpedSpatialInertiaInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set=<a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a>) const</td></tr>
<tr class="memdesc:a54928c367e4abdd1d9116282ae73a1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the summed spatial inertia in the world frame of all bodies that belong to model instances in <code>model_instance_id_set</code>.  <a href="#a54928c367e4abdd1d9116282ae73a1a8">More...</a><br /></td></tr>
<tr class="separator:a54928c367e4abdd1d9116282ae73a1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb1f7792097c6e26945b6feb6b7ca53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">drake::Matrix6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aceb1f7792097c6e26945b6feb6b7ca53">LumpedSpatialInertiaInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *&gt; &amp;bodies_of_interest) const</td></tr>
<tr class="memdesc:aceb1f7792097c6e26945b6feb6b7ca53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the summed spatial inertia in the world frame of all the bodies in <code>bodies_of_interest</code>.  <a href="#aceb1f7792097c6e26945b6feb6b7ca53">More...</a><br /></td></tr>
<tr class="separator:aceb1f7792097c6e26945b6feb6b7ca53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efcb13ad3a7d185b66d11b6d4166f19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a5efcb13ad3a7d185b66d11b6d4166f19">CalcBodyPoseInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:a5efcb13ad3a7d185b66d11b6d4166f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pose <code>X_WB</code> of <code>body's</code> frame B in the world frame W.  <a href="#a5efcb13ad3a7d185b66d11b6d4166f19">More...</a><br /></td></tr>
<tr class="separator:a5efcb13ad3a7d185b66d11b6d4166f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1da0223cf35ceab4cb90d5b17150b13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ab1da0223cf35ceab4cb90d5b17150b13">CalcFramePoseInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &amp;frame_F) const</td></tr>
<tr class="memdesc:ab1da0223cf35ceab4cb90d5b17150b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pose <code>X_WF</code> of <code>frame_F</code> in the world frame W.  <a href="#ab1da0223cf35ceab4cb90d5b17150b13">More...</a><br /></td></tr>
<tr class="separator:ab1da0223cf35ceab4cb90d5b17150b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf319e952111f5b2f45bb664243c7bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aadf319e952111f5b2f45bb664243c7bb">CalcFramePoseInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt; T &gt; &amp;X_BF) const</td></tr>
<tr class="memdesc:aadf319e952111f5b2f45bb664243c7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pose <code>X_WF</code> of the rigid body frame F in the world frame W.  <a href="#aadf319e952111f5b2f45bb664243c7bb">More...</a><br /></td></tr>
<tr class="separator:aadf319e952111f5b2f45bb664243c7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb8bcd6dcd60ccb725fa3732180cf56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">drake::Vector6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aebb8bcd6dcd60ccb725fa3732180cf56">CalcBodySpatialVelocityInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:aebb8bcd6dcd60ccb725fa3732180cf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spatial velocity <code>V_WB</code> of <code>body's</code> frame B measured and expressed in the world frame W.  <a href="#aebb8bcd6dcd60ccb725fa3732180cf56">More...</a><br /></td></tr>
<tr class="separator:aebb8bcd6dcd60ccb725fa3732180cf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32633fae7bbeaafc9616bd9216779426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">drake::Vector6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a32633fae7bbeaafc9616bd9216779426">CalcFrameSpatialVelocityInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &amp;frame_F) const</td></tr>
<tr class="memdesc:a32633fae7bbeaafc9616bd9216779426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spatial velocity <code>V_WF</code> of <a class="el" href="class_rigid_body_frame.html" title="Multibody systems typically have distinguished frames of interest that need to be monitored...">RigidBodyFrame</a> <code>frame_F</code> measured and expressed in the world frame W.  <a href="#a32633fae7bbeaafc9616bd9216779426">More...</a><br /></td></tr>
<tr class="separator:a32633fae7bbeaafc9616bd9216779426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ce465634ec4a603a26cb65b7c0b7df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">drake::Vector6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aa5ce465634ec4a603a26cb65b7c0b7df">CalcFrameSpatialVelocityInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt; T &gt; &amp;X_BF) const</td></tr>
<tr class="memdesc:aa5ce465634ec4a603a26cb65b7c0b7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spatial velocity <code>V_WF</code> of the frame F measured and expressed in the world frame W.  <a href="#aa5ce465634ec4a603a26cb65b7c0b7df">More...</a><br /></td></tr>
<tr class="separator:aa5ce465634ec4a603a26cb65b7c0b7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3d8e9bd41c3f7b756c7a964e3bb58e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">drake::Matrix6X</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aab3d8e9bd41c3f7b756c7a964e3bb58e">CalcFrameSpatialVelocityJacobianInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt; T &gt; &amp;X_BF, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot=false) const</td></tr>
<tr class="memdesc:aab3d8e9bd41c3f7b756c7a964e3bb58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian <code>J_WF</code> of the spatial velocity <code>V_WF</code> of frame F measured and expressed in the world frame W such that <code>V_WF = J_WF * v</code>, where <code>v</code> is the generalized velocity.  <a href="#aab3d8e9bd41c3f7b756c7a964e3bb58e">More...</a><br /></td></tr>
<tr class="separator:aab3d8e9bd41c3f7b756c7a964e3bb58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e4515aa2862a883f21fb2e168635aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aa3e4515aa2862a883f21fb2e168635aa">CalcFrameSpatialVelocityJacobianInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt; T &gt; &amp;X_BF, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot, <a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">drake::Matrix6X</a>&lt; T &gt; *J_WF) const</td></tr>
<tr class="memdesc:aa3e4515aa2862a883f21fb2e168635aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian <code>J_WF</code> of the spatial velocity <code>V_WF</code> of frame F measured and expressed in the world frame W such that <code>V_WF = J_WF * v</code>, where <code>v</code> is the generalized velocity.  <a href="#aa3e4515aa2862a883f21fb2e168635aa">More...</a><br /></td></tr>
<tr class="separator:aa3e4515aa2862a883f21fb2e168635aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6c3d81ee7a57e61c18c7d90cffbfca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">drake::Matrix6X</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a1d6c3d81ee7a57e61c18c7d90cffbfca">CalcFrameSpatialVelocityJacobianInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &amp;frame_F, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot=false) const</td></tr>
<tr class="memdesc:a1d6c3d81ee7a57e61c18c7d90cffbfca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian <code>J_WF</code> of the spatial velocity <code>V_WF</code> of frame F measured and expressed in the world frame W such that <code>V_WF = J_WF * v</code>, where <code>v</code> is the generalized velocity.  <a href="#a1d6c3d81ee7a57e61c18c7d90cffbfca">More...</a><br /></td></tr>
<tr class="separator:a1d6c3d81ee7a57e61c18c7d90cffbfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b9c955683d4c3486bfb9d9d6aed5de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a34b9c955683d4c3486bfb9d9d6aed5de">CalcFrameSpatialVelocityJacobianInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &amp;frame_F, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot, <a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">drake::Matrix6X</a>&lt; T &gt; *J_WF) const</td></tr>
<tr class="memdesc:a34b9c955683d4c3486bfb9d9d6aed5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian <code>J_WF</code> of the spatial velocity <code>V_WF</code> of frame F measured and expressed in the world frame W such that <code>V_WF = J_WF * v</code>, where <code>v</code> is the generalized velocity.  <a href="#a34b9c955683d4c3486bfb9d9d6aed5de">More...</a><br /></td></tr>
<tr class="separator:a34b9c955683d4c3486bfb9d9d6aed5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80375fe69939e9c53bf5eb172741c51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">drake::Matrix6X</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#af80375fe69939e9c53bf5eb172741c51">CalcBodySpatialVelocityJacobianInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot=false) const</td></tr>
<tr class="memdesc:af80375fe69939e9c53bf5eb172741c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian <code>J_WB</code> of the spatial velocity <code>V_WB</code> of body frame B measured and expressed in the world frame <code>W</code> such that <code>V_WB = J_WB * v</code>, where <code>v</code> is the generalized velocity.  <a href="#af80375fe69939e9c53bf5eb172741c51">More...</a><br /></td></tr>
<tr class="separator:af80375fe69939e9c53bf5eb172741c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36df94b032a1de53a79b16ee5c2560a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a36df94b032a1de53a79b16ee5c2560a6">CalcBodySpatialVelocityJacobianInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot, <a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">drake::Matrix6X</a>&lt; T &gt; *J_WB) const</td></tr>
<tr class="memdesc:a36df94b032a1de53a79b16ee5c2560a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian <code>J_WB</code> of the spatial velocity <code>V_WB</code> of body frame B measured and expressed in the world frame <code>W</code> such that <code>V_WB = J_WB * v</code>, where <code>v</code> is the generalized velocity.  <a href="#a36df94b032a1de53a79b16ee5c2560a6">More...</a><br /></td></tr>
<tr class="separator:a36df94b032a1de53a79b16ee5c2560a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4ec4dc3b053f6420a5fd449ff4d2c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">drake::Vector6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a3f4ec4dc3b053f6420a5fd449ff4d2c3">CalcFrameSpatialVelocityJacobianDotTimesVInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt; T &gt; &amp;X_BF) const</td></tr>
<tr class="memdesc:a3f4ec4dc3b053f6420a5fd449ff4d2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>Jdot_WF * v</code>, where <code>J_WF</code> is the Jacobian of spatial velocity, <code>V_WF</code>, of frame F measured and expressed in the world frame W, and <code>v</code> is the generalized velocity.  <a href="#a3f4ec4dc3b053f6420a5fd449ff4d2c3">More...</a><br /></td></tr>
<tr class="separator:a3f4ec4dc3b053f6420a5fd449ff4d2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8350cada7cd42d6137edda83bb541892"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">drake::Vector6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a8350cada7cd42d6137edda83bb541892">CalcFrameSpatialVelocityJacobianDotTimesVInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &amp;frame_F) const</td></tr>
<tr class="memdesc:a8350cada7cd42d6137edda83bb541892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>Jdot_WF * v</code>, where <code>J_WF</code> is the Jacobian of spatial velocity <code>V_WF</code> of frame F measured and expressed in the world frame W, and <code>v</code> is the generalized velocity.  <a href="#a8350cada7cd42d6137edda83bb541892">More...</a><br /></td></tr>
<tr class="separator:a8350cada7cd42d6137edda83bb541892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196d6872ffdc16fba0aa7c9f9f17bb01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">drake::Vector6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a196d6872ffdc16fba0aa7c9f9f17bb01">CalcBodySpatialVelocityJacobianDotTimesVInWorldFrame</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;cache, const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:a196d6872ffdc16fba0aa7c9f9f17bb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>Jdot_WB * v</code>, where <code>J_WB</code> is the Jacobian of the spatial velocity <code>V_WB</code> of body frame B measured and expressed in the world frame W, and <code>v</code> is the generalized velocity.  <a href="#a196d6872ffdc16fba0aa7c9f9f17bb01">More...</a><br /></td></tr>
<tr class="separator:a196d6872ffdc16fba0aa7c9f9f17bb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8967c5175ed74e112dd90962c094bea1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a8967c5175ed74e112dd90962c094bea1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af30fe85a821bd0e0ab46f2e165c8e480">drake::TwistMatrix</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a8967c5175ed74e112dd90962c094bea1">worldMomentumMatrix</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set=<a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a>, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot=false) const</td></tr>
<tr class="separator:a8967c5175ed74e112dd90962c094bea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527ff7514e7563e741f82b2c0d324788"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a527ff7514e7563e741f82b2c0d324788"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a527ff7514e7563e741f82b2c0d324788">worldMomentumMatrixDotTimesV</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set=<a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a>) const</td></tr>
<tr class="separator:a527ff7514e7563e741f82b2c0d324788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f67784aa70bcb79dbd4d06fce2b18cd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a9f67784aa70bcb79dbd4d06fce2b18cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af30fe85a821bd0e0ab46f2e165c8e480">drake::TwistMatrix</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a9f67784aa70bcb79dbd4d06fce2b18cd">centroidalMomentumMatrix</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set=<a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a>, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot=false) const</td></tr>
<tr class="separator:a9f67784aa70bcb79dbd4d06fce2b18cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e961432f8a0dcd58d8afd90308fbec8"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a0e961432f8a0dcd58d8afd90308fbec8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a0e961432f8a0dcd58d8afd90308fbec8">centroidalMomentumMatrixDotTimesV</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set=<a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a>) const</td></tr>
<tr class="separator:a0e961432f8a0dcd58d8afd90308fbec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a535a7f01b0924788c33bc1fe261898"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a7a535a7f01b0924788c33bc1fe261898"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, <a class="el" href="namespacedrake.html#af869092c52ed7cc9d2db40ce56050c7c">drake::kSpaceDimension</a>, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a7a535a7f01b0924788c33bc1fe261898">centerOfMassJacobian</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set=<a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a>, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot=false) const</td></tr>
<tr class="separator:a7a535a7f01b0924788c33bc1fe261898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c98475d2e1748ead1a2e2b6fcecb416"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a9c98475d2e1748ead1a2e2b6fcecb416"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, <a class="el" href="namespacedrake.html#af869092c52ed7cc9d2db40ce56050c7c">drake::kSpaceDimension</a>, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a9c98475d2e1748ead1a2e2b6fcecb416">centerOfMassJacobianDotTimesV</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set=<a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a>) const</td></tr>
<tr class="separator:a9c98475d2e1748ead1a2e2b6fcecb416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad910966c8321eb3de14acaa2ac51a3d3"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedC &gt; </td></tr>
<tr class="memitem:ad910966c8321eb3de14acaa2ac51a3d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ad910966c8321eb3de14acaa2ac51a3d3">jointLimitConstraints</a> (Eigen::MatrixBase&lt; DerivedA &gt; const &amp;q, Eigen::MatrixBase&lt; DerivedB &gt; &amp;phi, Eigen::MatrixBase&lt; DerivedC &gt; &amp;J) const</td></tr>
<tr class="separator:ad910966c8321eb3de14acaa2ac51a3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa708a274f3601c05ac7e59f6de33f447"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aa708a274f3601c05ac7e59f6de33f447">getNumJointLimitConstraints</a> () const</td></tr>
<tr class="separator:aa708a274f3601c05ac7e59f6de33f447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b374380bb8e22bcbdb98350f5dcac8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a4b374380bb8e22bcbdb98350f5dcac8e">getNumContacts</a> (const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;body_idx) const</td></tr>
<tr class="separator:a4b374380bb8e22bcbdb98350f5dcac8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07d38fa5629615c367b40a5008feb87"><td class="memTemplParams" colspan="2">template&lt;typename DerivedNormal , typename DerivedPoint &gt; </td></tr>
<tr class="memitem:af07d38fa5629615c367b40a5008feb87"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Eigen::Vector3d, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#af07d38fa5629615c367b40a5008feb87">resolveCenterOfPressure</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;cache, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="struct_force_torque_measurement.html">ForceTorqueMeasurement</a> &gt; &amp;force_torque_measurements, const Eigen::MatrixBase&lt; DerivedNormal &gt; &amp;<a class="el" href="model__test_8cc.html#afd56e5c17150fca11ac8e67451dd6663">normal</a>, const Eigen::MatrixBase&lt; DerivedPoint &gt; &amp;point_on_contact_plane) const</td></tr>
<tr class="memdesc:af07d38fa5629615c367b40a5008feb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes CoP in world frame.  <a href="#af07d38fa5629615c367b40a5008feb87">More...</a><br /></td></tr>
<tr class="separator:af07d38fa5629615c367b40a5008feb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c8046e84d90fb025aa136c64883409"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ac8c8046e84d90fb025aa136c64883409">FindAncestorBodies</a> (<a class="el" href="classint.html">int</a> body_index, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; *ancestor_bodies) const</td></tr>
<tr class="memdesc:ac8c8046e84d90fb025aa136c64883409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the ancestors of a body.  <a href="#ac8c8046e84d90fb025aa136c64883409">More...</a><br /></td></tr>
<tr class="separator:ac8c8046e84d90fb025aa136c64883409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f706aafe45e2c47a009abf339cb639b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a5f706aafe45e2c47a009abf339cb639b">FindAncestorBodies</a> (<a class="el" href="classint.html">int</a> body_index) const</td></tr>
<tr class="memdesc:a5f706aafe45e2c47a009abf339cb639b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to the above overload, expect that this function return the ancestor bodies instead of using an output argument.  <a href="#a5f706aafe45e2c47a009abf339cb639b">More...</a><br /></td></tr>
<tr class="separator:a5f706aafe45e2c47a009abf339cb639b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6862b2d1c00ff774f749c67b160c93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a9e6862b2d1c00ff774f749c67b160c93">findAncestorBodies</a> (<a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;ancestor_bodies, <a class="el" href="classint.html">int</a> body) const</td></tr>
<tr class="separator:a9e6862b2d1c00ff774f749c67b160c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efd7b07f685b1fff27272932efee106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a1efd7b07f685b1fff27272932efee106">FindKinematicPath</a> (<a class="el" href="classint.html">int</a> start_body_or_frame_idx, <a class="el" href="classint.html">int</a> end_body_or_frame_idx, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; *start_body_ancestors, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; *end_body_ancestors, <a class="el" href="struct_kinematic_path.html">KinematicPath</a> *path) const</td></tr>
<tr class="memdesc:a1efd7b07f685b1fff27272932efee106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the kinematic path between two bodies or frames.  <a href="#a1efd7b07f685b1fff27272932efee106">More...</a><br /></td></tr>
<tr class="separator:a1efd7b07f685b1fff27272932efee106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafc870eecb0a95a839d13a5d7e059c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_kinematic_path.html">KinematicPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#acafc870eecb0a95a839d13a5d7e059c2">findKinematicPath</a> (<a class="el" href="classint.html">int</a> start_body_or_frame_idx, <a class="el" href="classint.html">int</a> end_body_or_frame_idx) const</td></tr>
<tr class="separator:acafc870eecb0a95a839d13a5d7e059c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52dc803a7bd84afe62f3496880dfaff"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aa52dc803a7bd84afe62f3496880dfaff"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aa52dc803a7bd84afe62f3496880dfaff">massMatrix</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache) const</td></tr>
<tr class="memdesc:aa52dc803a7bd84afe62f3496880dfaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the positive definite mass (configuration space) matrix \( *H(q) \), defined by \(T = \frac{1}{2} v^T H(q) v \), where \( T \) is kinetic energy.  <a href="#aa52dc803a7bd84afe62f3496880dfaff">More...</a><br /></td></tr>
<tr class="separator:aa52dc803a7bd84afe62f3496880dfaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e2759e0895a88d305ec539bed01fec"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aa6e2759e0895a88d305ec539bed01fec"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aa6e2759e0895a88d305ec539bed01fec">dynamicsBiasTerm</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const <a class="el" href="namespacedrake.html#afcadf96d397f45d041d01bf17061bc32">drake::eigen_aligned_std_unordered_map</a>&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; const *, <a class="el" href="namespacedrake.html#af98fed5f98c376f4d45fff56bb96c8e1">drake::WrenchVector</a>&lt; Scalar &gt;&gt; &amp;external_wrenches, <a class="el" href="classbool.html">bool</a> include_velocity_terms=true) const</td></tr>
<tr class="memdesc:aa6e2759e0895a88d305ec539bed01fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the term \( C(q, v, f_\text{ext}) \) in the manipulator equations </p><p class="formulaDsp">
\[ H(q) \dot{v} + C(q, v, f_\text{ext}) = B(q) u \]
</p>
<p>.  <a href="#aa6e2759e0895a88d305ec539bed01fec">More...</a><br /></td></tr>
<tr class="separator:aa6e2759e0895a88d305ec539bed01fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db480ac1981bb7d352cac340cefb490"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a4db480ac1981bb7d352cac340cefb490"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a4db480ac1981bb7d352cac340cefb490">inverseDynamics</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const <a class="el" href="namespacedrake.html#afcadf96d397f45d041d01bf17061bc32">drake::eigen_aligned_std_unordered_map</a>&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; const *, <a class="el" href="namespacedrake.html#af98fed5f98c376f4d45fff56bb96c8e1">drake::WrenchVector</a>&lt; Scalar &gt;&gt; &amp;external_wrenches, const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;vd, <a class="el" href="classbool.html">bool</a> include_velocity_terms=true) const</td></tr>
<tr class="memdesc:a4db480ac1981bb7d352cac340cefb490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute </p><p class="formulaDsp">
\[ H(q) \dot{v} + C(q, v, f_\text{ext}) \]
</p>
<p> that is, the left hand side of the manipulator equations </p><p class="formulaDsp">
\[ H(q) \dot{v} + C(q, v, f_\text{ext}) = B(q) u \]
</p>
<p>.  <a href="#a4db480ac1981bb7d352cac340cefb490">More...</a><br /></td></tr>
<tr class="separator:a4db480ac1981bb7d352cac340cefb490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1debb13abba690c6b4eae4a7548711"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV &gt; </td></tr>
<tr class="memitem:a7c1debb13abba690c6b4eae4a7548711"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename DerivedV::Scalar, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a7c1debb13abba690c6b4eae4a7548711">frictionTorques</a> (Eigen::MatrixBase&lt; DerivedV &gt; const &amp;v) const</td></tr>
<tr class="separator:a7c1debb13abba690c6b4eae4a7548711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e5eb95e4f888f34d92e07b20ac0784"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a44e5eb95e4f888f34d92e07b20ac0784"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a44e5eb95e4f888f34d92e07b20ac0784">CalcGeneralizedSpringForces</a> (const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt; Scalar &gt; &amp;q) const</td></tr>
<tr class="memdesc:a44e5eb95e4f888f34d92e07b20ac0784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the generalized forces that correspond to joint springs.  <a href="#a44e5eb95e4f888f34d92e07b20ac0784">More...</a><br /></td></tr>
<tr class="separator:a44e5eb95e4f888f34d92e07b20ac0784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edd4c4a2ce10a172d8961293e43a6ef"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename DerivedPoints &gt; </td></tr>
<tr class="memitem:a8edd4c4a2ce10a172d8961293e43a6ef"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, 3, DerivedPoints::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a8edd4c4a2ce10a172d8961293e43a6ef">transformPoints</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;points, <a class="el" href="classint.html">int</a> from_body_or_frame_ind, <a class="el" href="classint.html">int</a> to_body_or_frame_ind) const</td></tr>
<tr class="separator:a8edd4c4a2ce10a172d8961293e43a6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe634c0bc332b198da202f2464ecb89c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:afe634c0bc332b198da202f2464ecb89c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, 4, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#afe634c0bc332b198da202f2464ecb89c">relativeQuaternion</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classint.html">int</a> from_body_or_frame_ind, <a class="el" href="classint.html">int</a> to_body_or_frame_ind) const</td></tr>
<tr class="separator:afe634c0bc332b198da202f2464ecb89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b864391909972e94ad00c3c1b0fc3f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ae5b864391909972e94ad00c3c1b0fc3f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, 3, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ae5b864391909972e94ad00c3c1b0fc3f">relativeRollPitchYaw</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classint.html">int</a> from_body_or_frame_ind, <a class="el" href="classint.html">int</a> to_body_or_frame_ind) const</td></tr>
<tr class="separator:ae5b864391909972e94ad00c3c1b0fc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5326fb460d780258e4a495d298ac77b0"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename DerivedPoints &gt; </td></tr>
<tr class="memitem:a5326fb460d780258e4a495d298ac77b0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a5326fb460d780258e4a495d298ac77b0">transformPointsJacobian</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;points, <a class="el" href="classint.html">int</a> from_body_or_frame_ind, <a class="el" href="classint.html">int</a> to_body_or_frame_ind, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot) const</td></tr>
<tr class="separator:a5326fb460d780258e4a495d298ac77b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8ddaddfebf60b8000697461d89dbb7"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a4f8ddaddfebf60b8000697461d89dbb7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, <a class="el" href="namespacedrake.html#a07869e660ffe730425feca7595de2273">drake::kQuaternionSize</a>, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a4f8ddaddfebf60b8000697461d89dbb7">relativeQuaternionJacobian</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classint.html">int</a> from_body_or_frame_ind, <a class="el" href="classint.html">int</a> to_body_or_frame_ind, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot) const</td></tr>
<tr class="separator:a4f8ddaddfebf60b8000697461d89dbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc1dd761df729d8c1e0d576a4f6daf9"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a7dc1dd761df729d8c1e0d576a4f6daf9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, <a class="el" href="namespacedrake.html#aeab5b0d99cafc2f6ae5812128cea27a3">drake::kRpySize</a>, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a7dc1dd761df729d8c1e0d576a4f6daf9">relativeRollPitchYawJacobian</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classint.html">int</a> from_body_or_frame_ind, <a class="el" href="classint.html">int</a> to_body_or_frame_ind, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot) const</td></tr>
<tr class="separator:a7dc1dd761df729d8c1e0d576a4f6daf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e31fba92943be01ef42ddc131cbda9"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a52e31fba92943be01ef42ddc131cbda9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a52e31fba92943be01ef42ddc131cbda9">forwardKinPositionGradient</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classint.html">int</a> npoints, <a class="el" href="classint.html">int</a> from_body_or_frame_ind, <a class="el" href="classint.html">int</a> to_body_or_frame_ind) const</td></tr>
<tr class="separator:a52e31fba92943be01ef42ddc131cbda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c799895df93f1b738dfd90ac0fe64a7"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename DerivedPoints &gt; </td></tr>
<tr class="memitem:a8c799895df93f1b738dfd90ac0fe64a7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a8c799895df93f1b738dfd90ac0fe64a7">transformPointsJacobianDotTimesV</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;points, <a class="el" href="classint.html">int</a> from_body_or_frame_ind, <a class="el" href="classint.html">int</a> to_body_or_frame_ind) const</td></tr>
<tr class="separator:a8c799895df93f1b738dfd90ac0fe64a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0e3c8ce89222cbe54640f1ad51b870"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a5b0e3c8ce89222cbe54640f1ad51b870"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a5b0e3c8ce89222cbe54640f1ad51b870">relativeQuaternionJacobianDotTimesV</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classint.html">int</a> from_body_or_frame_ind, <a class="el" href="classint.html">int</a> to_body_or_frame_ind) const</td></tr>
<tr class="separator:a5b0e3c8ce89222cbe54640f1ad51b870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f1c690b9d32b3a13a2651e02cff0aa"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ae7f1c690b9d32b3a13a2651e02cff0aa"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ae7f1c690b9d32b3a13a2651e02cff0aa">relativeRollPitchYawJacobianDotTimesV</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classint.html">int</a> from_body_or_frame_ind, <a class="el" href="classint.html">int</a> to_body_or_frame_ind) const</td></tr>
<tr class="separator:ae7f1c690b9d32b3a13a2651e02cff0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746f86636dd7258c9b06a0037f3f698a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a746f86636dd7258c9b06a0037f3f698a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af30fe85a821bd0e0ab46f2e165c8e480">drake::TwistMatrix</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a746f86636dd7258c9b06a0037f3f698a">geometricJacobian</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classint.html">int</a> base_body_or_frame_ind, <a class="el" href="classint.html">int</a> end_effector_body_or_frame_ind, <a class="el" href="classint.html">int</a> expressed_in_body_or_frame_ind, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot=false, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; *v_indices=nullptr) const</td></tr>
<tr class="separator:a746f86636dd7258c9b06a0037f3f698a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497527e262cda142488d88e7c4dbe9f9"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a497527e262cda142488d88e7c4dbe9f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a497527e262cda142488d88e7c4dbe9f9">geometricJacobianDotTimesV</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classint.html">int</a> base_body_or_frame_ind, <a class="el" href="classint.html">int</a> end_effector_body_or_frame_ind, <a class="el" href="classint.html">int</a> expressed_in_body_or_frame_ind) const</td></tr>
<tr class="separator:a497527e262cda142488d88e7c4dbe9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad8496db362562961cbc294d3515148"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a2ad8496db362562961cbc294d3515148"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a2ad8496db362562961cbc294d3515148">relativeTwist</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classint.html">int</a> base_or_frame_ind, <a class="el" href="classint.html">int</a> body_or_frame_ind, <a class="el" href="classint.html">int</a> expressed_in_body_or_frame_ind) const</td></tr>
<tr class="separator:a2ad8496db362562961cbc294d3515148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7156a1348ddbf364a0e076dae5132fe1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a7156a1348ddbf364a0e076dae5132fe1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a7156a1348ddbf364a0e076dae5132fe1">transformSpatialAcceleration</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const <a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt; Scalar &gt; &amp;spatial_acceleration, <a class="el" href="classint.html">int</a> base_or_frame_ind, <a class="el" href="classint.html">int</a> body_or_frame_ind, <a class="el" href="classint.html">int</a> old_body_or_frame_ind, <a class="el" href="classint.html">int</a> new_body_or_frame_ind) const</td></tr>
<tr class="separator:a7156a1348ddbf364a0e076dae5132fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10d52808ad8b8ae1340e0be40ee14cd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af10d52808ad8b8ae1340e0be40ee14cd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Transform&lt; Scalar, <a class="el" href="namespacedrake.html#af869092c52ed7cc9d2db40ce56050c7c">drake::kSpaceDimension</a>, Eigen::Isometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#af10d52808ad8b8ae1340e0be40ee14cd">relativeTransform</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classint.html">int</a> base_or_frame_ind, <a class="el" href="classint.html">int</a> body_or_frame_ind) const</td></tr>
<tr class="separator:af10d52808ad8b8ae1340e0be40ee14cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af926019e0d1224edf16e10a52fe207c2"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af926019e0d1224edf16e10a52fe207c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#af926019e0d1224edf16e10a52fe207c2">computeContactJacobians</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, Eigen::Ref&lt; const Eigen::VectorXi &gt; const &amp;idxA, Eigen::Ref&lt; const Eigen::VectorXi &gt; const &amp;idxB, Eigen::Ref&lt; const Eigen::Matrix3Xd &gt; const &amp;xA, Eigen::Ref&lt; const Eigen::Matrix3Xd &gt; const &amp;xB, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;J) const</td></tr>
<tr class="memdesc:af926019e0d1224edf16e10a52fe207c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian for many points in the format currently used by MATLAB.  <a href="#af926019e0d1224edf16e10a52fe207c2">More...</a><br /></td></tr>
<tr class="separator:af926019e0d1224edf16e10a52fe207c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37666bd71050b708a254ff53155ea838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a37666bd71050b708a254ff53155ea838">addCollisionElement</a> (const <a class="el" href="classdrake_1_1multibody_1_1collision_1_1_element.html">drake::multibody::collision::Element</a> &amp;element, <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const std::string &amp;group_name)</td></tr>
<tr class="memdesc:a37666bd71050b708a254ff53155ea838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new collision element to the tree.  <a href="#a37666bd71050b708a254ff53155ea838">More...</a><br /></td></tr>
<tr class="separator:a37666bd71050b708a254ff53155ea838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155f9a3322b8a50099916f744b55af18"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1collision_1_1_element.html">drake::multibody::collision::Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a155f9a3322b8a50099916f744b55af18">FindCollisionElement</a> (const <a class="el" href="namespacedrake_1_1multibody_1_1collision.html#abedcf22a55257b04e6b7a12700ae4c22">drake::multibody::collision::ElementId</a> &amp;<a class="el" href="multilane_2loader_8cc.html#afd0d68c6d31ff249f3ae8662162663c3">id</a>) const</td></tr>
<tr class="memdesc:a155f9a3322b8a50099916f744b55af18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a <code>const</code> pointer to an element of the collision model.  <a href="#a155f9a3322b8a50099916f744b55af18">More...</a><br /></td></tr>
<tr class="separator:a155f9a3322b8a50099916f744b55af18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d2387b280045cd75e6f4cc07913f61"><td class="memTemplParams" colspan="2">template&lt;class UnaryPredicate &gt; </td></tr>
<tr class="memitem:aa0d2387b280045cd75e6f4cc07913f61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aa0d2387b280045cd75e6f4cc07913f61">removeCollisionGroupsIf</a> (UnaryPredicate test)</td></tr>
<tr class="separator:aa0d2387b280045cd75e6f4cc07913f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9953a97ba893f803344bf23a63c9cde8"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a9953a97ba893f803344bf23a63c9cde8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a9953a97ba893f803344bf23a63c9cde8">updateCollisionElements</a> (const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const Eigen::Transform&lt; U, 3, Eigen::Isometry &gt; &amp;transform_to_world, <a class="el" href="classbool.html">bool</a> throw_if_missing_gradient=true)</td></tr>
<tr class="memdesc:a9953a97ba893f803344bf23a63c9cde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the collision elements registered with the collision detection engine.  <a href="#a9953a97ba893f803344bf23a63c9cde8">More...</a><br /></td></tr>
<tr class="separator:a9953a97ba893f803344bf23a63c9cde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edafc3ed0fa7d1c6cd22721a82b1232"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a4edafc3ed0fa7d1c6cd22721a82b1232"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a4edafc3ed0fa7d1c6cd22721a82b1232">updateDynamicCollisionElements</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; U &gt; &amp;kin_cache, <a class="el" href="classbool.html">bool</a> throw_if_missing_gradient=true)</td></tr>
<tr class="separator:a4edafc3ed0fa7d1c6cd22721a82b1232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320a6f219612759638eb715838b353ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a320a6f219612759638eb715838b353ec">getTerrainContactPoints</a> (const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, Eigen::Matrix3Xd *terrain_points, const std::string &amp;group_name=&quot;&quot;) const</td></tr>
<tr class="memdesc:a320a6f219612759638eb715838b353ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the contact points defined by a body's collision elements.  <a href="#a320a6f219612759638eb715838b353ec">More...</a><br /></td></tr>
<tr class="separator:a320a6f219612759638eb715838b353ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8516e2261e850c3f3086d252ef3ab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a3b8516e2261e850c3f3086d252ef3ab6">collisionRaycast</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;cache, const Eigen::Matrix3Xd &amp;origins, const Eigen::Matrix3Xd &amp;ray_endpoints, Eigen::VectorXd &amp;<a class="el" href="proximity__engine_8cc.html#ae9221f108938d069ec5c5a7b907df8a8">distances</a>, <a class="el" href="classbool.html">bool</a> use_margins=false)</td></tr>
<tr class="separator:a3b8516e2261e850c3f3086d252ef3ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e27d7c8a75cf266100f33fdb6c66813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a7e27d7c8a75cf266100f33fdb6c66813">collisionRaycast</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;cache, const Eigen::Matrix3Xd &amp;origins, const Eigen::Matrix3Xd &amp;ray_endpoints, Eigen::VectorXd &amp;<a class="el" href="proximity__engine_8cc.html#ae9221f108938d069ec5c5a7b907df8a8">distances</a>, Eigen::Matrix3Xd &amp;normals, <a class="el" href="classbool.html">bool</a> use_margins=false)</td></tr>
<tr class="separator:a7e27d7c8a75cf266100f33fdb6c66813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cea7311fd347cbd9d8f82039c5fd413"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a8cea7311fd347cbd9d8f82039c5fd413">collisionDetectFromPoints</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;cache, const Eigen::Matrix3Xd &amp;points, Eigen::VectorXd &amp;phi, Eigen::Matrix3Xd &amp;<a class="el" href="model__test_8cc.html#afd56e5c17150fca11ac8e67451dd6663">normal</a>, Eigen::Matrix3Xd &amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>, Eigen::Matrix3Xd &amp;body_x, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;body_idx, <a class="el" href="classbool.html">bool</a> use_margins)</td></tr>
<tr class="memdesc:a8cea7311fd347cbd9d8f82039c5fd413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <em>signed</em> distance from the given points to the nearest body in the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>.  <a href="#a8cea7311fd347cbd9d8f82039c5fd413">More...</a><br /></td></tr>
<tr class="separator:a8cea7311fd347cbd9d8f82039c5fd413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5202a27df2759895aa2084cb72cc300b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a5202a27df2759895aa2084cb72cc300b">collisionDetect</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;cache, Eigen::VectorXd &amp;phi, Eigen::Matrix3Xd &amp;<a class="el" href="model__test_8cc.html#afd56e5c17150fca11ac8e67451dd6663">normal</a>, Eigen::Matrix3Xd &amp;xA, Eigen::Matrix3Xd &amp;xB, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodyA_idx, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodyB_idx, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody_1_1collision.html#abedcf22a55257b04e6b7a12700ae4c22">drake::multibody::collision::ElementId</a> &gt; &amp;ids_to_check, <a class="el" href="classbool.html">bool</a> use_margins)</td></tr>
<tr class="separator:a5202a27df2759895aa2084cb72cc300b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9618c2419ccd22414c2c176dd949b134"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a9618c2419ccd22414c2c176dd949b134">collisionDetect</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;cache, Eigen::VectorXd &amp;phi, Eigen::Matrix3Xd &amp;<a class="el" href="model__test_8cc.html#afd56e5c17150fca11ac8e67451dd6663">normal</a>, Eigen::Matrix3Xd &amp;xA, Eigen::Matrix3Xd &amp;xB, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodyA_idx, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodyB_idx, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodies_idx, const std::set&lt; std::string &gt; &amp;active_element_groups, <a class="el" href="classbool.html">bool</a> use_margins=true)</td></tr>
<tr class="separator:a9618c2419ccd22414c2c176dd949b134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcad86795f3fd778b7d31314c5ccc85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a7bcad86795f3fd778b7d31314c5ccc85">collisionDetect</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;cache, Eigen::VectorXd &amp;phi, Eigen::Matrix3Xd &amp;<a class="el" href="model__test_8cc.html#afd56e5c17150fca11ac8e67451dd6663">normal</a>, Eigen::Matrix3Xd &amp;xA, Eigen::Matrix3Xd &amp;xB, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodyA_idx, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodyB_idx, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodies_idx, <a class="el" href="classbool.html">bool</a> use_margins=true)</td></tr>
<tr class="separator:a7bcad86795f3fd778b7d31314c5ccc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3f2782336211ad25cadcd004e2c19e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#afb3f2782336211ad25cadcd004e2c19e">collisionDetect</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;cache, Eigen::VectorXd &amp;phi, Eigen::Matrix3Xd &amp;<a class="el" href="model__test_8cc.html#afd56e5c17150fca11ac8e67451dd6663">normal</a>, Eigen::Matrix3Xd &amp;xA, Eigen::Matrix3Xd &amp;xB, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodyA_idx, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodyB_idx, const std::set&lt; std::string &gt; &amp;active_element_groups, <a class="el" href="classbool.html">bool</a> use_margins=true)</td></tr>
<tr class="separator:afb3f2782336211ad25cadcd004e2c19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7463d5993ca7e5d39f3d74a19823aa13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a7463d5993ca7e5d39f3d74a19823aa13">collisionDetect</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;cache, Eigen::VectorXd &amp;phi, Eigen::Matrix3Xd &amp;<a class="el" href="model__test_8cc.html#afd56e5c17150fca11ac8e67451dd6663">normal</a>, Eigen::Matrix3Xd &amp;xA, Eigen::Matrix3Xd &amp;xB, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodyA_idx, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodyB_idx, <a class="el" href="classbool.html">bool</a> use_margins=true)</td></tr>
<tr class="separator:a7463d5993ca7e5d39f3d74a19823aa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887d5e35d3c9efe5829919cce6bef698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a887d5e35d3c9efe5829919cce6bef698">allCollisions</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;cache, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodyA_idx, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;bodyB_idx, Eigen::Matrix3Xd &amp;ptsA, Eigen::Matrix3Xd &amp;ptsB, <a class="el" href="classbool.html">bool</a> use_margins=true)</td></tr>
<tr class="separator:a887d5e35d3c9efe5829919cce6bef698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff25f6baacbae752077e9815ef46d256"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aff25f6baacbae752077e9815ef46d256"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="structdrake_1_1multibody_1_1collision_1_1_point_pair.html">drake::multibody::collision::PointPair</a>&lt; U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aff25f6baacbae752077e9815ef46d256">ComputeMaximumDepthCollisionPoints</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; U &gt; &amp;cache, <a class="el" href="classbool.html">bool</a> use_margins=true, <a class="el" href="classbool.html">bool</a> throw_if_missing_gradient=true)</td></tr>
<tr class="memdesc:aff25f6baacbae752077e9815ef46d256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point of closest approach between bodies in the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> that are in contact.  <a href="#aff25f6baacbae752077e9815ef46d256">More...</a><br /></td></tr>
<tr class="separator:aff25f6baacbae752077e9815ef46d256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2985ac4da5a693dd0f7cbf4399857a98"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a2985ac4da5a693dd0f7cbf4399857a98">collidingPointsCheckOnly</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;cache, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Vector3d &gt; &amp;points, <a class="el" href="classdouble.html">double</a> collision_threshold)</td></tr>
<tr class="separator:a2985ac4da5a693dd0f7cbf4399857a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee04ee05aa234710873c057e3eaf374"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a4ee04ee05aa234710873c057e3eaf374">collidingPoints</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;cache, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Vector3d &gt; &amp;points, <a class="el" href="classdouble.html">double</a> collision_threshold)</td></tr>
<tr class="separator:a4ee04ee05aa234710873c057e3eaf374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e325c1b67c953d7f5232291db4e6fdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a5e325c1b67c953d7f5232291db4e6fdd">FindBody</a> (const std::string &amp;body_name, const std::string &amp;model_name=&quot;&quot;, <a class="el" href="classint.html">int</a> model_id=-1) const</td></tr>
<tr class="memdesc:a5e325c1b67c953d7f5232291db4e6fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a body with the specified <code>body_name</code> belonging to a model with the specified <code>model_name</code> and <code>model_id</code>.  <a href="#a5e325c1b67c953d7f5232291db4e6fdd">More...</a><br /></td></tr>
<tr class="separator:a5e325c1b67c953d7f5232291db4e6fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5bd45017c41d3b1c046ca284a82e07"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ace5bd45017c41d3b1c046ca284a82e07">FindBody</a> (<a class="el" href="namespacedrake_1_1multibody_1_1collision.html#abedcf22a55257b04e6b7a12700ae4c22">drake::multibody::collision::ElementId</a> element_id) const</td></tr>
<tr class="memdesc:ace5bd45017c41d3b1c046ca284a82e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the <a class="el" href="class_rigid_body.html">RigidBody</a> that owns the collision element indicated by the id.  <a href="#ace5bd45017c41d3b1c046ca284a82e07">More...</a><br /></td></tr>
<tr class="separator:ace5bd45017c41d3b1c046ca284a82e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fbd45e66ce80729e8b9b85874bb1c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aa7fbd45e66ce80729e8b9b85874bb1c7">FindModelInstanceBodies</a> (<a class="el" href="classint.html">int</a> model_instance_id) const</td></tr>
<tr class="memdesc:aa7fbd45e66ce80729e8b9b85874bb1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of pointers to all rigid bodies in this tree that belong to a particular model instance.  <a href="#aa7fbd45e66ce80729e8b9b85874bb1c7">More...</a><br /></td></tr>
<tr class="separator:aa7fbd45e66ce80729e8b9b85874bb1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63e8b7073c728971612311204ddf033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aa63e8b7073c728971612311204ddf033">findLink</a> (const std::string &amp;link_name, const std::string &amp;model_name=&quot;&quot;, <a class="el" href="classint.html">int</a> model_id=-1) const</td></tr>
<tr class="memdesc:aa63e8b7073c728971612311204ddf033"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a deprecated version of <code>FindBody(...)</code>.  <a href="#aa63e8b7073c728971612311204ddf033">More...</a><br /></td></tr>
<tr class="separator:aa63e8b7073c728971612311204ddf033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359d38df6f29c104adccaf34d0b7454c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a359d38df6f29c104adccaf34d0b7454c">FindBaseBodies</a> (<a class="el" href="classint.html">int</a> model_instance_id=-1) const</td></tr>
<tr class="memdesc:a359d38df6f29c104adccaf34d0b7454c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a vector of indexes of the bodies that are directly attached to the world via any type of joint.  <a href="#a359d38df6f29c104adccaf34d0b7454c">More...</a><br /></td></tr>
<tr class="separator:a359d38df6f29c104adccaf34d0b7454c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0ed8e04aeaef968766a67a3ee2bd54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#adc0ed8e04aeaef968766a67a3ee2bd54">FindBodyIndex</a> (const std::string &amp;body_name, <a class="el" href="classint.html">int</a> model_instance_id=-1) const</td></tr>
<tr class="memdesc:adc0ed8e04aeaef968766a67a3ee2bd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the index of a rigid body within this rigid body tree.  <a href="#adc0ed8e04aeaef968766a67a3ee2bd54">More...</a><br /></td></tr>
<tr class="separator:adc0ed8e04aeaef968766a67a3ee2bd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cb064cc59093fb94a1aad7287fe918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a20cb064cc59093fb94a1aad7287fe918">FindChildrenOfBody</a> (<a class="el" href="classint.html">int</a> parent_body_index, <a class="el" href="classint.html">int</a> model_instance_id=-1) const</td></tr>
<tr class="memdesc:a20cb064cc59093fb94a1aad7287fe918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of indexes of bodies that are the children of the body at index <code>parent_body_index</code>.  <a href="#a20cb064cc59093fb94a1aad7287fe918">More...</a><br /></td></tr>
<tr class="separator:a20cb064cc59093fb94a1aad7287fe918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ec5b2601497a1b1f5d57411d216be7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a62ec5b2601497a1b1f5d57411d216be7">findLinkId</a> (const std::string &amp;link_name, <a class="el" href="classint.html">int</a> model_id=-1) const</td></tr>
<tr class="memdesc:a62ec5b2601497a1b1f5d57411d216be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a deprecated version of <code>FindBodyIndex(...)</code>.  <a href="#a62ec5b2601497a1b1f5d57411d216be7">More...</a><br /></td></tr>
<tr class="separator:a62ec5b2601497a1b1f5d57411d216be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4b6ad34e5782815a16725b03ca7fd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a3c4b6ad34e5782815a16725b03ca7fd5">FindChildBodyOfJoint</a> (const std::string &amp;joint_name, <a class="el" href="classint.html">int</a> model_instance_id=-1) const</td></tr>
<tr class="memdesc:a3c4b6ad34e5782815a16725b03ca7fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a pointer to the rigid body whose parent joint is named <code>joint_name</code> and is part of a model instance with ID <code>model_instance_id</code>.  <a href="#a3c4b6ad34e5782815a16725b03ca7fd5">More...</a><br /></td></tr>
<tr class="separator:a3c4b6ad34e5782815a16725b03ca7fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1552be870f521c8316c9dbae724a07f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a1552be870f521c8316c9dbae724a07f4">findJoint</a> (const std::string &amp;joint_name, <a class="el" href="classint.html">int</a> model_id=-1) const</td></tr>
<tr class="separator:a1552be870f521c8316c9dbae724a07f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa544a9ff2936749d38b32b62c270c173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aa544a9ff2936749d38b32b62c270c173">FindIndexOfChildBodyOfJoint</a> (const std::string &amp;joint_name, <a class="el" href="classint.html">int</a> model_instance_id=-1) const</td></tr>
<tr class="memdesc:aa544a9ff2936749d38b32b62c270c173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index within the vector of rigid bodies of the rigid body whose parent joint is named <code>joint_name</code> and is part of a model instance with ID <code>model_instance_id</code>.  <a href="#aa544a9ff2936749d38b32b62c270c173">More...</a><br /></td></tr>
<tr class="separator:aa544a9ff2936749d38b32b62c270c173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7e9bb14a9e6441a85f913eadddfc4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aac7e9bb14a9e6441a85f913eadddfc4e">findJointId</a> (const std::string &amp;joint_name, <a class="el" href="classint.html">int</a> model_id=-1) const</td></tr>
<tr class="separator:aac7e9bb14a9e6441a85f913eadddfc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fd34a32edfffc921d4d7109243709f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#af8fd34a32edfffc921d4d7109243709f">findFrame</a> (const std::string &amp;frame_name, <a class="el" href="classint.html">int</a> model_id=-1) const</td></tr>
<tr class="memdesc:af8fd34a32edfffc921d4d7109243709f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a frame of the specified <code>frame_name</code> belonging to a model with the specified <code>model_id</code>.  <a href="#af8fd34a32edfffc921d4d7109243709f">More...</a><br /></td></tr>
<tr class="separator:af8fd34a32edfffc921d4d7109243709f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af624e55c30f00895414147dc1334538c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#af624e55c30f00895414147dc1334538c">get_body</a> (<a class="el" href="classint.html">int</a> body_index) const</td></tr>
<tr class="memdesc:af624e55c30f00895414147dc1334538c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the body at index <code>body_index</code>.  <a href="#af624e55c30f00895414147dc1334538c">More...</a><br /></td></tr>
<tr class="separator:af624e55c30f00895414147dc1334538c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750de836b86f126cc2b82eca6c25773f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a750de836b86f126cc2b82eca6c25773f">get_mutable_body</a> (<a class="el" href="classint.html">int</a> body_index)</td></tr>
<tr class="memdesc:a750de836b86f126cc2b82eca6c25773f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the body at index <code>body_index</code>.  <a href="#a750de836b86f126cc2b82eca6c25773f">More...</a><br /></td></tr>
<tr class="separator:a750de836b86f126cc2b82eca6c25773f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d058d7557f133059de2669abcf4383d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a2d058d7557f133059de2669abcf4383d">get_num_bodies</a> () const</td></tr>
<tr class="memdesc:a2d058d7557f133059de2669abcf4383d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bodies in this tree.  <a href="#a2d058d7557f133059de2669abcf4383d">More...</a><br /></td></tr>
<tr class="separator:a2d058d7557f133059de2669abcf4383d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7724e661f14644bd6d93f913d17f12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a2a7724e661f14644bd6d93f913d17f12">get_num_frames</a> () const</td></tr>
<tr class="memdesc:a2a7724e661f14644bd6d93f913d17f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of frames in this tree.  <a href="#a2a7724e661f14644bd6d93f913d17f12">More...</a><br /></td></tr>
<tr class="separator:a2a7724e661f14644bd6d93f913d17f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9e27e73e3045e35f483009d132b1a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a2a9e27e73e3045e35f483009d132b1a4">get_number_of_bodies</a> () const</td></tr>
<tr class="separator:a2a9e27e73e3045e35f483009d132b1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d9e00bbd5aee3b2da50bca0b43819c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ae1d9e00bbd5aee3b2da50bca0b43819c">getBodyOrFrameName</a> (<a class="el" href="classint.html">int</a> body_or_frame_id) const</td></tr>
<tr class="separator:ae1d9e00bbd5aee3b2da50bca0b43819c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfe664359107ac857001badda453fdf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_rigid_body_actuator.html">RigidBodyActuator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a8dfe664359107ac857001badda453fdf">GetActuator</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:a8dfe664359107ac857001badda453fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a rigid body actuator from this rigid body tree.  <a href="#a8dfe664359107ac857001badda453fdf">More...</a><br /></td></tr>
<tr class="separator:a8dfe664359107ac857001badda453fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f2e1d3a046aa0fdfd4ba09b7ef2e7d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a70f2e1d3a046aa0fdfd4ba09b7ef2e7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a70f2e1d3a046aa0fdfd4ba09b7ef2e7d">parseBodyOrFrameID</a> (const <a class="el" href="classint.html">int</a> body_or_frame_id, Eigen::Transform&lt; Scalar, 3, Eigen::Isometry &gt; *Tframe) const</td></tr>
<tr class="separator:a70f2e1d3a046aa0fdfd4ba09b7ef2e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860adb0d81bd2c85bb553c2463df984c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a860adb0d81bd2c85bb553c2463df984c">parseBodyOrFrameID</a> (const <a class="el" href="classint.html">int</a> body_or_frame_id) const</td></tr>
<tr class="separator:a860adb0d81bd2c85bb553c2463df984c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b1f01dec5165bc5a3ecb43c43f7ec4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a64b1f01dec5165bc5a3ecb43c43f7ec4">addDistanceConstraint</a> (<a class="el" href="classint.html">int</a> bodyA_index_in, const Eigen::Vector3d &amp;r_AP_in, <a class="el" href="classint.html">int</a> bodyB_index_in, const Eigen::Vector3d &amp;r_BQ_in, <a class="el" href="classdouble.html">double</a> distance_in)</td></tr>
<tr class="memdesc:a64b1f01dec5165bc5a3ecb43c43f7ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For details on parameters see RigidBodyDistanceContraint.  <a href="#a64b1f01dec5165bc5a3ecb43c43f7ec4">More...</a><br /></td></tr>
<tr class="separator:a64b1f01dec5165bc5a3ecb43c43f7ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f3880edd99724779a6bf4d60ecde64"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a66f3880edd99724779a6bf4d60ecde64"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a66f3880edd99724779a6bf4d60ecde64">positionConstraints</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache) const</td></tr>
<tr class="separator:a66f3880edd99724779a6bf4d60ecde64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba716a6494b76bc06d45410934433b1c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aba716a6494b76bc06d45410934433b1c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aba716a6494b76bc06d45410934433b1c">positionConstraintsJacobian</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot=true) const</td></tr>
<tr class="separator:aba716a6494b76bc06d45410934433b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc417fc535f72a29ecca7bf873234e0d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:acc417fc535f72a29ecca7bf873234e0d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#acc417fc535f72a29ecca7bf873234e0d">positionConstraintsJacDotTimesV</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache) const</td></tr>
<tr class="separator:acc417fc535f72a29ecca7bf873234e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113a1f4fed5c3230541fb3161aa49e13"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a113a1f4fed5c3230541fb3161aa49e13">getNumPositionConstraints</a> () const</td></tr>
<tr class="separator:a113a1f4fed5c3230541fb3161aa49e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d5766ec002601868e45e7f390a9465"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a01d5766ec002601868e45e7f390a9465"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived::Scalar, Derived::RowsAtCompileTime, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a01d5766ec002601868e45e7f390a9465">compactToFull</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;compact, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;joint_path, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot) const</td></tr>
<tr class="separator:a01d5766ec002601868e45e7f390a9465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8beda2a69676dd3e1d8d14c057eb81f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a8beda2a69676dd3e1d8d14c057eb81f4">add_rigid_body</a> (std::unique_ptr&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt;&gt; body)</td></tr>
<tr class="memdesc:a8beda2a69676dd3e1d8d14c057eb81f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds and takes ownership of a rigid body.  <a href="#a8beda2a69676dd3e1d8d14c057eb81f4">More...</a><br /></td></tr>
<tr class="separator:a8beda2a69676dd3e1d8d14c057eb81f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f76ceb30c04f1723e8d6371c575738e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a7f76ceb30c04f1723e8d6371c575738e">DefineCollisionFilterGroup</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a7f76ceb30c04f1723e8d6371c575738e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to define a new collision filter group.  <a href="#a7f76ceb30c04f1723e8d6371c575738e">More...</a><br /></td></tr>
<tr class="separator:a7f76ceb30c04f1723e8d6371c575738e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c94a62910b6ff7d820e81a1cdcf865"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ab6c94a62910b6ff7d820e81a1cdcf865">AddCollisionFilterGroupMember</a> (const std::string &amp;group_name, const std::string &amp;body_name, <a class="el" href="classint.html">int</a> model_id)</td></tr>
<tr class="memdesc:ab6c94a62910b6ff7d820e81a1cdcf865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="class_rigid_body.html">RigidBody</a> to a collision filter group.  <a href="#ab6c94a62910b6ff7d820e81a1cdcf865">More...</a><br /></td></tr>
<tr class="separator:ab6c94a62910b6ff7d820e81a1cdcf865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9f715660bbdc87f79fba9aaeb612ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a4c9f715660bbdc87f79fba9aaeb612ad">AddCollisionFilterIgnoreTarget</a> (const std::string &amp;group_name, const std::string &amp;target_group_name)</td></tr>
<tr class="memdesc:a4c9f715660bbdc87f79fba9aaeb612ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a collision group to the set of groups ignored by the specified collision filter group.  <a href="#a4c9f715660bbdc87f79fba9aaeb612ad">More...</a><br /></td></tr>
<tr class="separator:a4c9f715660bbdc87f79fba9aaeb612ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9981c39a1ebe848c0b78ccd3f54c90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#acf9981c39a1ebe848c0b78ccd3f54c90">world</a> ()</td></tr>
<tr class="memdesc:acf9981c39a1ebe848c0b78ccd3f54c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the <a class="el" href="class_rigid_body.html">RigidBody</a> associated with the world in the model.  <a href="#acf9981c39a1ebe848c0b78ccd3f54c90">More...</a><br /></td></tr>
<tr class="separator:acf9981c39a1ebe848c0b78ccd3f54c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae012a07a4821c25770bfbb748854ad56"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ae012a07a4821c25770bfbb748854ad56">world</a> () const</td></tr>
<tr class="memdesc:ae012a07a4821c25770bfbb748854ad56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the <a class="el" href="class_rigid_body.html">RigidBody</a> associated with the world in the model.  <a href="#ae012a07a4821c25770bfbb748854ad56">More...</a><br /></td></tr>
<tr class="separator:ae012a07a4821c25770bfbb748854ad56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30342f766e5b14049b65f710581f4bd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a30342f766e5b14049b65f710581f4bd1">get_num_positions</a> () const</td></tr>
<tr class="memdesc:a30342f766e5b14049b65f710581f4bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of position states outputted by this RigidBodyTree.  <a href="#a30342f766e5b14049b65f710581f4bd1">More...</a><br /></td></tr>
<tr class="separator:a30342f766e5b14049b65f710581f4bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93be76182a2b3061b1530d12076bcfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ab93be76182a2b3061b1530d12076bcfa">number_of_positions</a> () const</td></tr>
<tr class="separator:ab93be76182a2b3061b1530d12076bcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372731ef06a823324bfeda5c8a8a3ac8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a372731ef06a823324bfeda5c8a8a3ac8">get_num_velocities</a> () const</td></tr>
<tr class="memdesc:a372731ef06a823324bfeda5c8a8a3ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of velocity states outputted by this RigidBodyTree.  <a href="#a372731ef06a823324bfeda5c8a8a3ac8">More...</a><br /></td></tr>
<tr class="separator:a372731ef06a823324bfeda5c8a8a3ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a564f744c031d6491257aa0f4490ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aa0a564f744c031d6491257aa0f4490ce">number_of_velocities</a> () const</td></tr>
<tr class="separator:aa0a564f744c031d6491257aa0f4490ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17a4f6613813e5ff10d3f2eaaf513be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ac17a4f6613813e5ff10d3f2eaaf513be">get_num_actuators</a> () const</td></tr>
<tr class="memdesc:ac17a4f6613813e5ff10d3f2eaaf513be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of actuators in this RigidBodyTree.  <a href="#ac17a4f6613813e5ff10d3f2eaaf513be">More...</a><br /></td></tr>
<tr class="separator:ac17a4f6613813e5ff10d3f2eaaf513be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe87a180d00c685893090166d7a8dd46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#afe87a180d00c685893090166d7a8dd46">initialized</a> () const</td></tr>
<tr class="memdesc:afe87a180d00c685893090166d7a8dd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this RigidBodyTree is initialized.  <a href="#afe87a180d00c685893090166d7a8dd46">More...</a><br /></td></tr>
<tr class="separator:afe87a180d00c685893090166d7a8dd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ef71a5abd869d1461a7f1367a7c727"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ac2ef71a5abd869d1461a7f1367a7c727"><td class="memTemplItemLeft" align="right" valign="top">TwistMatrix&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ac2ef71a5abd869d1461a7f1367a7c727">worldMomentumMatrix</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot) const</td></tr>
<tr class="separator:ac2ef71a5abd869d1461a7f1367a7c727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac622a42b4403b2cdd4060d6f08d450a8"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ac622a42b4403b2cdd4060d6f08d450a8"><td class="memTemplItemLeft" align="right" valign="top">TwistVector&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ac622a42b4403b2cdd4060d6f08d450a8">worldMomentumMatrixDotTimesV</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set) const</td></tr>
<tr class="separator:ac622a42b4403b2cdd4060d6f08d450a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3078af454eec1842c34a35663590be20"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a3078af454eec1842c34a35663590be20"><td class="memTemplItemLeft" align="right" valign="top">TwistMatrix&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a3078af454eec1842c34a35663590be20">centroidalMomentumMatrix</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot) const</td></tr>
<tr class="separator:a3078af454eec1842c34a35663590be20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92729aa595b1025bb2173468872eb68"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ae92729aa595b1025bb2173468872eb68"><td class="memTemplItemLeft" align="right" valign="top">TwistVector&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ae92729aa595b1025bb2173468872eb68">centroidalMomentumMatrixDotTimesV</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set) const</td></tr>
<tr class="separator:ae92729aa595b1025bb2173468872eb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3705ad59184fe3fcfad96af6d5114a62"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a3705ad59184fe3fcfad96af6d5114a62"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, kSpaceDimension, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a3705ad59184fe3fcfad96af6d5114a62">centerOfMass</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set) const</td></tr>
<tr class="separator:a3705ad59184fe3fcfad96af6d5114a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17add192541efde45e8d8ea8404d9477"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a17add192541efde45e8d8ea8404d9477"><td class="memTemplItemLeft" align="right" valign="top">MatrixX&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a17add192541efde45e8d8ea8404d9477">transformVelocityMappingToQDotMapping</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename Derived::Scalar &gt; &amp;cache, const Eigen::MatrixBase&lt; Derived &gt; &amp;Av)</td></tr>
<tr class="separator:a17add192541efde45e8d8ea8404d9477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aea901f1e05d9b548a06333f95a4f19"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9aea901f1e05d9b548a06333f95a4f19"><td class="memTemplItemLeft" align="right" valign="top">MatrixX&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a9aea901f1e05d9b548a06333f95a4f19">transformQDotMappingToVelocityMapping</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename Derived::Scalar &gt; &amp;cache, const Eigen::MatrixBase&lt; Derived &gt; &amp;Ap)</td></tr>
<tr class="separator:a9aea901f1e05d9b548a06333f95a4f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73932132eeb7b040aa74ee57aa73bf0"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ab73932132eeb7b040aa74ee57aa73bf0"><td class="memTemplItemLeft" align="right" valign="top">MatrixX&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ab73932132eeb7b040aa74ee57aa73bf0">GetVelocityToQDotMapping</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache)</td></tr>
<tr class="separator:ab73932132eeb7b040aa74ee57aa73bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc193b53847fdac24143e08161de207"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aefc193b53847fdac24143e08161de207"><td class="memTemplItemLeft" align="right" valign="top">MatrixX&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aefc193b53847fdac24143e08161de207">GetQDotToVelocityMapping</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache)</td></tr>
<tr class="separator:aefc193b53847fdac24143e08161de207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bf88d8b8dd8644c0b260cc9d557b06"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a36bf88d8b8dd8644c0b260cc9d557b06"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; Scalar, kSpaceDimension, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a36bf88d8b8dd8644c0b260cc9d557b06">centerOfMassJacobian</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set, <a class="el" href="classbool.html">bool</a> in_terms_of_qdot) const</td></tr>
<tr class="separator:a36bf88d8b8dd8644c0b260cc9d557b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8ab2ab3db8a4959da7a1611c8d8f3b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a1b8ab2ab3db8a4959da7a1611c8d8f3b"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; Scalar, kSpaceDimension, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a1b8ab2ab3db8a4959da7a1611c8d8f3b">centerOfMassJacobianDotTimesV</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;model_instance_id_set) const</td></tr>
<tr class="separator:a1b8ab2ab3db8a4959da7a1611c8d8f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b28457f0672d6a6c15b61646580bcd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ae9b28457f0672d6a6c15b61646580bcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ae9b28457f0672d6a6c15b61646580bcd">parseBodyOrFrameID</a> (const <a class="el" href="classint.html">int</a> body_or_frame_id, Eigen::Transform&lt; Scalar, 3, Isometry &gt; *Tframe) const</td></tr>
<tr class="separator:ae9b28457f0672d6a6c15b61646580bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c5fd8881bd97dde7e7266ce4329e60"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a72c5fd8881bd97dde7e7266ce4329e60"><td class="memTemplItemLeft" align="right" valign="top">Transform&lt; Scalar, 3, Isometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a72c5fd8881bd97dde7e7266ce4329e60">relativeTransform</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classint.html">int</a> base_or_frame_ind, <a class="el" href="classint.html">int</a> body_or_frame_ind) const</td></tr>
<tr class="separator:a72c5fd8881bd97dde7e7266ce4329e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfe2a76e80365e043a9d92413c0b108"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a3bfe2a76e80365e043a9d92413c0b108"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a3bfe2a76e80365e043a9d92413c0b108">massMatrix</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache) const</td></tr>
<tr class="separator:a3bfe2a76e80365e043a9d92413c0b108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca30e682806bdc162294a13395d89c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a21ca30e682806bdc162294a13395d89c"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a21ca30e682806bdc162294a13395d89c">dynamicsBiasTerm</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const <a class="el" href="namespacedrake.html#afcadf96d397f45d041d01bf17061bc32">drake::eigen_aligned_std_unordered_map</a>&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; const *, WrenchVector&lt; Scalar &gt;&gt; &amp;external_wrenches, <a class="el" href="classbool.html">bool</a> include_velocity_terms) const</td></tr>
<tr class="separator:a21ca30e682806bdc162294a13395d89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c6088b2b6203aeb00305adf5c249bd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a54c6088b2b6203aeb00305adf5c249bd"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a54c6088b2b6203aeb00305adf5c249bd">inverseDynamics</a> (<a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const <a class="el" href="namespacedrake.html#afcadf96d397f45d041d01bf17061bc32">drake::eigen_aligned_std_unordered_map</a>&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; const *, WrenchVector&lt; Scalar &gt;&gt; &amp;external_wrenches, const Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;vd, <a class="el" href="classbool.html">bool</a> include_velocity_terms) const</td></tr>
<tr class="separator:a54c6088b2b6203aeb00305adf5c249bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4402575f7605eb607735c61630240a3a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV &gt; </td></tr>
<tr class="memitem:a4402575f7605eb607735c61630240a3a"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; typename DerivedV::Scalar, Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a4402575f7605eb607735c61630240a3a">frictionTorques</a> (Eigen::MatrixBase&lt; DerivedV &gt; const &amp;v) const</td></tr>
<tr class="separator:a4402575f7605eb607735c61630240a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d8d903ad67cb27354a4c81c3394d78"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ac7d8d903ad67cb27354a4c81c3394d78"><td class="memTemplItemLeft" align="right" valign="top">VectorX&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ac7d8d903ad67cb27354a4c81c3394d78">CalcGeneralizedSpringForces</a> (const VectorX&lt; Scalar &gt; &amp;q) const</td></tr>
<tr class="separator:ac7d8d903ad67cb27354a4c81c3394d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa15d156dacdccb399519f16a2aafc6"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a8fa15d156dacdccb399519f16a2aafc6"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a8fa15d156dacdccb399519f16a2aafc6">forwardKinPositionGradient</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, <a class="el" href="classint.html">int</a> npoints, <a class="el" href="classint.html">int</a> from_body_or_frame_ind, <a class="el" href="classint.html">int</a> to_body_or_frame_ind) const</td></tr>
<tr class="separator:a8fa15d156dacdccb399519f16a2aafc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca770c9a924ed6c8c27a48578ead486"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:adca770c9a924ed6c8c27a48578ead486"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#adca770c9a924ed6c8c27a48578ead486">positionConstraints</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache) const</td></tr>
<tr class="separator:adca770c9a924ed6c8c27a48578ead486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d753d104699644a99a69841d2aac4e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedC &gt; </td></tr>
<tr class="memitem:a10d753d104699644a99a69841d2aac4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a10d753d104699644a99a69841d2aac4e">jointLimitConstraints</a> (MatrixBase&lt; DerivedA &gt; const &amp;q, MatrixBase&lt; DerivedB &gt; &amp;phi, MatrixBase&lt; DerivedC &gt; &amp;J) const</td></tr>
<tr class="separator:a10d753d104699644a99a69841d2aac4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39121f0149ef5f9ca187111d18d35fd0"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a39121f0149ef5f9ca187111d18d35fd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a39121f0149ef5f9ca187111d18d35fd0">accumulateContactJacobian</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, const <a class="el" href="classint.html">int</a> bodyInd, Matrix3Xd const &amp;bodyPoints, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; size_t &gt; const &amp;cindA, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; size_t &gt; const &amp;cindB, Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;J) const</td></tr>
<tr class="separator:a39121f0149ef5f9ca187111d18d35fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4181a7a83f7805a5a6d6ee62b7ee46"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a9e4181a7a83f7805a5a6d6ee62b7ee46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a9e4181a7a83f7805a5a6d6ee62b7ee46">computeContactJacobians</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache, Ref&lt; const VectorXi &gt; const &amp;idxA, Ref&lt; const VectorXi &gt; const &amp;idxB, Ref&lt; const Matrix3Xd &gt; const &amp;xA, Ref&lt; const Matrix3Xd &gt; const &amp;xB, Matrix&lt; Scalar, Dynamic, Dynamic &gt; &amp;J) const</td></tr>
<tr class="separator:a9e4181a7a83f7805a5a6d6ee62b7ee46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a87bbc7234338cba447fd7e1e9d900064"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a87bbc7234338cba447fd7e1e9d900064">CreateKinematicsCacheFromBodiesVector</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; std::unique_ptr&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt;&gt;&gt; &amp;bodies)</td></tr>
<tr class="memdesc:a87bbc7234338cba447fd7e1e9d900064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> given a reference to a vector of rigid bodies contained within a <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>.  <a href="#a87bbc7234338cba447fd7e1e9d900064">More...</a><br /></td></tr>
<tr class="separator:a87bbc7234338cba447fd7e1e9d900064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8931220c0057896f5eeb44000e7ba1d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ae8931220c0057896f5eeb44000e7ba1d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ae8931220c0057896f5eeb44000e7ba1d">transformQDotToVelocity</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename Derived::Scalar &gt; &amp;cache, const Eigen::MatrixBase&lt; Derived &gt; &amp;qdot)</td></tr>
<tr class="memdesc:ae8931220c0057896f5eeb44000e7ba1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of the time derivative of generalized coordinates (qdot) to generalized velocity (v).  <a href="#ae8931220c0057896f5eeb44000e7ba1d">More...</a><br /></td></tr>
<tr class="separator:ae8931220c0057896f5eeb44000e7ba1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cf90b2baa4100731b63612b3874dda"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a53cf90b2baa4100731b63612b3874dda"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a53cf90b2baa4100731b63612b3874dda">transformVelocityToQDot</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename Derived::Scalar &gt; &amp;cache, const Eigen::MatrixBase&lt; Derived &gt; &amp;v)</td></tr>
<tr class="memdesc:a53cf90b2baa4100731b63612b3874dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of generalized velocities (v) to the time derivative of generalized coordinates (qdot).  <a href="#a53cf90b2baa4100731b63612b3874dda">More...</a><br /></td></tr>
<tr class="separator:a53cf90b2baa4100731b63612b3874dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f6f25c5489ccca2e23c18b04e000bf"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac0f6f25c5489ccca2e23c18b04e000bf"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ac0f6f25c5489ccca2e23c18b04e000bf">transformVelocityMappingToQDotMapping</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename Derived::Scalar &gt; &amp;cache, const Eigen::MatrixBase&lt; Derived &gt; &amp;Av)</td></tr>
<tr class="memdesc:ac0f6f25c5489ccca2e23c18b04e000bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a matrix B, which transforms generalized velocities (v) to an output space X, to a matrix A, which transforms the time derivative of generalized coordinates (qdot) to the same output X.  <a href="#ac0f6f25c5489ccca2e23c18b04e000bf">More...</a><br /></td></tr>
<tr class="separator:ac0f6f25c5489ccca2e23c18b04e000bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa316fc4cc3cf63249ba0a34788fd716"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:afa316fc4cc3cf63249ba0a34788fd716"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#afa316fc4cc3cf63249ba0a34788fd716">transformQDotMappingToVelocityMapping</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename Derived::Scalar &gt; &amp;cache, const Eigen::MatrixBase&lt; Derived &gt; &amp;Ap)</td></tr>
<tr class="memdesc:afa316fc4cc3cf63249ba0a34788fd716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a matrix A, which transforms the time derivative of generalized coordinates (qdot) to an output space X, to a matrix B, which transforms generalized velocities (v) to the same space X.  <a href="#afa316fc4cc3cf63249ba0a34788fd716">More...</a><br /></td></tr>
<tr class="separator:afa316fc4cc3cf63249ba0a34788fd716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508c431527531fb1caa654a84fa7edf2"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a508c431527531fb1caa654a84fa7edf2"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a508c431527531fb1caa654a84fa7edf2">GetVelocityToQDotMapping</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache)</td></tr>
<tr class="separator:a508c431527531fb1caa654a84fa7edf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5e620e9323ca4015164ae819b1b362"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a6f5e620e9323ca4015164ae819b1b362"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a6f5e620e9323ca4015164ae819b1b362">GetQDotToVelocityMapping</a> (const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;cache)</td></tr>
<tr class="separator:a6f5e620e9323ca4015164ae819b1b362"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7cc826c730317ed01e14324e51c34aae"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a7cc826c730317ed01e14324e51c34aae">joint_limit_min</a></td></tr>
<tr class="separator:a7cc826c730317ed01e14324e51c34aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a01bdc0bcc97ffc82e254be5f74fd2"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ab4a01bdc0bcc97ffc82e254be5f74fd2">joint_limit_max</a></td></tr>
<tr class="separator:ab4a01bdc0bcc97ffc82e254be5f74fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42c52af6d4bd94f124ccbd7ddb99fd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="class_rigid_body_actuator.html">RigidBodyActuator</a>, Eigen::aligned_allocator&lt; <a class="el" href="class_rigid_body_actuator.html">RigidBodyActuator</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ad42c52af6d4bd94f124ccbd7ddb99fd7">actuators</a></td></tr>
<tr class="separator:ad42c52af6d4bd94f124ccbd7ddb99fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6b6c592a95918331412560029e0a26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="class_rigid_body_loop.html">RigidBodyLoop</a>&lt; T &gt;, Eigen::aligned_allocator&lt; <a class="el" href="class_rigid_body_loop.html">RigidBodyLoop</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#aeb6b6c592a95918331412560029e0a26">loops</a></td></tr>
<tr class="separator:aeb6b6c592a95918331412560029e0a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586e3be7197f936fcd391e4d2c0a91a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="struct_rigid_body_distance_constraint.html">RigidBodyDistanceConstraint</a>, Eigen::aligned_allocator&lt; <a class="el" href="struct_rigid_body_distance_constraint.html">RigidBodyDistanceConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a586e3be7197f936fcd391e4d2c0a91a4">distance_constraints</a></td></tr>
<tr class="separator:a586e3be7197f936fcd391e4d2c0a91a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1487b2d5a17756fde9ce3edb2e487fed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a1487b2d5a17756fde9ce3edb2e487fed">a_grav</a></td></tr>
<tr class="separator:a1487b2d5a17756fde9ce3edb2e487fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829f97c1d058527ed13f29ca3f74fa93"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#a829f97c1d058527ed13f29ca3f74fa93">B</a></td></tr>
<tr class="separator:a829f97c1d058527ed13f29ca3f74fa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab870111cb2ef28594b4764b4fb5c3d2a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rigid_body_tree.html#ab870111cb2ef28594b4764b4fb5c3d2a">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;)</td></tr>
<tr class="memdesc:ab870111cb2ef28594b4764b4fb5c3d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A toString method for this class.  <a href="#ab870111cb2ef28594b4764b4fb5c3d2a">More...</a><br /></td></tr>
<tr class="separator:ab870111cb2ef28594b4764b4fb5c3d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class RigidBodyTree&lt; T &gt;</h3>

<p>Maintains a vector of <a class="el" href="class_rigid_body.html">RigidBody</a> objects that are arranged into a kinematic tree via <a class="el" href="class_drake_joint.html" title="A joint defines a spatial relationship between two rigid bodies. ">DrakeJoint</a> objects. </p>
<p>It provides various utility methods for computing kinematic and dynamics properties of the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>.</p>
<p>The internal organization of a <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>'s generalized state vector is as follows:</p>
<pre>
[model instance 1's generalized coordinate vector]
[model instance 2's generalized coordinate vector]
...
[model instance 1's generalized velocity vector]
[model instance 2's generalized velocity vector]
...
</pre><p>Each <a class="el" href="class_rigid_body.html">RigidBody</a> maintains for its joint that connects to its parent the indices of the joint's generalized coordinate vector and generalized velocity vector in the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>'s generalized state vector.</p>
<p>The starting index of the joint's generalized coordinate vector in the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>'s generalized state vector can be obtained by executing <a class="el" href="class_rigid_body.html#a27120298a5792a7c7e6f0a5a388adb0e" title="Returns the start index of this body&#39;s parent jont&#39;s position states; see RigidBody::set_position_sta...">RigidBody::get_position_start_index()</a>.</p>
<p>The starting index of the joint's generalized velocity vector in the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>'s generalized state vector can be computed as follows: <a class="el" href="class_rigid_body_tree.html#a30342f766e5b14049b65f710581f4bd1" title="Returns the number of position states outputted by this RigidBodyTree. ">RigidBodyTree::get_num_positions()</a> + <a class="el" href="class_rigid_body.html#aa32f9cadd00b7ac478d181653e689518" title="Returns the start index of this body&#39;s parent jont&#39;s velocity states; see RigidBody::set_velocity_sta...">RigidBody::get_velocity_start_index()</a>.</p>
<p>Note that the velocity index starts at the beginning of the velocity state variables and not at the beginning of the full state of the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. This is why the total number of positions needs to be added to the velocity index to get its index in the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>'s full state vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type. Must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac3ccd2f24194ee7ea436d2a7faffe013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ccd2f24194ee7ea436d2a7faffe013">&#9670;&nbsp;</a></span>BodyToWrenchMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_rigid_body_tree.html#ac3ccd2f24194ee7ea436d2a7faffe013">BodyToWrenchMap</a> =  <a class="el" href="namespacedrake.html#afcadf96d397f45d041d01bf17061bc32">drake::eigen_aligned_std_unordered_map</a>&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; const*, <a class="el" href="namespacedrake.html#af98fed5f98c376f4d45fff56bb96c8e1">drake::WrenchVector</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience alias for rigid body to external wrench map, for use with inverseDynamics and dynamicsBiasTerm. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5f304ab2f7b5bca3e19cc2da40d9eece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f304ab2f7b5bca3e19cc2da40d9eece">&#9670;&nbsp;</a></span>RigidBodyTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constructor that initializes the gravity vector to be [0, 0, -9.81] and a single <a class="el" href="class_rigid_body.html">RigidBody</a> named "world". </p>
<p>This <a class="el" href="class_rigid_body.html">RigidBody</a> can be accessed by calling <a class="el" href="class_rigid_body_tree.html#acf9981c39a1ebe848c0b78ccd3f54c90" title="Returns a mutable reference to the RigidBody associated with the world in the model. ">RigidBodyTree::world()</a>. </p>

</div>
</div>
<a id="a6d2829e9624e9492cc108a5e4d7d1b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2829e9624e9492cc108a5e4d7d1b18">&#9670;&nbsp;</a></span>~RigidBodyTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a39121f0149ef5f9ca187111d18d35fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39121f0149ef5f9ca187111d18d35fd0">&#9670;&nbsp;</a></span>accumulateContactJacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void accumulateContactJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>bodyInd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix3Xd const &amp;&#160;</td>
          <td class="paramname"><em>bodyPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; size_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cindA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; size_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cindB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a452a564b0d6d35750f8eafcb561cdfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452a564b0d6d35750f8eafcb561cdfb1">&#9670;&nbsp;</a></span>add_model_instance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> add_model_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new model instance to this <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code>. </p>
<p>The model instance is identified by a unique model instance ID, which is the return value of this method. </p>

</div>
</div>
<a id="a8beda2a69676dd3e1d8d14c057eb81f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8beda2a69676dd3e1d8d14c057eb81f4">&#9670;&nbsp;</a></span>add_rigid_body()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; * add_rigid_body </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds and takes ownership of a rigid body. </p>
<p>This also adds a frame whose pose is the same as the body's.</p>
<p>A <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> is the sole owner and manager of the <a class="el" href="class_rigid_body.html">RigidBody</a>'s in it. A body is assigned a unique id (RigidBody::id()) when added to a <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. This unique id can be use to access a body using RigidBodyTree::get_bodies()[id].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td>The rigid body to add to this rigid body tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bare, unowned pointer to the <code>body</code>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither a body nor frame with the same identifying information (name and model id / name) should already exist in the tree. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if preconditions are not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37666bd71050b708a254ff53155ea838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37666bd71050b708a254ff53155ea838">&#9670;&nbsp;</a></span>addCollisionElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addCollisionElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1collision_1_1_element.html">drake::multibody::collision::Element</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new collision element to the tree. </p>
<p>The input <code>element</code> will be copied and that copy will be stored in the tree, associated with the given <code>body</code>. This association is pending. It is necessary to call <a class="el" href="class_rigid_body_tree.html#acafe5ede9412674127cd08795647f26a">compile()</a> in order for the element to be fully integrated into the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>the element to add. </td></tr>
    <tr><td class="paramname">body</td><td>the body to associate the element with. </td></tr>
    <tr><td class="paramname">group_name</td><td>a group name to tag the associated element with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6c94a62910b6ff7d820e81a1cdcf865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c94a62910b6ff7d820e81a1cdcf865">&#9670;&nbsp;</a></span>AddCollisionFilterGroupMember()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddCollisionFilterGroupMember </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="class_rigid_body.html">RigidBody</a> to a collision filter group. </p>
<p>The <a class="el" href="class_rigid_body.html">RigidBody</a> is referenced by name and model instance id. The process will fail if the body cannot be found or if the group cannot be found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The collision filter group name to add the body to. </td></tr>
    <tr><td class="paramname">body_name</td><td>The name of the body to add. </td></tr>
    <tr><td class="paramname">model_id</td><td>The id of the model instance to which this body belongs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>in response to failure conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c9f715660bbdc87f79fba9aaeb612ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9f715660bbdc87f79fba9aaeb612ad">&#9670;&nbsp;</a></span>AddCollisionFilterIgnoreTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddCollisionFilterIgnoreTarget </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target_group_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a collision group to the set of groups ignored by the specified collision filter group. </p>
<p>Will fail if the specified group name does not refer to an existing collision filter group. (The target group name need not exist at this time.) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td></td></tr>
    <tr><td class="paramname">target_group_name</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>in response to failure conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64b1f01dec5165bc5a3ecb43c43f7ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b1f01dec5165bc5a3ecb43c43f7ec4">&#9670;&nbsp;</a></span>addDistanceConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addDistanceConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>bodyA_index_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>r_AP_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>bodyB_index_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>r_BQ_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>distance_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For details on parameters see RigidBodyDistanceContraint. </p>

</div>
</div>
<a id="a012bf4217daf3167cd6328d5ddd97785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012bf4217daf3167cd6328d5ddd97785">&#9670;&nbsp;</a></span>addFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addFrame </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>Frame to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither a body nor frame with the same identifying information (name and model id / name) should already exist in the tree. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if preconditions are not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a887d5e35d3c9efe5829919cce6bef698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887d5e35d3c9efe5829919cce6bef698">&#9670;&nbsp;</a></span>allCollisions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> allCollisions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyA_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyB_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>ptsA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>ptsB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_margins</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5efcb13ad3a7d185b66d11b6d4166f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efcb13ad3a7d185b66d11b6d4166f19">&#9670;&nbsp;</a></span>CalcBodyPoseInWorldFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt;T&gt; CalcBodyPoseInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the pose <code>X_WB</code> of <code>body's</code> frame B in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">body</td><td>Reference to the <a class="el" href="class_rigid_body.html">RigidBody</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_WB</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebb8bcd6dcd60ccb725fa3732180cf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb8bcd6dcd60ccb725fa3732180cf56">&#9670;&nbsp;</a></span>CalcBodySpatialVelocityInWorldFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector6&lt; T &gt; CalcBodySpatialVelocityInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the spatial velocity <code>V_WB</code> of <code>body's</code> frame B measured and expressed in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">body</td><td>Reference to the <a class="el" href="class_rigid_body.html">RigidBody</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">V_WB</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a196d6872ffdc16fba0aa7c9f9f17bb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196d6872ffdc16fba0aa7c9f9f17bb01">&#9670;&nbsp;</a></span>CalcBodySpatialVelocityJacobianDotTimesVInWorldFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">drake::Vector6</a>&lt;T&gt; CalcBodySpatialVelocityJacobianDotTimesVInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>Jdot_WB * v</code>, where <code>J_WB</code> is the Jacobian of the spatial velocity <code>V_WB</code> of body frame B measured and expressed in the world frame W, and <code>v</code> is the generalized velocity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">body</td><td>Reference to the <a class="el" href="class_rigid_body.html">RigidBody</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;tt&gt;Jdot_WB</td><td>* v </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af80375fe69939e9c53bf5eb172741c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80375fe69939e9c53bf5eb172741c51">&#9670;&nbsp;</a></span>CalcBodySpatialVelocityJacobianInWorldFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">drake::Matrix6X</a>&lt;T&gt; CalcBodySpatialVelocityJacobianInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Jacobian <code>J_WB</code> of the spatial velocity <code>V_WB</code> of body frame B measured and expressed in the world frame <code>W</code> such that <code>V_WB = J_WB * v</code>, where <code>v</code> is the generalized velocity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">body</td><td>Reference to the <a class="el" href="class_rigid_body.html">RigidBody</a>. </td></tr>
    <tr><td class="paramname">in_terms_of_qdot</td><td><code>true</code> for <code>J_WB</code> computed with respect to the time derivative of the generalized position such that <code>V_WB = J_WB * qdot</code>. <code>false</code> for <code>J_WB</code> computed with respect to <code>v</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">J_WB</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36df94b032a1de53a79b16ee5c2560a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36df94b032a1de53a79b16ee5c2560a6">&#9670;&nbsp;</a></span>CalcBodySpatialVelocityJacobianInWorldFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcBodySpatialVelocityJacobianInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">drake::Matrix6X</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>J_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Jacobian <code>J_WB</code> of the spatial velocity <code>V_WB</code> of body frame B measured and expressed in the world frame <code>W</code> such that <code>V_WB = J_WB * v</code>, where <code>v</code> is the generalized velocity. </p>
<p>This version does not allocate memory and will assert if <code>J_WB</code> is incorrectly sized. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td>Reference to the <a class="el" href="class_rigid_body.html">RigidBody</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_terms_of_qdot</td><td><code>true</code> for <code>J_WB</code> computed with respect to the time derivative of the generalized position such that <code>V_WB = J_WB * qdot</code>. <code>false</code> for <code>J_WB</code> computed with respect to <code>v</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J_WB</td><td>Pointer to the output Jacobian. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1da0223cf35ceab4cb90d5b17150b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1da0223cf35ceab4cb90d5b17150b13">&#9670;&nbsp;</a></span>CalcFramePoseInWorldFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt;T&gt; CalcFramePoseInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the pose <code>X_WF</code> of <code>frame_F</code> in the world frame W. </p>
<p><code>frame_F</code> does not necessarily need to be owned by this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. However, the <a class="el" href="class_rigid_body.html">RigidBody</a> to which <code>frame_F</code> attaches to has to be owned by this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">frame_F</td><td>Reference to the <a class="el" href="class_rigid_body_frame.html" title="Multibody systems typically have distinguished frames of interest that need to be monitored...">RigidBodyFrame</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_WF</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadf319e952111f5b2f45bb664243c7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf319e952111f5b2f45bb664243c7bb">&#9670;&nbsp;</a></span>CalcFramePoseInWorldFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Isometry3&lt; T &gt; CalcFramePoseInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the pose <code>X_WF</code> of the rigid body frame F in the world frame W. </p>
<p>Frame F is rigidly attached to <code>body</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">body</td><td>Reference to the <a class="el" href="class_rigid_body.html">RigidBody</a>. </td></tr>
    <tr><td class="paramname">X_BF</td><td>The pose of frame F in body frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_WF</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32633fae7bbeaafc9616bd9216779426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32633fae7bbeaafc9616bd9216779426">&#9670;&nbsp;</a></span>CalcFrameSpatialVelocityInWorldFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">drake::Vector6</a>&lt;T&gt; CalcFrameSpatialVelocityInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the spatial velocity <code>V_WF</code> of <a class="el" href="class_rigid_body_frame.html" title="Multibody systems typically have distinguished frames of interest that need to be monitored...">RigidBodyFrame</a> <code>frame_F</code> measured and expressed in the world frame W. </p>
<p><code>frame_F</code> does not necessarily need to be owned by this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. However, the <a class="el" href="class_rigid_body.html">RigidBody</a> to which <code>frame_F</code> attaches to has to be owned by this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">frame_F</td><td>Reference to the <a class="el" href="class_rigid_body_frame.html" title="Multibody systems typically have distinguished frames of interest that need to be monitored...">RigidBodyFrame</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">V_WF</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5ce465634ec4a603a26cb65b7c0b7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ce465634ec4a603a26cb65b7c0b7df">&#9670;&nbsp;</a></span>CalcFrameSpatialVelocityInWorldFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">drake::Vector6</a>&lt; T &gt; CalcFrameSpatialVelocityInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the spatial velocity <code>V_WF</code> of the frame F measured and expressed in the world frame W. </p>
<p>Frame F is rigidly attached to <code>body</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">body</td><td>Reference to the <a class="el" href="class_rigid_body.html">RigidBody</a>. </td></tr>
    <tr><td class="paramname">X_BF</td><td>The pose of frame F in body frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">V_WF</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f4ec4dc3b053f6420a5fd449ff4d2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4ec4dc3b053f6420a5fd449ff4d2c3">&#9670;&nbsp;</a></span>CalcFrameSpatialVelocityJacobianDotTimesVInWorldFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">drake::Vector6</a>&lt; T &gt; CalcFrameSpatialVelocityJacobianDotTimesVInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes <code>Jdot_WF * v</code>, where <code>J_WF</code> is the Jacobian of spatial velocity, <code>V_WF</code>, of frame F measured and expressed in the world frame W, and <code>v</code> is the generalized velocity. </p>
<p>Frame F is rigidly attached to <code>body</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">body</td><td>Reference to the <a class="el" href="class_rigid_body.html">RigidBody</a>. </td></tr>
    <tr><td class="paramname">X_BF</td><td>The pose of frame F in body frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;tt&gt;Jdot_WF</td><td>* v </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8350cada7cd42d6137edda83bb541892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8350cada7cd42d6137edda83bb541892">&#9670;&nbsp;</a></span>CalcFrameSpatialVelocityJacobianDotTimesVInWorldFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">drake::Vector6</a>&lt;T&gt; CalcFrameSpatialVelocityJacobianDotTimesVInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>Jdot_WF * v</code>, where <code>J_WF</code> is the Jacobian of spatial velocity <code>V_WF</code> of frame F measured and expressed in the world frame W, and <code>v</code> is the generalized velocity. </p>
<p><code>frame_F</code> does not necessarily need to be owned by this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. However, the <a class="el" href="class_rigid_body.html">RigidBody</a> to which <code>frame_F</code> attaches to has to be owned by this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">frame_F</td><td>Reference to the <a class="el" href="class_rigid_body_frame.html" title="Multibody systems typically have distinguished frames of interest that need to be monitored...">RigidBodyFrame</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;tt&gt;Jdot_WF</td><td>* v </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab3d8e9bd41c3f7b756c7a964e3bb58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3d8e9bd41c3f7b756c7a964e3bb58e">&#9670;&nbsp;</a></span>CalcFrameSpatialVelocityJacobianInWorldFrame() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">drake::Matrix6X</a>&lt; T &gt; CalcFrameSpatialVelocityJacobianInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian <code>J_WF</code> of the spatial velocity <code>V_WF</code> of frame F measured and expressed in the world frame W such that <code>V_WF = J_WF * v</code>, where <code>v</code> is the generalized velocity. </p>
<p>Frame F is rigidly attached to <code>body</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">B</td><td>Reference to the <a class="el" href="class_rigid_body.html">RigidBody</a>. </td></tr>
    <tr><td class="paramname">X_BF</td><td>The pose of frame F in body frame B. </td></tr>
    <tr><td class="paramname">in_terms_of_qdot</td><td><code>true</code> for <code>J_WF</code> computed with respect to the time derivative of the generalized position such that <code>V_WF = J_WF * qdot</code>. <code>false</code> for <code>J_WF</code> computed with respect to <code>v</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">J_WF</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3e4515aa2862a883f21fb2e168635aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e4515aa2862a883f21fb2e168635aa">&#9670;&nbsp;</a></span>CalcFrameSpatialVelocityJacobianInWorldFrame() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcFrameSpatialVelocityJacobianInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">drake::Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">drake::Matrix6X</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>J_WF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian <code>J_WF</code> of the spatial velocity <code>V_WF</code> of frame F measured and expressed in the world frame W such that <code>V_WF = J_WF * v</code>, where <code>v</code> is the generalized velocity. </p>
<p>Frame F is rigidly attached to <code>body</code>. This version does not allocate memory and will assert if <code>J_WF</code> is incorrectly sized. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Reference to the <a class="el" href="class_rigid_body.html">RigidBody</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_BF</td><td>The pose of frame F in body frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_terms_of_qdot</td><td><code>true</code> for <code>J_WF</code> computed with respect to the time derivative of the generalized position such that <code>V_WF = J_WF * qdot</code>. <code>false</code> for <code>J_WF</code> computed with respect to <code>v</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J_WF</td><td>Pointer to the output Jacobian. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d6c3d81ee7a57e61c18c7d90cffbfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6c3d81ee7a57e61c18c7d90cffbfca">&#9670;&nbsp;</a></span>CalcFrameSpatialVelocityJacobianInWorldFrame() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">drake::Matrix6X</a>&lt;T&gt; CalcFrameSpatialVelocityJacobianInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Jacobian <code>J_WF</code> of the spatial velocity <code>V_WF</code> of frame F measured and expressed in the world frame W such that <code>V_WF = J_WF * v</code>, where <code>v</code> is the generalized velocity. </p>
<p><code>frame_F</code> does not necessarily need to be owned by this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. However, the <a class="el" href="class_rigid_body.html">RigidBody</a> to which <code>frame_F</code> attaches to has to be owned by this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">frame_F</td><td>Reference to the <a class="el" href="class_rigid_body_frame.html" title="Multibody systems typically have distinguished frames of interest that need to be monitored...">RigidBodyFrame</a>. </td></tr>
    <tr><td class="paramname">in_terms_of_qdot</td><td><code>true</code> for <code>J_WF</code> computed with respect to the time derivative of the generalized position such that <code>V_WF = J_WF * qdot</code>. <code>false</code> for <code>J_WF</code> computed with respect to <code>v</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">J_WF</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34b9c955683d4c3486bfb9d9d6aed5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b9c955683d4c3486bfb9d9d6aed5de">&#9670;&nbsp;</a></span>CalcFrameSpatialVelocityJacobianInWorldFrame() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcFrameSpatialVelocityJacobianInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">drake::Matrix6X</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>J_WF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Jacobian <code>J_WF</code> of the spatial velocity <code>V_WF</code> of frame F measured and expressed in the world frame W such that <code>V_WF = J_WF * v</code>, where <code>v</code> is the generalized velocity. </p>
<p><code>frame_F</code> does not necessarily need to be owned by this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. However, the <a class="el" href="class_rigid_body.html">RigidBody</a> to which <code>frame_F</code> attaches to has to be owned by this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. This version does not allocate memory and will assert if <code>J_WF</code> is incorrectly sized. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_F</td><td>Reference to the <a class="el" href="class_rigid_body_frame.html" title="Multibody systems typically have distinguished frames of interest that need to be monitored...">RigidBodyFrame</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_terms_of_qdot</td><td><code>true</code> for <code>J_WF</code> computed with respect to the time derivative of the generalized position such that <code>V_WF = J_WF * qdot</code>. <code>false</code> for <code>J_WF</code> computed with respect to <code>v</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J_WF</td><td>Pointer to the output Jacobian. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44e5eb95e4f888f34d92e07b20ac0784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e5eb95e4f888f34d92e07b20ac0784">&#9670;&nbsp;</a></span>CalcGeneralizedSpringForces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt;Scalar&gt; CalcGeneralizedSpringForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the generalized forces that correspond to joint springs. </p>
<p>Spring forces are computed joint-by-joint and are a function of position only (they do not couple between joints) </p>

</div>
</div>
<a id="ac7d8d903ad67cb27354a4c81c3394d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d8d903ad67cb27354a4c81c3394d78">&#9670;&nbsp;</a></span>CalcGeneralizedSpringForces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorX&lt;Scalar&gt; CalcGeneralizedSpringForces </td>
          <td>(</td>
          <td class="paramtype">const VectorX&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21f75a7ae6524f91ee8e85e4887399bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f75a7ae6524f91ee8e85e4887399bf">&#9670;&nbsp;</a></span>centerOfMass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, <a class="el" href="namespacedrake.html#af869092c52ed7cc9d2db40ce56050c7c">drake::kSpaceDimension</a>, 1&gt; centerOfMass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em> = <code><a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3705ad59184fe3fcfad96af6d5114a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3705ad59184fe3fcfad96af6d5114a62">&#9670;&nbsp;</a></span>centerOfMass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, kSpaceDimension, 1&gt; centerOfMass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a535a7f01b0924788c33bc1fe261898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a535a7f01b0924788c33bc1fe261898">&#9670;&nbsp;</a></span>centerOfMassJacobian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, <a class="el" href="namespacedrake.html#af869092c52ed7cc9d2db40ce56050c7c">drake::kSpaceDimension</a>, Eigen::Dynamic&gt; centerOfMassJacobian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em> = <code><a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a36bf88d8b8dd8644c0b260cc9d557b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bf88d8b8dd8644c0b260cc9d557b06">&#9670;&nbsp;</a></span>centerOfMassJacobian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;Scalar, kSpaceDimension, Eigen::Dynamic&gt; centerOfMassJacobian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c98475d2e1748ead1a2e2b6fcecb416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c98475d2e1748ead1a2e2b6fcecb416">&#9670;&nbsp;</a></span>centerOfMassJacobianDotTimesV() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, <a class="el" href="namespacedrake.html#af869092c52ed7cc9d2db40ce56050c7c">drake::kSpaceDimension</a>, 1&gt; centerOfMassJacobianDotTimesV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em> = <code><a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b8ab2ab3db8a4959da7a1611c8d8f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8ab2ab3db8a4959da7a1611c8d8f3b">&#9670;&nbsp;</a></span>centerOfMassJacobianDotTimesV() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;Scalar, kSpaceDimension, 1&gt; centerOfMassJacobianDotTimesV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f67784aa70bcb79dbd4d06fce2b18cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f67784aa70bcb79dbd4d06fce2b18cd">&#9670;&nbsp;</a></span>centroidalMomentumMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af30fe85a821bd0e0ab46f2e165c8e480">drake::TwistMatrix</a>&lt;Scalar&gt; centroidalMomentumMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em> = <code><a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3078af454eec1842c34a35663590be20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3078af454eec1842c34a35663590be20">&#9670;&nbsp;</a></span>centroidalMomentumMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TwistMatrix&lt;Scalar&gt; centroidalMomentumMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e961432f8a0dcd58d8afd90308fbec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e961432f8a0dcd58d8afd90308fbec8">&#9670;&nbsp;</a></span>centroidalMomentumMatrixDotTimesV() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt;Scalar&gt; centroidalMomentumMatrixDotTimesV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em> = <code><a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae92729aa595b1025bb2173468872eb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92729aa595b1025bb2173468872eb68">&#9670;&nbsp;</a></span>centroidalMomentumMatrixDotTimesV() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TwistVector&lt;Scalar&gt; centroidalMomentumMatrixDotTimesV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af63e4fe558184619cea7b347a10c2816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63e4fe558184619cea7b347a10c2816">&#9670;&nbsp;</a></span>CheckCacheValidity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CheckCacheValidity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <code>cache</code> is valid for use with this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. </p>
<p>Throws a std::runtime_error exception if it is not valid. </p>

</div>
</div>
<a id="a90af483256d82685ec8c57af985fd13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90af483256d82685ec8c57af985fd13e">&#9670;&nbsp;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a deep clone of this <a class="el" href="class_rigid_body_tree.html">RigidBodyTree&lt;double&gt;</a>. </p>
<p>Currently, everything <em>except</em> for collision and visual elements are cloned. Only supported for T = double. </p>

</div>
</div>
<a id="a4ee04ee05aa234710873c057e3eaf374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee04ee05aa234710873c057e3eaf374">&#9670;&nbsp;</a></span>collidingPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">vector</a>&lt; size_t &gt; collidingPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>collision_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2985ac4da5a693dd0f7cbf4399857a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2985ac4da5a693dd0f7cbf4399857a98">&#9670;&nbsp;</a></span>collidingPointsCheckOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> collidingPointsCheckOnly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>collision_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5202a27df2759895aa2084cb72cc300b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5202a27df2759895aa2084cb72cc300b">&#9670;&nbsp;</a></span>collisionDetect() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> collisionDetect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>xA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>xB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyA_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyB_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody_1_1collision.html#abedcf22a55257b04e6b7a12700ae4c22">drake::multibody::collision::ElementId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids_to_check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_margins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9618c2419ccd22414c2c176dd949b134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9618c2419ccd22414c2c176dd949b134">&#9670;&nbsp;</a></span>collisionDetect() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> collisionDetect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>xA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>xB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyA_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyB_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodies_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_element_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_margins</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bcad86795f3fd778b7d31314c5ccc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcad86795f3fd778b7d31314c5ccc85">&#9670;&nbsp;</a></span>collisionDetect() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> collisionDetect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>xA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>xB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyA_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyB_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodies_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_margins</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb3f2782336211ad25cadcd004e2c19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3f2782336211ad25cadcd004e2c19e">&#9670;&nbsp;</a></span>collisionDetect() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> collisionDetect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>xA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>xB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyA_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyB_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_element_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_margins</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7463d5993ca7e5d39f3d74a19823aa13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7463d5993ca7e5d39f3d74a19823aa13">&#9670;&nbsp;</a></span>collisionDetect() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> collisionDetect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>xA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>xB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyA_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyB_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_margins</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8cea7311fd347cbd9d8f82039c5fd413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cea7311fd347cbd9d8f82039c5fd413">&#9670;&nbsp;</a></span>collisionDetectFromPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void collisionDetectFromPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>body_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_margins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the <em>signed</em> distance from the given points to the nearest body in the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>a <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> constructed by <a class="el" href="class_rigid_body_tree.html#a443ff641d739d2512e28449c6132a4ce" title="Initializes a KinematicsCache with the given configuration q, computes the kinematics, and returns the cache. ">RigidBodyTree::doKinematics</a> given <code>q</code> and <code>v</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>A 3xN matrix of points, in world frame, to which signed distance will be computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">phi</td><td>Resized to N elements and filled with the computed signed distances, or inf if no closest point was found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">normal</td><td>Resized to 3xN elements and filled with collision element normals in world frame, at the closest point on the collision geometry to each point in <code>points</code>. Undefined where no closest point was found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>Resized to 3xN elements and filled with the closest points on the collision geometry to each point in <code>points</code>, in world frame. Undefined where no closest point was found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">body_x</td><td>Resized to 3xN elements and filled with the closest points on the collision geometry to each point in <code>points</code>, in the body frame of the closest body. Undefined where no closest point was found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">body_idx</td><td>Resized to N elements and filled with the body idx of the closest body to each point in <code>points</code>, or -1 where no closest body was found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_margins</td><td>Whether to pad each collision body with a narrow (see bullet_model) margin to improve stability of normal estimation at the cost of the accuracy of closest points calculations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b8516e2261e850c3f3086d252ef3ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8516e2261e850c3f3086d252ef3ab6">&#9670;&nbsp;</a></span>collisionRaycast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> collisionRaycast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>origins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>ray_endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_margins</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e27d7c8a75cf266100f33fdb6c66813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e27d7c8a75cf266100f33fdb6c66813">&#9670;&nbsp;</a></span>collisionRaycast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> collisionRaycast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>origins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>ray_endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_margins</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01d5766ec002601868e45e7f390a9465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d5766ec002601868e45e7f390a9465">&#9670;&nbsp;</a></span>compactToFull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename Derived::Scalar, Derived::RowsAtCompileTime, Eigen::Dynamic&gt; compactToFull </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>compact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acafe5ede9412674127cd08795647f26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafe5ede9412674127cd08795647f26a">&#9670;&nbsp;</a></span>compile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e4181a7a83f7805a5a6d6ee62b7ee46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4181a7a83f7805a5a6d6ee62b7ee46">&#9670;&nbsp;</a></span>computeContactJacobians() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void computeContactJacobians </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ref&lt; const VectorXi &gt; const &amp;&#160;</td>
          <td class="paramname"><em>idxA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ref&lt; const VectorXi &gt; const &amp;&#160;</td>
          <td class="paramname"><em>idxB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ref&lt; const Matrix3Xd &gt; const &amp;&#160;</td>
          <td class="paramname"><em>xA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ref&lt; const Matrix3Xd &gt; const &amp;&#160;</td>
          <td class="paramname"><em>xB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix&lt; Scalar, Dynamic, Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af926019e0d1224edf16e10a52fe207c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af926019e0d1224edf16e10a52fe207c2">&#9670;&nbsp;</a></span>computeContactJacobians() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void computeContactJacobians </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; const Eigen::VectorXi &gt; const &amp;&#160;</td>
          <td class="paramname"><em>idxA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; const Eigen::VectorXi &gt; const &amp;&#160;</td>
          <td class="paramname"><em>idxB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; const Eigen::Matrix3Xd &gt; const &amp;&#160;</td>
          <td class="paramname"><em>xA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; const Eigen::Matrix3Xd &gt; const &amp;&#160;</td>
          <td class="paramname"><em>xB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian for many points in the format currently used by MATLAB. </p>
<p>(possibly should be scheduled for deletion, taking accumulateContactJacobians() with it) </p>

</div>
</div>
<a id="aff25f6baacbae752077e9815ef46d256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff25f6baacbae752077e9815ef46d256">&#9670;&nbsp;</a></span>ComputeMaximumDepthCollisionPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="structdrake_1_1multibody_1_1collision_1_1_point_pair.html">drake::multibody::collision::PointPair</a>&lt; U &gt; &gt; ComputeMaximumDepthCollisionPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_margins</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>throw_if_missing_gradient</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the point of closest approach between bodies in the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> that are in contact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache[in]</td><td>a <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> constructed by <a class="el" href="class_rigid_body_tree.html#a443ff641d739d2512e28449c6132a4ce" title="Initializes a KinematicsCache with the given configuration q, computes the kinematics, and returns the cache. ">RigidBodyTree::doKinematics</a> given <code>q</code> and <code>v</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Collision points are returned as a vector of PointPair's. See the documentation for PointPair for details. The collision point on the surface of each body is stored in the PointPair structure in the frame of the corresponding body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">use_margins</td><td>If <code>true</code> the model uses the representation with margins. If <code>false</code>, the representation without margins is used instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>based on the criteria of <a class="el" href="namespacedrake_1_1math.html#a44dafc4c3502cdb9bc73393bd7460f49" title="B = DiscardZeroGradient(A, precision) enables casting from a matrix of AutoDiffScalars to AutoDiffSca...">DiscardZeroGradient()</a> only if <code>throws_if_missing_gradient</code> is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0227c8f2ea7c5d4fac5c3dfafc3b9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0227c8f2ea7c5d4fac5c3dfafc3b9a0">&#9670;&nbsp;</a></span>computePositionNameToIndexMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, <a class="el" href="classint.html">int</a> &gt; computePositionNameToIndexMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map from DOF position name to DOF index within the output vector of this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. </p>
<p><b>WARNING:</b> There is a known bug in this method, see: #4697. </p>

</div>
</div>
<a id="a6a71eca20b58c55688bd643b29e18cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a71eca20b58c55688bd643b29e18cc3">&#9670;&nbsp;</a></span>CreateKinematicsCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; CreateKinematicsCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> to perform computations with this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. </p>
<p>The returned <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> is consistently templated on the scalar type for this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> instance. Aborts if this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> was not previously initialized with a call to <a class="el" href="class_rigid_body_tree.html#acafe5ede9412674127cd08795647f26a">RigidBodyTree::compile()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The created <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </dd></dl>

</div>
</div>
<a id="a87bbc7234338cba447fd7e1e9d900064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bbc7234338cba447fd7e1e9d900064">&#9670;&nbsp;</a></span>CreateKinematicsCacheFromBodiesVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; CreateKinematicsCacheFromBodiesVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; std::unique_ptr&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bodies</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> given a reference to a vector of rigid bodies contained within a <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. </p>
<p>This method is static since all the information to create the corresponding <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> resides in the input parameter vector <code>bodies</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bodies</td><td>A vector of unique pointers to the rigid bodies of a given <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> for which a <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> needs to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </dd></dl>

</div>
</div>
<a id="a0da5b42598002045e53728b112834aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da5b42598002045e53728b112834aba">&#9670;&nbsp;</a></span>CreateKinematicsCacheWithType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; CacheT &gt; CreateKinematicsCacheWithType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A helper template method used to create a <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> templated on <code>CacheT</code> from a <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> templated on <code>T</code>, with <code>CacheT</code> and <code>T</code> not necessarily the same scalar type. </p>
<p>This method is particularly useful in mex files where only a reference to a <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>&lt;double&gt;</code> is available to create kinematics caches on different scalar types. Aborts if this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> was not previously initialized with a call to <a class="el" href="class_rigid_body_tree.html#acafe5ede9412674127cd08795647f26a">RigidBodyTree::compile()</a>.</p>
<p>Users should not call this method but instead create <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> objects with <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>:<a class="el" href="class_rigid_body_tree.html#a6a71eca20b58c55688bd643b29e18cc3" title="Creates a KinematicsCache to perform computations with this RigidBodyTree. ">CreateKinematicsCache()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CacheT</td><td>The scalar type for the returned <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> templated on <code>CacheT</code> that can be used for computations on this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> with methods instantiated on <code>CacheT</code>. </dd></dl>

</div>
</div>
<a id="a7f76ceb30c04f1723e8d6371c575738e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f76ceb30c04f1723e8d6371c575738e">&#9670;&nbsp;</a></span>DefineCollisionFilterGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DefineCollisionFilterGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to define a new collision filter group. </p>
<p>The given name <em>must</em> be unique since the last invocation of <a class="el" href="class_rigid_body_tree.html#acafe5ede9412674127cd08795647f26a">compile()</a> (or construction, whichever is more recent). Duplicate names or attempting to add more collision filter groups than the system can handle will lead to failure. In the event of failure, an exception is thrown. kMaxNumCollisionFilterGroups defines the limit of total collision filter groups that are supported. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The unique name of the new group.  std::logic_error in response to failure conditions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a443ff641d739d2512e28449c6132a4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443ff641d739d2512e28449c6132a4ce">&#9670;&nbsp;</a></span>doKinematics() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt;typename DerivedQ::Scalar&gt; doKinematics </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="class_kinematics_cache.html">KinematicsCache</a></code> with the given configuration <code>q</code>, computes the kinematics, and returns the cache. </p>
<p>This method is explicitly instantiated in <a class="el" href="rigid__body__tree_8cc.html">rigid_body_tree.cc</a> for a small set of supported <code>DerivedQ</code>. </p>

</div>
</div>
<a id="aedff6d96b0ba888cefaf4a2b0fddcae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedff6d96b0ba888cefaf4a2b0fddcae8">&#9670;&nbsp;</a></span>doKinematics() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt;typename DerivedQ::Scalar&gt; doKinematics </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>compute_JdotV</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a <code><a class="el" href="class_kinematics_cache.html">KinematicsCache</a></code> with the given configuration <code>q</code> and velocity <code>v</code>, computes the kinematics, and returns the cache. </p>
<p>This method is explicitly instantiated in <a class="el" href="rigid__body__tree_8cc.html">rigid_body_tree.cc</a> for a small set of supported <code>DerivedQ</code> and <code>DerivedV</code>. </p>

</div>
</div>
<a id="a0374b8587d2bba4c7e1a520f3b3160ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0374b8587d2bba4c7e1a520f3b3160ec">&#9670;&nbsp;</a></span>doKinematics() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void doKinematics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>compute_JdotV</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the kinematics on the given <code>cache</code>. </p>
<p>This method is explicitly instantiated in <a class="el" href="rigid__body__tree_8cc.html">rigid_body_tree.cc</a> for a small set of supported Scalar types. </p>

</div>
</div>
<a id="a0f8d5b9822df97355629b16ccac175ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8d5b9822df97355629b16ccac175ea">&#9670;&nbsp;</a></span>drawKinematicTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drawKinematicTree </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>graphviz_dotfile_filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6e2759e0895a88d305ec539bed01fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e2759e0895a88d305ec539bed01fec">&#9670;&nbsp;</a></span>dynamicsBiasTerm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt; dynamicsBiasTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#afcadf96d397f45d041d01bf17061bc32">drake::eigen_aligned_std_unordered_map</a>&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; const *, <a class="el" href="namespacedrake.html#af98fed5f98c376f4d45fff56bb96c8e1">drake::WrenchVector</a>&lt; Scalar &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>external_wrenches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>include_velocity_terms</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the term \( C(q, v, f_\text{ext}) \) in the manipulator equations </p><p class="formulaDsp">
\[ H(q) \dot{v} + C(q, v, f_\text{ext}) = B(q) u \]
</p>
<p>. </p>
<p>Convenience method that calls inverseDynamics with \( \dot{v} = 0 \). See inverseDynamics for argument descriptions. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rigid_body_tree.html#a4db480ac1981bb7d352cac340cefb490" title="Compute  that is, the left hand side of the manipulator equations . ">inverseDynamics</a> </dd></dl>

</div>
</div>
<a id="a21ca30e682806bdc162294a13395d89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ca30e682806bdc162294a13395d89c">&#9670;&nbsp;</a></span>dynamicsBiasTerm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;Scalar, Eigen::Dynamic, 1&gt; dynamicsBiasTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#afcadf96d397f45d041d01bf17061bc32">drake::eigen_aligned_std_unordered_map</a>&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; const *, WrenchVector&lt; Scalar &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>external_wrenches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>include_velocity_terms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8c8046e84d90fb025aa136c64883409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c8046e84d90fb025aa136c64883409">&#9670;&nbsp;</a></span>FindAncestorBodies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FindAncestorBodies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>body_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; *&#160;</td>
          <td class="paramname"><em>ancestor_bodies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the ancestors of a body. </p>
<p>The ancestors include the body's parent, the parent's parent, etc., all the way to the root of this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>, which represents the world.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body_index</td><td>The index of the body in this <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> for which the ancestors of the body are found. Ancestors are returned in a vector of body indexes.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ancestor_bodies</td><td>A vector of body indexes of the ancestor bodies of the body with index <code>body_index</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f706aafe45e2c47a009abf339cb639b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f706aafe45e2c47a009abf339cb639b">&#9670;&nbsp;</a></span>FindAncestorBodies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; FindAncestorBodies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identical to the above overload, expect that this function return the ancestor bodies instead of using an output argument. </p>

</div>
</div>
<a id="a9e6862b2d1c00ff774f749c67b160c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6862b2d1c00ff774f749c67b160c93">&#9670;&nbsp;</a></span>findAncestorBodies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void findAncestorBodies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ancestor_bodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a359d38df6f29c104adccaf34d0b7454c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359d38df6f29c104adccaf34d0b7454c">&#9670;&nbsp;</a></span>FindBaseBodies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; FindBaseBodies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_instance_id</em> = <code>-1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a vector of indexes of the bodies that are directly attached to the world via any type of joint. </p>
<p>This method has a time complexity of <code>O(N)</code> where <code>N</code> is the number of bodies in the tree, which can be determined by calling <a class="el" href="class_rigid_body_tree.html#a2d058d7557f133059de2669abcf4383d" title="Returns the number of bodies in this tree. ">RigidBodyTree::get_num_bodies()</a>. </p>

</div>
</div>
<a id="a5e325c1b67c953d7f5232291db4e6fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e325c1b67c953d7f5232291db4e6fdd">&#9670;&nbsp;</a></span>FindBody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; * FindBody </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a body with the specified <code>body_name</code> belonging to a model with the specified <code>model_name</code> and <code>model_id</code>. </p>
<p>Note that if <code>model_name</code> is the empty string and <code>model_id</code> is -1, every model is searched. If <code>model_name</code> and <code>model_id</code> are inconsistent, no body will be found and an exception will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body_name</td><td>The name of the body to find. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_name</td><td>The name of the model to which the body belongs. If this value is an empty string, every model is searched. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_id</td><td>The ID of the model to which the body belongs. If this value is -1, every model is searched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if multiple matching bodies are found or no matching bodies are found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace5bd45017c41d3b1c046ca284a82e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5bd45017c41d3b1c046ca284a82e07">&#9670;&nbsp;</a></span>FindBody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * FindBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody_1_1collision.html#abedcf22a55257b04e6b7a12700ae4c22">drake::multibody::collision::ElementId</a>&#160;</td>
          <td class="paramname"><em>element_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the <a class="el" href="class_rigid_body.html">RigidBody</a> that owns the collision element indicated by the id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_id</td><td>The id to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the owning <a class="el" href="class_rigid_body.html">RigidBody</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if no body can be mapped to the element id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc0ed8e04aeaef968766a67a3ee2bd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0ed8e04aeaef968766a67a3ee2bd54">&#9670;&nbsp;</a></span>FindBodyIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> FindBodyIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>body_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_instance_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the index of a rigid body within this rigid body tree. </p>
<p>The rigid body tree maintains a vector of pointers to all rigid bodies that are part of the rigid body tree. The index of a rigid body is the index within this vector at which a pointer to the rigid body is stored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body_name</td><td>The body whose index we want to find. It should be unique within the searched models, otherwise an exception will be thrown.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instance_id</td><td>The ID of the model instance. This parameter is optional. If supplied, only the model instance with the specified instance ID is searched; otherwise, all model instances are searched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the specified rigid body.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if no rigid body with the specified <code>body_name</code> and <code>model_id</code> was found or if multiple matching rigid bodies were found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c4b6ad34e5782815a16725b03ca7fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4b6ad34e5782815a16725b03ca7fd5">&#9670;&nbsp;</a></span>FindChildBodyOfJoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; * FindChildBodyOfJoint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>joint_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_instance_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a pointer to the rigid body whose parent joint is named <code>joint_name</code> and is part of a model instance with ID <code>model_instance_id</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joint_name</td><td>The name of the parent joint of the rigid body to find.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instance_id</td><td>The ID of the model instance that owns the rigid body to find. This parameter is optional. If supplied, the set of rigid bodies to search through is restricted to those that belong to the specified model instance. Otherwise, all rigid bodies in this tree are searched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the rigid body whose parent joint is named <code>joint_name</code> joint and, if <code>model_instance_id</code> is specified, is part of the specified model instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If either no rigid body is found or multiple matching rigid bodies are found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20cb064cc59093fb94a1aad7287fe918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20cb064cc59093fb94a1aad7287fe918">&#9670;&nbsp;</a></span>FindChildrenOfBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; FindChildrenOfBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>parent_body_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_instance_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of indexes of bodies that are the children of the body at index <code>parent_body_index</code>. </p>
<p>The resulting list can be further filtered to be bodies that belong to model instance ID <code>model_instance_id</code>. This method has a time complexity of <code>O(N)</code> where <code>N</code> is the number of bodies in the tree, which can be determined by calling <a class="el" href="class_rigid_body_tree.html#a2d058d7557f133059de2669abcf4383d" title="Returns the number of bodies in this tree. ">RigidBodyTree::get_num_bodies()</a>. </p>

</div>
</div>
<a id="a155f9a3322b8a50099916f744b55af18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155f9a3322b8a50099916f744b55af18">&#9670;&nbsp;</a></span>FindCollisionElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1collision_1_1_element.html">drake::multibody::collision::Element</a>* FindCollisionElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1multibody_1_1collision.html#abedcf22a55257b04e6b7a12700ae4c22">drake::multibody::collision::ElementId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a <code>const</code> pointer to an element of the collision model. </p>
<dl class="section note"><dt>Note</dt><dd>The use of Find (instead of get) and the use of CamelCase both imply a potential runtime cost are carried over from the collision model accessor method. </dd></dl>

</div>
</div>
<a id="af8fd34a32edfffc921d4d7109243709f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fd34a32edfffc921d4d7109243709f">&#9670;&nbsp;</a></span>findFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &gt; findFrame </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frame_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a frame of the specified <code>frame_name</code> belonging to a model with the specified <code>model_id</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_name</td><td>The name of the frame to find.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_id</td><td>The ID of the model to which the frame belongs. If this value is -1, search all models.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The frame with the specified name and model instance ID.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if either multiple matching frames are found or no matching frame is found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa544a9ff2936749d38b32b62c270c173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa544a9ff2936749d38b32b62c270c173">&#9670;&nbsp;</a></span>FindIndexOfChildBodyOfJoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> FindIndexOfChildBodyOfJoint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>joint_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_instance_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index within the vector of rigid bodies of the rigid body whose parent joint is named <code>joint_name</code> and is part of a model instance with ID <code>model_instance_id</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joint_name</td><td>The name of the parent joint of the rigid body whose index is being searched for.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instance_id</td><td>The ID of the model instance that owns the rigid body to find. This parameter is optional. If supplied, the set of rigid bodies to search through is restricted to those that belong to the specified model instance. Otherwise, all rigid bodies in this tree are searched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the rigid body whose parent joint is named <code>joint_name</code> and, if <code>model_instance_id</code> is specified, is part of the specified model instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If either no rigid body is found or multiple matching rigid bodies are found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1552be870f521c8316c9dbae724a07f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1552be870f521c8316c9dbae724a07f4">&#9670;&nbsp;</a></span>findJoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; * findJoint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>joint_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac7e9bb14a9e6441a85f913eadddfc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7e9bb14a9e6441a85f913eadddfc4e">&#9670;&nbsp;</a></span>findJointId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> findJointId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>joint_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1efd7b07f685b1fff27272932efee106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efd7b07f685b1fff27272932efee106">&#9670;&nbsp;</a></span>FindKinematicPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FindKinematicPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>start_body_or_frame_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>end_body_or_frame_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; *&#160;</td>
          <td class="paramname"><em>start_body_ancestors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; *&#160;</td>
          <td class="paramname"><em>end_body_ancestors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_kinematic_path.html">KinematicPath</a> *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the kinematic path between two bodies or frames. </p>
<p>This function will not allocate memory if <code>path</code>, <code>start_body_ancestors</code> and <code>end_body_ancestors</code> are preallocated. </p>

</div>
</div>
<a id="acafc870eecb0a95a839d13a5d7e059c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafc870eecb0a95a839d13a5d7e059c2">&#9670;&nbsp;</a></span>findKinematicPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_kinematic_path.html">KinematicPath</a> findKinematicPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>start_body_or_frame_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>end_body_or_frame_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa63e8b7073c728971612311204ddf033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63e8b7073c728971612311204ddf033">&#9670;&nbsp;</a></span>findLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; * findLink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a deprecated version of <code>FindBody(...)</code>. </p>
<p>Please use <code>FindBody(...)</code> instead. </p>

</div>
</div>
<a id="a62ec5b2601497a1b1f5d57411d216be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ec5b2601497a1b1f5d57411d216be7">&#9670;&nbsp;</a></span>findLinkId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> findLinkId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>link_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a deprecated version of <code>FindBodyIndex(...)</code>. </p>
<p>Please use <code>FindBodyIndex(...)</code> instead. </p>

</div>
</div>
<a id="aa7fbd45e66ce80729e8b9b85874bb1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fbd45e66ce80729e8b9b85874bb1c7">&#9670;&nbsp;</a></span>FindModelInstanceBodies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; * &gt; FindModelInstanceBodies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>model_instance_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of pointers to all rigid bodies in this tree that belong to a particular model instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instance_id</td><td>The ID of the model instance whose rigid bodies are being searched for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pointers to every rigid body belonging to the specified model instance. </dd></dl>

</div>
</div>
<a id="a52e31fba92943be01ef42ddc131cbda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e31fba92943be01ef42ddc131cbda9">&#9670;&nbsp;</a></span>forwardKinPositionGradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt; forwardKinPositionGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>from_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>to_body_or_frame_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fa15d156dacdccb399519f16a2aafc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa15d156dacdccb399519f16a2aafc6">&#9670;&nbsp;</a></span>forwardKinPositionGradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt; forwardKinPositionGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>from_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>to_body_or_frame_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c1debb13abba690c6b4eae4a7548711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1debb13abba690c6b4eae4a7548711">&#9670;&nbsp;</a></span>frictionTorques() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename DerivedV::Scalar, Eigen::Dynamic, 1&gt; frictionTorques </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4402575f7605eb607735c61630240a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4402575f7605eb607735c61630240a3a">&#9670;&nbsp;</a></span>frictionTorques() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;typename DerivedV::Scalar, Dynamic, 1&gt; frictionTorques </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedV &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a746f86636dd7258c9b06a0037f3f698a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746f86636dd7258c9b06a0037f3f698a">&#9670;&nbsp;</a></span>geometricJacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af30fe85a821bd0e0ab46f2e165c8e480">drake::TwistMatrix</a>&lt;Scalar&gt; geometricJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>base_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>end_effector_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>expressed_in_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; *&#160;</td>
          <td class="paramname"><em>v_indices</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a497527e262cda142488d88e7c4dbe9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497527e262cda142488d88e7c4dbe9f9">&#9670;&nbsp;</a></span>geometricJacobianDotTimesV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt;Scalar&gt; geometricJacobianDotTimesV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>base_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>end_effector_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>expressed_in_body_or_frame_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af624e55c30f00895414147dc1334538c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af624e55c30f00895414147dc1334538c">&#9670;&nbsp;</a></span>get_body()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; get_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the body at index <code>body_index</code>. </p>
<p>Parameter <code>body_index</code> must be between zero and the number of bodies in this tree, which can be determined by calling <a class="el" href="class_rigid_body_tree.html#a2d058d7557f133059de2669abcf4383d" title="Returns the number of bodies in this tree. ">RigidBodyTree::get_num_bodies()</a>. </p>

</div>
</div>
<a id="a750de836b86f126cc2b82eca6c25773f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750de836b86f126cc2b82eca6c25773f">&#9670;&nbsp;</a></span>get_mutable_body()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; * get_mutable_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the body at index <code>body_index</code>. </p>
<p>Parameter <code>body_index</code> must be between zero and the number of bodies in this tree, which can be determined by calling <a class="el" href="class_rigid_body_tree.html#a2d058d7557f133059de2669abcf4383d" title="Returns the number of bodies in this tree. ">RigidBodyTree::get_num_bodies()</a>. </p>

</div>
</div>
<a id="a943cea1f9b2568fa6ca812089d9bf78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943cea1f9b2568fa6ca812089d9bf78c">&#9670;&nbsp;</a></span>get_next_clique_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> get_next_clique_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac17a4f6613813e5ff10d3f2eaaf513be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17a4f6613813e5ff10d3f2eaaf513be">&#9670;&nbsp;</a></span>get_num_actuators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> get_num_actuators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of actuators in this RigidBodyTree. </p>

</div>
</div>
<a id="a2d058d7557f133059de2669abcf4383d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d058d7557f133059de2669abcf4383d">&#9670;&nbsp;</a></span>get_num_bodies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> get_num_bodies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bodies in this tree. </p>
<p>This includes the one body that represents the world. </p>

</div>
</div>
<a id="a2a7724e661f14644bd6d93f913d17f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7724e661f14644bd6d93f913d17f12">&#9670;&nbsp;</a></span>get_num_frames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> get_num_frames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of frames in this tree. </p>

</div>
</div>
<a id="ac31919012770675ceedb50e5d120cc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31919012770675ceedb50e5d120cc2d">&#9670;&nbsp;</a></span>get_num_model_instances()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> get_num_model_instances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of model instances in the tree, not including the world. </p>

</div>
</div>
<a id="a30342f766e5b14049b65f710581f4bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30342f766e5b14049b65f710581f4bd1">&#9670;&nbsp;</a></span>get_num_positions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> get_num_positions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of position states outputted by this RigidBodyTree. </p>

</div>
</div>
<a id="a372731ef06a823324bfeda5c8a8a3ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372731ef06a823324bfeda5c8a8a3ac8">&#9670;&nbsp;</a></span>get_num_velocities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> get_num_velocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of velocity states outputted by this RigidBodyTree. </p>

</div>
</div>
<a id="a2a9e27e73e3045e35f483009d132b1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9e27e73e3045e35f483009d132b1a4">&#9670;&nbsp;</a></span>get_number_of_bodies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> get_number_of_bodies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34037cd15b3b78dfb4119658e5817a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34037cd15b3b78dfb4119658e5817a58">&#9670;&nbsp;</a></span>get_number_of_model_instances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> get_number_of_model_instances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af94b66bc740f806794618ad439c0dcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94b66bc740f806794618ad439c0dcc9">&#9670;&nbsp;</a></span>get_position_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string get_position_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>position_num</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the position state at index <code>position_num</code> within this <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code>'s state vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position_num</td><td>An index value between zero and <a class="el" href="class_rigid_body_tree.html#ab93be76182a2b3061b1530d12076bcfa">number_of_positions()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the position value at index <code>position_num</code>. </dd></dl>

</div>
</div>
<a id="ac818dfc39fe0e26797ba59f46a443b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac818dfc39fe0e26797ba59f46a443b8f">&#9670;&nbsp;</a></span>get_velocity_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string get_velocity_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>velocity_num</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the velocity state at index <code>velocity_num</code> within this <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code>'s state vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">velocity_num</td><td>An index value between <a class="el" href="class_rigid_body_tree.html#ab93be76182a2b3061b1530d12076bcfa">number_of_positions()</a> and number_of_veocities().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the velocity value at index <code>velocity_num</code>. </dd></dl>

</div>
</div>
<a id="a8dfe664359107ac857001badda453fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfe664359107ac857001badda453fdf">&#9670;&nbsp;</a></span>GetActuator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_rigid_body_actuator.html">RigidBodyActuator</a> &amp; GetActuator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a rigid body actuator from this rigid body tree. </p>
<p>The actuator is selected based on its name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the rigid body actuator to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the rigid body actuator with name <code>name</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if no rigid body actuator with name <code>name</code> exists. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1d9e00bbd5aee3b2da50bca0b43819c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d9e00bbd5aee3b2da50bca0b43819c">&#9670;&nbsp;</a></span>getBodyOrFrameName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string getBodyOrFrameName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>body_or_frame_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ee5854d54c562df2e21dca5f5d3624c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee5854d54c562df2e21dca5f5d3624c">&#9670;&nbsp;</a></span>getMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> getMass </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em> = <code><a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the total combined mass of a set of model instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instance_id_set</td><td>A set of model instance ID values corresponding to the model instances whose masses should be included in the returned value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total combined mass of the model instances in <code>model_instance_id_set</code>. </dd></dl>

</div>
</div>
<a id="a4b374380bb8e22bcbdb98350f5dcac8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b374380bb8e22bcbdb98350f5dcac8e">&#9670;&nbsp;</a></span>getNumContacts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> getNumContacts </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa708a274f3601c05ac7e59f6de33f447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa708a274f3601c05ac7e59f6de33f447">&#9670;&nbsp;</a></span>getNumJointLimitConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t getNumJointLimitConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a113a1f4fed5c3230541fb3161aa49e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113a1f4fed5c3230541fb3161aa49e13">&#9670;&nbsp;</a></span>getNumPositionConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t getNumPositionConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed68fa92e7d3a34b676cf871ec65da8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed68fa92e7d3a34b676cf871ec65da8e">&#9670;&nbsp;</a></span>getPositionName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string getPositionName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>position_num</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f5e620e9323ca4015164ae819b1b362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5e620e9323ca4015164ae819b1b362">&#9670;&nbsp;</a></span>GetQDotToVelocityMapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt;Scalar&gt; GetQDotToVelocityMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aefc193b53847fdac24143e08161de207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc193b53847fdac24143e08161de207">&#9670;&nbsp;</a></span>GetQDotToVelocityMapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixX&lt;Scalar&gt; GetQDotToVelocityMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dac5378b14d06c84f487ed21bd1335f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dac5378b14d06c84f487ed21bd1335f">&#9670;&nbsp;</a></span>getRandomConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd getRandomConfiguration </td>
          <td>(</td>
          <td class="paramtype">std::default_random_engine &amp;&#160;</td>
          <td class="paramname"><em>generator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8899470dfea29c51a4deeba97b8da0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8899470dfea29c51a4deeba97b8da0c">&#9670;&nbsp;</a></span>getStateName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string getStateName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>state_num</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a320a6f219612759638eb715838b353ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320a6f219612759638eb715838b353ec">&#9670;&nbsp;</a></span>getTerrainContactPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getTerrainContactPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix3Xd *&#160;</td>
          <td class="paramname"><em>terrain_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the contact points defined by a body's collision elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td>The body who's collision elements are searched.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">terrain_points</td><td>Contact points are added to this matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_name</td><td>If a group name was given, use it to look up the subset of collision elements that belong to that collision group. Otherwise, uses the full set of collision elements that belong to the body.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if an invalid group name is given. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d5b3900dcd190b88974883b1e0271ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5b3900dcd190b88974883b1e0271ec">&#9670;&nbsp;</a></span>getVelocityName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string getVelocityName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>velocity_num</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a508c431527531fb1caa654a84fa7edf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508c431527531fb1caa654a84fa7edf2">&#9670;&nbsp;</a></span>GetVelocityToQDotMapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt;Scalar&gt; GetVelocityToQDotMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab73932132eeb7b040aa74ee57aa73bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73932132eeb7b040aa74ee57aa73bf0">&#9670;&nbsp;</a></span>GetVelocityToQDotMapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixX&lt;Scalar&gt; GetVelocityToQDotMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0affd497911ca3154107ea425b81702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0affd497911ca3154107ea425b81702">&#9670;&nbsp;</a></span>getZeroConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd getZeroConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe87a180d00c685893090166d7a8dd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe87a180d00c685893090166d7a8dd46">&#9670;&nbsp;</a></span>initialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this RigidBodyTree is initialized. </p>
<p>It is initialized after <a class="el" href="class_rigid_body_tree.html#acafe5ede9412674127cd08795647f26a">compile()</a> is called. </p>

</div>
</div>
<a id="a4db480ac1981bb7d352cac340cefb490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db480ac1981bb7d352cac340cefb490">&#9670;&nbsp;</a></span>inverseDynamics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt; inverseDynamics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#afcadf96d397f45d041d01bf17061bc32">drake::eigen_aligned_std_unordered_map</a>&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; const *, <a class="el" href="namespacedrake.html#af98fed5f98c376f4d45fff56bb96c8e1">drake::WrenchVector</a>&lt; Scalar &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>external_wrenches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>include_velocity_terms</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute </p><p class="formulaDsp">
\[ H(q) \dot{v} + C(q, v, f_\text{ext}) \]
</p>
<p> that is, the left hand side of the manipulator equations </p><p class="formulaDsp">
\[ H(q) \dot{v} + C(q, v, f_\text{ext}) = B(q) u \]
</p>
<p>. </p>
<p>Note that the 'dynamics bias term' \( C(q, v, f_\text{ext}) \) can be computed by simply setting \( \dot{v} = 0\). Note also that if only the gravitational terms contained in \( C(q, v, *f_\text{ext}) \) are required, one can set <em>include_velocity_terms</em> to false. Alternatively, one can pass in a <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> created with \( v = 0\) or without specifying the velocity vector.</p>
<p>Algorithm: recursive Newton-Euler. Does not explicitly compute mass matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>a <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> constructed given \( q \) and \( v \) </td></tr>
    <tr><td class="paramname">external_wrenches</td><td>external wrenches exerted upon bodies ( \( f_\text{ext} \)). Expressed in body frame. </td></tr>
    <tr><td class="paramname">vd</td><td>\( \dot{v} \) </td></tr>
    <tr><td class="paramname">include_velocity_terms</td><td>whether to include velocity-dependent terms in \( C(q, v, f_\text{ext}) \). Setting <em>include_velocity_terms</em> to false is Equivalent to setting \( v = 0 \) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\( H(q) \dot{v} + C(q, v, f_\text{ext}) \) </dd></dl>

</div>
</div>
<a id="a54c6088b2b6203aeb00305adf5c249bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c6088b2b6203aeb00305adf5c249bd">&#9670;&nbsp;</a></span>inverseDynamics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;Scalar, Eigen::Dynamic, 1&gt; inverseDynamics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#afcadf96d397f45d041d01bf17061bc32">drake::eigen_aligned_std_unordered_map</a>&lt; <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; const *, WrenchVector&lt; Scalar &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>external_wrenches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>include_velocity_terms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a489c40ff74c5683873d1557a15c836bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489c40ff74c5683873d1557a15c836bc">&#9670;&nbsp;</a></span>is_part_of_model_instances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_part_of_model_instances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>body</code> is part of a model instance whose ID is in <code>model_instance_id_set</code>. </p>

</div>
</div>
<a id="ad910966c8321eb3de14acaa2ac51a3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad910966c8321eb3de14acaa2ac51a3d3">&#9670;&nbsp;</a></span>jointLimitConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jointLimitConstraints </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedA &gt; const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10d753d104699644a99a69841d2aac4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d753d104699644a99a69841d2aac4e">&#9670;&nbsp;</a></span>jointLimitConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jointLimitConstraints </td>
          <td>(</td>
          <td class="paramtype">MatrixBase&lt; DerivedA &gt; const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54928c367e4abdd1d9116282ae73a1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54928c367e4abdd1d9116282ae73a1a8">&#9670;&nbsp;</a></span>LumpedSpatialInertiaInWorldFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">drake::Matrix6</a>&lt; T &gt; LumpedSpatialInertiaInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em> = <code><a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the summed spatial inertia in the world frame of all bodies that belong to model instances in <code>model_instance_id_set</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">model_instance_id_set</td><td>A set of model instance ID values corresponding to the model instances whose spatial inertia should be included in the returned value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The summed spatial inertia. </dd></dl>

</div>
</div>
<a id="aceb1f7792097c6e26945b6feb6b7ca53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb1f7792097c6e26945b6feb6b7ca53">&#9670;&nbsp;</a></span>LumpedSpatialInertiaInWorldFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">drake::Matrix6</a>&lt; T &gt; LumpedSpatialInertiaInWorldFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>bodies_of_interest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the summed spatial inertia in the world frame of all the bodies in <code>bodies_of_interest</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Reference to the <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>. </td></tr>
    <tr><td class="paramname">bodies_of_interest</td><td>Vector of bodies, whose spatial inertia will be summed and returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The summed spatial inertia. </dd></dl>

</div>
</div>
<a id="aa52dc803a7bd84afe62f3496880dfaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52dc803a7bd84afe62f3496880dfaff">&#9670;&nbsp;</a></span>massMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt; massMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the positive definite mass (configuration space) matrix \( *H(q) \), defined by \(T = \frac{1}{2} v^T H(q) v \), where \( T \) is kinetic energy. </p>
<p>The mass matrix also appears in the manipulator equations </p><p class="formulaDsp">
\[ H(q) \dot{v} + C(q, v, f_\text{ext}) = B(q) u \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>a <a class="el" href="class_kinematics_cache.html">KinematicsCache</a> constructed given \( q \) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mass matrix \( H(q) \) </dd></dl>

</div>
</div>
<a id="a3bfe2a76e80365e043a9d92413c0b108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfe2a76e80365e043a9d92413c0b108">&#9670;&nbsp;</a></span>massMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt; massMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab93be76182a2b3061b1530d12076bcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93be76182a2b3061b1530d12076bcfa">&#9670;&nbsp;</a></span>number_of_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> number_of_positions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0a564f744c031d6491257aa0f4490ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a564f744c031d6491257aa0f4490ce">&#9670;&nbsp;</a></span>number_of_velocities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> number_of_velocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70f2e1d3a046aa0fdfd4ba09b7ef2e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f2e1d3a046aa0fdfd4ba09b7ef2e7d">&#9670;&nbsp;</a></span>parseBodyOrFrameID() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> parseBodyOrFrameID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>body_or_frame_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Transform&lt; Scalar, 3, Eigen::Isometry &gt; *&#160;</td>
          <td class="paramname"><em>Tframe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a860adb0d81bd2c85bb553c2463df984c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860adb0d81bd2c85bb553c2463df984c">&#9670;&nbsp;</a></span>parseBodyOrFrameID() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> parseBodyOrFrameID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>body_or_frame_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9b28457f0672d6a6c15b61646580bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b28457f0672d6a6c15b61646580bcd">&#9670;&nbsp;</a></span>parseBodyOrFrameID() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> parseBodyOrFrameID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>body_or_frame_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Transform&lt; Scalar, 3, Isometry &gt; *&#160;</td>
          <td class="paramname"><em>Tframe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66f3880edd99724779a6bf4d60ecde64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f3880edd99724779a6bf4d60ecde64">&#9670;&nbsp;</a></span>positionConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt; positionConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adca770c9a924ed6c8c27a48578ead486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca770c9a924ed6c8c27a48578ead486">&#9670;&nbsp;</a></span>positionConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;Scalar, Eigen::Dynamic, 1&gt; positionConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc417fc535f72a29ecca7bf873234e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc417fc535f72a29ecca7bf873234e0d">&#9670;&nbsp;</a></span>positionConstraintsJacDotTimesV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt; positionConstraintsJacDotTimesV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba716a6494b76bc06d45410934433b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba716a6494b76bc06d45410934433b1c">&#9670;&nbsp;</a></span>positionConstraintsJacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt; positionConstraintsJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12447ed4fd0c7c2225d393669a836471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12447ed4fd0c7c2225d393669a836471">&#9670;&nbsp;</a></span>print_joint_welding_diagnostics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void print_joint_welding_diagnostics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>wants_to_print</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When <code>val</code> is true, diagnostics in <a class="el" href="class_rigid_body_tree.html#acafe5ede9412674127cd08795647f26a">compile()</a> will be printed with <a class="el" href="namespacedrake.html#aa157c1d75c2e52df3370e5f458022ee9" title="Retrieve an instance of a logger to use for logging; for example: ">drake::log()</a>-&gt;info(). </p>
<p>When false, <a class="el" href="namespacedrake.html#aa157c1d75c2e52df3370e5f458022ee9" title="Retrieve an instance of a logger to use for logging; for example: ">drake::log()</a>-&gt;<a class="el" href="system__identification_8cc.html#a322565ccf348d13e4d3de13af771e5fc">debug()</a> will be used instead. </p>

</div>
</div>
<a id="afe634c0bc332b198da202f2464ecb89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe634c0bc332b198da202f2464ecb89c">&#9670;&nbsp;</a></span>relativeQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, 4, 1&gt; relativeQuaternion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>from_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>to_body_or_frame_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f8ddaddfebf60b8000697461d89dbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8ddaddfebf60b8000697461d89dbb7">&#9670;&nbsp;</a></span>relativeQuaternionJacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, <a class="el" href="namespacedrake.html#a07869e660ffe730425feca7595de2273">drake::kQuaternionSize</a>, Eigen::Dynamic&gt; relativeQuaternionJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>from_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>to_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b0e3c8ce89222cbe54640f1ad51b870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0e3c8ce89222cbe54640f1ad51b870">&#9670;&nbsp;</a></span>relativeQuaternionJacobianDotTimesV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt; relativeQuaternionJacobianDotTimesV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>from_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>to_body_or_frame_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5b864391909972e94ad00c3c1b0fc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b864391909972e94ad00c3c1b0fc3f">&#9670;&nbsp;</a></span>relativeRollPitchYaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, 3, 1&gt; relativeRollPitchYaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>from_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>to_body_or_frame_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dc1dd761df729d8c1e0d576a4f6daf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc1dd761df729d8c1e0d576a4f6daf9">&#9670;&nbsp;</a></span>relativeRollPitchYawJacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, <a class="el" href="namespacedrake.html#aeab5b0d99cafc2f6ae5812128cea27a3">drake::kRpySize</a>, Eigen::Dynamic&gt; relativeRollPitchYawJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>from_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>to_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7f1c690b9d32b3a13a2651e02cff0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f1c690b9d32b3a13a2651e02cff0aa">&#9670;&nbsp;</a></span>relativeRollPitchYawJacobianDotTimesV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt; relativeRollPitchYawJacobianDotTimesV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>from_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>to_body_or_frame_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af10d52808ad8b8ae1340e0be40ee14cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10d52808ad8b8ae1340e0be40ee14cd">&#9670;&nbsp;</a></span>relativeTransform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Transform&lt;Scalar, <a class="el" href="namespacedrake.html#af869092c52ed7cc9d2db40ce56050c7c">drake::kSpaceDimension</a>, Eigen::Isometry&gt; relativeTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>base_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>body_or_frame_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72c5fd8881bd97dde7e7266ce4329e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c5fd8881bd97dde7e7266ce4329e60">&#9670;&nbsp;</a></span>relativeTransform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Transform&lt;Scalar, 3, Isometry&gt; relativeTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>base_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>body_or_frame_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ad8496db362562961cbc294d3515148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad8496db362562961cbc294d3515148">&#9670;&nbsp;</a></span>relativeTwist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt;Scalar&gt; relativeTwist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>base_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>expressed_in_body_or_frame_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0d2387b280045cd75e6f4cc07913f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d2387b280045cd75e6f4cc07913f61">&#9670;&nbsp;</a></span>removeCollisionGroupsIf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void removeCollisionGroupsIf </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>test</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af07d38fa5629615c367b40a5008feb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07d38fa5629615c367b40a5008feb87">&#9670;&nbsp;</a></span>resolveCenterOfPressure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::Vector3d, <a class="el" href="classdouble.html">double</a> &gt; resolveCenterOfPressure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="struct_force_torque_measurement.html">ForceTorqueMeasurement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>force_torque_measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedNormal &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_on_contact_plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes CoP in world frame. </p>
<p>Normal and point on contact plane should be in world frame too. </p>

</div>
</div>
<a id="a0eb7ce71c2d436a3c63ea2e2d2149865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb7ce71c2d436a3c63ea2e2d2149865">&#9670;&nbsp;</a></span>surfaceTangents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void surfaceTangents </td>
          <td>(</td>
          <td class="paramtype">Eigen::Map&lt; Eigen::Matrix3Xd &gt; const &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Map&lt; Eigen::Matrix3Xd &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tangents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa527aaa5e2aa17fc46efb5b14c608701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa527aaa5e2aa17fc46efb5b14c608701">&#9670;&nbsp;</a></span>transformCollisionFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> transformCollisionFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Isometry3d &amp;&#160;</td>
          <td class="paramname"><em>displace_transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given transform to the given <code>body's</code> collision elements, displacing them from their current configurations. </p>
<p>These new poses will be considered the elements' pose with respect to the body.</p>
<p>This is important to the parsing code to maintain a Drake <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> invariant. <a class="el" href="class_rigid_body.html">RigidBody</a> instances do not maintain their own pose relative to their in-board joint. The joint's space is considered to be the body's space. So, if a URDF or SDF file defines the body with a non-identity pose relative to the parent, the parser uses this to move the collision elements relative to the effective body frame &ndash; that of the parent joint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>The body whose collision elements will be moved. </td></tr>
    <tr><td class="paramname">displace_transform</td><td>The transform to apply to each collision element. </td></tr>
    <tr><td class="paramname">true</td><td>if the collision element was successfully updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the 's elements were successfully transformed. </dd></dl>

</div>
</div>
<a id="a8edd4c4a2ce10a172d8961293e43a6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edd4c4a2ce10a172d8961293e43a6ef">&#9670;&nbsp;</a></span>transformPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, 3, DerivedPoints::ColsAtCompileTime&gt; transformPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>from_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>to_body_or_frame_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5326fb460d780258e4a495d298ac77b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5326fb460d780258e4a495d298ac77b0">&#9670;&nbsp;</a></span>transformPointsJacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt; transformPointsJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>from_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>to_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c799895df93f1b738dfd90ac0fe64a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c799895df93f1b738dfd90ac0fe64a7">&#9670;&nbsp;</a></span>transformPointsJacobianDotTimesV()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt; transformPointsJacobianDotTimesV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>from_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>to_body_or_frame_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa316fc4cc3cf63249ba0a34788fd716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa316fc4cc3cf63249ba0a34788fd716">&#9670;&nbsp;</a></span>transformQDotMappingToVelocityMapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt;typename Derived::Scalar&gt; transformQDotMappingToVelocityMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename Derived::Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a matrix A, which transforms the time derivative of generalized coordinates (qdot) to an output space X, to a matrix B, which transforms generalized velocities (v) to the same space X. </p>
<p>For example, A could be a Jacobian matrix that transforms qdot to spatial velocities at the end effector. Formally, this would be the matrix of partial derivatives of end-effector configuration computed with respect to the generalized coordinates (q). This function would allow the user to transform this Jacobian matrix to the more commonly used one: the matrix of partial derivatives of end-effector configuration computed with respect to quasi-coordinates (). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ap</td><td>a <code>m x nq</code> sized matrix, where <code>nq</code> is the dimension of the generalized coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B,a</td><td><code>m x nv</code> sized matrix, where <code>nv</code> is the dimension of the generalized velocities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rigid_body_tree.html#ac0f6f25c5489ccca2e23c18b04e000bf" title="Converts a matrix B, which transforms generalized velocities (v) to an output space X...">transformVelocityMappingToQDotMapping()</a> </dd></dl>

</div>
</div>
<a id="a9aea901f1e05d9b548a06333f95a4f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aea901f1e05d9b548a06333f95a4f19">&#9670;&nbsp;</a></span>transformQDotMappingToVelocityMapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixX&lt;typename Derived::Scalar&gt; transformQDotMappingToVelocityMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename Derived::Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8931220c0057896f5eeb44000e7ba1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8931220c0057896f5eeb44000e7ba1d">&#9670;&nbsp;</a></span>transformQDotToVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt; typename Derived::Scalar &gt; transformQDotToVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename Derived::Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a vector of the time derivative of generalized coordinates (qdot) to generalized velocity (v). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>the kinematics cache, which is assumed to be up-to-date with respect to the state </td></tr>
    <tr><td class="paramname">qdot</td><td>a <code>nq</code> dimensional vector, where <code>nq</code> is the dimension of the generalized coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>nv</code> dimensional vector, where <code>nv</code> is the dimension of the generalized velocities. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rigid_body_tree.html#a53cf90b2baa4100731b63612b3874dda" title="Converts a vector of generalized velocities (v) to the time derivative of generalized coordinates (qd...">transformVelocityToQDot()</a> </dd></dl>

</div>
</div>
<a id="a7156a1348ddbf364a0e076dae5132fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7156a1348ddbf364a0e076dae5132fe1">&#9670;&nbsp;</a></span>transformSpatialAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt;Scalar&gt; transformSpatialAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_acceleration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>base_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>old_body_or_frame_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>new_body_or_frame_ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0f6f25c5489ccca2e23c18b04e000bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f6f25c5489ccca2e23c18b04e000bf">&#9670;&nbsp;</a></span>transformVelocityMappingToQDotMapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt;typename Derived::Scalar&gt; transformVelocityMappingToQDotMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename Derived::Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>Av</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a matrix B, which transforms generalized velocities (v) to an output space X, to a matrix A, which transforms the time derivative of generalized coordinates (qdot) to the same output X. </p>
<p>For example, B could be a Jacobian matrix that transforms generalized velocities to spatial velocities at the end-effector. Formally, this would be the matrix of partial derivatives of end-effector configuration computed with respect to quasi-coordinates (). This function would allow transforming that Jacobian so that all partial derivatives would be computed with respect to qdot. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Av,a</td><td><code>m x nv</code> sized matrix, where <code>nv</code> is the dimension of the generalized velocities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">A</td><td>a <code>m x nq</code> sized matrix, where <code>nq</code> is the dimension of the generalized coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rigid_body_tree.html#afa316fc4cc3cf63249ba0a34788fd716" title="Converts a matrix A, which transforms the time derivative of generalized coordinates (qdot) to an out...">transformQDotMappingToVelocityMapping()</a> </dd></dl>

</div>
</div>
<a id="a17add192541efde45e8d8ea8404d9477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17add192541efde45e8d8ea8404d9477">&#9670;&nbsp;</a></span>transformVelocityMappingToQDotMapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixX&lt;typename Derived::Scalar&gt; transformVelocityMappingToQDotMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename Derived::Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>Av</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53cf90b2baa4100731b63612b3874dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cf90b2baa4100731b63612b3874dda">&#9670;&nbsp;</a></span>transformVelocityToQDot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt; typename Derived::Scalar &gt; transformVelocityToQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; typename Derived::Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a vector of generalized velocities (v) to the time derivative of generalized coordinates (qdot). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>the kinematics cache, which is assumed to be up-to-date with respect to the state </td></tr>
    <tr><td class="paramname">v</td><td>a <code>nv</code> dimensional vector, where <code>nv</code> is the dimension of the generalized velocities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">qdot</td><td>a <code>nq</code> dimensional vector, where <code>nq</code> is the dimension of the generalized coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rigid_body_tree.html#ae8931220c0057896f5eeb44000e7ba1d" title="Converts a vector of the time derivative of generalized coordinates (qdot) to generalized velocity (v...">transformQDotToVelocity()</a> </dd></dl>

</div>
</div>
<a id="a9953a97ba893f803344bf23a63c9cde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9953a97ba893f803344bf23a63c9cde8">&#9670;&nbsp;</a></span>updateCollisionElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateCollisionElements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; U, 3, Eigen::Isometry &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform_to_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>throw_if_missing_gradient</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the collision elements registered with the collision detection engine. </p>
<p>Note: If U is not a double then the transforms from kinematics cache will be forcefully cast to doubles (discarding any gradient information). Callers that set <code>throw_if_missing_gradient</code> to <code>false</code> are responsible for ensuring that future code is secure despite all gradients with respect to the collision engine being arbitrarily set to zero. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rigid_body_tree.html#aff25f6baacbae752077e9815ef46d256" title="Computes the point of closest approach between bodies in the RigidBodyTree that are in contact...">ComputeMaximumDepthCollisionPoints</a> for an example.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>based on the criteria of <a class="el" href="namespacedrake_1_1math.html#a44dafc4c3502cdb9bc73393bd7460f49" title="B = DiscardZeroGradient(A, precision) enables casting from a matrix of AutoDiffScalars to AutoDiffSca...">DiscardZeroGradient()</a> only if <code>throws_if_missing_gradient</code> is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4edafc3ed0fa7d1c6cd22721a82b1232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edafc3ed0fa7d1c6cd22721a82b1232">&#9670;&nbsp;</a></span>updateDynamicCollisionElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateDynamicCollisionElements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>kin_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>throw_if_missing_gradient</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rigid_body_tree.html#a9953a97ba893f803344bf23a63c9cde8" title="Updates the collision elements registered with the collision detection engine. ">updateCollisionElements</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>based on the criteria of <a class="el" href="namespacedrake_1_1math.html#a44dafc4c3502cdb9bc73393bd7460f49" title="B = DiscardZeroGradient(A, precision) enables casting from a matrix of AutoDiffScalars to AutoDiffSca...">DiscardZeroGradient()</a> only if <code>throws_if_missing_gradient</code> is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf9981c39a1ebe848c0b78ccd3f54c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9981c39a1ebe848c0b78ccd3f54c90">&#9670;&nbsp;</a></span>world() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; world </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable reference to the <a class="el" href="class_rigid_body.html">RigidBody</a> associated with the world in the model. </p>
<p>This is the root of the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. </p>

</div>
</div>
<a id="ae012a07a4821c25770bfbb748854ad56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae012a07a4821c25770bfbb748854ad56">&#9670;&nbsp;</a></span>world() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; world </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the <a class="el" href="class_rigid_body.html">RigidBody</a> associated with the world in the model. </p>
<p>This is the root of the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a>. </p>

</div>
</div>
<a id="a8967c5175ed74e112dd90962c094bea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8967c5175ed74e112dd90962c094bea1">&#9670;&nbsp;</a></span>worldMomentumMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af30fe85a821bd0e0ab46f2e165c8e480">drake::TwistMatrix</a>&lt;Scalar&gt; worldMomentumMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em> = <code><a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2ef71a5abd869d1461a7f1367a7c727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ef71a5abd869d1461a7f1367a7c727">&#9670;&nbsp;</a></span>worldMomentumMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TwistMatrix&lt;Scalar&gt; worldMomentumMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_terms_of_qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a527ff7514e7563e741f82b2c0d324788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527ff7514e7563e741f82b2c0d324788">&#9670;&nbsp;</a></span>worldMomentumMatrixDotTimesV() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt;Scalar&gt; worldMomentumMatrixDotTimesV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em> = <code><a class="el" href="struct_rigid_body_tree_constants.html#ab395f619389e54832f2ac0c31fa8fb83">RigidBodyTreeConstants::default_model_instance_id_set</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac622a42b4403b2cdd4060d6f08d450a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac622a42b4403b2cdd4060d6f08d450a8">&#9670;&nbsp;</a></span>worldMomentumMatrixDotTimesV() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TwistVector&lt;Scalar&gt; worldMomentumMatrixDotTimesV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_kinematics_cache.html">KinematicsCache</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instance_id_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab870111cb2ef28594b4764b4fb5c3d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab870111cb2ef28594b4764b4fb5c3d2a">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A toString method for this class. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1487b2d5a17756fde9ce3edb2e487fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1487b2d5a17756fde9ce3edb2e487fed">&#9670;&nbsp;</a></span>a_grav</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">drake::TwistVector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; a_grav</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad42c52af6d4bd94f124ccbd7ddb99fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42c52af6d4bd94f124ccbd7ddb99fd7">&#9670;&nbsp;</a></span>actuators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="class_rigid_body_actuator.html">RigidBodyActuator</a>, Eigen::aligned_allocator&lt;<a class="el" href="class_rigid_body_actuator.html">RigidBodyActuator</a>&gt; &gt; actuators</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a829f97c1d058527ed13f29ca3f74fa93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829f97c1d058527ed13f29ca3f74fa93">&#9670;&nbsp;</a></span>B</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd B</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a586e3be7197f936fcd391e4d2c0a91a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586e3be7197f936fcd391e4d2c0a91a4">&#9670;&nbsp;</a></span>distance_constraints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="struct_rigid_body_distance_constraint.html">RigidBodyDistanceConstraint</a>, Eigen::aligned_allocator&lt;<a class="el" href="struct_rigid_body_distance_constraint.html">RigidBodyDistanceConstraint</a>&gt; &gt; distance_constraints</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4a01bdc0bcc97ffc82e254be5f74fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a01bdc0bcc97ffc82e254be5f74fd2">&#9670;&nbsp;</a></span>joint_limit_max</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd joint_limit_max</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cc826c730317ed01e14324e51c34aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc826c730317ed01e14324e51c34aae">&#9670;&nbsp;</a></span>joint_limit_min</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd joint_limit_min</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb6b6c592a95918331412560029e0a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6b6c592a95918331412560029e0a26">&#9670;&nbsp;</a></span>loops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="class_rigid_body_loop.html">RigidBodyLoop</a>&lt;T&gt;, Eigen::aligned_allocator&lt;<a class="el" href="class_rigid_body_loop.html">RigidBodyLoop</a>&lt;T&gt; &gt; &gt; loops</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/attic/multibody/<a class="el" href="ik__options_8h.html">ik_options.h</a></li>
<li>drake/attic/multibody/<a class="el" href="rigid__body__tree_8h.html">rigid_body_tree.h</a></li>
<li>drake/attic/multibody/<a class="el" href="rigid__body__tree_8cc.html">rigid_body_tree.cc</a></li>
<li>drake/attic/multibody/<a class="el" href="rigid__body__tree__contact_8cc.html">rigid_body_tree_contact.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
