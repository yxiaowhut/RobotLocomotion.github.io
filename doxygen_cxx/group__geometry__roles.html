<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Geometry Roles</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__geometry__roles.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Geometry Roles</div>  </div>
</div><!--header-->
<div class="contents">
<p>Geometry roles help define how a real-world object is modeled in Drake. </p>
<p>We model the physical presence of real-world objects with geometric representations. For a single object, we can assign many different properties to the corresponding geometry depending on how the geometry is used (or what aspect of the real-world object it represents). There are many operations that can be applied to geometric representations. Each operation may only depend on some of the possible properties. Furthermore, it may be advantageous to represent a single real-world object with different geometries for different operations.</p>
<p><b>An example</b></p>
<p>A physical robot arm (such as the KUKA Iiwa) has a great deal of detail: flanges, vents, bolts, inset holes, stylistic creases, shiny paint, dull paint, lettering, etc. Furthermore, the materials the arm is made of have meaningful properties (e.g., Young's modulus, Poisson ratio, etc.) All of these taken together are part of the physical whole.</p>
<p>The physical arm is partially represented in Drake with geometric approximations and a set of properties which map the physical detail to the Drake's underlying mathematical models (other aspects of the arm, e.g., mass properties, are associated with the arm components as "bodies"). There are many things we may want to use this geometric representation of the arm for:</p>
<ul>
<li>Display the progress of an interactive simulation of the arm in a GUI-based visualization tool.</li>
<li>Compute contact forces between the virtual arm and its virtual environment.</li>
<li>Find clearances between objects.</li>
<li>Simulate what a camera or other sensor reports when exposed to the simulated environment.</li>
<li>Calculate aerodynamic or fluid forces acting on objects.</li>
<li>And more in the future.</li>
</ul>
<p>These are all meaningful operations on the virtual arm, but each operation requires a subset of the objects' properties. For example, the Young's modulus of the arm's end effector is not relevant to the external display of the state of the arm.</p>
<p>Beyond the relevancy of a property for any given operation, two different operations may be best served by having different geometric representations of the same physical object. For example, in modeling a bowling ball, the finger holes may not be necessary for determining contact forces and by simply representing the ball as a sphere the operation becomes much more efficient. On the other hand, a perception system for a robot that is attempting to pick up the ball and place fingers in the holes, would require a representation with the actual holes.</p>
<p><b>Geometry roles and geometry operations</b></p>
<p><em>Geometry roles</em> are the Drake mechanism that allows us to represent a single real-world object with different geometries best suited to the type of operation. (Rather than a single, monolithic representation which may be ill-suited for all operations.)</p>
<p>Drake partitions its geometry operations into classes (in the non-C++ sense of the word) and defines a unique role for each class of operations.</p>
<ul>
<li><b>Proximity role</b>: these are the operations that are related to evaluations of the signed distance between two geometries. When the objects are separated, the distance is positive, when penetrating, the distance is negative. The distance value can be characterized by e.g., nearest points in the separated case and by points of deepest penetration in the penetrating case (although this is not an exhaustive list). Due to the cost of these types of algorithms, these geometric representations tend to be simple approximations of real-world objects: single primitive shapes, unions of multiple primitive shapes, simple convex meshes, lower resolution versions of otherwise complex meshes. Typically, these types of queries are used in motion planning and the generation of contact forces. The properties associated with this role are typically things like Young's modulus, Poisson ratio, coefficients of friction, etc. Generally, these properties don't affect the <em>geometric</em> operation, but are used in conjunction with the geometry query results to produce forces and the like. Since these properties are defined on a per-geometry basis, <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram...">SceneGraph</a> stores these quantities with the geometries as a courtesy and these values can be requested from <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram...">SceneGraph</a> to, e.g., calculate forces. This role is unique in this regard &ndash; the geometry parameters for the other roles affect the result of the geometric operation.</li>
<li><b>Illustration role</b>: these are the operations that connect drake to some external visualizers. The intent is that geometries with this role don't contribute to system calculations, they provide the basis for visualizing, or <em>illustrating</em>, the state of the system. It can include geometries that illustrate abstract concepts or geometries which are literal representations of real-world object surfaces. The properties associated with this role are those necessary to draw the illustration.</li>
</ul>
<p>Role assignment is achieved by assigning as set of role-related <em>properties</em> to a geometry (see SceneGraph::AssignRole()). The set <em>can</em> be empty. Each role has a specific property set associated with it:</p><ul>
<li><b>Proximity role</b>: <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html" title="The set of properties for geometry used in a proximity role. ">ProximityProperties</a></li>
<li><b>Illustration role</b>: <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role. ">IllustrationProperties</a></li>
</ul>
<p>Even for a single role, different consumers of a geometry may use different properties. For example, a contact model is a likely consumer of geometries with the proximity role. However, how contact is implemented may vary from model to model. Those implementations can require model-specific parameters. The <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html" title="The set of properties for geometry used in a proximity role. ">ProximityProperties</a> need to include properties compatible with all the consumers active in the system.</p>
<p>In such a case, each consumer should document the properties it requires and how they are organized (see <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html" title="The base class for defining a set of geometry properties. ">GeometryProperties</a>). The properties can be segregated by collecting their model-specific parameters into a named property group as specified by each consumer.</p>
<p>To make a geometry <em>universally</em> compatible with <em>anything</em> in Drake, it would provide properties for all known consumers of geometry properties (e.g., contact models, visualizers, etc.) In practice, it is sufficient to satisfy those consumers used in a particular system.</p>
<p>Finally, a geometry is not limited to having a single role. A geometry must always have at least one role to have any impact. But it can have multiple roles.</p>
<p>Generally, any code that is dependent on geometry roles, should document the type of role that it depends on, and the properties (if any) associated with that role that it requires/prefers.</p>
<p>Roles are assigned during geometry registration (see SceneGraph::AssignRole()). </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
