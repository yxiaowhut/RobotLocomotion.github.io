<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Mobilizer&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_mobilizer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1_mobilizer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Mobilizer&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Mobilizer is a fundamental object within Drake's multibody engine used to specify the allowed motions between two <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> objects within a MultibodyTree.  
 <a href="classdrake_1_1multibody_1_1_mobilizer.html#details">More...</a></p>

<p><code>#include &lt;drake/multibody/tree/mobilizer.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a88583065bb66ffdbc3445640719d5cc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a88583065bb66ffdbc3445640719d5cc0">Mobilizer</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;<a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a6d9e71c282b333033aca747fe62ca73a">inboard_frame</a>, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;<a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a1d58f258a467a0ab7a593f1838b64bf6">outboard_frame</a>)</td></tr>
<tr class="memdesc:a88583065bb66ffdbc3445640719d5cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum amount of information that we need to define a Mobilizer is the knowledge of the inboard and outboard frames it connects.  <a href="#a88583065bb66ffdbc3445640719d5cc0">More...</a><br /></td></tr>
<tr class="separator:a88583065bb66ffdbc3445640719d5cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc3be43d9fe873001c79fcaada202e3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#addc3be43d9fe873001c79fcaada202e3">num_positions</a> () const =0</td></tr>
<tr class="memdesc:addc3be43d9fe873001c79fcaada202e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of generalized coordinates granted by this mobilizer.  <a href="#addc3be43d9fe873001c79fcaada202e3">More...</a><br /></td></tr>
<tr class="separator:addc3be43d9fe873001c79fcaada202e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aca305be7e0dbd081a568c1f73d3848"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a6aca305be7e0dbd081a568c1f73d3848">num_velocities</a> () const =0</td></tr>
<tr class="memdesc:a6aca305be7e0dbd081a568c1f73d3848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of generalized velocities granted by this mobilizer.  <a href="#a6aca305be7e0dbd081a568c1f73d3848">More...</a><br /></td></tr>
<tr class="separator:a6aca305be7e0dbd081a568c1f73d3848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d0ae62c51f7e6b183e79f7e9e05b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a86d0ae62c51f7e6b183e79f7e9e05b91">position_start_in_q</a> () const</td></tr>
<tr class="memdesc:a86d0ae62c51f7e6b183e79f7e9e05b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index to the first generalized position for this mobilizer within the vector q of generalized positions for the full multibody system.  <a href="#a86d0ae62c51f7e6b183e79f7e9e05b91">More...</a><br /></td></tr>
<tr class="separator:a86d0ae62c51f7e6b183e79f7e9e05b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47f8ba95456400c66ccf983ceb05e03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#ae47f8ba95456400c66ccf983ceb05e03">velocity_start_in_v</a> () const</td></tr>
<tr class="memdesc:ae47f8ba95456400c66ccf983ceb05e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index to the first generalized velocity for this mobilizer within the vector v of generalized velocities for the full multibody system.  <a href="#ae47f8ba95456400c66ccf983ceb05e03">More...</a><br /></td></tr>
<tr class="separator:ae47f8ba95456400c66ccf983ceb05e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9e71c282b333033aca747fe62ca73a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a6d9e71c282b333033aca747fe62ca73a">inboard_frame</a> () const</td></tr>
<tr class="memdesc:a6d9e71c282b333033aca747fe62ca73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the inboard frame.  <a href="#a6d9e71c282b333033aca747fe62ca73a">More...</a><br /></td></tr>
<tr class="separator:a6d9e71c282b333033aca747fe62ca73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d58f258a467a0ab7a593f1838b64bf6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a1d58f258a467a0ab7a593f1838b64bf6">outboard_frame</a> () const</td></tr>
<tr class="memdesc:a1d58f258a467a0ab7a593f1838b64bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the outboard frame.  <a href="#a1d58f258a467a0ab7a593f1838b64bf6">More...</a><br /></td></tr>
<tr class="separator:a1d58f258a467a0ab7a593f1838b64bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3404876c6666380c6f8a6be1e271b9e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#ab3404876c6666380c6f8a6be1e271b9e">inboard_body</a> () const</td></tr>
<tr class="memdesc:ab3404876c6666380c6f8a6be1e271b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the body associated with <code>this</code> mobilizer's inboard frame.  <a href="#ab3404876c6666380c6f8a6be1e271b9e">More...</a><br /></td></tr>
<tr class="separator:ab3404876c6666380c6f8a6be1e271b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26c8aff25bb56c2343cba3275c4c51e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#ad26c8aff25bb56c2343cba3275c4c51e">outboard_body</a> () const</td></tr>
<tr class="memdesc:ad26c8aff25bb56c2343cba3275c4c51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the body associated with <code>this</code> mobilizer's outboard frame.  <a href="#ad26c8aff25bb56c2343cba3275c4c51e">More...</a><br /></td></tr>
<tr class="separator:ad26c8aff25bb56c2343cba3275c4c51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8aac4909224becd506c5ff60de2c6c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdrake_1_1multibody_1_1_mobilizer_topology.html">MobilizerTopology</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a6c8aac4909224becd506c5ff60de2c6c">get_topology</a> () const</td></tr>
<tr class="memdesc:a6c8aac4909224becd506c5ff60de2c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the topology information for this mobilizer.  <a href="#a6c8aac4909224becd506c5ff60de2c6c">More...</a><br /></td></tr>
<tr class="separator:a6c8aac4909224becd506c5ff60de2c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11436315170be634a01332980e9fc38"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#aa11436315170be634a01332980e9fc38">get_positions_from_array</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;q_array) const</td></tr>
<tr class="memdesc:aa11436315170be634a01332980e9fc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const <a class="el" href="namespace_eigen.html">Eigen</a> expression of the vector of generalized positions for <code>this</code> mobilizer from a vector <code>q_array</code> of generalized positions for the entire MultibodyTree model.  <a href="#aa11436315170be634a01332980e9fc38">More...</a><br /></td></tr>
<tr class="separator:aa11436315170be634a01332980e9fc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166fd80c1944c6ed3d0058681bdeebf9"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; Eigen::Ref&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a166fd80c1944c6ed3d0058681bdeebf9">get_mutable_positions_from_array</a> (<a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; q_array) const</td></tr>
<tr class="memdesc:a166fd80c1944c6ed3d0058681bdeebf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable version of <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#aa11436315170be634a01332980e9fc38" title="Returns a const Eigen expression of the vector of generalized positions for this mobilizer from a vec...">get_positions_from_array()</a>.  <a href="#a166fd80c1944c6ed3d0058681bdeebf9">More...</a><br /></td></tr>
<tr class="separator:a166fd80c1944c6ed3d0058681bdeebf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e477324284c1a1067b556ea9bff0d7"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a95e477324284c1a1067b556ea9bff0d7">get_velocities_from_array</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;v_array) const</td></tr>
<tr class="memdesc:a95e477324284c1a1067b556ea9bff0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const <a class="el" href="namespace_eigen.html">Eigen</a> expression of the vector of generalized velocities for <code>this</code> mobilizer from a vector <code>v_array</code> of generalized velocities for the entire MultibodyTree model.  <a href="#a95e477324284c1a1067b556ea9bff0d7">More...</a><br /></td></tr>
<tr class="separator:a95e477324284c1a1067b556ea9bff0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25f0a62315bcdd5d61913a5f6373180"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; Eigen::Ref&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#ae25f0a62315bcdd5d61913a5f6373180">get_mutable_velocities_from_array</a> (<a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; v_array) const</td></tr>
<tr class="memdesc:ae25f0a62315bcdd5d61913a5f6373180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable version of <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a95e477324284c1a1067b556ea9bff0d7" title="Returns a const Eigen expression of the vector of generalized velocities for this mobilizer from a ve...">get_velocities_from_array()</a>.  <a href="#ae25f0a62315bcdd5d61913a5f6373180">More...</a><br /></td></tr>
<tr class="separator:ae25f0a62315bcdd5d61913a5f6373180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5ce8400c799f11a008add02545d26f"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a9d5ce8400c799f11a008add02545d26f">get_accelerations_from_array</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;vdot_array) const</td></tr>
<tr class="memdesc:a9d5ce8400c799f11a008add02545d26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const <a class="el" href="namespace_eigen.html">Eigen</a> expression of the vector of generalized accelerations for <code>this</code> mobilizer from a vector <code>vdot_array</code> of generalized accelerations for the entire MultibodyTree model.  <a href="#a9d5ce8400c799f11a008add02545d26f">More...</a><br /></td></tr>
<tr class="separator:a9d5ce8400c799f11a008add02545d26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d70a163baf7b36785ac6516a622968"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; Eigen::Ref&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#af6d70a163baf7b36785ac6516a622968">get_mutable_accelerations_from_array</a> (<a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; vdot_array) const</td></tr>
<tr class="memdesc:af6d70a163baf7b36785ac6516a622968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable version of <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a9d5ce8400c799f11a008add02545d26f" title="Returns a const Eigen expression of the vector of generalized accelerations for this mobilizer from a...">get_accelerations_from_array()</a>.  <a href="#af6d70a163baf7b36785ac6516a622968">More...</a><br /></td></tr>
<tr class="separator:af6d70a163baf7b36785ac6516a622968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bf9d5b5a16c2de21bd26a066d31c20"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#ae5bf9d5b5a16c2de21bd26a066d31c20">get_generalized_forces_from_array</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;tau_array) const</td></tr>
<tr class="memdesc:ae5bf9d5b5a16c2de21bd26a066d31c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const <a class="el" href="namespace_eigen.html">Eigen</a> expression of the vector of generalized forces for <code>this</code> mobilizer from a vector of generalized forces for the entire MultibodyTree model.  <a href="#ae5bf9d5b5a16c2de21bd26a066d31c20">More...</a><br /></td></tr>
<tr class="separator:ae5bf9d5b5a16c2de21bd26a066d31c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9561ae218bbd64bace25f031673ea8"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; Eigen::Ref&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#aae9561ae218bbd64bace25f031673ea8">get_mutable_generalized_forces_from_array</a> (<a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; tau_array) const</td></tr>
<tr class="memdesc:aae9561ae218bbd64bace25f031673ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable version of <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#ae5bf9d5b5a16c2de21bd26a066d31c20" title="Returns a const Eigen expression of the vector of generalized forces for this mobilizer from a vector...">get_generalized_forces_from_array()</a>.  <a href="#aae9561ae218bbd64bace25f031673ea8">More...</a><br /></td></tr>
<tr class="separator:aae9561ae218bbd64bace25f031673ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf90093f037e7c5eebb57b8298a08815"><td class="memTemplParams" colspan="2">template&lt;typename ToScalar &gt; </td></tr>
<tr class="memitem:abf90093f037e7c5eebb57b8298a08815"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&lt; ToScalar &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#abf90093f037e7c5eebb57b8298a08815">CloneToScalar</a> (const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; ToScalar &gt; &amp;cloned_tree) const</td></tr>
<tr class="memdesc:abf90093f037e7c5eebb57b8298a08815"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVI to <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#aab1dfad4c4ecbeb38c1642861e372216" title="Clones this Mobilizer (templated on T) to a mobilizer templated on double. ">DoCloneToScalar()</a> templated on the scalar type of the new clone to be created.  <a href="#abf90093f037e7c5eebb57b8298a08815">More...</a><br /></td></tr>
<tr class="separator:abf90093f037e7c5eebb57b8298a08815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2b80985a7a5d6f4e7dfb3cb117ffb8"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_body_node.html">internal::BodyNode</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#aef2b80985a7a5d6f4e7dfb3cb117ffb8">CreateBodyNode</a> (const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_body_node.html">internal::BodyNode</a>&lt; T &gt; *parent_node, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; *body, const <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&lt; T &gt; *mobilizer) const =0</td></tr>
<tr class="memdesc:aef2b80985a7a5d6f4e7dfb3cb117ffb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For MultibodyTree internal use only.  <a href="#aef2b80985a7a5d6f4e7dfb3cb117ffb8">More...</a><br /></td></tr>
<tr class="separator:aef2b80985a7a5d6f4e7dfb3cb117ffb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:aa6e480584087b38a6ab262c318677f41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#aa6e480584087b38a6ab262c318677f41">Mobilizer</a> (const <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a> &amp;)=delete</td></tr>
<tr class="separator:aa6e480584087b38a6ab262c318677f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae88d1acbce7e08de78fe051029f1c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a9ae88d1acbce7e08de78fe051029f1c8">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a> &amp;)=delete</td></tr>
<tr class="separator:a9ae88d1acbce7e08de78fe051029f1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf179b5c1328d17a41d9a31c01821e92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#abf179b5c1328d17a41d9a31c01821e92">Mobilizer</a> (<a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:abf179b5c1328d17a41d9a31c01821e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973e3098a8f916b64f625b6e1f6bc653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a973e3098a8f916b64f625b6e1f6bc653">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a973e3098a8f916b64f625b6e1f6bc653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods that define a Mobilizer</div></td></tr>
<tr class="memitem:a5aa27a24c2c9e5ddc38d771e455c3b88"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a5aa27a24c2c9e5ddc38d771e455c3b88">set_zero_state</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state) const =0</td></tr>
<tr class="memdesc:a5aa27a24c2c9e5ddc38d771e455c3b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code>state</code> to what will be considered to be the <em>zero</em> configuration for <code>this</code> mobilizer.  <a href="#a5aa27a24c2c9e5ddc38d771e455c3b88">More...</a><br /></td></tr>
<tr class="separator:a5aa27a24c2c9e5ddc38d771e455c3b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d21737dd8cda28722ab6a1ac38201e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#ac1d21737dd8cda28722ab6a1ac38201e">set_zero_configuration</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:ac1d21737dd8cda28722ab6a1ac38201e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state stored in <code>context</code> to a <em>zero configuration</em> as defined by <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a5aa27a24c2c9e5ddc38d771e455c3b88" title="Sets the state to what will be considered to be the zero configuration for this mobilizer. ">set_zero_state()</a>.  <a href="#ac1d21737dd8cda28722ab6a1ac38201e">More...</a><br /></td></tr>
<tr class="separator:ac1d21737dd8cda28722ab6a1ac38201e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e96fa796678267f386cafa2315e1302"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a3e96fa796678267f386cafa2315e1302">CalcAcrossMobilizerTransform</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;context) const =0</td></tr>
<tr class="memdesc:a3e96fa796678267f386cafa2315e1302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the across-mobilizer transform <code>X_FM(q)</code> between the inboard frame F and the outboard frame M as a function of the vector of generalized positions <code>q</code>.  <a href="#a3e96fa796678267f386cafa2315e1302">More...</a><br /></td></tr>
<tr class="separator:a3e96fa796678267f386cafa2315e1302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22309313c4735a8585e0f065d09abd60"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a22309313c4735a8585e0f065d09abd60">CalcAcrossMobilizerSpatialVelocity</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;v) const =0</td></tr>
<tr class="memdesc:a22309313c4735a8585e0f065d09abd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the across-mobilizer spatial velocity <code>V_FM(q, v)</code> of the outboard frame M in the inboard frame F.  <a href="#a22309313c4735a8585e0f065d09abd60">More...</a><br /></td></tr>
<tr class="separator:a22309313c4735a8585e0f065d09abd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271216ca6db7c7c8c57ec6f1607c91c4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a271216ca6db7c7c8c57ec6f1607c91c4">CalcAcrossMobilizerSpatialAcceleration</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;vdot) const =0</td></tr>
<tr class="memdesc:a271216ca6db7c7c8c57ec6f1607c91c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the across-mobilizer spatial accelerations <code>A_FM(q, v, v̇)</code> of the outboard frame M in the inboard frame F.  <a href="#a271216ca6db7c7c8c57ec6f1607c91c4">More...</a><br /></td></tr>
<tr class="separator:a271216ca6db7c7c8c57ec6f1607c91c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7795f7cf542298d92089b3f3e0007fcb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a7795f7cf542298d92089b3f3e0007fcb">ProjectSpatialForce</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html">SpatialForce</a>&lt; T &gt; &amp;F_Mo_F, Eigen::Ref&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; tau) const =0</td></tr>
<tr class="memdesc:a7795f7cf542298d92089b3f3e0007fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects the spatial force <code>F_Mo</code> on <code>this</code> mobilizer's outboard frame M onto the sub-space of motions spanned by the geometric Jacobian <code>H_FM(q)</code> to obtain the generalized forces <code>tau</code> (i.e.  <a href="#a7795f7cf542298d92089b3f3e0007fcb">More...</a><br /></td></tr>
<tr class="separator:a7795f7cf542298d92089b3f3e0007fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102742f11ab814a1e801552786f52e3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a102742f11ab814a1e801552786f52e3e">CalcNMatrix</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; N) const</td></tr>
<tr class="memdesc:a102742f11ab814a1e801552786f52e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the kinematic mapping matrix <code>N(q)</code> that maps generalized velocities for this mobilizer to time derivatives of the generalized positions for this mobilizer according to <code>q̇ = N(q)⋅v</code>.  <a href="#a102742f11ab814a1e801552786f52e3e">More...</a><br /></td></tr>
<tr class="separator:a102742f11ab814a1e801552786f52e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb1fc16ffbedec7ca4bcdbd61ed8466"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a3fb1fc16ffbedec7ca4bcdbd61ed8466">CalcNplusMatrix</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Nplus) const</td></tr>
<tr class="memdesc:a3fb1fc16ffbedec7ca4bcdbd61ed8466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the kinematic mapping matrix <code>N⁺(q)</code> that maps time derivatives of the generalized positions to generalized velocities according to <code>v = N⁺(q)⋅q̇</code>.  <a href="#a3fb1fc16ffbedec7ca4bcdbd61ed8466">More...</a><br /></td></tr>
<tr class="separator:a3fb1fc16ffbedec7ca4bcdbd61ed8466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbd64e78f3a522c007e242334223e93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a1dbd64e78f3a522c007e242334223e93">MapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;v, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; qdot) const =0</td></tr>
<tr class="memdesc:a1dbd64e78f3a522c007e242334223e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the kinematic mapping <code>q̇ = N(q)⋅v</code> between generalized velocities v and time derivatives of the generalized positions <code>qdot</code>.  <a href="#a1dbd64e78f3a522c007e242334223e93">More...</a><br /></td></tr>
<tr class="separator:a1dbd64e78f3a522c007e242334223e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2186b0940efa312260a78d9ae97cd645"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a2186b0940efa312260a78d9ae97cd645">MapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;qdot, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; v) const =0</td></tr>
<tr class="memdesc:a2186b0940efa312260a78d9ae97cd645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mapping <code>v = N⁺(q)⋅q̇</code> from time derivatives of the generalized positions <code>qdot</code> to generalized velocities v, where <code>N⁺(q)</code> is the left pseudo-inverse of <code>N(q)</code> defined by <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a1dbd64e78f3a522c007e242334223e93" title="Computes the kinematic mapping q̇ = N(q)⋅v between generalized velocities v and time derivatives of ...">MapVelocityToQDot()</a>.  <a href="#a2186b0940efa312260a78d9ae97cd645">More...</a><br /></td></tr>
<tr class="separator:a2186b0940efa312260a78d9ae97cd645"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac9a84f0da88933802af930064c8458eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#ac9a84f0da88933802af930064c8458eb">DoCalcNMatrix</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; N) const =0</td></tr>
<tr class="memdesc:ac9a84f0da88933802af930064c8458eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVI to <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a102742f11ab814a1e801552786f52e3e" title="Computes the kinematic mapping matrix N(q) that maps generalized velocities for this mobilizer to tim...">CalcNMatrix()</a>.  <a href="#ac9a84f0da88933802af930064c8458eb">More...</a><br /></td></tr>
<tr class="separator:ac9a84f0da88933802af930064c8458eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b83715e0998ec2de4ee4857e0aa693"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#af2b83715e0998ec2de4ee4857e0aa693">DoCalcNplusMatrix</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Nplus) const =0</td></tr>
<tr class="memdesc:af2b83715e0998ec2de4ee4857e0aa693"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVI to <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a3fb1fc16ffbedec7ca4bcdbd61ed8466" title="Computes the kinematic mapping matrix N⁺(q) that maps time derivatives of the generalized positions ...">CalcNplusMatrix()</a>.  <a href="#af2b83715e0998ec2de4ee4857e0aa693">More...</a><br /></td></tr>
<tr class="separator:af2b83715e0998ec2de4ee4857e0aa693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to make a clone templated on different scalar types.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The only const argument to these methods is the new MultibodyTree clone under construction, which is required to already own the clones of the inboard and outboard frames of the mobilizer being cloned. </p>
</div></td></tr>
<tr class="memitem:aab1dfad4c4ecbeb38c1642861e372216"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#aab1dfad4c4ecbeb38c1642861e372216">DoCloneToScalar</a> (const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;tree_clone) const =0</td></tr>
<tr class="memdesc:aab1dfad4c4ecbeb38c1642861e372216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this Mobilizer (templated on T) to a mobilizer templated on <code>double</code>.  <a href="#aab1dfad4c4ecbeb38c1642861e372216">More...</a><br /></td></tr>
<tr class="separator:aab1dfad4c4ecbeb38c1642861e372216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16130874c9a04d5273f3b492eae9ceac"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a16130874c9a04d5273f3b492eae9ceac">DoCloneToScalar</a> (const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &amp;tree_clone) const =0</td></tr>
<tr class="memdesc:a16130874c9a04d5273f3b492eae9ceac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this Mobilizer (templated on T) to a mobilizer templated on AutoDiffXd.  <a href="#a16130874c9a04d5273f3b492eae9ceac">More...</a><br /></td></tr>
<tr class="separator:a16130874c9a04d5273f3b492eae9ceac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::Mobilizer&lt; T &gt;</h3>

<p>Mobilizer is a fundamental object within Drake's multibody engine used to specify the allowed motions between two <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> objects within a MultibodyTree. </p>
<p>Specifying the allowed motions between two <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> objects effectively also specifies a kinematic relationship between the two bodies associated with those two frames. Consider the following example to build a simple pendulum system:</p>
<div class="fragment"><div class="line">MultibodyTree&lt;double&gt; model;</div><div class="line"><span class="comment">// ... Code here to setup quantities below as mass, com, X_BP, etc. ...</span></div><div class="line"><span class="keyword">const</span> Body&lt;double&gt;&amp; pendulum =</div><div class="line">  model.AddBody&lt;<a class="code" href="class_rigid_body.html">RigidBody</a>&gt;(SpatialInertia&lt;double&gt;(mass, com, unit_inertia));</div><div class="line"><span class="comment">// We will connect the pendulum body to the world frame using a</span></div><div class="line"><span class="comment">// RevoluteMobilizer. To do so we define a pin frame P rigidly attached to</span></div><div class="line"><span class="comment">// the pendulum body.</span></div><div class="line">FixedOffsetFrame&lt;double&gt;&amp; pin_frame =</div><div class="line">  model.AddFrame&lt;FixedOffsetFrame&gt;(</div><div class="line">    pendulum.body_frame(),</div><div class="line">    X_BP <span class="comment">/* pose of pin frame P in body frame B */</span>);</div><div class="line"><span class="comment">// The mobilizer connects the world frame and the pin frame effectively</span></div><div class="line"><span class="comment">// adding the single degree of freedom describing this system. In this</span></div><div class="line"><span class="comment">// regard, the the role of a mobilizer is equivalent but conceptually</span></div><div class="line"><span class="comment">// different than a set of constraints that effectively remove all degrees</span></div><div class="line"><span class="comment">// of freedom but the one permitting rotation about the z-axis.</span></div><div class="line"><span class="keyword">const</span> RevoluteMobilizer&lt;double&gt;&amp; revolute_mobilizer =</div><div class="line">  model.AddMobilizer&lt;RevoluteMobilizer&gt;(</div><div class="line">    model.world_frame(), <span class="comment">/* inboard frame */</span></div><div class="line">    pin_frame, <span class="comment">/* outboard frame */</span></div><div class="line">    Vector3d::UnitZ() <span class="comment">/* revolute axis in this case */</span>));</div></div><!-- fragment --><h3>Tree Structure</h3>
<p>A Mobilizer induces a tree structure within a MultibodyTree model, connecting an inboard (topologically closer to the world) frame to an outboard (topologically further from the world) frame. Every time a Mobilizer is added to a MultibodyTree (using the <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8886c79b1a00896934a25d70317f1033" title="Takes ownership of mobilizer and adds it to this MultibodyTree. ">MultibodyTree::AddMobilizer()</a> method), a number of degrees of freedom associated with the particular type of Mobilizer are added to the multibody system. In the example above for the single pendulum, adding a <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html" title="This Mobilizer allows two frames to rotate relatively to one another around an axis that is constant ...">RevoluteMobilizer</a> has two purposes:</p>
<ul>
<li>It defines the tree structure of the model. World is the inboard body while "pendulum" is the outboard body in the MultibodyTree.</li>
<li>It informs the MultibodyTree of the degrees of freedom granted by the revolute mobilizer between the two frames it connects.</li>
<li>It defines a permissible motion space spanned by the generalized coordinates introduced by the mobilizer.</li>
</ul>
<h3>Mathematical Description of a Mobilizer</h3>
<p>A Mobilizer describes the kinematics relationship between an inboard frame F and an outboard frame M, introducing an nq-dimensional vector of generalized coordinates q and an nv-dimensional vector of generalized velocities v. Notice that in general <code>nq != nv</code>, though <code>nq == nv</code> is a very common case. The kinematic relationships introduced by a Mobilizer are fully specified by, [Seth 2010]:</p>
<ul>
<li>X_FM(q): The pose of the outboard frame M as measured and expressed in the inboard frame F, as a function of the mobilizer's generalized positions. This pose is computed by <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a3e96fa796678267f386cafa2315e1302" title="Computes the across-mobilizer transform X_FM(q) between the inboard frame F and the outboard frame M ...">CalcAcrossMobilizerTransform()</a>.</li>
<li>H_FM(q): the geometric Jacobian matrix describing the relationship between generalized velocities <code>v ∈ ℝⁿᵛ</code> and the spatial velocity <code>V_FM ∈ M⁶</code>. This Jacobian can be thought of as the application: <code>v ∈ ℝⁿᵛ → M⁶: V_FM(q, v) = H_FM(q) * v</code>, where M⁶ is the vector space of "motion vectors" (be aware that while M⁶ is introduced in [Featherstone 2008, Ch. 2] spatial velocities in Drake are not Plücker vectors as in Featherstone's book). A Mobilizer implements this operator in the method <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a22309313c4735a8585e0f065d09abd60" title="Computes the across-mobilizer spatial velocity V_FM(q, v) of the outboard frame M in the inboard fram...">CalcAcrossMobilizerSpatialVelocity()</a>.</li>
<li>H_FMᵀ(q): The transpose of the geometric Jacobian <code>H_FM(q)</code> describing the relationship between the spatial force <code>F_Mo_F ∈ F⁶</code> and the generalized forces <code>tau ∈ ℝⁿᵛ</code>, where F⁶ is the vector space of "force vectors" (be aware that while F⁶ is introduced in [Featherstone 2008, Ch. 2] spatial forces in Drake are not Plücker vectors as in Featherstone's book.) This mathematical object can be thought of as the application: <code>F_Mo_F ∈ F⁶ → ℝⁿᵛ: tau = H_FMᵀ(q) * F_Mo_F</code>, where <code>Mo</code> is M's origin (see <a class="el" href="group__multibody__frames__and__bodies.html">Frames and Bodies</a> for the monogram notation in use.) A Mobilizer implements this operator in the method <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a7795f7cf542298d92089b3f3e0007fcb" title="Projects the spatial force F_Mo on this mobilizer&#39;s outboard frame M onto the sub-space of motions sp...">ProjectSpatialForce()</a>.</li>
<li>Hdot_FM(q, v): The time derivative of the Jacobian matrix involved in the computation of the spatial acceleration <code>A_FM(q, v, v̇)</code> between the F and M frames as the application: <code>v̇ ∈ ℝⁿᵛ → M⁶: A_FM(q, v, v̇) = H_FM(q) * v̇ + Ḣ_FM(q, v) * v</code>. A Mobilizer implements this application in <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a271216ca6db7c7c8c57ec6f1607c91c4" title="Computes the across-mobilizer spatial accelerations A_FM(q, v, v̇) of the outboard frame M in the inb...">CalcAcrossMobilizerSpatialAcceleration()</a>.</li>
<li>N(q): The kinematic coupling matrix describing the relationship between the rate of change of generalized coordinates and the generalized velocities by <code>q̇ = N(q)⋅v</code>, [Seth 2010]. N(q) is an <code>nq x nv</code> matrix. A Mobilizer implements this application in <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a1dbd64e78f3a522c007e242334223e93" title="Computes the kinematic mapping q̇ = N(q)⋅v between generalized velocities v and time derivatives of ...">MapVelocityToQDot()</a>.</li>
<li>N⁺(q): The left pseudo-inverse of <code>N(q)</code>. <code>N⁺(q)</code> can be used to invert the relationship <code>q̇ = N(q)⋅v</code> without residual error, provided that <code>q̇</code> is in the range space of <code>N(q)</code> (that is, if it <em>could</em> have been produced as <code>q̇ = N(q)⋅v</code> for some <code>v</code>). The application <code>v = N⁺(q)⋅q̇</code> is implemented in <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a2186b0940efa312260a78d9ae97cd645" title="Computes the mapping v = N⁺(q)⋅q̇ from time derivatives of the generalized positions qdot to genera...">MapQDotToVelocity()</a>.</li>
</ul>
<p>In general, <code>nv != nq</code>. As an example, consider a quaternion mobilizer that would allow frame M to move freely with respect to frame F. For such a mobilizer the generalized positions vector might contain a quaternion to describe rotations plus a position vector to describe translations. However, we might choose the angular velocity <code>w_FM</code> and the linear velocity <code>v_FM</code> as the generalized velocities (or more generally, the spatial velocity <code>V_FM</code>.) In such a case <code>nq = 7</code> (4 dofs for a quaternion plus 3 dofs for a position vector) and <code>nv = 6</code> (3 dofs for an angular velocity and 3 dofs for a linear velocity).</p>
<p>For a detailed discussion on the concept of a mobilizer please refer to [Seth 2010]. The Jacobian or "hinge" matrix <code>H_FM(q)</code> is introduced in [Jain 2010], though be aware that what [Jain 2010] calls the hinge matrix is the transpose of the Jacobian H_FM matrix here in Drake. For details in the monogram notation used above please refer to <a class="el" href="group__multibody__spatial__algebra.html">Spatial Algebra</a>.</p>
<p>Mobilizer is an abstract base class defining the minimum functionality that derived Mobilizer objects must implement in order to fully define the kinematic relationship between the two frames they connect. Geometric and analytical Jacobian matrices in the context of differential kinematics are described in [Sciavicco 2000].</p>
<h4>Relation between the analytical and geometric Jacobians</h4>
<p>The time derivative of the across-mobilizer transform <code>X_FM</code> is intimately related to the across-mobilizer spatial velocity <code>V_FM</code>. This relationship immediately implies a relationship between the analytical Jacobian <code>dX_FM/dq</code> and the geometric Jacobian matrix <code>H_FM</code>. The linear component of the spatial velocity <code>V_FM</code> relates to the time derivative of <code>X_FM</code> by: </p><pre>
  v_FM = V_FM.translational() = dp_FM/dt = Xdot_FM.translational()
</pre><p> where <code>p_FM = X_FM.translational()</code> and <code>Xdot_FM = dX_FM/dt</code>. The time derivative of <code>p_FM</code> can be rewritten as: </p><pre>
  dp_FM/dt = dp_FM/dq * N(q) * v = Hv_FM * v
</pre><p> where <code>Hv_FM</code> denotes the last three rows in <code>H_FM</code> related with the translational component of the Jacobian matrix Therefore: </p><pre>
  Hv_FM = dp_FM/dq(q) * N(q)
</pre><p>Similarly, for the rotational component: </p><pre>
 dR_FM/dt = Xdot_FM.linear() = [w_FM] * R_FM = [Hw_FM * v] * R_FM
</pre><p> where <code>[w_FM]</code> is the cross product matrix of the across-mobilizer angular velocity <code>w_FM</code>, <code>R_FM</code> is the orientation of M in F, and <code>Hw_FM</code> corresponds to the first three rows in <code>H_FM</code> related to the angular component of the geometric Jacobian matrix. The time derivative of the orientation <code>R_FM</code> can be expressed in terms of the analytic Jacobian of <code>R_FM</code> as: </p><pre>
  dR_FM/dt = dR_FM/dq * N(q) * v
</pre><p> These last two equations show that the angular components of the Jacobian matrix <code>Hw_FM</code> are directly related to the gradients of the rotation matrix <code>R_FM</code>. This relationhip is: </p><pre>
  [Hwi_FM(q)] * R_FM(q) = dR_FM/dqi(q) * N(q)
</pre><p> corresponding to the i-th generalized position <code>qi</code> where <code>Hwi_FM(q)</code> is the i-th column of <code>Hw_FM(q)</code> and <code>dR_FM/dqi(q)</code> is the partial derivative of <code>R_FM</code> with respect to the i-th generalized coordinate for this mobilizer.</p>
<h4>Active forces and power</h4>
<p>The power generated by a mobilizer can be computed in two equivalent ways. That is, the power can be computed in terms of the spatial force <code>F_Mo</code> and the spatial velocity <code>V_FM</code> as: </p><pre>
  P = F_Moᵀ * V_FM
</pre><p> or in terms of the generalized forces <code>tau = H_FMᵀ(q) * F_Mo</code> and the generalized velocities v as: </p><pre>
  P = tauᵀ * v
</pre><p> Notice that spatial forces in the null space of <code>H_FM(q)</code> do not perform any work. Since the result from the previous two expressions must be equal, the Jacobian operator <code>H_FM(q)</code> and the transpose operator <code>H_FMᵀ(q)</code> are constrained by: </p><pre>
  (H_FMᵀ(q) * F) * v = Fᵀ * (H_FM(q) * v), ∀ v ∈ ℝⁿᵛ ∧ `F ∈ F⁶`
</pre><p> Therefore, this enforces a relationship to the operations implemented by <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a22309313c4735a8585e0f065d09abd60" title="Computes the across-mobilizer spatial velocity V_FM(q, v) of the outboard frame M in the inboard fram...">CalcAcrossMobilizerSpatialVelocity()</a> and <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a7795f7cf542298d92089b3f3e0007fcb" title="Projects the spatial force F_Mo on this mobilizer&#39;s outboard frame M onto the sub-space of motions sp...">ProjectSpatialForce()</a> for any Mobilizer object.</p>
<ul>
<li>[Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis and algorithms. Springer Science &amp; Business Media.</li>
<li>[Seth 2010] Seth, A., Sherman, M., Eastman, P. and Delp, S., 2010. Minimal formulation of joint motion for biomechanisms. Nonlinear dynamics, 62(1), pp.291-303.</li>
<li>[Sciavicco 2000] Sciavicco, L. and Siciliano, B., 2000. Modelling and control of robot manipulators, 2nd Edn. Springer.</li>
<li>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics algorithms. Springer.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type. Must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa6e480584087b38a6ab262c318677f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e480584087b38a6ab262c318677f41">&#9670;&nbsp;</a></span>Mobilizer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf179b5c1328d17a41d9a31c01821e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf179b5c1328d17a41d9a31c01821e92">&#9670;&nbsp;</a></span>Mobilizer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88583065bb66ffdbc3445640719d5cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88583065bb66ffdbc3445640719d5cc0">&#9670;&nbsp;</a></span>Mobilizer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inboard_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outboard_frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The minimum amount of information that we need to define a Mobilizer is the knowledge of the inboard and outboard frames it connects. </p>
<p>Subclasses of Mobilizer are therefore required to provide this information in their respective constructors. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>inboard_frame</code> and <code>outboard_frame</code> reference the same frame object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a271216ca6db7c7c8c57ec6f1607c91c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271216ca6db7c7c8c57ec6f1607c91c4">&#9670;&nbsp;</a></span>CalcAcrossMobilizerSpatialAcceleration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt;T&gt; CalcAcrossMobilizerSpatialAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the across-mobilizer spatial accelerations <code>A_FM(q, v, v̇)</code> of the outboard frame M in the inboard frame F. </p>
<p>This method can be thought of as the application of the operation <code>v̇ ∈ ℝⁿᵛ → M⁶: A_FM(q, v, v̇) = H_FM(q) * v̇ + Ḣ_FM(q) * v</code>, where <code>nv</code> is the number of generalized velocities of this mobilizer (see <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a6aca305be7e0dbd081a568c1f73d3848" title="Returns the number of generalized velocities granted by this mobilizer. ">num_velocities()</a>) and M⁶ is the vector space of "motion vectors" (be aware that while M⁶ is introduced in [Featherstone 2008, Ch. 2] spatial vectors in Drake are not Plücker vectors as in Featherstone's book). Therefore, we say this method is in its <em>operator form</em>; the Jacobian matrix <code>H_FM(q)</code> is not explicitly formed. This method aborts in Debug builds if the dimension of the input vector of generalized accelerations has a size different from <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a6aca305be7e0dbd081a568c1f73d3848" title="Returns the number of generalized velocities granted by this mobilizer. ">num_velocities()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context of the parent tree that owns this mobilizer. This mobilizer's generalized positions q and generalized velocities v are taken from this context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vdot</td><td>The vector of generalized velocities' time derivatives v̇. It must live in ℝⁿᵛ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">A_FM</td><td>The across-mobilizer spatial acceleration of the outboard frame M measured and expressed in the inboard frame F. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_space_x_y_z_mobilizer.html#a987d7525c960c6aa39641cb5712bf5b8">SpaceXYZMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_mobilizer.html#a987d7525c960c6aa39641cb5712bf5b8">QuaternionFloatingMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html#a987d7525c960c6aa39641cb5712bf5b8">RevoluteMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_prismatic_mobilizer.html#ad523ab8836f0bf99220c6959aab817c2">PrismaticMobilizer&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_weld_mobilizer.html#ad523ab8836f0bf99220c6959aab817c2">WeldMobilizer&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a22309313c4735a8585e0f065d09abd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22309313c4735a8585e0f065d09abd60">&#9670;&nbsp;</a></span>CalcAcrossMobilizerSpatialVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt;T&gt; CalcAcrossMobilizerSpatialVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the across-mobilizer spatial velocity <code>V_FM(q, v)</code> of the outboard frame M in the inboard frame F. </p>
<p>This method can be thought of as the application of the operator <code>H_FM(q)</code> to the input vector of generalized velocities <code>v</code>, i.e. the output of this method is the application <code>v ∈ ℝⁿᵛ → M⁶: V_FM(q, v) = H_FM(q) * v</code>, where <code>nv</code> is the number of generalized velocities of this mobilizer (see <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a6aca305be7e0dbd081a568c1f73d3848" title="Returns the number of generalized velocities granted by this mobilizer. ">num_velocities()</a>) and M⁶ is the vector space of "motion vectors" (be aware that while M⁶ is introduced in [Featherstone 2008, Ch. 2] spatial velocities in Drake are not Plücker vectors as in Featherstone's book). Therefore we say this method is the <em>operator form</em> of the Jacobian matrix <code>H_FM(q)</code>. This method aborts in Debug builds if the dimension of the input vector of generalized velocities has a size different from <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a6aca305be7e0dbd081a568c1f73d3848" title="Returns the number of generalized velocities granted by this mobilizer. ">num_velocities()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context of the parent tree that owns this mobilizer. This mobilizer's generalized positions q are inferred from this context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A vector of generalized velocities. It must live in ℝⁿᵛ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">V_FM</td><td>The across-mobilizer spatial velocity of the outboard frame M measured and expressed in the inboard frame F. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_space_x_y_z_mobilizer.html#acffa635ba7934bb240666a3e84cb1e7c">SpaceXYZMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_mobilizer.html#acffa635ba7934bb240666a3e84cb1e7c">QuaternionFloatingMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html#acffa635ba7934bb240666a3e84cb1e7c">RevoluteMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_prismatic_mobilizer.html#a8dfc7c889736d44cd4ba8a713b1e7d81">PrismaticMobilizer&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_weld_mobilizer.html#a8dfc7c889736d44cd4ba8a713b1e7d81">WeldMobilizer&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a3e96fa796678267f386cafa2315e1302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e96fa796678267f386cafa2315e1302">&#9670;&nbsp;</a></span>CalcAcrossMobilizerTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt;T&gt; CalcAcrossMobilizerTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the across-mobilizer transform <code>X_FM(q)</code> between the inboard frame F and the outboard frame M as a function of the vector of generalized positions <code>q</code>. </p>
<p>Mobilizer subclasses implementing this method can retrieve the fixed-size vector of generalized positions for <code>this</code> mobilizer from <code>context</code> with:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> q = this-&gt;get_positions(context);</div></div><!-- fragment --><p>Additionally, <code>context</code> can provide any other parameters the mobilizer could depend on. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_space_x_y_z_mobilizer.html#aebd5011f8f1bb1144fb6792177e53549">SpaceXYZMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_mobilizer.html#aebd5011f8f1bb1144fb6792177e53549">QuaternionFloatingMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html#aebd5011f8f1bb1144fb6792177e53549">RevoluteMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_prismatic_mobilizer.html#a667c5272b6a6616adfbd4f0cc29002d9">PrismaticMobilizer&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_weld_mobilizer.html#a667c5272b6a6616adfbd4f0cc29002d9">WeldMobilizer&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a102742f11ab814a1e801552786f52e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102742f11ab814a1e801552786f52e3e">&#9670;&nbsp;</a></span>CalcNMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcNMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the kinematic mapping matrix <code>N(q)</code> that maps generalized velocities for this mobilizer to time derivatives of the generalized positions for this mobilizer according to <code>q̇ = N(q)⋅v</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context for the parent tree that owns this mobilizer storing the generalized positions q. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>The kinematic mapping matrix <code>N(q)</code>. On input it must have size <code>nq x nv</code> with nq and nv the number of generalized positions and the number of generalized velocities for this mobilizer, respectively. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a1dbd64e78f3a522c007e242334223e93" title="Computes the kinematic mapping q̇ = N(q)⋅v between generalized velocities v and time derivatives of ...">MapVelocityToQDot()</a>. </dd></dl>

</div>
</div>
<a id="a3fb1fc16ffbedec7ca4bcdbd61ed8466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb1fc16ffbedec7ca4bcdbd61ed8466">&#9670;&nbsp;</a></span>CalcNplusMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcNplusMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Nplus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the kinematic mapping matrix <code>N⁺(q)</code> that maps time derivatives of the generalized positions to generalized velocities according to <code>v = N⁺(q)⋅q̇</code>. </p>
<p><code>N⁺(q)</code> is the left pseudoinverse of the kinematic mapping <code>N(q)</code>, see <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a102742f11ab814a1e801552786f52e3e" title="Computes the kinematic mapping matrix N(q) that maps generalized velocities for this mobilizer to tim...">CalcNMatrix()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context for the parent tree that owns this mobilizer storing the generalized positions q. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Nplus</td><td>The kinematic mapping matrix <code>N⁺(q)</code>. On input it must have size <code>nv x nq</code> with nq the number of generalized positions and nv the number of generalized velocities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a1dbd64e78f3a522c007e242334223e93" title="Computes the kinematic mapping q̇ = N(q)⋅v between generalized velocities v and time derivatives of ...">MapVelocityToQDot()</a>. </dd></dl>

</div>
</div>
<a id="abf90093f037e7c5eebb57b8298a08815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf90093f037e7c5eebb57b8298a08815">&#9670;&nbsp;</a></span>CloneToScalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&lt;ToScalar&gt; &gt; CloneToScalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; ToScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloned_tree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NVI to <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#aab1dfad4c4ecbeb38c1642861e372216" title="Clones this Mobilizer (templated on T) to a mobilizer templated on double. ">DoCloneToScalar()</a> templated on the scalar type of the new clone to be created. </p>
<p>This method is mostly intended to be called by <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aa867ed6fe063cc08113ff54918da55a7" title="Creates a deep copy of this MultibodyTree templated on the scalar type ToScalar. ">MultibodyTree::CloneToScalar()</a>. Most users should not call this clone method directly but rather clone the entire parent MultibodyTree if needed. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aa867ed6fe063cc08113ff54918da55a7" title="Creates a deep copy of this MultibodyTree templated on the scalar type ToScalar. ">MultibodyTree::CloneToScalar()</a> </dd></dl>

</div>
</div>
<a id="aef2b80985a7a5d6f4e7dfb3cb117ffb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2b80985a7a5d6f4e7dfb3cb117ffb8">&#9670;&nbsp;</a></span>CreateBodyNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classdrake_1_1multibody_1_1internal_1_1_body_node.html">internal::BodyNode</a>&lt;T&gt; &gt; CreateBodyNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_body_node.html">internal::BodyNode</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>parent_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>mobilizer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For MultibodyTree internal use only. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#ad720dcf409edffcb9439b70de11126a3">MobilizerImpl&lt; T, compile_time_num_positions, compile_time_num_velocities &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#ad720dcf409edffcb9439b70de11126a3">MobilizerImpl&lt; T, 0, 0 &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#ad720dcf409edffcb9439b70de11126a3">MobilizerImpl&lt; T, 7, 6 &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#ad720dcf409edffcb9439b70de11126a3">MobilizerImpl&lt; T, 1, 1 &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#ad720dcf409edffcb9439b70de11126a3">MobilizerImpl&lt; T, 2, 2 &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#ad720dcf409edffcb9439b70de11126a3">MobilizerImpl&lt; T, 3, 3 &gt;</a>.</p>

</div>
</div>
<a id="ac9a84f0da88933802af930064c8458eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a84f0da88933802af930064c8458eb">&#9670;&nbsp;</a></span>DoCalcNMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoCalcNMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NVI to <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a102742f11ab814a1e801552786f52e3e" title="Computes the kinematic mapping matrix N(q) that maps generalized velocities for this mobilizer to tim...">CalcNMatrix()</a>. </p>
<p>Implementations can safely assume that N is not the nullptr and that N has the proper size. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_space_x_y_z_mobilizer.html#a1f045d6c86930bffb9e99082f85c75fb">SpaceXYZMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_mobilizer.html#a1f045d6c86930bffb9e99082f85c75fb">QuaternionFloatingMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_prismatic_mobilizer.html#a1f045d6c86930bffb9e99082f85c75fb">PrismaticMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html#a1f045d6c86930bffb9e99082f85c75fb">RevoluteMobilizer&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_weld_mobilizer.html#a1f045d6c86930bffb9e99082f85c75fb">WeldMobilizer&lt; T &gt;</a>.</p>

</div>
</div>
<a id="af2b83715e0998ec2de4ee4857e0aa693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b83715e0998ec2de4ee4857e0aa693">&#9670;&nbsp;</a></span>DoCalcNplusMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoCalcNplusMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Nplus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NVI to <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a3fb1fc16ffbedec7ca4bcdbd61ed8466" title="Computes the kinematic mapping matrix N⁺(q) that maps time derivatives of the generalized positions ...">CalcNplusMatrix()</a>. </p>
<p>Implementations can safely assume that Nplus is not the nullptr and that Nplus has the proper size. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_space_x_y_z_mobilizer.html#a0e6484da7cbb763b61a9f386ba67a124">SpaceXYZMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_mobilizer.html#a0e6484da7cbb763b61a9f386ba67a124">QuaternionFloatingMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_prismatic_mobilizer.html#a0e6484da7cbb763b61a9f386ba67a124">PrismaticMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html#a0e6484da7cbb763b61a9f386ba67a124">RevoluteMobilizer&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_weld_mobilizer.html#a0e6484da7cbb763b61a9f386ba67a124">WeldMobilizer&lt; T &gt;</a>.</p>

</div>
</div>
<a id="aab1dfad4c4ecbeb38c1642861e372216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1dfad4c4ecbeb38c1642861e372216">&#9670;&nbsp;</a></span>DoCloneToScalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; DoCloneToScalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree_clone</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones this Mobilizer (templated on T) to a mobilizer templated on <code>double</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Inboard and outboard frames for this mobilizer already have a clone in <code>tree_clone</code>. </dd></dl>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_space_x_y_z_mobilizer.html#a094d5acccca2eb1ec18b9b5275d1e84f">SpaceXYZMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_mobilizer.html#a094d5acccca2eb1ec18b9b5275d1e84f">QuaternionFloatingMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_prismatic_mobilizer.html#a5e64ff0108636b8cef6a7be88d1fbe39">PrismaticMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html#a094d5acccca2eb1ec18b9b5275d1e84f">RevoluteMobilizer&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_weld_mobilizer.html#a5e64ff0108636b8cef6a7be88d1fbe39">WeldMobilizer&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a16130874c9a04d5273f3b492eae9ceac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16130874c9a04d5273f3b492eae9ceac">&#9670;&nbsp;</a></span>DoCloneToScalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&lt;<a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>&gt; &gt; DoCloneToScalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree_clone</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones this Mobilizer (templated on T) to a mobilizer templated on AutoDiffXd. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Inboard and outboard frames for this mobilizer already have a clone in <code>tree_clone</code>. </dd></dl>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_space_x_y_z_mobilizer.html#aefbca07b6a33dfe1f97d8f2fb880ffb1">SpaceXYZMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_mobilizer.html#aefbca07b6a33dfe1f97d8f2fb880ffb1">QuaternionFloatingMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_prismatic_mobilizer.html#ae98faca0d2b3d73a6e986f6838fc6446">PrismaticMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html#aefbca07b6a33dfe1f97d8f2fb880ffb1">RevoluteMobilizer&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_weld_mobilizer.html#ae98faca0d2b3d73a6e986f6838fc6446">WeldMobilizer&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a9d5ce8400c799f11a008add02545d26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5ce8400c799f11a008add02545d26f">&#9670;&nbsp;</a></span>get_accelerations_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const Eigen::Ref&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; &gt; get_accelerations_from_array </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vdot_array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const <a class="el" href="namespace_eigen.html">Eigen</a> expression of the vector of generalized accelerations for <code>this</code> mobilizer from a vector <code>vdot_array</code> of generalized accelerations for the entire MultibodyTree model. </p>
<p>This method aborts if the input array is not of size <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ae0163ac0976659d811e3337647ff0313" title="Returns the number of generalized velocities of the model. ">MultibodyTree::num_velocities()</a>. </p>

</div>
</div>
<a id="ae5bf9d5b5a16c2de21bd26a066d31c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bf9d5b5a16c2de21bd26a066d31c20">&#9670;&nbsp;</a></span>get_generalized_forces_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const Eigen::Ref&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; &gt; get_generalized_forces_from_array </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tau_array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const <a class="el" href="namespace_eigen.html">Eigen</a> expression of the vector of generalized forces for <code>this</code> mobilizer from a vector of generalized forces for the entire MultibodyTree model. </p>
<p>This method aborts if the input array is not of size <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ae0163ac0976659d811e3337647ff0313" title="Returns the number of generalized velocities of the model. ">MultibodyTree::num_velocities()</a>. </p>

</div>
</div>
<a id="af6d70a163baf7b36785ac6516a622968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d70a163baf7b36785ac6516a622968">&#9670;&nbsp;</a></span>get_mutable_accelerations_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;Eigen::Ref&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; &gt; get_mutable_accelerations_from_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>vdot_array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutable version of <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a9d5ce8400c799f11a008add02545d26f" title="Returns a const Eigen expression of the vector of generalized accelerations for this mobilizer from a...">get_accelerations_from_array()</a>. </p>

</div>
</div>
<a id="aae9561ae218bbd64bace25f031673ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9561ae218bbd64bace25f031673ea8">&#9670;&nbsp;</a></span>get_mutable_generalized_forces_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;Eigen::Ref&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; &gt; get_mutable_generalized_forces_from_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>tau_array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutable version of <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#ae5bf9d5b5a16c2de21bd26a066d31c20" title="Returns a const Eigen expression of the vector of generalized forces for this mobilizer from a vector...">get_generalized_forces_from_array()</a>. </p>

</div>
</div>
<a id="a166fd80c1944c6ed3d0058681bdeebf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166fd80c1944c6ed3d0058681bdeebf9">&#9670;&nbsp;</a></span>get_mutable_positions_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;Eigen::Ref&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; &gt; get_mutable_positions_from_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>q_array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutable version of <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#aa11436315170be634a01332980e9fc38" title="Returns a const Eigen expression of the vector of generalized positions for this mobilizer from a vec...">get_positions_from_array()</a>. </p>

</div>
</div>
<a id="ae25f0a62315bcdd5d61913a5f6373180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25f0a62315bcdd5d61913a5f6373180">&#9670;&nbsp;</a></span>get_mutable_velocities_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;Eigen::Ref&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; &gt; get_mutable_velocities_from_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>v_array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutable version of <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a95e477324284c1a1067b556ea9bff0d7" title="Returns a const Eigen expression of the vector of generalized velocities for this mobilizer from a ve...">get_velocities_from_array()</a>. </p>

</div>
</div>
<a id="aa11436315170be634a01332980e9fc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11436315170be634a01332980e9fc38">&#9670;&nbsp;</a></span>get_positions_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const Eigen::Ref&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; &gt; get_positions_from_array </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>q_array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const <a class="el" href="namespace_eigen.html">Eigen</a> expression of the vector of generalized positions for <code>this</code> mobilizer from a vector <code>q_array</code> of generalized positions for the entire MultibodyTree model. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>q_array</code> is of size <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of generalized positions of the model. ">MultibodyTree::num_positions()</a>. </dd></dl>

</div>
</div>
<a id="a6c8aac4909224becd506c5ff60de2c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8aac4909224becd506c5ff60de2c6c">&#9670;&nbsp;</a></span>get_topology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdrake_1_1multibody_1_1_mobilizer_topology.html">MobilizerTopology</a>&amp; get_topology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the topology information for this mobilizer. </p>
<p>Users should not need to call this method since <a class="el" href="structdrake_1_1multibody_1_1_mobilizer_topology.html" title="Data structure to store the topological information associated with a Mobilizer object. ">MobilizerTopology</a> is an internal bookkeeping detail. </p>

</div>
</div>
<a id="a95e477324284c1a1067b556ea9bff0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e477324284c1a1067b556ea9bff0d7">&#9670;&nbsp;</a></span>get_velocities_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const Eigen::Ref&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; &gt; get_velocities_from_array </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v_array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const <a class="el" href="namespace_eigen.html">Eigen</a> expression of the vector of generalized velocities for <code>this</code> mobilizer from a vector <code>v_array</code> of generalized velocities for the entire MultibodyTree model. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>v_array</code> is of size <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#ae0163ac0976659d811e3337647ff0313" title="Returns the number of generalized velocities of the model. ">MultibodyTree::num_velocities()</a>. </dd></dl>

</div>
</div>
<a id="ab3404876c6666380c6f8a6be1e271b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3404876c6666380c6f8a6be1e271b9e">&#9670;&nbsp;</a></span>inboard_body()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;&amp; inboard_body </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the body associated with <code>this</code> mobilizer's inboard frame. </p>

</div>
</div>
<a id="a6d9e71c282b333033aca747fe62ca73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9e71c282b333033aca747fe62ca73a">&#9670;&nbsp;</a></span>inboard_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;T&gt;&amp; inboard_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the inboard frame. </p>

</div>
</div>
<a id="a2186b0940efa312260a78d9ae97cd645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2186b0940efa312260a78d9ae97cd645">&#9670;&nbsp;</a></span>MapQDotToVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MapQDotToVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mapping <code>v = N⁺(q)⋅q̇</code> from time derivatives of the generalized positions <code>qdot</code> to generalized velocities v, where <code>N⁺(q)</code> is the left pseudo-inverse of <code>N(q)</code> defined by <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a1dbd64e78f3a522c007e242334223e93" title="Computes the kinematic mapping q̇ = N(q)⋅v between generalized velocities v and time derivatives of ...">MapVelocityToQDot()</a>. </p>
<p>The generalized positions vector is stored in <code>context</code>. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_space_x_y_z_mobilizer.html#a9b3f8e222f0f86dc9ea56d5307061dbc">SpaceXYZMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_mobilizer.html#a9b3f8e222f0f86dc9ea56d5307061dbc">QuaternionFloatingMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_prismatic_mobilizer.html#a05ac85da34bf06df02f1c87d86652311">PrismaticMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html#a9b3f8e222f0f86dc9ea56d5307061dbc">RevoluteMobilizer&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_weld_mobilizer.html#a05ac85da34bf06df02f1c87d86652311">WeldMobilizer&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a1dbd64e78f3a522c007e242334223e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbd64e78f3a522c007e242334223e93">&#9670;&nbsp;</a></span>MapVelocityToQDot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MapVelocityToQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the kinematic mapping <code>q̇ = N(q)⋅v</code> between generalized velocities v and time derivatives of the generalized positions <code>qdot</code>. </p>
<p>The generalized positions vector is stored in <code>context</code>. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_space_x_y_z_mobilizer.html#a454d7d787d38bc132c75ce36217169ea">SpaceXYZMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_mobilizer.html#a454d7d787d38bc132c75ce36217169ea">QuaternionFloatingMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html#a454d7d787d38bc132c75ce36217169ea">RevoluteMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_prismatic_mobilizer.html#a809b7e57a979541cb075a4695f0bce7d">PrismaticMobilizer&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_weld_mobilizer.html#a809b7e57a979541cb075a4695f0bce7d">WeldMobilizer&lt; T &gt;</a>.</p>

</div>
</div>
<a id="addc3be43d9fe873001c79fcaada202e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc3be43d9fe873001c79fcaada202e3">&#9670;&nbsp;</a></span>num_positions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classint.html">int</a> num_positions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of generalized coordinates granted by this mobilizer. </p>
<p>As an example, consider <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html" title="This Mobilizer allows two frames to rotate relatively to one another around an axis that is constant ...">RevoluteMobilizer</a>, for which <code><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#addc3be43d9fe873001c79fcaada202e3" title="Returns the number of generalized coordinates granted by this mobilizer. ">num_positions()</a> == 1</code> since <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html" title="This Mobilizer allows two frames to rotate relatively to one another around an axis that is constant ...">RevoluteMobilizer</a> adds a single generalized coordinate representing the rotational degree of freedom about a given axis between the inboard and outboard frames. Another example would be a 6 DOF "free" mobilizer internally using a quaternion representation to parameterize free rotations and a position vector to parameterize free translations; this method would return 7 (a quaternion plus a position vector). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a6aca305be7e0dbd081a568c1f73d3848" title="Returns the number of generalized velocities granted by this mobilizer. ">num_velocities()</a> </dd></dl>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#a1679c3151f11e68426d967bb83641e7b">MobilizerImpl&lt; T, compile_time_num_positions, compile_time_num_velocities &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#a1679c3151f11e68426d967bb83641e7b">MobilizerImpl&lt; T, 0, 0 &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#a1679c3151f11e68426d967bb83641e7b">MobilizerImpl&lt; T, 7, 6 &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#a1679c3151f11e68426d967bb83641e7b">MobilizerImpl&lt; T, 1, 1 &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#a1679c3151f11e68426d967bb83641e7b">MobilizerImpl&lt; T, 2, 2 &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#a1679c3151f11e68426d967bb83641e7b">MobilizerImpl&lt; T, 3, 3 &gt;</a>.</p>

</div>
</div>
<a id="a6aca305be7e0dbd081a568c1f73d3848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aca305be7e0dbd081a568c1f73d3848">&#9670;&nbsp;</a></span>num_velocities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classint.html">int</a> num_velocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of generalized velocities granted by this mobilizer. </p>
<p>Given that all physics occurs in the generalized velocities space, the number of generalized velocities exactly matches the number of degrees of freedom granted by the mobilizer. As an example, consider <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html" title="This Mobilizer allows two frames to rotate relatively to one another around an axis that is constant ...">RevoluteMobilizer</a>, for which <code><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a6aca305be7e0dbd081a568c1f73d3848" title="Returns the number of generalized velocities granted by this mobilizer. ">num_velocities()</a> == 1</code> since for <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html" title="This Mobilizer allows two frames to rotate relatively to one another around an axis that is constant ...">RevoluteMobilizer</a> its one and only generalized velocity describes the magnitude of the angular velocity about a given axis between the inboard and outboard frames. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#addc3be43d9fe873001c79fcaada202e3" title="Returns the number of generalized coordinates granted by this mobilizer. ">num_positions()</a> </dd></dl>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#ac47f9ed86739416e02d8d4d490afe59b">MobilizerImpl&lt; T, compile_time_num_positions, compile_time_num_velocities &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#ac47f9ed86739416e02d8d4d490afe59b">MobilizerImpl&lt; T, 0, 0 &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#ac47f9ed86739416e02d8d4d490afe59b">MobilizerImpl&lt; T, 7, 6 &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#ac47f9ed86739416e02d8d4d490afe59b">MobilizerImpl&lt; T, 1, 1 &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#ac47f9ed86739416e02d8d4d490afe59b">MobilizerImpl&lt; T, 2, 2 &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_mobilizer_impl.html#ac47f9ed86739416e02d8d4d490afe59b">MobilizerImpl&lt; T, 3, 3 &gt;</a>.</p>

</div>
</div>
<a id="a973e3098a8f916b64f625b6e1f6bc653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973e3098a8f916b64f625b6e1f6bc653">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ae88d1acbce7e08de78fe051029f1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae88d1acbce7e08de78fe051029f1c8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad26c8aff25bb56c2343cba3275c4c51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26c8aff25bb56c2343cba3275c4c51e">&#9670;&nbsp;</a></span>outboard_body()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;&amp; outboard_body </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the body associated with <code>this</code> mobilizer's outboard frame. </p>

</div>
</div>
<a id="a1d58f258a467a0ab7a593f1838b64bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d58f258a467a0ab7a593f1838b64bf6">&#9670;&nbsp;</a></span>outboard_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;T&gt;&amp; outboard_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the outboard frame. </p>

</div>
</div>
<a id="a86d0ae62c51f7e6b183e79f7e9e05b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d0ae62c51f7e6b183e79f7e9e05b91">&#9670;&nbsp;</a></span>position_start_in_q()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> position_start_in_q </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index to the first generalized position for this mobilizer within the vector q of generalized positions for the full multibody system. </p>

</div>
</div>
<a id="a7795f7cf542298d92089b3f3e0007fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7795f7cf542298d92089b3f3e0007fcb">&#9670;&nbsp;</a></span>ProjectSpatialForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ProjectSpatialForce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_context.html">MultibodyTreeContext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html">SpatialForce</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_Mo_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Projects the spatial force <code>F_Mo</code> on <code>this</code> mobilizer's outboard frame M onto the sub-space of motions spanned by the geometric Jacobian <code>H_FM(q)</code> to obtain the generalized forces <code>tau</code> (i.e. </p>
<p>the active components of <code>F_Mo</code>). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a22309313c4735a8585e0f065d09abd60" title="Computes the across-mobilizer spatial velocity V_FM(q, v) of the outboard frame M in the inboard fram...">CalcAcrossMobilizerSpatialVelocity()</a> and this class' documentation for the definition of the geometric Jacobian <code>H_FM(q)</code>.</dd></dl>
<p>This method can be thought of as the application of the transpose operator <code>H_FMᵀ(q)</code> to the input spatial force <code>F_Mo_F</code>, i.e. the output of this method is the application <code>F_Mo_F ∈ F⁶ → ℝⁿᵛ: tau = H_FMᵀ(q) * F_Mo_F</code>, where <code>nv</code> is the number of generalized velocities of this mobilizer (see <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a6aca305be7e0dbd081a568c1f73d3848" title="Returns the number of generalized velocities granted by this mobilizer. ">num_velocities()</a>) and F⁶ is the vector space of "force vectors" (be aware that while F⁶ is introduced in [Featherstone 2008, Ch. 2] spatial forces in Drake are not Plücker vectors as in Featherstone's book). Therefore we say this method is the <em>operator form</em> of the Jacobian matrix transpose <code>H_FMᵀ(q)</code>. This method aborts in Debug builds if the dimension of the output vector of generalized forces has a size different from <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a6aca305be7e0dbd081a568c1f73d3848" title="Returns the number of generalized velocities granted by this mobilizer. ">num_velocities()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context of the parent tree that owns this mobilizer. This mobilizer's generalized positions q are stored in this context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F_Mo_F</td><td>A <a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html" title="This class is used to represent a spatial force (also called a wrench) that combines both rotational ...">SpatialForce</a> applied at <code>this</code> mobilizer's outboard frame origin <code>Mo</code>, expressed in the inboard frame F. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">tau</td><td>The vector of generalized forces. It must live in ℝⁿᵛ. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_space_x_y_z_mobilizer.html#a3b491142ba7765400e42e6bc24b39240">SpaceXYZMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_mobilizer.html#a3b491142ba7765400e42e6bc24b39240">QuaternionFloatingMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html#a3b491142ba7765400e42e6bc24b39240">RevoluteMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_prismatic_mobilizer.html#a4426792223a63849fae538b25d61a909">PrismaticMobilizer&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_weld_mobilizer.html#a4426792223a63849fae538b25d61a909">WeldMobilizer&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ac1d21737dd8cda28722ab6a1ac38201e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d21737dd8cda28722ab6a1ac38201e">&#9670;&nbsp;</a></span>set_zero_configuration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_zero_configuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the state stored in <code>context</code> to a <em>zero configuration</em> as defined by <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a5aa27a24c2c9e5ddc38d771e455c3b88" title="Sets the state to what will be considered to be the zero configuration for this mobilizer. ">set_zero_state()</a>. </p>
<p>See <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a5aa27a24c2c9e5ddc38d771e455c3b88" title="Sets the state to what will be considered to be the zero configuration for this mobilizer. ">set_zero_state()</a> for details. </p>

</div>
</div>
<a id="a5aa27a24c2c9e5ddc38d771e455c3b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa27a24c2c9e5ddc38d771e455c3b88">&#9670;&nbsp;</a></span>set_zero_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void set_zero_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <code>state</code> to what will be considered to be the <em>zero</em> configuration for <code>this</code> mobilizer. </p>
<p>For most mobilizers the <em>zero</em> configuration corresponds to the value of generalized positions at which the inboard frame F and the outboard frame coincide or, in other words, when <code>X_FM = Id</code> is the identity pose. In the general case however, the zero configuration will correspond to a value of the generalized positions for which <code>X_FM = X_FM_ref</code> where <code>X_FM_ref</code> may generally be different from the identity transformation. In other words, <code>X_FM_ref = CalcAcrossMobilizerTransform(ref_context)</code> where <code>ref_context</code> is a Context storing a State set to the zero configuration with <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a5aa27a24c2c9e5ddc38d771e455c3b88" title="Sets the state to what will be considered to be the zero configuration for this mobilizer. ">set_zero_state()</a>. In addition, all generalized velocities are set to zero in the <em>zero</em> configuration.</p>
<p>Most often the <em>zero</em> configuration will correspond to setting the vector of generalized positions related to this mobilizer to zero. However, in the general case, setting all generalized coordinates to zero does not correspond to the <em>zero</em> configuration and it might even not represent a mathematicaly valid one. Consider for instance a quaternion mobilizer, for which its <em>zero</em> configuration corresponds to the quaternion [1, 0, 0, 0]. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_space_x_y_z_mobilizer.html#ab5a7651bb8b15c07bade18e44d742697">SpaceXYZMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_mobilizer.html#ab5a7651bb8b15c07bade18e44d742697">QuaternionFloatingMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_revolute_mobilizer.html#ab5a7651bb8b15c07bade18e44d742697">RevoluteMobilizer&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_prismatic_mobilizer.html#aa7e03d9fc66da18defa5fc679c310549">PrismaticMobilizer&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_weld_mobilizer.html#aa7e03d9fc66da18defa5fc679c310549">WeldMobilizer&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ae47f8ba95456400c66ccf983ceb05e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47f8ba95456400c66ccf983ceb05e03">&#9670;&nbsp;</a></span>velocity_start_in_v()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> velocity_start_in_v </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index to the first generalized velocity for this mobilizer within the vector v of generalized velocities for the full multibody system. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/tree/<a class="el" href="mobilizer_8h.html">mobilizer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html">Mobilizer</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
