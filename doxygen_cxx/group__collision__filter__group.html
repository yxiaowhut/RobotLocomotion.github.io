<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Collision Filter Groups</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__collision__filter__group.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Collision Filter Groups<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a> &raquo; <a class="el" href="group__multibody.html">Multibody Dynamics</a> &raquo; <a class="el" href="group__collision__concepts.html">Collision Concepts (RigidBodyPlant only)</a> &raquo; <a class="el" href="group__collision__filter__concepts.html">Collision Filter Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<h1><a class="anchor" id="cfg_principle"></a>
The Principle</h1>
<p>A collision filter group represents collision filtering by defining a collection of collision elements. That <em>group</em> then defines "ignore" relationships with other groups. A collision element's membership in a group does not guarantee inclusion in <em>any</em> filtered collision pairs. This group must be included in at least one group's ignore list; inclusion in its own ignore list would be sufficient.)</p>
<p>A collision-filter-group-based filtering system's unique benefit arises from thinking about <em>classes</em> of collision elements. It serves as a short hand for communicating that no collision element in one class can collide with elements belonging to another class. Each unique collision filter group defines such a class.</p>
<p>This can be used to indicate that two different models cannot collide. Simply create two collision filter groups, assigning all of the collision elements of one model to the first group, and all elements of the second model to the second group. Set either group to <em>ignore</em> the other (or both, redundancy doesn't hurt).</p>
<h1><a class="anchor" id="cfg_impl"></a>
Declaring Collision Filter Groups</h1>
<h2><a class="anchor" id="cfg_impl_in_file"></a>
Declaring collision filter groups in URDF/SDF files</h2>
<p>Collision filter groups can be instantiated by specifying them in URDF/SDF files.</p>
<p><em>Declaration</em></p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">collision_filter_group</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;group1&quot;</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">member</span> <span class="keyword">link</span>=<span class="stringliteral">&quot;body1&quot;</span>/&gt;</div><div class="line">    &lt;<span class="keywordtype">member</span> <span class="keyword">link</span>=<span class="stringliteral">&quot;body2&quot;</span>/&gt;</div><div class="line">    &lt;<span class="keywordtype">ignored_collision_filter_group</span> <span class="keyword">collision_filter_group</span>=<span class="stringliteral">&quot;group2&quot;</span>/&gt;</div><div class="line">    &lt;<span class="keywordtype">ignored_collision_filter_group</span> <span class="keyword">collision_filter_group</span>=<span class="stringliteral">&quot;group3&quot;</span>/&gt;</div><div class="line">&lt;/<span class="keywordtype">collision_filter_group</span>&gt;</div></div><!-- fragment --><p>This XML-snippet illustrates the syntax for declaring a collision filter group. It declares a collision filter group named <code>group1</code>. It has two members, <code>body1</code> and <code>body2</code> (although it could have any number of links). This is short-hand for communicating that the <em>collision elements</em> of <code>body1</code> and <code>body2</code> belong to <code>group1</code>. Furthermore, <code>group1</code> ignores two groups: <code>group2</code> and <code>group3</code>. It is not considered an error to ignore a non-existing group, but it is considered an error to reference a link that hasn't been defined.</p>
<p>One possible use of collision filter groups is to create a set of collision elements which <em>cannot</em> collide with each other (i.e., no self-collisions in the group). This is achieved by having the group ignore <em>itself</em>. E.g.,</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">collision_filter_group</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;no_self_collision_group&quot;</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">member</span> <span class="keyword">link</span>=<span class="stringliteral">&quot;body1&quot;</span>/&gt;</div><div class="line">    &lt;<span class="keywordtype">member</span> <span class="keyword">link</span>=<span class="stringliteral">&quot;body2&quot;</span>/&gt;</div><div class="line">    &lt;<span class="keywordtype">ignored_collision_filter_group</span> <span class="keyword">collision_filter_group</span>=<span class="stringliteral">&quot;no_self_collision_group&quot;</span>/&gt;</div><div class="line">&lt;/<span class="keywordtype">collision_filter_group</span>&gt;</div></div><!-- fragment --><p>Urdf files support the definition of a single robot. As such, all <code>&lt;collision_filter_group&gt;</code> (<code>&lt;cfg&gt;</code> for brevity) tags are children of the <code>&lt;robot&gt;</code> tag.</p>
<p>Sdf files support the definition of multiple robots (aka "models"). As such, the <code>&lt;cfg&gt;</code> tags are children of each <code>&lt;model&gt;</code> tag. The <code>&lt;cfg&gt;</code> tags can only include links that are defined <em>in that model</em> in its membership lists. The implication of that is collision filter groups defined in sdf files contain bodies from a single model only. However, a collision filter group in <em>one</em> model can ignore a collision filter group in another model. See <a href="https://github.com/RobotLocomotion/drake/blob/master/multibody/collision/test/multi_model_groups.sdf">multi_model_groups.sdf</a> for an example.</p>
<h2><a class="anchor" id="cfg_impl_in_code"></a>
Declaring collision filter groups in code</h2>
<p>In addition to parsing the collision filter groups from the urdf/sdf files, there is an API on the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> that allows manipulation. However, the API is constrained. The workflow is as follows:</p>
<ul>
<li>Add one or more bodies</li>
<li>Add one or more collision filter groups</li>
<li>Add bodies to the collision filter groups</li>
<li>Add groups to the "ignore set" of the created groups</li>
<li>Compile the tree</li>
</ul>
<p>The API only supports <em>building up</em> collision filter groups and <em>adding</em> bodies to groups. There is no API for removing bodies from previously declared groups or removing groups from another group's ignore list. The API is strictly additive.</p>
<p>Furthermore, once declared collision filter groups have been compiled (via invocation of <a class="el" href="class_rigid_body_tree.html#acafe5ede9412674127cd08795647f26a">RigidBodyTree::compile()</a>) the <em>names</em> can no longer be referenced. This is what allows the same urdf/sdf file to be read multiple times but not have the named collision filter groups in the file end up spanning all of the models.</p>
<p>However, Drake <em>does</em> support some post-compile filtering modifications. These include:</p><ul>
<li>Adding a new collision filter group. The previously compiled bodies and newly added, uncompiled bodies can all be assigned to the group. However, it can't ignore previously compiled groups (as those names no longer exist).</li>
<li>Attaching a new body with collision elements to a previously compiled body (via a joint). If both bodies have collision elements, collisions between elements on the new and old body will be appropriately filtered.</li>
<li>Compiled bodies can have <em>new</em> collision elements added. They will inherit the same filter behavior as the other elements on the compiled body. (And pick up any new filter behavior after compilation as appropriate.)</li>
</ul>
<p>In <em>typical</em> use, parsing a model from a file calls <a class="el" href="class_rigid_body_tree.html#acafe5ede9412674127cd08795647f26a">RigidBodyTree::compile()</a> and any named collision filter groups in that file cannot be subsequently referenced. The parsing API provides a mechanism for suppressing the automatic tree compilation. There is a parallel set of parse functions which take an additional <code>bool</code>, indicating if the tree should be compiled (<code>true</code>) or not upon parse completion. By passing <code>false</code>, the parsing process will <em>not</em> compile the tree, but it becomes the caller's responsibility to make sure that <a class="el" href="class_rigid_body_tree.html#acafe5ede9412674127cd08795647f26a">RigidBodyTree::compile()</a> is invoked before doing any work on the tree. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> do_compile = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">const</span> std::string file_name = <span class="stringliteral">&quot;some_file.urdf&quot;</span>;</div><div class="line"><a class="code" href="class_rigid_body_tree.html">RigidBodyTree&lt;double&gt;</a> tree;</div><div class="line"><a class="code" href="namespacedrake_1_1parsers_1_1urdf.html#a2b97fa1335f0862e2b3b3ac01bb8148b">AddModelInstanceFromUrdfFileToWorld</a>(file_name, <a class="code" href="namespacedrake_1_1multibody_1_1joints.html#a50cf3eda4d4ab9469c222364b683710bad3a9a1d30f7bce2387271e72e604414a">kRollPitchYaw</a>, do_compile, &amp;tree);</div><div class="line">tree.<a class="code" href="class_rigid_body_tree.html#a7f76ceb30c04f1723e8d6371c575738e">DefineCollisionFilterGroup</a>(<span class="stringliteral">&quot;new_group&quot;</span>);  <span class="comment">// doesn&#39;t already exist.</span></div><div class="line">tree.<a class="code" href="class_rigid_body_tree.html#ab6c94a62910b6ff7d820e81a1cdcf865">AddCollisionFilterGroupMember</a>(<span class="stringliteral">&quot;new_group&quot;</span>, <span class="stringliteral">&quot;body1&quot;</span>, 0); <span class="comment">// Assumes known body name and model instance id.</span></div><div class="line">tree.<a class="code" href="class_rigid_body_tree.html#a4c9f715660bbdc87f79fba9aaeb612ad">AddCollisionFilterIgnoreTarget</a>(<span class="stringliteral">&quot;new_group&quot;</span>, <span class="stringliteral">&quot;group_from_urdf&quot;</span>);</div><div class="line">tree.<a class="code" href="class_rigid_body_tree.html#acafe5ede9412674127cd08795647f26a">compile</a>();</div></div><!-- fragment --><h2><a class="anchor" id="cfg_impl_code"></a>
In-code representation</h2>
<p>Collision filter groups are implemented as a pair of fixed-width bitmasks, stored with each collision element. Each collision filter group corresponds to a single bit. One bitmask represents the set of groups a collision element belongs to. The second represents the groups that this collision element <em>ignores</em>. When a pair of collision elements are considered for collision, the membership mask of each is ANDed with the ignore mask of the other. If either operations produces a non-zero result, the pair is filtered. The cost of the comparison is constant, but related to the bitmask width.</p>
<p>The width is defined at compile time and is defined by <a class="el" href="namespacedrake_1_1multibody_1_1collision.html#a00986eb20639d7ee55a20011f9ca8c03" title="The maximum width of the collision filter group bitmasks. ">drake::multibody::collision::kMaxNumCollisionFilterGroups</a>. The fixed width is a performance optimization but it means that there is a finite number of collision filter groups available in the system. Each <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> instance has its <em>own</em> space of collision filter group identifiers.</p>
<p>By default, all elements belong to a common, universal group which corresponds to bit zero. A collision element can be rendered "invisible" by assigning it to a group that ignores this universal group.</p>
<p>Next topic: collision_filter_mapping </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
