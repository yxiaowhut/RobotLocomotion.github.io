<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: VectorBase&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1systems_1_1_vector_base.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classdrake_1_1systems_1_1_vector_base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">VectorBase&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classdrake_1_1systems_1_1_vector_base.html" title="VectorBase is an abstract base class that real-valued signals between Systems and real-valued System ...">VectorBase</a> is an abstract base class that real-valued signals between Systems and real-valued <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> state vectors must implement.  
 <a href="classdrake_1_1systems_1_1_vector_base.html#details">More...</a></p>

<p><code>#include &lt;drake/systems/framework/vector_base.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abc19c2584a73f03bd1e31277d11315b4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#abc19c2584a73f03bd1e31277d11315b4">~VectorBase</a> ()</td></tr>
<tr class="separator:abc19c2584a73f03bd1e31277d11315b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b716289158c33f86a8cf30219be68c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c">size</a> () const =0</td></tr>
<tr class="memdesc:a36b716289158c33f86a8cf30219be68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the vector.  <a href="#a36b716289158c33f86a8cf30219be68c">More...</a><br /></td></tr>
<tr class="separator:a36b716289158c33f86a8cf30219be68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d8077b68744988dc9344dac8efbd37"><td class="memItemLeft" align="right" valign="top">virtual const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#ab5d8077b68744988dc9344dac8efbd37">GetAtIndex</a> (<a class="el" href="classint.html">int</a> index) const =0</td></tr>
<tr class="memdesc:ab5d8077b68744988dc9344dac8efbd37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the given index in the vector.  <a href="#ab5d8077b68744988dc9344dac8efbd37">More...</a><br /></td></tr>
<tr class="separator:ab5d8077b68744988dc9344dac8efbd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af070ccc1bc51d29089248d1cf15f25ef"><td class="memItemLeft" align="right" valign="top">virtual T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#af070ccc1bc51d29089248d1cf15f25ef">GetAtIndex</a> (<a class="el" href="classint.html">int</a> index)=0</td></tr>
<tr class="memdesc:af070ccc1bc51d29089248d1cf15f25ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the given index in the vector.  <a href="#af070ccc1bc51d29089248d1cf15f25ef">More...</a><br /></td></tr>
<tr class="separator:af070ccc1bc51d29089248d1cf15f25ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544681f87243cb9f80715bb1aa9c0a99"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a544681f87243cb9f80715bb1aa9c0a99">operator[]</a> (std::size_t idx)</td></tr>
<tr class="separator:a544681f87243cb9f80715bb1aa9c0a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99150adfc55ef9056b7feddc006d8878"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a99150adfc55ef9056b7feddc006d8878">operator[]</a> (std::size_t idx) const</td></tr>
<tr class="separator:a99150adfc55ef9056b7feddc006d8878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5902bbfda44607fda562f0c3956520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a5c5902bbfda44607fda562f0c3956520">SetAtIndex</a> (<a class="el" href="classint.html">int</a> index, const T &amp;<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>)</td></tr>
<tr class="memdesc:a5c5902bbfda44607fda562f0c3956520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the state at the given index with the value.  <a href="#a5c5902bbfda44607fda562f0c3956520">More...</a><br /></td></tr>
<tr class="separator:a5c5902bbfda44607fda562f0c3956520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8364f71b762045df41bfcb58927fe5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a3a8364f71b762045df41bfcb58927fe5">SetFrom</a> (const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>)</td></tr>
<tr class="memdesc:a3a8364f71b762045df41bfcb58927fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the entire vector with the contents of <code>value</code>.  <a href="#a3a8364f71b762045df41bfcb58927fe5">More...</a><br /></td></tr>
<tr class="separator:a3a8364f71b762045df41bfcb58927fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9d9b7396dccc9374d87a9be04a2597"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#aea9d9b7396dccc9374d87a9be04a2597">SetFromVector</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>)</td></tr>
<tr class="memdesc:aea9d9b7396dccc9374d87a9be04a2597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the entire vector with the contents of <code>value</code>.  <a href="#aea9d9b7396dccc9374d87a9be04a2597">More...</a><br /></td></tr>
<tr class="separator:aea9d9b7396dccc9374d87a9be04a2597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04797332f4fa1889d462e5c7aacf1400"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a04797332f4fa1889d462e5c7aacf1400">SetZero</a> ()</td></tr>
<tr class="separator:a04797332f4fa1889d462e5c7aacf1400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23751ea78ff51179a9b3ed90317c922d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a23751ea78ff51179a9b3ed90317c922d">CopyToVector</a> () const</td></tr>
<tr class="memdesc:a23751ea78ff51179a9b3ed90317c922d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the entire state to a vector with no semantics.  <a href="#a23751ea78ff51179a9b3ed90317c922d">More...</a><br /></td></tr>
<tr class="separator:a23751ea78ff51179a9b3ed90317c922d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451522facd7139f2f8f22f193e0b5d22"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a451522facd7139f2f8f22f193e0b5d22">ScaleAndAddToVector</a> (const T &amp;scale, Eigen::Ref&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; vec) const</td></tr>
<tr class="memdesc:a451522facd7139f2f8f22f193e0b5d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scaled version of this vector to <a class="el" href="namespace_eigen.html">Eigen</a> vector <code>vec</code>, which must be the same size.  <a href="#a451522facd7139f2f8f22f193e0b5d22">More...</a><br /></td></tr>
<tr class="separator:a451522facd7139f2f8f22f193e0b5d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb348d2ee8136278c64e180f4af21b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#aecb348d2ee8136278c64e180f4af21b7">PlusEqScaled</a> (const T &amp;scale, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aecb348d2ee8136278c64e180f4af21b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in scaled vector <code>rhs</code> to this vector.  <a href="#aecb348d2ee8136278c64e180f4af21b7">More...</a><br /></td></tr>
<tr class="separator:aecb348d2ee8136278c64e180f4af21b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6e85df88627efb8d807f0784f1e974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#acc6e85df88627efb8d807f0784f1e974">PlusEqScaled</a> (const std::initializer_list&lt; std::pair&lt; T, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&gt;&gt; &amp;rhs_scale)</td></tr>
<tr class="memdesc:acc6e85df88627efb8d807f0784f1e974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in multiple scaled vectors to this vector.  <a href="#acc6e85df88627efb8d807f0784f1e974">More...</a><br /></td></tr>
<tr class="separator:acc6e85df88627efb8d807f0784f1e974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc86d5305584bc7cb96971f60220125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#accc86d5305584bc7cb96971f60220125">operator+=</a> (const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:accc86d5305584bc7cb96971f60220125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in vector <code>rhs</code> to this vector.  <a href="#accc86d5305584bc7cb96971f60220125">More...</a><br /></td></tr>
<tr class="separator:accc86d5305584bc7cb96971f60220125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb91f3ae2b66473a274073f56c5fbec0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#acb91f3ae2b66473a274073f56c5fbec0">operator-=</a> (const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acb91f3ae2b66473a274073f56c5fbec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract in vector <code>rhs</code> to this vector.  <a href="#acb91f3ae2b66473a274073f56c5fbec0">More...</a><br /></td></tr>
<tr class="separator:acb91f3ae2b66473a274073f56c5fbec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0146bee9700fa522e0ffa93020a83f"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#abb0146bee9700fa522e0ffa93020a83f">NormInf</a> () const</td></tr>
<tr class="memdesc:abb0146bee9700fa522e0ffa93020a83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the infinity norm for this vector.  <a href="#abb0146bee9700fa522e0ffa93020a83f">More...</a><br /></td></tr>
<tr class="separator:abb0146bee9700fa522e0ffa93020a83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c411be6444ac037acc071dc5df92669"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a6c411be6444ac037acc071dc5df92669">CalcInequalityConstraint</a> (<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>) const</td></tr>
<tr class="memdesc:a6c411be6444ac037acc071dc5df92669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates a vector <code>value</code> suitable for a <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html" title="A SystemConstraint is a generic base-class for constraints on Systems. ">SystemConstraint</a> inequality constraint.  <a href="#a6c411be6444ac037acc071dc5df92669">More...</a><br /></td></tr>
<tr class="separator:a6c411be6444ac037acc071dc5df92669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:aa84df3c9367e9d410bfa85761b241986"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#aa84df3c9367e9d410bfa85761b241986">VectorBase</a> (const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;)=delete</td></tr>
<tr class="separator:aa84df3c9367e9d410bfa85761b241986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9241a7663c3b91834cb25850cf0d2d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a9241a7663c3b91834cb25850cf0d2d8f">operator=</a> (const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;)=delete</td></tr>
<tr class="separator:a9241a7663c3b91834cb25850cf0d2d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8a6afc05d041ccb78c000e578b0e81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#afb8a6afc05d041ccb78c000e578b0e81">VectorBase</a> (<a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:afb8a6afc05d041ccb78c000e578b0e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263f433b6b65dbda74b1e1f43870d0f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a263f433b6b65dbda74b1e1f43870d0f5">operator=</a> (<a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a263f433b6b65dbda74b1e1f43870d0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a146b52fc4bf3790ed55a6c097ca3e76b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a146b52fc4bf3790ed55a6c097ca3e76b">VectorBase</a> ()</td></tr>
<tr class="separator:a146b52fc4bf3790ed55a6c097ca3e76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29263b08da7434571714014d818c6a0d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a29263b08da7434571714014d818c6a0d">DoPlusEqScaled</a> (const std::initializer_list&lt; std::pair&lt; T, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&gt;&gt; &amp;rhs_scale)</td></tr>
<tr class="memdesc:a29263b08da7434571714014d818c6a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds in multiple scaled vectors to this vector.  <a href="#a29263b08da7434571714014d818c6a0d">More...</a><br /></td></tr>
<tr class="separator:a29263b08da7434571714014d818c6a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::systems::VectorBase&lt; T &gt;</h3>

<p><a class="el" href="classdrake_1_1systems_1_1_vector_base.html" title="VectorBase is an abstract base class that real-valued signals between Systems and real-valued System ...">VectorBase</a> is an abstract base class that real-valued signals between Systems and real-valued <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> state vectors must implement. </p>
<p>Classes that inherit from <a class="el" href="classdrake_1_1systems_1_1_vector_base.html" title="VectorBase is an abstract base class that real-valued signals between Systems and real-valued System ...">VectorBase</a> will typically provide names for the elements of the vector, and may also provide other computations for the convenience of Systems handling the signal. The vector is always a column vector. It may or may not be contiguous in memory. Contiguous subclasses should typically inherit from <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase. ">BasicVector</a>, not from <a class="el" href="classdrake_1_1systems_1_1_vector_base.html" title="VectorBase is an abstract base class that real-valued signals between Systems and real-valued System ...">VectorBase</a> directly.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must be a Scalar compatible with <a class="el" href="namespace_eigen.html">Eigen</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa84df3c9367e9d410bfa85761b241986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84df3c9367e9d410bfa85761b241986">&#9670;&nbsp;</a></span>VectorBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb8a6afc05d041ccb78c000e578b0e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8a6afc05d041ccb78c000e578b0e81">&#9670;&nbsp;</a></span>VectorBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc19c2584a73f03bd1e31277d11315b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc19c2584a73f03bd1e31277d11315b4">&#9670;&nbsp;</a></span>~VectorBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a146b52fc4bf3790ed55a6c097ca3e76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146b52fc4bf3790ed55a6c097ca3e76b">&#9670;&nbsp;</a></span>VectorBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6c411be6444ac037acc071dc5df92669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c411be6444ac037acc071dc5df92669">&#9670;&nbsp;</a></span>CalcInequalityConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CalcInequalityConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populates a vector <code>value</code> suitable for a <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html" title="A SystemConstraint is a generic base-class for constraints on Systems. ">SystemConstraint</a> inequality constraint. </p>
<p>For all indices <code>i</code> in the result vector, the validity constraint is <code>result[i] &gt;= 0</code>. For a given subclass type, the size of the result must not vary over time. The VectorBase default implementation sets the <code>value</code> to be empty (no constraints). </p>

</div>
</div>
<a id="a23751ea78ff51179a9b3ed90317c922d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23751ea78ff51179a9b3ed90317c922d">&#9670;&nbsp;</a></span>CopyToVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; CopyToVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the entire state to a vector with no semantics. </p>
<p>Implementations should ensure this operation is O(N) in the size of the value and allocates only the O(N) memory that it returns. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#aacd54af0deadf6ab63f51075def1f164">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#aacd54af0deadf6ab63f51075def1f164">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#aacd54af0deadf6ab63f51075def1f164">BasicVector&lt; AutoDiffXd &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#aacd54af0deadf6ab63f51075def1f164">BasicVector&lt; drake::symbolic::Expression &gt;</a>.</p>

</div>
</div>
<a id="a29263b08da7434571714014d818c6a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29263b08da7434571714014d818c6a0d">&#9670;&nbsp;</a></span>DoPlusEqScaled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoPlusEqScaled </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::pair&lt; T, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds in multiple scaled vectors to this vector. </p>
<p>All vectors are guaranteed to be the same size.</p>
<p>You should override this method if possible with a more efficient approach that leverages structure; the default implementation performs element-by-element computations that are likely inefficient, but even this implementation minimizes memory accesses for efficiency. If the vector is contiguous, for example, implementations that leverage SIMD operations should be far more efficient. Overriding implementations should ensure that this operation remains O(N) in the size of the value and allocates no memory. </p>

</div>
</div>
<a id="ab5d8077b68744988dc9344dac8efbd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d8077b68744988dc9344dac8efbd37">&#9670;&nbsp;</a></span>GetAtIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T&amp; GetAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element at the given index in the vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the index is &gt;= <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c" title="Returns the number of elements in the vector. ">size()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Implementations should ensure this operation is O(1) and allocates no memory. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ad5f75e44b87db78bc5352e753e561153">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ad5f75e44b87db78bc5352e753e561153">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ad5f75e44b87db78bc5352e753e561153">BasicVector&lt; AutoDiffXd &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ad5f75e44b87db78bc5352e753e561153">BasicVector&lt; drake::symbolic::Expression &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_subvector.html#ad5f75e44b87db78bc5352e753e561153">Subvector&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_supervector.html#ad5f75e44b87db78bc5352e753e561153">Supervector&lt; T &gt;</a>.</p>

</div>
</div>
<a id="af070ccc1bc51d29089248d1cf15f25ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af070ccc1bc51d29089248d1cf15f25ef">&#9670;&nbsp;</a></span>GetAtIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T&amp; GetAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element at the given index in the vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the index is &gt;= <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c" title="Returns the number of elements in the vector. ">size()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Implementations should ensure this operation is O(1) and allocates no memory. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ae5c2cc95b42a88aaa7473c89f87762c8">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ae5c2cc95b42a88aaa7473c89f87762c8">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ae5c2cc95b42a88aaa7473c89f87762c8">BasicVector&lt; AutoDiffXd &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ae5c2cc95b42a88aaa7473c89f87762c8">BasicVector&lt; drake::symbolic::Expression &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_subvector.html#ae5c2cc95b42a88aaa7473c89f87762c8">Subvector&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_supervector.html#ae5c2cc95b42a88aaa7473c89f87762c8">Supervector&lt; T &gt;</a>.</p>

</div>
</div>
<a id="abb0146bee9700fa522e0ffa93020a83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0146bee9700fa522e0ffa93020a83f">&#9670;&nbsp;</a></span>NormInf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T NormInf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the infinity norm for this vector. </p>
<p>You should override this method if possible with a more efficient approach that leverages structure; the default implementation performs element-by-element computations that are likely inefficient. If the vector is contiguous, for example, <a class="el" href="namespace_eigen.html">Eigen</a> implementations should be far more efficient. Overriding implementations should ensure that this operation remains O(N) in the size of the value and allocates no memory. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a5a9cdb3c81dec953712f8b9d2813b1bc">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a5a9cdb3c81dec953712f8b9d2813b1bc">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a5a9cdb3c81dec953712f8b9d2813b1bc">BasicVector&lt; AutoDiffXd &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a5a9cdb3c81dec953712f8b9d2813b1bc">BasicVector&lt; drake::symbolic::Expression &gt;</a>.</p>

</div>
</div>
<a id="accc86d5305584bc7cb96971f60220125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc86d5305584bc7cb96971f60220125">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add in vector <code>rhs</code> to this vector. </p>

</div>
</div>
<a id="acb91f3ae2b66473a274073f56c5fbec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb91f3ae2b66473a274073f56c5fbec0">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract in vector <code>rhs</code> to this vector. </p>

</div>
</div>
<a id="a263f433b6b65dbda74b1e1f43870d0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263f433b6b65dbda74b1e1f43870d0f5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9241a7663c3b91834cb25850cf0d2d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9241a7663c3b91834cb25850cf0d2d8f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a544681f87243cb9f80715bb1aa9c0a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544681f87243cb9f80715bb1aa9c0a99">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99150adfc55ef9056b7feddc006d8878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99150adfc55ef9056b7feddc006d8878">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecb348d2ee8136278c64e180f4af21b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb348d2ee8136278c64e180f4af21b7">&#9670;&nbsp;</a></span>PlusEqScaled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&amp; PlusEqScaled </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add in scaled vector <code>rhs</code> to this vector. </p>
<p>Both vectors must be the same size. </p>

</div>
</div>
<a id="acc6e85df88627efb8d807f0784f1e974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6e85df88627efb8d807f0784f1e974">&#9670;&nbsp;</a></span>PlusEqScaled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&amp; PlusEqScaled </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::pair&lt; T, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add in multiple scaled vectors to this vector. </p>
<p>All vectors must be the same size. </p>

</div>
</div>
<a id="a451522facd7139f2f8f22f193e0b5d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451522facd7139f2f8f22f193e0b5d22">&#9670;&nbsp;</a></span>ScaleAndAddToVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ScaleAndAddToVector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scaled version of this vector to <a class="el" href="namespace_eigen.html">Eigen</a> vector <code>vec</code>, which must be the same size. </p>
<p>Implementations may override this default implementation with a more efficient approach, for instance if this vector is contiguous. Implementations should ensure this operation remains O(N) in the size of the value and allocates no memory. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ad58915c32c99db5cecc14677cf4bf672">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ad58915c32c99db5cecc14677cf4bf672">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ad58915c32c99db5cecc14677cf4bf672">BasicVector&lt; AutoDiffXd &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ad58915c32c99db5cecc14677cf4bf672">BasicVector&lt; drake::symbolic::Expression &gt;</a>.</p>

</div>
</div>
<a id="a5c5902bbfda44607fda562f0c3956520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5902bbfda44607fda562f0c3956520">&#9670;&nbsp;</a></span>SetAtIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the state at the given index with the value. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the index is &gt;= <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c" title="Returns the number of elements in the vector. ">size()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a8364f71b762045df41bfcb58927fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8364f71b762045df41bfcb58927fe5">&#9670;&nbsp;</a></span>SetFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the entire vector with the contents of <code>value</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>value</code> is not a column vector with <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c" title="Returns the number of elements in the vector. ">size()</a> rows.</td></tr>
  </table>
  </dd>
</dl>
<p>Implementations should ensure this operation is O(N) in the size of the value and allocates no memory. </p>

</div>
</div>
<a id="aea9d9b7396dccc9374d87a9be04a2597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9d9b7396dccc9374d87a9be04a2597">&#9670;&nbsp;</a></span>SetFromVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetFromVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the entire vector with the contents of <code>value</code>. </p>
<p>Throws std::runtime_error if <code>value</code> is not a column vector with <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c" title="Returns the number of elements in the vector. ">size()</a> rows.</p>
<p>Implementations should ensure this operation is O(N) in the size of the value and allocates no memory. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a833aef49249a64c8e6b596c19bc85e11">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a833aef49249a64c8e6b596c19bc85e11">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a833aef49249a64c8e6b596c19bc85e11">BasicVector&lt; AutoDiffXd &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a833aef49249a64c8e6b596c19bc85e11">BasicVector&lt; drake::symbolic::Expression &gt;</a>.</p>

</div>
</div>
<a id="a04797332f4fa1889d462e5c7aacf1400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04797332f4fa1889d462e5c7aacf1400">&#9670;&nbsp;</a></span>SetZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a4dd70d019cddfb299785f5497313e576">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a4dd70d019cddfb299785f5497313e576">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a4dd70d019cddfb299785f5497313e576">BasicVector&lt; AutoDiffXd &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a4dd70d019cddfb299785f5497313e576">BasicVector&lt; drake::symbolic::Expression &gt;</a>.</p>

</div>
</div>
<a id="a36b716289158c33f86a8cf30219be68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b716289158c33f86a8cf30219be68c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classint.html">int</a> size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the vector. </p>
<p>Implementations should ensure this operation is O(1) and allocates no memory. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a4538a1305a44cbf7a5bd9a536b55eaad">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a4538a1305a44cbf7a5bd9a536b55eaad">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a4538a1305a44cbf7a5bd9a536b55eaad">BasicVector&lt; AutoDiffXd &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a4538a1305a44cbf7a5bd9a536b55eaad">BasicVector&lt; drake::symbolic::Expression &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_subvector.html#a4538a1305a44cbf7a5bd9a536b55eaad">Subvector&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_supervector.html#a4538a1305a44cbf7a5bd9a536b55eaad">Supervector&lt; T &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/systems/framework/<a class="el" href="vector__base_8h.html">vector_base.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1systems.html">systems</a></li><li class="navelem"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
