<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: UnitInertia&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_unit_inertia.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1_unit_inertia-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">UnitInertia&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is used to represent rotational inertias for unit mass bodies.  
 <a href="classdrake_1_1multibody_1_1_unit_inertia.html#details">More...</a></p>

<p><code>#include &lt;drake/multibody/tree/unit_inertia.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af90ef8ef37ca899a26ab2963124f85e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#af90ef8ef37ca899a26ab2963124f85e9">UnitInertia</a> ()</td></tr>
<tr class="memdesc:af90ef8ef37ca899a26ab2963124f85e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default UnitInertia constructor sets all entries to NaN for quick detection of uninitialized values.  <a href="#af90ef8ef37ca899a26ab2963124f85e9">More...</a><br /></td></tr>
<tr class="separator:af90ef8ef37ca899a26ab2963124f85e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9314ec0aaa546381e720cd991f07dee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#aa9314ec0aaa546381e720cd991f07dee">UnitInertia</a> (const T &amp;Ixx, const T &amp;Iyy, const T &amp;Izz)</td></tr>
<tr class="memdesc:aa9314ec0aaa546381e720cd991f07dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unit inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with each product of inertia set to zero.  <a href="#aa9314ec0aaa546381e720cd991f07dee">More...</a><br /></td></tr>
<tr class="separator:aa9314ec0aaa546381e720cd991f07dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79df22b67e93b31938267a4df9527293"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a79df22b67e93b31938267a4df9527293">UnitInertia</a> (const T &amp;Ixx, const T &amp;Iyy, const T &amp;Izz, const T &amp;Ixy, const T &amp;Ixz, const T &amp;Iyz)</td></tr>
<tr class="memdesc:a79df22b67e93b31938267a4df9527293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unit inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with products of inertia <code>Ixy</code>, <code>Ixz</code>, <code>Iyz</code>.  <a href="#a79df22b67e93b31938267a4df9527293">More...</a><br /></td></tr>
<tr class="separator:a79df22b67e93b31938267a4df9527293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29844d6e36bf50f6bf5bb44b5d05205"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#ab29844d6e36bf50f6bf5bb44b5d05205">UnitInertia</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I)</td></tr>
<tr class="memdesc:ab29844d6e36bf50f6bf5bb44b5d05205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a UnitInertia from a <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class helps describe the mass distribution (inertia properties) of a body or composite body abou...">RotationalInertia</a>.  <a href="#ab29844d6e36bf50f6bf5bb44b5d05205">More...</a><br /></td></tr>
<tr class="separator:ab29844d6e36bf50f6bf5bb44b5d05205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b0fa29234319721cd8689fdb111c23"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ae3b0fa29234319721cd8689fdb111c23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#ae3b0fa29234319721cd8689fdb111c23">cast</a> () const</td></tr>
<tr class="memdesc:ae3b0fa29234319721cd8689fdb111c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new UnitInertia object templated on <code>Scalar</code> initialized from the value of <code>this</code> unit inertia.  <a href="#ae3b0fa29234319721cd8689fdb111c23">More...</a><br /></td></tr>
<tr class="separator:ae3b0fa29234319721cd8689fdb111c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8569b38683ca9da5ebd7d02e76a74302"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a8569b38683ca9da5ebd7d02e76a74302">SetFromRotationalInertia</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I, const T &amp;mass)</td></tr>
<tr class="memdesc:a8569b38683ca9da5ebd7d02e76a74302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> unit inertia from a generally non-unit inertia I corresponding to a body with a given <code>mass</code>.  <a href="#a8569b38683ca9da5ebd7d02e76a74302">More...</a><br /></td></tr>
<tr class="separator:a8569b38683ca9da5ebd7d02e76a74302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2147d14d9c65f7935c1ace3a3e037ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#af2147d14d9c65f7935c1ace3a3e037ee">ReExpressInPlace</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_FE)</td></tr>
<tr class="memdesc:af2147d14d9c65f7935c1ace3a3e037ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express a unit inertia in a different frame, performing the operation in place and modifying the original object.  <a href="#af2147d14d9c65f7935c1ace3a3e037ee">More...</a><br /></td></tr>
<tr class="separator:af2147d14d9c65f7935c1ace3a3e037ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398457f90a21345f211ed527c6e9c6c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a398457f90a21345f211ed527c6e9c6c7">DRAKE_DEPRECATED</a> (&quot;Use <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#af2147d14d9c65f7935c1ace3a3e037ee">UnitInertia::ReExpressInPlace</a>(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February 5, 2019.&quot;) UnitInertia&lt; T &gt; &amp;<a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#af2147d14d9c65f7935c1ace3a3e037ee">ReExpressInPlace</a>(const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R_FE)</td></tr>
<tr class="separator:a398457f90a21345f211ed527c6e9c6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8231314dc085af878e5ff89cd36b40a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#ab8231314dc085af878e5ff89cd36b40a">ReExpress</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_FE) const</td></tr>
<tr class="memdesc:ab8231314dc085af878e5ff89cd36b40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>this</code> unit inertia <code>G_BP_E</code> of a body B about a point P and expressed in frame E, this method computes the same unit inertia re-expressed in another frame F as <code>G_BP_F = R_FE * G_BP_E * (R_FE)ᵀ</code>.  <a href="#ab8231314dc085af878e5ff89cd36b40a">More...</a><br /></td></tr>
<tr class="separator:ab8231314dc085af878e5ff89cd36b40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10aa84acfbe46cbcf5bc440d3aeb2b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#ab10aa84acfbe46cbcf5bc440d3aeb2b0">DRAKE_DEPRECATED</a> (&quot;Use <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#ab8231314dc085af878e5ff89cd36b40a">UnitInertia::ReExpress</a>(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February 5, 2019.&quot;) UnitInertia&lt; T &gt; <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#ab8231314dc085af878e5ff89cd36b40a">ReExpress</a>(const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R_FE) const</td></tr>
<tr class="separator:ab10aa84acfbe46cbcf5bc440d3aeb2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b718707c9e2b7fe417950a8ba4c57e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a44b718707c9e2b7fe417950a8ba4c57e">ShiftFromCenterOfMassInPlace</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_BcQ_E)</td></tr>
<tr class="memdesc:a44b718707c9e2b7fe417950a8ba4c57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a central unit inertia <code>G_Bcm_E</code> computed about a body's center of mass (or centroid) <code>Bcm</code> and expressed in a frame E, this method shifts this inertia using the parallel axis theorem to be computed about a point Q.  <a href="#a44b718707c9e2b7fe417950a8ba4c57e">More...</a><br /></td></tr>
<tr class="separator:a44b718707c9e2b7fe417950a8ba4c57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7a991d6fb01efebd0654f57018b7d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a9d7a991d6fb01efebd0654f57018b7d4">ShiftFromCenterOfMass</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_BcQ_E) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:a9d7a991d6fb01efebd0654f57018b7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts this central unit inertia to a different point, and returns the result.  <a href="#a9d7a991d6fb01efebd0654f57018b7d4">More...</a><br /></td></tr>
<tr class="separator:a9d7a991d6fb01efebd0654f57018b7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b39c6656200a848579b87b986f6965"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a63b39c6656200a848579b87b986f6965">ShiftToCenterOfMassInPlace</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E)</td></tr>
<tr class="memdesc:a63b39c6656200a848579b87b986f6965"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the unit inertia <code>G_BQ_E</code> of a body or composite body B computed about a point Q and expressed in a frame E, this method shifts this inertia using the parallel axis theorem to be computed about the center of mass <code>Bcm</code> of B.  <a href="#a63b39c6656200a848579b87b986f6965">More...</a><br /></td></tr>
<tr class="separator:a63b39c6656200a848579b87b986f6965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15446b478364a5bd0a74419bd7a0b719"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a15446b478364a5bd0a74419bd7a0b719">ShiftToCenterOfMass</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:a15446b478364a5bd0a74419bd7a0b719"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the unit inertia <code>G_BQ_E</code> of a body or composite body B computed about a point Q and expressed in a frame E, this method shifts this inertia using the parallel axis theorem to be computed about the center of mass <code>Bcm</code> of B.  <a href="#a15446b478364a5bd0a74419bd7a0b719">More...</a><br /></td></tr>
<tr class="separator:a15446b478364a5bd0a74419bd7a0b719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a6dcd4923027cb6fa0b9ad164c211ceae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a6dcd4923027cb6fa0b9ad164c211ceae">UnitInertia</a> (const <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a> &amp;)=default</td></tr>
<tr class="separator:a6dcd4923027cb6fa0b9ad164c211ceae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e321b3b8489b5519c9bc079ad3b521a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a0e321b3b8489b5519c9bc079ad3b521a">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a> &amp;)=default</td></tr>
<tr class="separator:a0e321b3b8489b5519c9bc079ad3b521a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924ebae0ded3ad97827dfe1564c1c368"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a924ebae0ded3ad97827dfe1564c1c368">UnitInertia</a> (<a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a924ebae0ded3ad97827dfe1564c1c368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329d230352494812d0e1662fb73f4ff8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a329d230352494812d0e1662fb73f4ff8">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a329d230352494812d0e1662fb73f4ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Disable operators that may result in non-unit inertias.</div></td></tr>
<tr class="memitem:aa16a9cdf1bf2f4e7f59af88fb90ea4f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#aa16a9cdf1bf2f4e7f59af88fb90ea4f8">operator+=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;)=delete</td></tr>
<tr class="separator:aa16a9cdf1bf2f4e7f59af88fb90ea4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a91ea3d4a5c586d46ba46000f12541"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#ad9a91ea3d4a5c586d46ba46000f12541">operator-=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;)=delete</td></tr>
<tr class="separator:ad9a91ea3d4a5c586d46ba46000f12541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908300bf2b212d2526fa5803f732dba2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a908300bf2b212d2526fa5803f732dba2">operator*=</a> (const T &amp;)=delete</td></tr>
<tr class="separator:a908300bf2b212d2526fa5803f732dba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82325138e40aa8b7ecb26c7d8ef3aa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#af82325138e40aa8b7ecb26c7d8ef3aa6">operator/=</a> (const T &amp;)=delete</td></tr>
<tr class="separator:af82325138e40aa8b7ecb26c7d8ef3aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdrake_1_1multibody_1_1_rotational_inertia')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia&lt; T &gt;</a></td></tr>
<tr class="memitem:ab3ffc4a4e197a2a2155641d75c2a7c49 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab3ffc4a4e197a2a2155641d75c2a7c49">RotationalInertia</a> ()</td></tr>
<tr class="memdesc:ab3ffc4a4e197a2a2155641d75c2a7c49 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rotational inertia that has all its moments/products of inertia equal to NaN (helps quickly detect uninitialized values).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab3ffc4a4e197a2a2155641d75c2a7c49">More...</a><br /></td></tr>
<tr class="separator:ab3ffc4a4e197a2a2155641d75c2a7c49 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36dbdaa401764e4df48b07d3b6ad7d4 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#af36dbdaa401764e4df48b07d3b6ad7d4">RotationalInertia</a> (const T &amp;Ixx, const T &amp;Iyy, const T &amp;Izz)</td></tr>
<tr class="memdesc:af36dbdaa401764e4df48b07d3b6ad7d4 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rotational inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with each product of inertia set to zero.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#af36dbdaa401764e4df48b07d3b6ad7d4">More...</a><br /></td></tr>
<tr class="separator:af36dbdaa401764e4df48b07d3b6ad7d4 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319d6a0feeb306267605332cdd1906d6 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a319d6a0feeb306267605332cdd1906d6">RotationalInertia</a> (const T &amp;Ixx, const T &amp;Iyy, const T &amp;Izz, const T &amp;Ixy, const T &amp;Ixz, const T &amp;Iyz)</td></tr>
<tr class="memdesc:a319d6a0feeb306267605332cdd1906d6 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rotational inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with products of inertia <code>Ixy</code>, <code>Ixz</code>, <code>Iyz</code>.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a319d6a0feeb306267605332cdd1906d6">More...</a><br /></td></tr>
<tr class="separator:a319d6a0feeb306267605332cdd1906d6 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ee8d395f9f46a1086071be0faa8e37 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a73ee8d395f9f46a1086071be0faa8e37">RotationalInertia</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PQ_E)</td></tr>
<tr class="memdesc:a73ee8d395f9f46a1086071be0faa8e37 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rotational inertia for a particle Q of mass <code>mass</code>, whose position vector from about-point P is p_PQ_E (E is expressed-in frame).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a73ee8d395f9f46a1086071be0faa8e37">More...</a><br /></td></tr>
<tr class="separator:a73ee8d395f9f46a1086071be0faa8e37 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad107abcacb84cbabb41b87ba81360f91 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ad107abcacb84cbabb41b87ba81360f91">rows</a> () const</td></tr>
<tr class="memdesc:ad107abcacb84cbabb41b87ba81360f91 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">For consistency with <a class="el" href="namespace_eigen.html">Eigen</a>'s API, the <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ad107abcacb84cbabb41b87ba81360f91" title="For consistency with Eigen&#39;s API, the rows() method returns 3. ">rows()</a> method returns 3.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#ad107abcacb84cbabb41b87ba81360f91">More...</a><br /></td></tr>
<tr class="separator:ad107abcacb84cbabb41b87ba81360f91 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8509d6f7951179378f848f5f4cc37720 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a8509d6f7951179378f848f5f4cc37720">cols</a> () const</td></tr>
<tr class="memdesc:a8509d6f7951179378f848f5f4cc37720 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">For consistency with <a class="el" href="namespace_eigen.html">Eigen</a>'s API, the <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a8509d6f7951179378f848f5f4cc37720" title="For consistency with Eigen&#39;s API, the cols() method returns 3. ">cols()</a> method returns 3.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a8509d6f7951179378f848f5f4cc37720">More...</a><br /></td></tr>
<tr class="separator:a8509d6f7951179378f848f5f4cc37720 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63faf9877a005bf08269b508f2d17b42 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a63faf9877a005bf08269b508f2d17b42">get_moments</a> () const</td></tr>
<tr class="memdesc:a63faf9877a005bf08269b508f2d17b42 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz].  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a63faf9877a005bf08269b508f2d17b42">More...</a><br /></td></tr>
<tr class="separator:a63faf9877a005bf08269b508f2d17b42 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73703796210df51bb25acbb19168913a inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a73703796210df51bb25acbb19168913a">get_products</a> () const</td></tr>
<tr class="memdesc:a73703796210df51bb25acbb19168913a inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz].  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a73703796210df51bb25acbb19168913a">More...</a><br /></td></tr>
<tr class="separator:a73703796210df51bb25acbb19168913a inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23798f37ae600d4d79b8a2e71586c4c7 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a23798f37ae600d4d79b8a2e71586c4c7">Trace</a> () const</td></tr>
<tr class="memdesc:a23798f37ae600d4d79b8a2e71586c4c7 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a rotational inertia's trace (i.e., Ixx + Iyy + Izz, the sum of the diagonal elements of the inertia matrix).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a23798f37ae600d4d79b8a2e71586c4c7">More...</a><br /></td></tr>
<tr class="separator:a23798f37ae600d4d79b8a2e71586c4c7 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3751c9eaa974909523b6d8d3fd0833a8 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a3751c9eaa974909523b6d8d3fd0833a8">CalcMaximumPossibleMomentOfInertia</a> () const</td></tr>
<tr class="memdesc:a3751c9eaa974909523b6d8d3fd0833a8 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible moment of inertia for <code>this</code> rotational inertia about-point P for any expressed-in frame E.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a3751c9eaa974909523b6d8d3fd0833a8">More...</a><br /></td></tr>
<tr class="separator:a3751c9eaa974909523b6d8d3fd0833a8 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae48d85764cacfd54fc3001250b4eac inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#afae48d85764cacfd54fc3001250b4eac">operator()</a> (<a class="el" href="classint.html">int</a> <a class="el" href="geometry__properties__test_8cc.html#acb559820d9ca11295b4500f179ef6392">i</a>, <a class="el" href="classint.html">int</a> j) const</td></tr>
<tr class="memdesc:afae48d85764cacfd54fc3001250b4eac inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const access to the <code>(i, j)</code> element of this rotational inertia.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#afae48d85764cacfd54fc3001250b4eac">More...</a><br /></td></tr>
<tr class="separator:afae48d85764cacfd54fc3001250b4eac inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38985b256018ac664935ee8423bbe8b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#af38985b256018ac664935ee8423bbe8b">CopyToFullMatrix3</a> () const</td></tr>
<tr class="memdesc:af38985b256018ac664935ee8423bbe8b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a full 3x3 matrix copy of this rotational inertia.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#af38985b256018ac664935ee8423bbe8b">More...</a><br /></td></tr>
<tr class="separator:af38985b256018ac664935ee8423bbe8b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0546b3ac658fccec61a5156a926765dd inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a0546b3ac658fccec61a5156a926765dd">IsNearlyEqualTo</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;other, <a class="el" href="classdouble.html">double</a> precision) const</td></tr>
<tr class="memdesc:a0546b3ac658fccec61a5156a926765dd inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <code>this</code> rotational inertia to <code>other</code> rotional inertia within the specified <code>precision</code> (which is a dimensionless number specifying the relative precision to which the comparison is performed).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a0546b3ac658fccec61a5156a926765dd">More...</a><br /></td></tr>
<tr class="separator:a0546b3ac658fccec61a5156a926765dd inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d65a4cd4dd6105398ee79ad825035f inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a22d65a4cd4dd6105398ee79ad825035f">operator+=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:a22d65a4cd4dd6105398ee79ad825035f inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotational inertia <code>I_BP_E</code> to <code>this</code> rotational inertia.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a22d65a4cd4dd6105398ee79ad825035f">More...</a><br /></td></tr>
<tr class="separator:a22d65a4cd4dd6105398ee79ad825035f inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b4714f1ad30911025024f1eda4d72e inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab3b4714f1ad30911025024f1eda4d72e">operator+</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E) const</td></tr>
<tr class="memdesc:ab3b4714f1ad30911025024f1eda4d72e inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotational inertia <code>I_BP_E</code> to <code>this</code> rotational inertia.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab3b4714f1ad30911025024f1eda4d72e">More...</a><br /></td></tr>
<tr class="separator:ab3b4714f1ad30911025024f1eda4d72e inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9616b9b963139066953c80ac978c362a inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a9616b9b963139066953c80ac978c362a">operator-=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:a9616b9b963139066953c80ac978c362a inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a9616b9b963139066953c80ac978c362a">More...</a><br /></td></tr>
<tr class="separator:a9616b9b963139066953c80ac978c362a inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff3c0d26ee10bb5d824ee6d3498eb4d inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#aaff3c0d26ee10bb5d824ee6d3498eb4d">operator-</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E) const</td></tr>
<tr class="memdesc:aaff3c0d26ee10bb5d824ee6d3498eb4d inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#aaff3c0d26ee10bb5d824ee6d3498eb4d">More...</a><br /></td></tr>
<tr class="separator:aaff3c0d26ee10bb5d824ee6d3498eb4d inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65b0fb94c4a5a8b580c8db31e7ce659 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab65b0fb94c4a5a8b580c8db31e7ce659">operator*=</a> (const T &amp;nonnegative_scalar)</td></tr>
<tr class="memdesc:ab65b0fb94c4a5a8b580c8db31e7ce659 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> rotational inertia by a nonnegative scalar (&gt;= 0).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab65b0fb94c4a5a8b580c8db31e7ce659">More...</a><br /></td></tr>
<tr class="separator:ab65b0fb94c4a5a8b580c8db31e7ce659 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cbefdc664161fc4775ab5d719e67bf inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a19cbefdc664161fc4775ab5d719e67bf">operator*</a> (const T &amp;nonnegative_scalar) const</td></tr>
<tr class="memdesc:a19cbefdc664161fc4775ab5d719e67bf inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> rotational inertia by a nonnegative scalar (&gt;= 0).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a19cbefdc664161fc4775ab5d719e67bf">More...</a><br /></td></tr>
<tr class="separator:a19cbefdc664161fc4775ab5d719e67bf inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad317217e02206a32e8a46b11f206bbe inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#aad317217e02206a32e8a46b11f206bbe">operator*</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;w_E) const</td></tr>
<tr class="memdesc:aad317217e02206a32e8a46b11f206bbe inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> rotational inertia about-point P, expressed-in frame E by the vector w_E (which <em>must</em> also have the same expressed-in frame E).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#aad317217e02206a32e8a46b11f206bbe">More...</a><br /></td></tr>
<tr class="separator:aad317217e02206a32e8a46b11f206bbe inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb6014636db3579a84defd7824ee4c1 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a3cb6014636db3579a84defd7824ee4c1">operator/=</a> (const T &amp;positive_scalar)</td></tr>
<tr class="memdesc:a3cb6014636db3579a84defd7824ee4c1 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides <code>this</code> rotational inertia by a positive scalar (&gt; 0).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a3cb6014636db3579a84defd7824ee4c1">More...</a><br /></td></tr>
<tr class="separator:a3cb6014636db3579a84defd7824ee4c1 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0d8c42739dc16a87225c2b0057517b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a7a0d8c42739dc16a87225c2b0057517b">operator/</a> (const T &amp;positive_scalar) const</td></tr>
<tr class="memdesc:a7a0d8c42739dc16a87225c2b0057517b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides <code>this</code> rotational inertia by a positive scalar(&gt; 0).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a7a0d8c42739dc16a87225c2b0057517b">More...</a><br /></td></tr>
<tr class="separator:a7a0d8c42739dc16a87225c2b0057517b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae461fd75b1b4eba6c95a57621adb4e9d inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ae461fd75b1b4eba6c95a57621adb4e9d">SetToNaN</a> ()</td></tr>
<tr class="memdesc:ae461fd75b1b4eba6c95a57621adb4e9d inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> rotational inertia so all its elements are equal to NaN.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#ae461fd75b1b4eba6c95a57621adb4e9d">More...</a><br /></td></tr>
<tr class="separator:ae461fd75b1b4eba6c95a57621adb4e9d inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57e5aca5db002545e4b9335c8d9dbfa inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ae57e5aca5db002545e4b9335c8d9dbfa">SetZero</a> ()</td></tr>
<tr class="memdesc:ae57e5aca5db002545e4b9335c8d9dbfa inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> rotational inertia so all its moments/products of inertia are zero, e.g., for convenient initialization before a computation or for inertia calculations involving a particle (point-mass).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#ae57e5aca5db002545e4b9335c8d9dbfa">More...</a><br /></td></tr>
<tr class="separator:ae57e5aca5db002545e4b9335c8d9dbfa inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a73339c4b21bba9c3fa975f7a6c4220 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a1a73339c4b21bba9c3fa975f7a6c4220">IsNaN</a> () const</td></tr>
<tr class="memdesc:a1a73339c4b21bba9c3fa975f7a6c4220 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any moment/product in <code>this</code> rotational inertia is NaN.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a1a73339c4b21bba9c3fa975f7a6c4220">More...</a><br /></td></tr>
<tr class="separator:a1a73339c4b21bba9c3fa975f7a6c4220 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1e01c37486db2e78263fb70eaff550 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:afa1e01c37486db2e78263fb70eaff550 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#afa1e01c37486db2e78263fb70eaff550">cast</a> () const</td></tr>
<tr class="memdesc:afa1e01c37486db2e78263fb70eaff550 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new RotationalInertia object templated on <code>Scalar</code> initialized from the values of <code>this</code> rotational inertia's entries.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#afa1e01c37486db2e78263fb70eaff550">More...</a><br /></td></tr>
<tr class="separator:afa1e01c37486db2e78263fb70eaff550 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b63ae12f2b1cc131b2584efe07a2b6b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a6b63ae12f2b1cc131b2584efe07a2b6b">CalcPrincipalMomentsOfInertia</a> () const</td></tr>
<tr class="memdesc:a6b63ae12f2b1cc131b2584efe07a2b6b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes <code>this</code> rotational inertia about-point P, expressed-in- frame E, and computes its principal moments of inertia about-point P, but expressed-in a frame aligned with the principal axes.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a6b63ae12f2b1cc131b2584efe07a2b6b">More...</a><br /></td></tr>
<tr class="separator:a6b63ae12f2b1cc131b2584efe07a2b6b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e71eb4bd2a7648a411e1cbaf94812b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b">CouldBePhysicallyValid</a> () const</td></tr>
<tr class="memdesc:a03e71eb4bd2a7648a411e1cbaf94812b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs several necessary checks to verify whether <code>this</code> rotational inertia <em>could</em> be physically valid, including:  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b">More...</a><br /></td></tr>
<tr class="separator:a03e71eb4bd2a7648a411e1cbaf94812b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18d9151885c8c0ab91a24db506d4270 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab18d9151885c8c0ab91a24db506d4270">ReExpressInPlace</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_AE)</td></tr>
<tr class="memdesc:ab18d9151885c8c0ab91a24db506d4270 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-expresses <code>this</code> rotational inertia <code>I_BP_E</code> to <code>I_BP_A</code>.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab18d9151885c8c0ab91a24db506d4270">More...</a><br /></td></tr>
<tr class="separator:ab18d9151885c8c0ab91a24db506d4270 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c03fdc2e8311a8d71c14ef89e64260c inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a8c03fdc2e8311a8d71c14ef89e64260c">DRAKE_DEPRECATED</a> (&quot;Use <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab18d9151885c8c0ab91a24db506d4270">ReExpressInPlace</a>(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February 5, 2019.&quot;) RotationalInertia&lt; T &gt; &amp;<a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab18d9151885c8c0ab91a24db506d4270">ReExpressInPlace</a>(const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R_AE)</td></tr>
<tr class="separator:a8c03fdc2e8311a8d71c14ef89e64260c inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eb5284c5ec57a645aee167798a1f2c inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a08eb5284c5ec57a645aee167798a1f2c">ReExpress</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_AE) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:a08eb5284c5ec57a645aee167798a1f2c inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-expresses <code>this</code> rotational inertia <code>I_BP_E</code> to <code>I_BP_A</code> i.e., re-expresses body B's rotational inertia from frame E to frame A.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a08eb5284c5ec57a645aee167798a1f2c">More...</a><br /></td></tr>
<tr class="separator:a08eb5284c5ec57a645aee167798a1f2c inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93df06a03ac0135b2a06e56be3144273 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a93df06a03ac0135b2a06e56be3144273">DRAKE_DEPRECATED</a> (&quot;Use <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a08eb5284c5ec57a645aee167798a1f2c">RotationalInertia::ReExpress</a>(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February 5, 2019.&quot;) RotationalInertia&lt; T &gt; <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a08eb5284c5ec57a645aee167798a1f2c">ReExpress</a>(const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R_AE) const __attribute__((warn_unused_result))</td></tr>
<tr class="separator:a93df06a03ac0135b2a06e56be3144273 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719e23ae8c26b0c8cf0c7f30dd112559 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a719e23ae8c26b0c8cf0c7f30dd112559">RotationalInertia</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;)=default</td></tr>
<tr class="separator:a719e23ae8c26b0c8cf0c7f30dd112559 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78d207e550d7d227b7e7f37557fb66a inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab78d207e550d7d227b7e7f37557fb66a">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;)=default</td></tr>
<tr class="separator:ab78d207e550d7d227b7e7f37557fb66a inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e215bccd4ce720b787f8b5195a7551 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a87e215bccd4ce720b787f8b5195a7551">RotationalInertia</a> (<a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a87e215bccd4ce720b787f8b5195a7551 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25060922d76f06276ac5f169e748ebd inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ac25060922d76f06276ac5f169e748ebd">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ac25060922d76f06276ac5f169e748ebd inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233d049441510e6de4347afa89eff0e0 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a233d049441510e6de4347afa89eff0e0">ShiftFromCenterOfMassInPlace</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_BcmQ_E)</td></tr>
<tr class="memdesc:a233d049441510e6de4347afa89eff0e0 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a233d049441510e6de4347afa89eff0e0">More...</a><br /></td></tr>
<tr class="separator:a233d049441510e6de4347afa89eff0e0 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6d68bf65261dba0c10a00174fed83c inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a5a6d68bf65261dba0c10a00174fed83c">ShiftFromCenterOfMass</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_BcmQ_E) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:a5a6d68bf65261dba0c10a00174fed83c inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a5a6d68bf65261dba0c10a00174fed83c">More...</a><br /></td></tr>
<tr class="separator:a5a6d68bf65261dba0c10a00174fed83c inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a43d32c412efc0f5e1b6ccc1b1cc17 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a82a43d32c412efc0f5e1b6ccc1b1cc17">ShiftToCenterOfMassInPlace</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E)</td></tr>
<tr class="memdesc:a82a43d32c412efc0f5e1b6ccc1b1cc17 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point Q to about-point <code>Bcm</code> (B's center of mass).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a82a43d32c412efc0f5e1b6ccc1b1cc17">More...</a><br /></td></tr>
<tr class="separator:a82a43d32c412efc0f5e1b6ccc1b1cc17 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef27cf48918c4ca310e1e5d67de50f7a inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#aef27cf48918c4ca310e1e5d67de50f7a">ShiftToCenterOfMass</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:aef27cf48918c4ca310e1e5d67de50f7a inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point Q to about-point <code>Bcm</code> (B's center of mass).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#aef27cf48918c4ca310e1e5d67de50f7a">More...</a><br /></td></tr>
<tr class="separator:aef27cf48918c4ca310e1e5d67de50f7a inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631d7db4d8c28e6108d78b8309dabc2b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a631d7db4d8c28e6108d78b8309dabc2b">ShiftToThenAwayFromCenterOfMassInPlace</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PBcm_E, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E)</td></tr>
<tr class="memdesc:a631d7db4d8c28e6108d78b8309dabc2b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a631d7db4d8c28e6108d78b8309dabc2b">More...</a><br /></td></tr>
<tr class="separator:a631d7db4d8c28e6108d78b8309dabc2b inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa36a24a9c8fa583631e45d1ad366ce3 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#afa36a24a9c8fa583631e45d1ad366ce3">ShiftToThenAwayFromCenterOfMass</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PBcm_E, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:afa36a24a9c8fa583631e45d1ad366ce3 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass).  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#afa36a24a9c8fa583631e45d1ad366ce3">More...</a><br /></td></tr>
<tr class="separator:afa36a24a9c8fa583631e45d1ad366ce3 inherit pub_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Unit inertia for common 3D objects</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The following methods assist in the construction of UnitInertia instances for common 3D objects such as boxes, spheres, rods and others.</p>
<p>This method computes a UnitInertia for body with unit mass, typically around its centroid, and in a frame aligned with its principal axes. To construct general UnitInertia objects use these methods along with <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a44b718707c9e2b7fe417950a8ba4c57e" title="For a central unit inertia G_Bcm_E computed about a body&#39;s center of mass (or centroid) Bcm and expre...">ShiftFromCenterOfMassInPlace()</a> to move the point about which the inertia is computed and use <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#ab8231314dc085af878e5ff89cd36b40a" title="Given this unit inertia G_BP_E of a body B about a point P and expressed in frame E...">ReExpress()</a> to express in a different frame. A non-unit <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class helps describe the mass distribution (inertia properties) of a body or composite body abou...">RotationalInertia</a> is obtained by multiplying the generated UnitInertia by a non-unit mass value. </p>
</div></td></tr>
<tr class="memitem:ae6f93bf07bd55dd7ab860b0c321713c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#ae6f93bf07bd55dd7ab860b0c321713c0">PointMass</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_FQ)</td></tr>
<tr class="memdesc:ae6f93bf07bd55dd7ab860b0c321713c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a unit inertia for a point mass of unit mass located at point Q, whose location in a frame F is given by the position vector <code>p_FQ</code> (that is, p_FoQ_F).  <a href="#ae6f93bf07bd55dd7ab860b0c321713c0">More...</a><br /></td></tr>
<tr class="separator:ae6f93bf07bd55dd7ab860b0c321713c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3d4bf1e85ad1942c12478e5e3aa906"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#adf3d4bf1e85ad1942c12478e5e3aa906">SolidSphere</a> (const T &amp;r)</td></tr>
<tr class="memdesc:adf3d4bf1e85ad1942c12478e5e3aa906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unit inertia for a unit-mass solid sphere of uniform density and radius <code>r</code> taken about its center.  <a href="#adf3d4bf1e85ad1942c12478e5e3aa906">More...</a><br /></td></tr>
<tr class="separator:adf3d4bf1e85ad1942c12478e5e3aa906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e7babe23518ac81fc0a3c1c7157496"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a18e7babe23518ac81fc0a3c1c7157496">HollowSphere</a> (const T &amp;r)</td></tr>
<tr class="memdesc:a18e7babe23518ac81fc0a3c1c7157496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unit inertia for a unit-mass hollow sphere of radius <code>r</code> consisting of an infinitesimally thin shell of uniform density.  <a href="#a18e7babe23518ac81fc0a3c1c7157496">More...</a><br /></td></tr>
<tr class="separator:a18e7babe23518ac81fc0a3c1c7157496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508911b2ad53d5a156259e5b4690278a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a508911b2ad53d5a156259e5b4690278a">SolidBox</a> (const T &amp;Lx, const T &amp;Ly, const T &amp;Lz)</td></tr>
<tr class="memdesc:a508911b2ad53d5a156259e5b4690278a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unit inertia for a unit-mass solid box of uniform density taken about its geometric center.  <a href="#a508911b2ad53d5a156259e5b4690278a">More...</a><br /></td></tr>
<tr class="separator:a508911b2ad53d5a156259e5b4690278a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224f50a8d9351914db96e47ddb5767fb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a224f50a8d9351914db96e47ddb5767fb">SolidCube</a> (const T &amp;L)</td></tr>
<tr class="memdesc:a224f50a8d9351914db96e47ddb5767fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unit inertia for a unit-mass solid cube (a box with equal-sized sides) of uniform density taken about its geometric center.  <a href="#a224f50a8d9351914db96e47ddb5767fb">More...</a><br /></td></tr>
<tr class="separator:a224f50a8d9351914db96e47ddb5767fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa752eb88a4a3eb76242ccb373b81ccf3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#aa752eb88a4a3eb76242ccb373b81ccf3">SolidCylinder</a> (const T &amp;r, const T &amp;L, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;b_E=<a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;::UnitZ())</td></tr>
<tr class="memdesc:aa752eb88a4a3eb76242ccb373b81ccf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unit inertia for a unit-mass cylinder B, of uniform density, having its axis of revolution along input vector <code>b_E</code>.  <a href="#aa752eb88a4a3eb76242ccb373b81ccf3">More...</a><br /></td></tr>
<tr class="separator:aa752eb88a4a3eb76242ccb373b81ccf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26c23e707688c5fe5f0c71f22fbee62"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#af26c23e707688c5fe5f0c71f22fbee62">SolidCylinderAboutEnd</a> (const T &amp;r, const T &amp;L)</td></tr>
<tr class="memdesc:af26c23e707688c5fe5f0c71f22fbee62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unit inertia for a unit-mass cylinder of uniform density oriented along the z-axis computed about a point at the center of its base.  <a href="#af26c23e707688c5fe5f0c71f22fbee62">More...</a><br /></td></tr>
<tr class="separator:af26c23e707688c5fe5f0c71f22fbee62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66b55a2788b7027b92ef7434da5569b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#aa66b55a2788b7027b92ef7434da5569b">AxiallySymmetric</a> (const T &amp;J, const T &amp;K, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;b_E)</td></tr>
<tr class="memdesc:aa66b55a2788b7027b92ef7434da5569b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unit inertia for a unit-mass body B for which there exists a line L passing through the body's center of mass <code>Bcm</code> having the property that the body's moment of inertia about all lines perpendicular to L are equal.  <a href="#aa66b55a2788b7027b92ef7434da5569b">More...</a><br /></td></tr>
<tr class="separator:aa66b55a2788b7027b92ef7434da5569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e6f8e48b01a027112221c2e59ddbad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#aa7e6f8e48b01a027112221c2e59ddbad">StraightLine</a> (const T &amp;K, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;b_E)</td></tr>
<tr class="memdesc:aa7e6f8e48b01a027112221c2e59ddbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unit inertia for a body B of unit-mass uniformly distributed along a straight, finite, line L with direction <code>b_E</code> and with moment of inertia K about any axis perpendicular to this line.  <a href="#aa7e6f8e48b01a027112221c2e59ddbad">More...</a><br /></td></tr>
<tr class="separator:aa7e6f8e48b01a027112221c2e59ddbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902f33de7ecd8ef964190051ee56588c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a902f33de7ecd8ef964190051ee56588c">ThinRod</a> (const T &amp;L, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;b_E)</td></tr>
<tr class="memdesc:a902f33de7ecd8ef964190051ee56588c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unit inertia for a unit mass rod B of length L, about its center of mass, with its mass uniformly distributed along a line parallel to vector <code>b_E</code>.  <a href="#a902f33de7ecd8ef964190051ee56588c">More...</a><br /></td></tr>
<tr class="separator:a902f33de7ecd8ef964190051ee56588c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870636b327cc9cd813547c32c45a06c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a870636b327cc9cd813547c32c45a06c1">TriaxiallySymmetric</a> (const T &amp;I_triaxial)</td></tr>
<tr class="memdesc:a870636b327cc9cd813547c32c45a06c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a unit inertia with equal moments of inertia along its diagonal and with each product of inertia set to zero.  <a href="#a870636b327cc9cd813547c32c45a06c1">More...</a><br /></td></tr>
<tr class="separator:a870636b327cc9cd813547c32c45a06c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classdrake_1_1multibody_1_1_rotational_inertia')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia&lt; T &gt;</a></td></tr>
<tr class="memitem:a96949d335bfe501c62587705d47ce6ad inherit pub_static_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a96949d335bfe501c62587705d47ce6ad">TriaxiallySymmetric</a> (const T &amp;I_triaxial)</td></tr>
<tr class="memdesc:a96949d335bfe501c62587705d47ce6ad inherit pub_static_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rotational inertia with equal moments of inertia along its diagonal and with each product of inertia set to zero.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#a96949d335bfe501c62587705d47ce6ad">More...</a><br /></td></tr>
<tr class="separator:a96949d335bfe501c62587705d47ce6ad inherit pub_static_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdrake_1_1multibody_1_1_rotational_inertia')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia&lt; T &gt;</a></td></tr>
<tr class="memitem:af016e2a9451f4692a56bec5209ddbaf5 inherit pro_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#af016e2a9451f4692a56bec5209ddbaf5">MinusEqualsUnchecked</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:af016e2a9451f4692a56bec5209ddbaf5 inherit pro_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#af016e2a9451f4692a56bec5209ddbaf5">More...</a><br /></td></tr>
<tr class="separator:af016e2a9451f4692a56bec5209ddbaf5 inherit pro_methods_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classdrake_1_1multibody_1_1_rotational_inertia"><td colspan="2" onclick="javascript:toggleInherit('related_classdrake_1_1multibody_1_1_rotational_inertia')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia&lt; T &gt;</a></td></tr>
<tr class="memitem:ab220ab02073a10f117b7b355a7596010 inherit related_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab220ab02073a10f117b7b355a7596010 inherit related_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab220ab02073a10f117b7b355a7596010">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I)</td></tr>
<tr class="memdesc:ab220ab02073a10f117b7b355a7596010 inherit related_classdrake_1_1multibody_1_1_rotational_inertia"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion operator to write RotationalInertia's into a <code>std::ostream</code>.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab220ab02073a10f117b7b355a7596010">More...</a><br /></td></tr>
<tr class="separator:ab220ab02073a10f117b7b355a7596010 inherit related_classdrake_1_1multibody_1_1_rotational_inertia"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::UnitInertia&lt; T &gt;</h3>

<p>This class is used to represent rotational inertias for unit mass bodies. </p>
<p>Therefore, unlike <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class helps describe the mass distribution (inertia properties) of a body or composite body abou...">RotationalInertia</a> whose units are kg⋅m², the units of a UnitInertia are those of length squared. A unit inertia is a useful concept to represent the geometric distribution of mass in a body regardless of the actual value of the body mass. The rotational inertia of a body can therefore be obtained by multiplying its unit inertia by its mass. Unit inertia matrices can also be called <b>gyration</b> matrices and therefore we choose to represent them in source code notation with the capital letter G. In contrast, the capital letter I is used to represent non-unit mass rotational inertias. This class restricts the set of allowed operations on a unit inertia to ensure the unit-mass invariant. For instance, multiplication by a scalar can only return a general <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class helps describe the mass distribution (inertia properties) of a body or composite body abou...">RotationalInertia</a> but not a UnitInertia.</p>
<dl class="section note"><dt>Note</dt><dd>This class has no means to check at construction from user provided parameters whether it actually represents the unit inertia or gyration matrix of a unit-mass body. However, as previously noted, once a unit inertia is created, a number of operations are disallowed to ensure the unit-mass invariant. Also notice that once a unit inertia is created, it <em>is</em> the unit inertia of <em>some</em> body, perhaps with scaled geometry from the user's intention.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The underlying scalar type. Must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar.</td></tr>
  </table>
  </dd>
</dl>
<p>Instantiated templates for the following kinds of T's are provided:</p>
<ul>
<li>double</li>
<li>AutoDiffXd</li>
<li><a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">symbolic::Expression</a></li>
</ul>
<p>They are already available to link against in the containing library. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6dcd4923027cb6fa0b9ad164c211ceae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dcd4923027cb6fa0b9ad164c211ceae">&#9670;&nbsp;</a></span>UnitInertia() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a924ebae0ded3ad97827dfe1564c1c368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924ebae0ded3ad97827dfe1564c1c368">&#9670;&nbsp;</a></span>UnitInertia() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af90ef8ef37ca899a26ab2963124f85e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90ef8ef37ca899a26ab2963124f85e9">&#9670;&nbsp;</a></span>UnitInertia() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default UnitInertia constructor sets all entries to NaN for quick detection of uninitialized values. </p>

</div>
</div>
<a id="aa9314ec0aaa546381e720cd991f07dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9314ec0aaa546381e720cd991f07dee">&#9670;&nbsp;</a></span>UnitInertia() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Iyy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Izz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a unit inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with each product of inertia set to zero. </p>
<p>In debug builds, throws std::logic_error if unit inertia constructed from these arguments violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">RotationalInertia::CouldBePhysicallyValid()</a>. </p>

</div>
</div>
<a id="a79df22b67e93b31938267a4df9527293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79df22b67e93b31938267a4df9527293">&#9670;&nbsp;</a></span>UnitInertia() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Iyy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Izz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Iyz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a unit inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with products of inertia <code>Ixy</code>, <code>Ixz</code>, <code>Iyz</code>. </p>
<p>In debug builds, throws std::logic_error if unit inertia constructed from these arguments violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">RotationalInertia::CouldBePhysicallyValid()</a>. </p>

</div>
</div>
<a id="ab29844d6e36bf50f6bf5bb44b5d05205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29844d6e36bf50f6bf5bb44b5d05205">&#9670;&nbsp;</a></span>UnitInertia() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a UnitInertia from a <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class helps describe the mass distribution (inertia properties) of a body or composite body abou...">RotationalInertia</a>. </p>
<p>This constructor has no way to verify that the input rotational inertia actually is a unit inertia. But the construction will nevertheless succeed, and the values of the input rotational inertia will henceforth be considered a valid unit inertia. It is the responsibility of the user to pass a valid unit inertia. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa66b55a2788b7027b92ef7434da5569b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66b55a2788b7027b92ef7434da5569b">&#9670;&nbsp;</a></span>AxiallySymmetric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; AxiallySymmetric </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unit inertia for a unit-mass body B for which there exists a line L passing through the body's center of mass <code>Bcm</code> having the property that the body's moment of inertia about all lines perpendicular to L are equal. </p>
<p>Examples of bodies with an axially symmetric inertia include axisymmetric objects such as cylinders and cones. Other commonly occurring geometries with this property are, for instance, propellers with 3+ evenly spaced blades. Given a unit vector b defining the symmetry line L, the moment of inertia J about this line L and the moment of inertia K about any line perpendicular to L, the axially symmetric unit inertia G is computed as: </p><pre>
  G = K * Id + (J - K) * b ⊗ b
</pre><p> where <code>Id</code> is the identity matrix and ⊗ denotes the tensor product operator. See Mitiguy, P., 2016. Advanced Dynamics &amp; Motion Simulation.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td><ul>
<li>J is negative. J can be zero.</li>
<li>K is negative. K can be zero.</li>
<li>J ≤ 2 * K, this corresponds to the triangle inequality, see <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>.</li>
<li><code>b_E</code> is the zero vector. That is if <code>‖b_E‖₂ ≤ ε</code>, where ε is the machine epsilon.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>J is a principal moment of inertia with principal axis equal to b. K is a principal moment with multiplicity of two. Any two axes perpendicular to b are principal axes with principal moment K.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>Unit inertia about axis b. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>Unit inertia about any axis perpendicular to b. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b_E</td><td>Vector defining the symmetry axis, expressed in a frame E. <code>b_E</code> can have a norm different from one; however, it will be normalized before using it. Therefore its norm is ignored and only its direction is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">G_Bcm_E</td><td>An axially symmetric unit inertia about body B's center of mass, expressed in the same frame E as the input unit vector <code>b_E</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3b0fa29234319721cd8689fdb111c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b0fa29234319721cd8689fdb111c23">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;Scalar&gt; cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new UnitInertia object templated on <code>Scalar</code> initialized from the value of <code>this</code> unit inertia. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type on which the new unit inertia will be templated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html" title="This class is used to represent rotational inertias for unit mass bodies. ">UnitInertia</a>&lt;From&gt;::cast&lt;To&gt;()</code> creates a new <code><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html" title="This class is used to represent rotational inertias for unit mass bodies. ">UnitInertia</a>&lt;To&gt;</code> from a <code><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html" title="This class is used to represent rotational inertias for unit mass bodies. ">UnitInertia</a>&lt;From&gt;</code> but only if type <code>To</code> is constructible from type <code>From</code>. As an example of this, <code><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html" title="This class is used to represent rotational inertias for unit mass bodies. ">UnitInertia</a>&lt;double&gt;::cast&lt;AutoDiffXd&gt;()</code> is valid since <code>AutoDiffXd a(1.0)</code> is valid. However, <code><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html" title="This class is used to represent rotational inertias for unit mass bodies. ">UnitInertia</a>&lt;AutoDiffXd&gt;::cast&lt;double&gt;()</code> is not. </dd></dl>

</div>
</div>
<a id="a398457f90a21345f211ed527c6e9c6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398457f90a21345f211ed527c6e9c6c7">&#9670;&nbsp;</a></span>DRAKE_DEPRECATED() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DRAKE_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;Use <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;::<a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#af2147d14d9c65f7935c1ace3a3e037ee">ReExpressInPlace</a>(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February&#160;</td>
          <td class="paramname"><em>5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2019.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab10aa84acfbe46cbcf5bc440d3aeb2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10aa84acfbe46cbcf5bc440d3aeb2b0">&#9670;&nbsp;</a></span>DRAKE_DEPRECATED() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DRAKE_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;Use <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt;::<a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#ab8231314dc085af878e5ff89cd36b40a">ReExpress</a>(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February&#160;</td>
          <td class="paramname"><em>5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2019.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a18e7babe23518ac81fc0a3c1c7157496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e7babe23518ac81fc0a3c1c7157496">&#9670;&nbsp;</a></span>HollowSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; HollowSphere </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the unit inertia for a unit-mass hollow sphere of radius <code>r</code> consisting of an infinitesimally thin shell of uniform density. </p>
<p>The unit inertia is taken about the center of the sphere. </p>

</div>
</div>
<a id="a908300bf2b212d2526fa5803f732dba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908300bf2b212d2526fa5803f732dba2">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa16a9cdf1bf2f4e7f59af88fb90ea4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16a9cdf1bf2f4e7f59af88fb90ea4f8">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9a91ea3d4a5c586d46ba46000f12541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a91ea3d4a5c586d46ba46000f12541">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af82325138e40aa8b7ecb26c7d8ef3aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82325138e40aa8b7ecb26c7d8ef3aa6">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a329d230352494812d0e1662fb73f4ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329d230352494812d0e1662fb73f4ff8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e321b3b8489b5519c9bc079ad3b521a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e321b3b8489b5519c9bc079ad3b521a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6f93bf07bd55dd7ab860b0c321713c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f93bf07bd55dd7ab860b0c321713c0">&#9670;&nbsp;</a></span>PointMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; PointMass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a unit inertia for a point mass of unit mass located at point Q, whose location in a frame F is given by the position vector <code>p_FQ</code> (that is, p_FoQ_F). </p>
<p>The unit inertia <code>G_QFo_F</code> of point mass Q about the origin <code>Fo</code> of frame F and expressed in F for this unit mass point equals the square of the cross product matrix of <code>p_FQ</code>. In coordinate-free form: </p><p class="formulaDsp">
\[ G^{Q/F_o} = (^Fp^Q_\times)^2 = (^Fp^Q_\times)^T \, ^Fp^Q_\times = -^Fp^Q_\times \, ^Fp^Q_\times \]
</p>
<p> where \( ^Fp^Q_\times \) is the cross product matrix of vector \( ^Fp^Q \). In source code the above expression is written as: </p><pre>
  G_QFo_F = px_FQ² = px_FQᵀ * px_FQ = -px_FQ * px_FQ
</pre><p> where <code>px_FQ</code> denotes the cross product matrix of the position vector <code>p_FQ</code> (expressed in F) such that the cross product with another vector <code>a</code> can be obtained as <code>px.cross(a) = px * a</code>. The cross product matrix <code>px</code> is skew-symmetric. The square of the cross product matrix is a symmetric matrix with non-negative diagonals and obeys the triangle inequality. Matrix <code>px²</code> can be used to compute the triple vector product as <code>-p x (p x a) = -p.cross(p.cross(a)) = px² * a</code>. </p>

</div>
</div>
<a id="ab8231314dc085af878e5ff89cd36b40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8231314dc085af878e5ff89cd36b40a">&#9670;&nbsp;</a></span>ReExpress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; ReExpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FE</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <code>this</code> unit inertia <code>G_BP_E</code> of a body B about a point P and expressed in frame E, this method computes the same unit inertia re-expressed in another frame F as <code>G_BP_F = R_FE * G_BP_E * (R_FE)ᵀ</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_FE</td><td>RotationMatrix relating frames F and E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">G_BP_F</td><td>The same unit inertia for body B about point P but now re-expressed in frame F. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2147d14d9c65f7935c1ace3a3e037ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2147d14d9c65f7935c1ace3a3e037ee">&#9670;&nbsp;</a></span>ReExpressInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt;&amp; ReExpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FE</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-express a unit inertia in a different frame, performing the operation in place and modifying the original object. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#ab8231314dc085af878e5ff89cd36b40a" title="Given this unit inertia G_BP_E of a body B about a point P and expressed in frame E...">ReExpress()</a> for details. </dd></dl>

</div>
</div>
<a id="a8569b38683ca9da5ebd7d02e76a74302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8569b38683ca9da5ebd7d02e76a74302">&#9670;&nbsp;</a></span>SetFromRotationalInertia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt;&amp; SetFromRotationalInertia </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>this</code> unit inertia from a generally non-unit inertia I corresponding to a body with a given <code>mass</code>. </p>
<dl class="section note"><dt>Note</dt><dd>In Debug builds, this operation aborts if the provided <code>mass</code> is not strictly positive. </dd></dl>

</div>
</div>
<a id="a9d7a991d6fb01efebd0654f57018b7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7a991d6fb01efebd0654f57018b7d4">&#9670;&nbsp;</a></span>ShiftFromCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; ShiftFromCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BcQ_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts this central unit inertia to a different point, and returns the result. </p>
<p>See <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a44b718707c9e2b7fe417950a8ba4c57e" title="For a central unit inertia G_Bcm_E computed about a body&#39;s center of mass (or centroid) Bcm and expre...">ShiftFromCenterOfMassInPlace()</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BcmQ_E</td><td>A vector from the body's centroid <code>Bcm</code> to point Q expressed in the same frame E in which <code>this</code> inertia is expressed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">G_BQ_E</td><td>This same unit inertia taken about a point Q instead of the centroid <code>Bcm</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44b718707c9e2b7fe417950a8ba4c57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b718707c9e2b7fe417950a8ba4c57e">&#9670;&nbsp;</a></span>ShiftFromCenterOfMassInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt;&amp; ShiftFromCenterOfMassInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BcQ_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a central unit inertia <code>G_Bcm_E</code> computed about a body's center of mass (or centroid) <code>Bcm</code> and expressed in a frame E, this method shifts this inertia using the parallel axis theorem to be computed about a point Q. </p>
<p>This operation is performed in place, modifying the original object which is no longer a central inertia. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BcmQ_E</td><td>A vector from the body's centroid <code>Bcm</code> to point Q expressed in the same frame E in which <code>this</code> inertia is expressed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> unit inertia, which has now been taken about point Q so can be written as <code>G_BQ_E</code>. </dd></dl>

</div>
</div>
<a id="a15446b478364a5bd0a74419bd7a0b719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15446b478364a5bd0a74419bd7a0b719">&#9670;&nbsp;</a></span>ShiftToCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; ShiftToCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_QBcm_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For the unit inertia <code>G_BQ_E</code> of a body or composite body B computed about a point Q and expressed in a frame E, this method shifts this inertia using the parallel axis theorem to be computed about the center of mass <code>Bcm</code> of B. </p>
<p>See <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a63b39c6656200a848579b87b986f6965" title="For the unit inertia G_BQ_E of a body or composite body B computed about a point Q and expressed in a...">ShiftToCenterOfMassInPlace()</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_QBcm_E</td><td>A position vector from the about point Q to the body's centroid <code>Bcm</code> expressed in the same frame E in which <code>this</code> inertia is expressed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">G_Bcm_E</td><td>This same unit which has now been taken about point <code>Bcm</code> so that it can be written as <code>G_BBcm_E</code>, or <code>G_Bcm_E</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation could result in a non-physical rotational inertia. Use with care. See <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a63b39c6656200a848579b87b986f6965" title="For the unit inertia G_BQ_E of a body or composite body B computed about a point Q and expressed in a...">ShiftToCenterOfMassInPlace()</a> for details. </dd></dl>

</div>
</div>
<a id="a63b39c6656200a848579b87b986f6965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b39c6656200a848579b87b986f6965">&#9670;&nbsp;</a></span>ShiftToCenterOfMassInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt;&amp; ShiftToCenterOfMassInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_QBcm_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For the unit inertia <code>G_BQ_E</code> of a body or composite body B computed about a point Q and expressed in a frame E, this method shifts this inertia using the parallel axis theorem to be computed about the center of mass <code>Bcm</code> of B. </p>
<p>This operation is performed in place, modifying the original object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_QBcm_E</td><td>A position vector from the about point Q to the body's centroid <code>Bcm</code> expressed in the same frame E in which <code>this</code> inertia is expressed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> unit inertia, which has now been taken about point <code>Bcm</code> so can be written as <code>G_BBcm_E</code>, or <code>G_Bcm_E</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation could result in a non-physical rotational inertia. The shifted inertia is obtained by subtracting the point mass unit inertia of point <code>Bcm</code> about point Q as: G_Bcm_E = G_BQ_E - G_BcmQ_E = G_BQ_E - px_QBcm_E² Therefore the resulting inertia could have negative moments of inertia if the unit inertia of the unit mass at point <code>Bcm</code> is larger than <code>G_BQ_E</code>. Use with care. </dd></dl>

</div>
</div>
<a id="a508911b2ad53d5a156259e5b4690278a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508911b2ad53d5a156259e5b4690278a">&#9670;&nbsp;</a></span>SolidBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; SolidBox </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Lx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Lz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the unit inertia for a unit-mass solid box of uniform density taken about its geometric center. </p>
<p>If one length is zero the inertia corresponds to that of a thin rectangular sheet. If two lengths are zero the inertia corresponds to that of a thin rod in the remaining direction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Lx</td><td>The length of the box edge in the principal x-axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ly</td><td>The length of the box edge in the principal y-axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Lz</td><td>The length of the box edge in the principal z-axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a224f50a8d9351914db96e47ddb5767fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224f50a8d9351914db96e47ddb5767fb">&#9670;&nbsp;</a></span>SolidCube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; SolidCube </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the unit inertia for a unit-mass solid cube (a box with equal-sized sides) of uniform density taken about its geometric center. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>The length of each of the cube's sides. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa752eb88a4a3eb76242ccb373b81ccf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa752eb88a4a3eb76242ccb373b81ccf3">&#9670;&nbsp;</a></span>SolidCylinder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; SolidCylinder </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_E</em> = <code><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;::UnitZ()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the unit inertia for a unit-mass cylinder B, of uniform density, having its axis of revolution along input vector <code>b_E</code>. </p>
<p>The resulting unit inertia is computed about the cylinder's center of mass <code>Bcm</code> and is expressed in the same frame E as the input axis of revolution <code>b_E</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>The radius of the cylinder, it must be non-negative. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>The length of the cylinder, it must be non-negative. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b_E</td><td>Vector defining the axis of revolution of the cylinder, expressed in a frame E. <code>b_E</code> can have a norm different from one; however, it will be normalized before using it. Therefore its norm is ignored and only its direction is used. It defaults to <code>Vector3&lt;T&gt;::UnitZ()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">G_Bcm_E</td><td>The unit inertia for a solid cylinder B, of uniform density, with axis of revolution along <code>b_E</code>, computed about the cylinder's center of mass <code>Bcm</code>, and expressed in the same frame E as the input axis of rotation <code>b_E</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td><ul>
<li>Radius r is negative.</li>
<li>Length L is negative.</li>
<li><code>b_E</code> is the zero vector. That is if <code>‖b_E‖₂ ≤ ε</code>, where ε is the machine epsilon. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af26c23e707688c5fe5f0c71f22fbee62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26c23e707688c5fe5f0c71f22fbee62">&#9670;&nbsp;</a></span>SolidCylinderAboutEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; SolidCylinderAboutEnd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the unit inertia for a unit-mass cylinder of uniform density oriented along the z-axis computed about a point at the center of its base. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>The radius of the cylinder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>The length of the cylinder. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf3d4bf1e85ad1942c12478e5e3aa906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3d4bf1e85ad1942c12478e5e3aa906">&#9670;&nbsp;</a></span>SolidSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; SolidSphere </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the unit inertia for a unit-mass solid sphere of uniform density and radius <code>r</code> taken about its center. </p>

</div>
</div>
<a id="aa7e6f8e48b01a027112221c2e59ddbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e6f8e48b01a027112221c2e59ddbad">&#9670;&nbsp;</a></span>StraightLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; StraightLine </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the unit inertia for a body B of unit-mass uniformly distributed along a straight, finite, line L with direction <code>b_E</code> and with moment of inertia K about any axis perpendicular to this line. </p>
<p>Since the mass of the body is uniformly distributed on this line L, its center of mass is located right at the center. As an example, consider the inertia of a thin rod for which its transversal dimensions can be neglected, see <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a902f33de7ecd8ef964190051ee56588c" title="Computes the unit inertia for a unit mass rod B of length L, about its center of mass, with its mass uniformly distributed along a line parallel to vector b_E. ">ThinRod()</a>.</p>
<p>This method aborts if K is not positive.</p>
<dl class="section note"><dt>Note</dt><dd>This is the particular case for an axially symmetric unit inertia with zero moment about its axis, see <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#aa66b55a2788b7027b92ef7434da5569b" title="Returns the unit inertia for a unit-mass body B for which there exists a line L passing through the b...">AxiallySymmetric()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>Unit inertia about any axis perpendicular to the line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b_E</td><td>Vector defining the direction of the line, expressed in a frame E. <code>b_E</code> can have a norm different from one. Its norm is ignored and only its direction is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">G_Bcm_E</td><td>The unit inertia for a body B of unit mass uniformly distributed along a straight line L, about its center of mass <code>Bcm</code> which is located at the center of the line, expressed in the same frame E as the input unit vector <code>b_E</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a902f33de7ecd8ef964190051ee56588c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902f33de7ecd8ef964190051ee56588c">&#9670;&nbsp;</a></span>ThinRod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; ThinRod </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the unit inertia for a unit mass rod B of length L, about its center of mass, with its mass uniformly distributed along a line parallel to vector <code>b_E</code>. </p>
<p>This method aborts if L is not positive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>The length of the rod. It must be positive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b_E</td><td>Vector defining the axis of the rod, expressed in a frame E. <code>b_E</code> can have a norm different from one. Its norm is ignored and only its direction is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">G_Bcm_E</td><td>The unit inertia of the rod B about its center of mass <code>Bcm</code>, expressed in the same frame E as the input unit vector <code>b_E</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a870636b327cc9cd813547c32c45a06c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870636b327cc9cd813547c32c45a06c1">&#9670;&nbsp;</a></span>TriaxiallySymmetric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt; TriaxiallySymmetric </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>I_triaxial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a unit inertia with equal moments of inertia along its diagonal and with each product of inertia set to zero. </p>
<p>This factory is useful for the unit inertia of a uniform-density sphere or cube. In debug builds, throws std::logic_error if I_triaxial is negative/NaN. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#adf3d4bf1e85ad1942c12478e5e3aa906" title="Computes the unit inertia for a unit-mass solid sphere of uniform density and radius r taken about it...">UnitInertia::SolidSphere()</a> and <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html#a224f50a8d9351914db96e47ddb5767fb" title="Computes the unit inertia for a unit-mass solid cube (a box with equal-sized sides) of uniform densit...">UnitInertia::SolidCube()</a> for <a class="el" href="namespacedrake_1_1examples.html">examples</a>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/tree/<a class="el" href="unit__inertia_8h.html">unit_inertia.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
