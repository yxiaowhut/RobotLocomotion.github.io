<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: GenericPlan&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GenericPlan&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents a plan interpretor, which conceptually serves as a bridge between a high level planner (e.g.  
 <a href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#details">More...</a></p>

<p><code>#include &lt;drake/attic/systems/controllers/plan_eval/generic_plan.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e6f0c2d24101e2bf2ccbdaab4b6d24d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a2e6f0c2d24101e2bf2ccbdaab4b6d24d">Clone</a> () const</td></tr>
<tr class="memdesc:a2e6f0c2d24101e2bf2ccbdaab4b6d24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unique pointer to a copy of this instance.  <a href="#a2e6f0c2d24101e2bf2ccbdaab4b6d24d">More...</a><br /></td></tr>
<tr class="separator:a2e6f0c2d24101e2bf2ccbdaab4b6d24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87dddadb6e66a15733f7f3de5e35e7ac"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a87dddadb6e66a15733f7f3de5e35e7ac">~GenericPlan</a> ()</td></tr>
<tr class="separator:a87dddadb6e66a15733f7f3de5e35e7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a9c0820d6dd26e76ca531e0509f6fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a98a9c0820d6dd26e76ca531e0509f6fd">Initialize</a> (const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;robot_status, const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;paramset, const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;alias_groups)</td></tr>
<tr class="memdesc:a98a9c0820d6dd26e76ca531e0509f6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this plan.  <a href="#a98a9c0820d6dd26e76ca531e0509f6fd">More...</a><br /></td></tr>
<tr class="separator:a98a9c0820d6dd26e76ca531e0509f6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29c375b19391669ca40b3a946e95efd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#ac29c375b19391669ca40b3a946e95efd">ModifyPlan</a> (const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;robot_status, const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;paramset, const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;alias_groups)</td></tr>
<tr class="memdesc:ac29c375b19391669ca40b3a946e95efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control logic should be implemented in this function.  <a href="#ac29c375b19391669ca40b3a946e95efd">More...</a><br /></td></tr>
<tr class="separator:ac29c375b19391669ca40b3a946e95efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0d0f1d25238564b0baeedecb678a8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a3a0d0f1d25238564b0baeedecb678a8b">HandlePlan</a> (const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;robot_status, const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;paramset, const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;alias_groups, const <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">systems::AbstractValue</a> &amp;plan)</td></tr>
<tr class="memdesc:a3a0d0f1d25238564b0baeedecb678a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a discrete plan (e.g.  <a href="#a3a0d0f1d25238564b0baeedecb678a8b">More...</a><br /></td></tr>
<tr class="separator:a3a0d0f1d25238564b0baeedecb678a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9614f5e9faf3f3cfa85c2f843d9e4dd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a9614f5e9faf3f3cfa85c2f843d9e4dd5">UpdateQpInput</a> (const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;robot_status, const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;paramset, const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;alias_groups, <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_qp_input.html">systems::controllers::qp_inverse_dynamics::QpInput</a> *qp_input) const</td></tr>
<tr class="memdesc:a9614f5e9faf3f3cfa85c2f843d9e4dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>qp_input</code> given the current state of the plan and measured robot state in <code>robot_status</code>.  <a href="#a9614f5e9faf3f3cfa85c2f843d9e4dd5">More...</a><br /></td></tr>
<tr class="separator:a9614f5e9faf3f3cfa85c2f843d9e4dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c2d020ba2b2678379ef0252b511941"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1systems_1_1controllers_1_1plan__eval.html#af544cc03f89544a07be19198582d9bcd">ContactState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a52c2d020ba2b2678379ef0252b511941">get_planned_contact_state</a> () const</td></tr>
<tr class="memdesc:a52c2d020ba2b2678379ef0252b511941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current planned contact state.  <a href="#a52c2d020ba2b2678379ef0252b511941">More...</a><br /></td></tr>
<tr class="separator:a52c2d020ba2b2678379ef0252b511941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835c82a92d0e112858fc6b0946e12b1e"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *, <a class="el" href="classdrake_1_1manipulation_1_1_piecewise_cartesian_trajectory.html">manipulation::PiecewiseCartesianTrajectory</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a835c82a92d0e112858fc6b0946e12b1e">get_body_trajectories</a> () const</td></tr>
<tr class="memdesc:a835c82a92d0e112858fc6b0946e12b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of all Cartesian trajectories.  <a href="#a835c82a92d0e112858fc6b0946e12b1e">More...</a><br /></td></tr>
<tr class="separator:a835c82a92d0e112858fc6b0946e12b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da479515c5a009182a9ce79d7e21061"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1manipulation_1_1_piecewise_cartesian_trajectory.html">manipulation::PiecewiseCartesianTrajectory</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a4da479515c5a009182a9ce79d7e21061">get_body_trajectory</a> (const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *body) const</td></tr>
<tr class="memdesc:a4da479515c5a009182a9ce79d7e21061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Cartesian trajectory for <code>body</code>.  <a href="#a4da479515c5a009182a9ce79d7e21061">More...</a><br /></td></tr>
<tr class="separator:a4da479515c5a009182a9ce79d7e21061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa38608aa67d0ce04b54724e7db4a85"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1manipulation_1_1_piecewise_cubic_trajectory.html">manipulation::PiecewiseCubicTrajectory</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#acfa38608aa67d0ce04b54724e7db4a85">get_dof_trajectory</a> () const</td></tr>
<tr class="memdesc:acfa38608aa67d0ce04b54724e7db4a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns trajectory for all degrees of freedom.  <a href="#acfa38608aa67d0ce04b54724e7db4a85">More...</a><br /></td></tr>
<tr class="separator:acfa38608aa67d0ce04b54724e7db4a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569c4b7dfd2fa659473094444ecbfe15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a569c4b7dfd2fa659473094444ecbfe15">has_body_trajectory</a> (const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *body) const</td></tr>
<tr class="memdesc:a569c4b7dfd2fa659473094444ecbfe15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is a Cartesian trajectory for <code>body</code>.  <a href="#a569c4b7dfd2fa659473094444ecbfe15">More...</a><br /></td></tr>
<tr class="separator:a569c4b7dfd2fa659473094444ecbfe15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4a6b9e8ec1131058a9af73794e343e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#afc4a6b9e8ec1131058a9af73794e343e">IsRigidBodyTreeCompatible</a> (const <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; T &gt; &amp;robot) const</td></tr>
<tr class="memdesc:afc4a6b9e8ec1131058a9af73794e343e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>robot</code> is compatible.  <a href="#afc4a6b9e8ec1131058a9af73794e343e">More...</a><br /></td></tr>
<tr class="separator:afc4a6b9e8ec1131058a9af73794e343e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2870a638d45e4506364a56d1cd378d65"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a2870a638d45e4506364a56d1cd378d65">IsRigidBodyTreeAliasGroupsCompatible</a> (const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;alias_groups) const</td></tr>
<tr class="memdesc:a2870a638d45e4506364a56d1cd378d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>alias_groups</code> is compatible.  <a href="#a2870a638d45e4506364a56d1cd378d65">More...</a><br /></td></tr>
<tr class="separator:a2870a638d45e4506364a56d1cd378d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc10368f00b01f829f4a12e4fb0ab05"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a0cc10368f00b01f829f4a12e4fb0ab05">IsParamSetCompatible</a> (const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;paramset) const</td></tr>
<tr class="memdesc:a0cc10368f00b01f829f4a12e4fb0ab05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>paramset</code> is compatible.  <a href="#a0cc10368f00b01f829f4a12e4fb0ab05">More...</a><br /></td></tr>
<tr class="separator:a0cc10368f00b01f829f4a12e4fb0ab05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad5a722b7e80e6c00c73a7c58d2cd8487"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#ad5a722b7e80e6c00c73a7c58d2cd8487">GenericPlan</a> ()</td></tr>
<tr class="memdesc:ad5a722b7e80e6c00c73a7c58d2cd8487"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is convenient to separate allocation with initialization because the later commonly depends on extra information such as measured robot state.  <a href="#ad5a722b7e80e6c00c73a7c58d2cd8487">More...</a><br /></td></tr>
<tr class="separator:ad5a722b7e80e6c00c73a7c58d2cd8487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80d19a3138d262af6743c36ea5ed660"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#ac80d19a3138d262af6743c36ea5ed660">CloneGenericPlanDerived</a> () const =0</td></tr>
<tr class="memdesc:ac80d19a3138d262af6743c36ea5ed660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom fields can be cloned here.  <a href="#ac80d19a3138d262af6743c36ea5ed660">More...</a><br /></td></tr>
<tr class="separator:ac80d19a3138d262af6743c36ea5ed660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c53822078fb0a47d0589dc2be65ec7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#ac5c53822078fb0a47d0589dc2be65ec7">InitializeGenericPlanDerived</a> (const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;robot_status, const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;paramset, const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;alias_groups)=0</td></tr>
<tr class="memdesc:ac5c53822078fb0a47d0589dc2be65ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom initialization can be implemented here.  <a href="#ac5c53822078fb0a47d0589dc2be65ec7">More...</a><br /></td></tr>
<tr class="separator:ac5c53822078fb0a47d0589dc2be65ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc891a0ff49d00008fe11bc070b0627"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#adfc891a0ff49d00008fe11bc070b0627">ModifyPlanGenericPlanDerived</a> (const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;robot_status, const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;paramset, const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;alias_groups)=0</td></tr>
<tr class="memdesc:adfc891a0ff49d00008fe11bc070b0627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom state mutation can be implemented here.  <a href="#adfc891a0ff49d00008fe11bc070b0627">More...</a><br /></td></tr>
<tr class="separator:adfc891a0ff49d00008fe11bc070b0627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fd650e5c407d9876b4dda11892cef2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#ac6fd650e5c407d9876b4dda11892cef2">HandlePlanGenericPlanDerived</a> (const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;robot_status, const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;paramset, const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;alias_groups, const <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">systems::AbstractValue</a> &amp;plan)=0</td></tr>
<tr class="memdesc:ac6fd650e5c407d9876b4dda11892cef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom plan handling can be implemented here.  <a href="#ac6fd650e5c407d9876b4dda11892cef2">More...</a><br /></td></tr>
<tr class="separator:ac6fd650e5c407d9876b4dda11892cef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbb804feea336cd76eac958dbc64521"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#afdbb804feea336cd76eac958dbc64521">UpdateQpInputGenericPlanDerived</a> (const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;robot_status, const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;paramset, const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;alias_groups, <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_qp_input.html">systems::controllers::qp_inverse_dynamics::QpInput</a> *qp_input) const =0</td></tr>
<tr class="memdesc:afdbb804feea336cd76eac958dbc64521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom QpInput updates can be implemented here.  <a href="#afdbb804feea336cd76eac958dbc64521">More...</a><br /></td></tr>
<tr class="separator:afdbb804feea336cd76eac958dbc64521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02642b00fec0747e133cc2c8c9a43e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#ac02642b00fec0747e133cc2c8c9a43e1">UpdateContactState</a> (const <a class="el" href="namespacedrake_1_1systems_1_1controllers_1_1plan__eval.html#af544cc03f89544a07be19198582d9bcd">ContactState</a> &amp;contact_state)</td></tr>
<tr class="memdesc:ac02642b00fec0747e133cc2c8c9a43e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the planned contact state to <code>contact_state</code>.  <a href="#ac02642b00fec0747e133cc2c8c9a43e1">More...</a><br /></td></tr>
<tr class="separator:ac02642b00fec0747e133cc2c8c9a43e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818a3cd09958ade6d12932d5d8a79313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a818a3cd09958ade6d12932d5d8a79313">set_body_trajectory</a> (const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *body, const <a class="el" href="classdrake_1_1manipulation_1_1_piecewise_cartesian_trajectory.html">manipulation::PiecewiseCartesianTrajectory</a>&lt; T &gt; &amp;traj)</td></tr>
<tr class="memdesc:a818a3cd09958ade6d12932d5d8a79313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a Cartesian trajectory for <code>body</code>.  <a href="#a818a3cd09958ade6d12932d5d8a79313">More...</a><br /></td></tr>
<tr class="separator:a818a3cd09958ade6d12932d5d8a79313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83fd7abd615134ba06a664ab16a88d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#ad83fd7abd615134ba06a664ab16a88d2">remove_body_trajectory</a> (const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *body)</td></tr>
<tr class="memdesc:ad83fd7abd615134ba06a664ab16a88d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a Cartesian trajectory for <code>body</code>.  <a href="#ad83fd7abd615134ba06a664ab16a88d2">More...</a><br /></td></tr>
<tr class="separator:ad83fd7abd615134ba06a664ab16a88d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39999496388bfe806fe9cbe5822b7de6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a39999496388bfe806fe9cbe5822b7de6">set_dof_trajectory</a> (const <a class="el" href="classdrake_1_1manipulation_1_1_piecewise_cubic_trajectory.html">manipulation::PiecewiseCubicTrajectory</a>&lt; T &gt; &amp;traj)</td></tr>
<tr class="memdesc:a39999496388bfe806fe9cbe5822b7de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets dof trajectory to <code>traj</code>.  <a href="#a39999496388bfe806fe9cbe5822b7de6">More...</a><br /></td></tr>
<tr class="separator:a39999496388bfe806fe9cbe5822b7de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9b026cc01616e96595a473fba4d4c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a4d9b026cc01616e96595a473fba4d4c4">CheckCompatibilityAndThrow</a> (const <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; T &gt; &amp;robot, const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;paramset, const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;alias_groups) const</td></tr>
<tr class="memdesc:a4d9b026cc01616e96595a473fba4d4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks <code>robot</code>, <code>paramset</code> and <code>alias_groups's</code> compatibility, throws std::logic_error if any is incompatible.  <a href="#a4d9b026cc01616e96595a473fba4d4c4">More...</a><br /></td></tr>
<tr class="separator:a4d9b026cc01616e96595a473fba4d4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a803b29b4b1f7938e4ddce68e1db2dcc5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a803b29b4b1f7938e4ddce68e1db2dcc5">GenericPlan</a> (const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a> &amp;)=default</td></tr>
<tr class="separator:a803b29b4b1f7938e4ddce68e1db2dcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418ac341470e4847190a2b8fd7e18851"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a418ac341470e4847190a2b8fd7e18851">operator=</a> (const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a> &amp;)=default</td></tr>
<tr class="separator:a418ac341470e4847190a2b8fd7e18851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af347c51c15f02378df54c2f9b9bce0ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#af347c51c15f02378df54c2f9b9bce0ea">GenericPlan</a> (<a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a> &amp;&amp;)=default</td></tr>
<tr class="separator:af347c51c15f02378df54c2f9b9bce0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba5a1fa6345f47f07fc0bf2c4e74610"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#a6ba5a1fa6345f47f07fc0bf2c4e74610">operator=</a> (<a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a6ba5a1fa6345f47f07fc0bf2c4e74610"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::systems::controllers::plan_eval::GenericPlan&lt; T &gt;</h3>

<p>This class represents a plan interpretor, which conceptually serves as a bridge between a high level planner (e.g. </p>
<p>A* planner) and a low level controller (e.g. PID controller). It is responsible for generating high frequency / dense commands that are compatible with the low level controller from the behavioral inputs. One main advantage for this separation is that the planner does not need to worry about any stabilization or realtime requirements associated with the hardware. This class also provides an interface for simple reactive behaviors such as "move arm in a straight line
until the hand touches something", which requires little computation but high rate feedback. Here is a concrete example: suppose the robot is a position and velocity controlled manipulator arm, and a motion planner is used to generate a sequence of joint configurations for the robot to follow. A simple implementation can use splines to represent smooth motions through those desired configurations, from which dense position and velocity set points are interpolated and sent to the PID controller at high rate.</p>
<p>For this class, the low level controller of choice is QPController. So the output of this class is an QpInput. The behavioral level inputs are type erased and stored in <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html" title="A fully type-erased container class. ">systems::AbstractValue</a>. Derived classes are responsible for recovering the proper plan type. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a803b29b4b1f7938e4ddce68e1db2dcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803b29b4b1f7938e4ddce68e1db2dcc5">&#9670;&nbsp;</a></span>GenericPlan() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af347c51c15f02378df54c2f9b9bce0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af347c51c15f02378df54c2f9b9bce0ea">&#9670;&nbsp;</a></span>GenericPlan() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87dddadb6e66a15733f7f3de5e35e7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87dddadb6e66a15733f7f3de5e35e7ac">&#9670;&nbsp;</a></span>~GenericPlan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5a722b7e80e6c00c73a7c58d2cd8487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a722b7e80e6c00c73a7c58d2cd8487">&#9670;&nbsp;</a></span>GenericPlan() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It is convenient to separate allocation with initialization because the later commonly depends on extra information such as measured robot state. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4d9b026cc01616e96595a473fba4d4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9b026cc01616e96595a473fba4d4c4">&#9670;&nbsp;</a></span>CheckCompatibilityAndThrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CheckCompatibilityAndThrow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>robot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;&#160;</td>
          <td class="paramname"><em>paramset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>alias_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks <code>robot</code>, <code>paramset</code> and <code>alias_groups's</code> compatibility, throws std::logic_error if any is incompatible. </p>

</div>
</div>
<a id="a2e6f0c2d24101e2bf2ccbdaab4b6d24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6f0c2d24101e2bf2ccbdaab4b6d24d">&#9670;&nbsp;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a>&lt; T &gt; &gt; Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a unique pointer to a copy of this instance. </p>
<p>Derived classes need to implement <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#ac80d19a3138d262af6743c36ea5ed660" title="Custom fields can be cloned here. ">CloneGenericPlanDerived()</a> to copy custom internal fields. </p>

</div>
</div>
<a id="ac80d19a3138d262af6743c36ea5ed660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80d19a3138d262af6743c36ea5ed660">&#9670;&nbsp;</a></span>CloneGenericPlanDerived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a>&lt;T&gt;* CloneGenericPlanDerived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom fields can be cloned here. </p>

</div>
</div>
<a id="a835c82a92d0e112858fc6b0946e12b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835c82a92d0e112858fc6b0946e12b1e">&#9670;&nbsp;</a></span>get_body_trajectories()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt;T&gt;*, <a class="el" href="classdrake_1_1manipulation_1_1_piecewise_cartesian_trajectory.html">manipulation::PiecewiseCartesianTrajectory</a>&lt;T&gt; &gt;&amp; get_body_trajectories </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a map of all Cartesian trajectories. </p>

</div>
</div>
<a id="a4da479515c5a009182a9ce79d7e21061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da479515c5a009182a9ce79d7e21061">&#9670;&nbsp;</a></span>get_body_trajectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1manipulation_1_1_piecewise_cartesian_trajectory.html">manipulation::PiecewiseCartesianTrajectory</a>&lt;T&gt;&amp; get_body_trajectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Cartesian trajectory for <code>body</code>. </p>

</div>
</div>
<a id="acfa38608aa67d0ce04b54724e7db4a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa38608aa67d0ce04b54724e7db4a85">&#9670;&nbsp;</a></span>get_dof_trajectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1manipulation_1_1_piecewise_cubic_trajectory.html">manipulation::PiecewiseCubicTrajectory</a>&lt;T&gt;&amp; get_dof_trajectory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns trajectory for all degrees of freedom. </p>

</div>
</div>
<a id="a52c2d020ba2b2678379ef0252b511941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c2d020ba2b2678379ef0252b511941">&#9670;&nbsp;</a></span>get_planned_contact_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1systems_1_1controllers_1_1plan__eval.html#af544cc03f89544a07be19198582d9bcd">ContactState</a>&amp; get_planned_contact_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current planned contact state. </p>

</div>
</div>
<a id="a3a0d0f1d25238564b0baeedecb678a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0d0f1d25238564b0baeedecb678a8b">&#9670;&nbsp;</a></span>HandlePlan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HandlePlan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>robot_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;&#160;</td>
          <td class="paramname"><em>paramset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>alias_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">systems::AbstractValue</a> &amp;&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles a discrete plan (e.g. </p>
<p>footstep plan for a walking controller or a sequence of joint angles for a manipulator). Derived classes need to implement custom behaviors in <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#ac6fd650e5c407d9876b4dda11892cef2" title="Custom plan handling can be implemented here. ">HandlePlanGenericPlanDerived()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">robot_status</td><td>Current status of the robot. </td></tr>
    <tr><td class="paramname">paramset</td><td><a class="el" href="classdrake_1_1systems_1_1_parameters.html" title="Parameters is a container for variables that parameterize a System so that it can represent a family ...">Parameters</a>. </td></tr>
    <tr><td class="paramname">alias_groups</td><td>Topological information of the robot. </td></tr>
    <tr><td class="paramname">plan</td><td><a class="el" href="classdrake_1_1systems_1_1_abstract_value.html" title="A fully type-erased container class. ">AbstractValue</a> that contains the plan.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> reference in <code>robot_status</code> or <code>paramset</code> or <code>alias_groups</code> is incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6fd650e5c407d9876b4dda11892cef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fd650e5c407d9876b4dda11892cef2">&#9670;&nbsp;</a></span>HandlePlanGenericPlanDerived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HandlePlanGenericPlanDerived </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>robot_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;&#160;</td>
          <td class="paramname"><em>paramset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>alias_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">systems::AbstractValue</a> &amp;&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom plan handling can be implemented here. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_manipulator_move_end_effector_plan.html#a32b05aa7b02c18312e647bf2ea390257">ManipulatorMoveEndEffectorPlan&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a569c4b7dfd2fa659473094444ecbfe15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569c4b7dfd2fa659473094444ecbfe15">&#9670;&nbsp;</a></span>has_body_trajectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> has_body_trajectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there is a Cartesian trajectory for <code>body</code>. </p>

</div>
</div>
<a id="a98a9c0820d6dd26e76ca531e0509f6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a9c0820d6dd26e76ca531e0509f6fd">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>robot_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;&#160;</td>
          <td class="paramname"><em>paramset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>alias_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes this plan. </p>
<p>This function sets a dummy plan to main the current joint configuration in <code>robot_status</code>. It assumes no contacts and no Cartesian tracking objectives are present. Derived classes can implement custom behaviors or override these in <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#ac5c53822078fb0a47d0589dc2be65ec7" title="Custom initialization can be implemented here. ">InitializeGenericPlanDerived()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">robot_status</td><td>Current status of the robot. </td></tr>
    <tr><td class="paramname">paramset</td><td><a class="el" href="classdrake_1_1systems_1_1_parameters.html" title="Parameters is a container for variables that parameterize a System so that it can represent a family ...">Parameters</a>. </td></tr>
    <tr><td class="paramname">alias_groups</td><td>Topological information of the robot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> reference in <code>robot_status</code> or <code>paramset</code> or <code>alias_groups</code> is incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5c53822078fb0a47d0589dc2be65ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c53822078fb0a47d0589dc2be65ec7">&#9670;&nbsp;</a></span>InitializeGenericPlanDerived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void InitializeGenericPlanDerived </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>robot_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;&#160;</td>
          <td class="paramname"><em>paramset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>alias_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom initialization can be implemented here. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_manipulator_move_end_effector_plan.html#a399f633e1eb516865e2749cd415a0938">ManipulatorMoveEndEffectorPlan&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a0cc10368f00b01f829f4a12e4fb0ab05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc10368f00b01f829f4a12e4fb0ab05">&#9670;&nbsp;</a></span>IsParamSetCompatible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> IsParamSetCompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;&#160;</td>
          <td class="paramname"><em>paramset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>paramset</code> is compatible. </p>
<p>The default implementation always returns true. Derived class must override to implement meaningful checks. </p>

</div>
</div>
<a id="a2870a638d45e4506364a56d1cd378d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2870a638d45e4506364a56d1cd378d65">&#9670;&nbsp;</a></span>IsRigidBodyTreeAliasGroupsCompatible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> IsRigidBodyTreeAliasGroupsCompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>alias_groups</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>alias_groups</code> is compatible. </p>
<p>The default implementation always returns true. Derived class must override to implement meaningful checks. </p>

</div>
</div>
<a id="afc4a6b9e8ec1131058a9af73794e343e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4a6b9e8ec1131058a9af73794e343e">&#9670;&nbsp;</a></span>IsRigidBodyTreeCompatible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> IsRigidBodyTreeCompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>robot</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>robot</code> is compatible. </p>
<p>The default implementation always returns true. Derived class must override to implement meaningful checks. </p>

</div>
</div>
<a id="ac29c375b19391669ca40b3a946e95efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29c375b19391669ca40b3a946e95efd">&#9670;&nbsp;</a></span>ModifyPlan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ModifyPlan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>robot_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;&#160;</td>
          <td class="paramname"><em>paramset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>alias_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control logic should be implemented in this function. </p>
<p>This function is intended to be called in a main loop. All internal state mutations (e.g. state machine transition, reference trajectory generation, etc) should be done here. Derived classes need to implement custom behaviors in <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#adfc891a0ff49d00008fe11bc070b0627" title="Custom state mutation can be implemented here. ">ModifyPlanGenericPlanDerived()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">robot_status</td><td>Current status of the robot. </td></tr>
    <tr><td class="paramname">paramset</td><td><a class="el" href="classdrake_1_1systems_1_1_parameters.html" title="Parameters is a container for variables that parameterize a System so that it can represent a family ...">Parameters</a>. </td></tr>
    <tr><td class="paramname">alias_groups</td><td>Topological information of the robot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> reference in <code>robot_status</code> or <code>paramset</code> or <code>alias_groups</code> is incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfc891a0ff49d00008fe11bc070b0627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc891a0ff49d00008fe11bc070b0627">&#9670;&nbsp;</a></span>ModifyPlanGenericPlanDerived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ModifyPlanGenericPlanDerived </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>robot_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;&#160;</td>
          <td class="paramname"><em>paramset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>alias_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom state mutation can be implemented here. </p>

</div>
</div>
<a id="a6ba5a1fa6345f47f07fc0bf2c4e74610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba5a1fa6345f47f07fc0bf2c4e74610">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a418ac341470e4847190a2b8fd7e18851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418ac341470e4847190a2b8fd7e18851">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad83fd7abd615134ba06a664ab16a88d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83fd7abd615134ba06a664ab16a88d2">&#9670;&nbsp;</a></span>remove_body_trajectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void remove_body_trajectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a Cartesian trajectory for <code>body</code>. </p>

</div>
</div>
<a id="a818a3cd09958ade6d12932d5d8a79313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818a3cd09958ade6d12932d5d8a79313">&#9670;&nbsp;</a></span>set_body_trajectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_body_trajectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rigid_body.html">RigidBody</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1manipulation_1_1_piecewise_cartesian_trajectory.html">manipulation::PiecewiseCartesianTrajectory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>traj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a Cartesian trajectory for <code>body</code>. </p>
<p>Replaces the existing one if it exists. </p>

</div>
</div>
<a id="a39999496388bfe806fe9cbe5822b7de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39999496388bfe806fe9cbe5822b7de6">&#9670;&nbsp;</a></span>set_dof_trajectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_dof_trajectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1manipulation_1_1_piecewise_cubic_trajectory.html">manipulation::PiecewiseCubicTrajectory</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>traj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets dof trajectory to <code>traj</code>. </p>

</div>
</div>
<a id="ac02642b00fec0747e133cc2c8c9a43e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02642b00fec0747e133cc2c8c9a43e1">&#9670;&nbsp;</a></span>UpdateContactState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UpdateContactState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1systems_1_1controllers_1_1plan__eval.html#af544cc03f89544a07be19198582d9bcd">ContactState</a> &amp;&#160;</td>
          <td class="paramname"><em>contact_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the planned contact state to <code>contact_state</code>. </p>

</div>
</div>
<a id="a9614f5e9faf3f3cfa85c2f843d9e4dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9614f5e9faf3f3cfa85c2f843d9e4dd5">&#9670;&nbsp;</a></span>UpdateQpInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UpdateQpInput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>robot_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;&#160;</td>
          <td class="paramname"><em>paramset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>alias_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_qp_input.html">systems::controllers::qp_inverse_dynamics::QpInput</a> *&#160;</td>
          <td class="paramname"><em>qp_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>qp_input</code> given the current state of the plan and measured robot state in <code>robot_status</code>. </p>
<p>Specifically, this function performs the following: </p><pre>
1. Generates all ContactInformation for each body that are planned to be in
contact.
2. For all degrees of freedom, desired accelerations are computed by:
`vd_d = kp * (q* - q) + kd * (v* - v) + vd*`, where `q*, v*` and `vd*` are
interpolated from the planned trajectory, `q, v` are from <code>robot_status</code>,
and kp and kd are looked up from <code>paramset</code>.
3. For all bodies that have a Cartesian tracking objective, desired
Cartesian accelerations are computed by:
`xd_d = kp * (x* - x) + kd * (xd* - xd) + xdd*`, where `x*, xd*, xdd*` are
interpolated from the planned trajectories, `x, xd` are from
<code>robot_status</code>, and kp and kd are looked up from <code>paramset</code>.
</pre><p> Derived classes can implement custom behaviors or override these in <a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html#afdbb804feea336cd76eac958dbc64521" title="Custom QpInput updates can be implemented here. ">UpdateQpInputGenericPlanDerived()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">robot_status</td><td>Current status of the robot. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">paramset</td><td><a class="el" href="classdrake_1_1systems_1_1_parameters.html" title="Parameters is a container for variables that parameterize a System so that it can represent a family ...">Parameters</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">alias_groups</td><td>Topological information of the robot. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qp_input</td><td>Output for QpInput.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> reference in <code>robot_status</code> or <code>paramset</code> or <code>alias_groups</code> is incompatible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdbb804feea336cd76eac958dbc64521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbb804feea336cd76eac958dbc64521">&#9670;&nbsp;</a></span>UpdateQpInputGenericPlanDerived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void UpdateQpInputGenericPlanDerived </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_robot_kinematic_state.html">systems::controllers::qp_inverse_dynamics::RobotKinematicState</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>robot_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_param_set.html">systems::controllers::qp_inverse_dynamics::ParamSet</a> &amp;&#160;</td>
          <td class="paramname"><em>paramset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_rigid_body_tree_alias_groups.html">RigidBodyTreeAliasGroups</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>alias_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1qp__inverse__dynamics_1_1_qp_input.html">systems::controllers::qp_inverse_dynamics::QpInput</a> *&#160;</td>
          <td class="paramname"><em>qp_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom QpInput updates can be implemented here. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/attic/systems/controllers/plan_eval/<a class="el" href="generic__plan_8h.html">generic_plan.h</a></li>
<li>drake/attic/systems/controllers/plan_eval/<a class="el" href="generic__plan_8cc.html">generic_plan.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1systems.html">systems</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1systems_1_1controllers.html">controllers</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1systems_1_1controllers_1_1plan__eval.html">plan_eval</a></li><li class="navelem"><a class="el" href="classdrake_1_1systems_1_1controllers_1_1plan__eval_1_1_generic_plan.html">GenericPlan</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
