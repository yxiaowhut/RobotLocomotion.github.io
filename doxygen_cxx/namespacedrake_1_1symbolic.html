<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::symbolic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacedrake_1_1symbolic.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drake::symbolic Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake_1_1symbolic_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1symbolic_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1symbolic_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for binary expressions.  <a href="classdrake_1_1symbolic_1_1_binary_expression_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_code_gen_visitor.html">CodeGenVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor class for code generation.  <a href="classdrake_1_1symbolic_1_1_code_gen_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic environment (mapping from a variable to a value).  <a href="classdrake_1_1symbolic_1_1_environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic form of an expression.  <a href="classdrake_1_1symbolic_1_1_expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing absolute value function.  <a href="classdrake_1_1symbolic_1_1_expression_abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing arccosine function.  <a href="classdrake_1_1symbolic_1_1_expression_acos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing an addition which is a sum of products.  <a href="classdrake_1_1symbolic_1_1_expression_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_add_factory.html">ExpressionAddFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory class to help build <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html" title="Symbolic expression representing an addition which is a sum of products. ">ExpressionAdd</a> expressions.  <a href="classdrake_1_1symbolic_1_1_expression_add_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing arcsine function.  <a href="classdrake_1_1symbolic_1_1_expression_asin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing arctangent function.  <a href="classdrake_1_1symbolic_1_1_expression_atan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing atan2 function (arctangent function with two arguments).  <a href="classdrake_1_1symbolic_1_1_expression_atan2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing ceil function.  <a href="classdrake_1_1symbolic_1_1_expression_ceiling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an abstract class which is the base of concrete symbolic-expression classes.  <a href="classdrake_1_1symbolic_1_1_expression_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing a constant.  <a href="classdrake_1_1symbolic_1_1_expression_constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing cosine function.  <a href="classdrake_1_1symbolic_1_1_expression_cos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing hyperbolic cosine function.  <a href="classdrake_1_1symbolic_1_1_expression_cosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing division.  <a href="classdrake_1_1symbolic_1_1_expression_div.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing exponentiation using the base of natural logarithms.  <a href="classdrake_1_1symbolic_1_1_expression_exp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing floor function.  <a href="classdrake_1_1symbolic_1_1_expression_floor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing if-then-else expression.  <a href="classdrake_1_1symbolic_1_1_expression_if_then_else.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing logarithms.  <a href="classdrake_1_1symbolic_1_1_expression_log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing max function.  <a href="classdrake_1_1symbolic_1_1_expression_max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing min function.  <a href="classdrake_1_1symbolic_1_1_expression_min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing a multiplication of powers.  <a href="classdrake_1_1symbolic_1_1_expression_mul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_mul_factory.html">ExpressionMulFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory class to help build <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html" title="Symbolic expression representing a multiplication of powers. ">ExpressionMul</a> expressions.  <a href="classdrake_1_1symbolic_1_1_expression_mul_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_na_n.html">ExpressionNaN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing NaN (not-a-number).  <a href="classdrake_1_1symbolic_1_1_expression_na_n.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing power function.  <a href="classdrake_1_1symbolic_1_1_expression_pow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing sine function.  <a href="classdrake_1_1symbolic_1_1_expression_sin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing hyperbolic sine function.  <a href="classdrake_1_1symbolic_1_1_expression_sinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing square-root.  <a href="classdrake_1_1symbolic_1_1_expression_sqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing tangent function.  <a href="classdrake_1_1symbolic_1_1_expression_tan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing hyperbolic tangent function.  <a href="classdrake_1_1symbolic_1_1_expression_tanh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing an uninterpreted function.  <a href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing a variable.  <a href="classdrake_1_1symbolic_1_1_expression_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic form of a first-order logic formula.  <a href="classdrake_1_1symbolic_1_1_formula.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing conjunctions (f1 ∧ ...  <a href="classdrake_1_1symbolic_1_1_formula_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an abstract class which is the base of concrete symbolic-formula classes (i.e.  <a href="classdrake_1_1symbolic_1_1_formula_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing equality (e1 = e2).  <a href="classdrake_1_1symbolic_1_1_formula_eq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing false.  <a href="classdrake_1_1symbolic_1_1_formula_false.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing universal quantifications (∀ x₁, ..., * xn.  <a href="classdrake_1_1symbolic_1_1_formula_forall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'greater-than-or-equal-to' (e1 ≥ e2).  <a href="classdrake_1_1symbolic_1_1_formula_geq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'greater-than' (e1 &gt; e2).  <a href="classdrake_1_1symbolic_1_1_formula_gt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing isnan predicate.  <a href="classdrake_1_1symbolic_1_1_formula_isnan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'less-than-or-equal-to' (e1 ≤ e2).  <a href="classdrake_1_1symbolic_1_1_formula_leq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'less-than' (e1 &lt; e2).  <a href="classdrake_1_1symbolic_1_1_formula_lt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing disequality (e1 ≠ e2).  <a href="classdrake_1_1symbolic_1_1_formula_neq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing negations (¬f).  <a href="classdrake_1_1symbolic_1_1_formula_not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing disjunctions (f1 ∨ ...  <a href="classdrake_1_1symbolic_1_1_formula_or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing positive-semidefinite (PSD) constraint.  <a href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing true.  <a href="classdrake_1_1symbolic_1_1_formula_true.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing a Boolean variable.  <a href="classdrake_1_1symbolic_1_1_formula_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1symbolic_1_1_graded_reverse_lex_order.html">GradedReverseLexOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Graded reverse lexicographic order.  <a href="structdrake_1_1symbolic_1_1_graded_reverse_lex_order.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a monomial, a product of powers of variables with non-negative integer exponents.  <a href="classdrake_1_1symbolic_1_1_monomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for N-ary logic operators (∧ and ∨).  <a href="classdrake_1_1symbolic_1_1_nary_formula_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents symbolic polynomials.  <a href="classdrake_1_1symbolic_1_1_polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents symbolic rational function.  <a href="classdrake_1_1symbolic_1_1_rational_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for relational operators (==, !=, &lt;, &lt;=, &gt;, &gt;=).  <a href="classdrake_1_1symbolic_1_1_relational_formula_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html">RewritingRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html" title="A RewritingRule, lhs =&gt; rhs, consists of two Patterns lhs and rhs. ">RewritingRule</a></code>, <code>lhs =&gt; rhs</code>, consists of two Patterns <code>lhs</code> and <code>rhs</code>.  <a href="classdrake_1_1symbolic_1_1_rewriting_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for unary expressions.  <a href="classdrake_1_1symbolic_1_1_unary_expression_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic variable.  <a href="classdrake_1_1symbolic_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of variables.  <a href="classdrake_1_1symbolic_1_1_variables.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acbfe43d34e6c71c503d4de11da53bbb7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> = std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;</td></tr>
<tr class="separator:acbfe43d34e6c71c503d4de11da53bbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb27ddf30420e620beb8e6725d83208f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aeb27ddf30420e620beb8e6725d83208f">Pattern</a> = <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td></tr>
<tr class="memdesc:aeb27ddf30420e620beb8e6725d83208f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern is an expression which possibly includes variables which represent placeholders.  <a href="#aeb27ddf30420e620beb8e6725d83208f">More...</a><br /></td></tr>
<tr class="separator:aeb27ddf30420e620beb8e6725d83208f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134e54042165751a5e5369b4631c90eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a134e54042165751a5e5369b4631c90eb">Rewriter</a> = std::function&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>(const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a134e54042165751a5e5369b4631c90eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>Rewriter</code> is a function from an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">Expression</a> to an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">Expression</a>.  <a href="#a134e54042165751a5e5369b4631c90eb">More...</a><br /></td></tr>
<tr class="separator:a134e54042165751a5e5369b4631c90eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aebde9bdda9a428ef1bab6175954d30fa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">ExpressionKind</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faacb17869fe51048b5a5c4c6106551a255">Constant</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa5a92344ee95acf10c31901b36418be77">Var</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faaec211f7c20af43e742bf2570c3cb84f9">Add</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa62b6d55816cf737bfc6f42e60df1a3f2">Mul</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa43d11850893d2fe84a1e618121c1cc0a">Div</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faace0be71e33226e4c1db2bcea5959f16b">Log</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa1e34af023adeb7d5f484f8eb4b9826b6">Abs</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faacad39a154bffb61175f674d6eefaf6d0">Exp</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faaae77f3ad25595e35b327334d89410054">Sqrt</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa8be6d3e955290ee50c00a4bc92aa7749">Pow</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa0986d137604183312e6d3599578bc6cd">Sin</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faaffca562be079b9e4e41ea9d6a86c582b">Cos</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa1266b4e6f81e60733ec6c717e0181f60">Tan</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa76cfc54de4e2b9cde17334c821217d11">Asin</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faaed4629033ecb516ed7d1536e162030bb">Acos</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faac9968ab1fa8103acbb3a4f22265f2def">Atan</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa5816dfcaf3b6dbb486ef9c8c006ff613">Atan2</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa98ed804abf4edd1f3be3fa894fa8cc3d">Sinh</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa4371c3565b771b40c187487cc0190392">Cosh</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faacc132a41cab5676334f353a22a0aa5c5">Tanh</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa78d811e98514cd165dda532286610fd2">Min</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa6a061313d22e51e0f25b7cd4dc065233">Max</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faab95a01ffffa8fcdd2a9af961937c097c">Ceil</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faaf3f6d0343d56ce88ce7958170ed05cb3">Floor</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faaaff6933d8331eca27edc911467980c9c">IfThenElse</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa7ecfb3bf076a6a9635f975fe96ac97fd">NaN</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa2e59a51ac43bc3415c1b8ce7b3f98579">UninterpretedFunction</a>
<br />
 }<tr class="memdesc:aebde9bdda9a428ef1bab6175954d30fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinds of symbolic expressions.  <a href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aebde9bdda9a428ef1bab6175954d30fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6869e7044dd90be5d972ee7dd4e821b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6af8320b26d30ab433c5a54546d21f414c">False</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6af827cf462f62848df37c5e1e94a4da74">True</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a5a92344ee95acf10c31901b36418be77">Var</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a3718b5ecf60aa0dba49e150e96cb1fc3">Eq</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6ae4ecc5da3c6dbb4448f25990dc609727">Neq</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a086cb8308e5a36e7c4ed1f8873ad801f">Gt</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a5dabfebb89e6e45a8cf8573d92746ed3">Geq</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a50033c15af7795cd6617f117b29d6922">Lt</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6abe5721bf93d718a79358217ec9b88176">Leq</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6ac33315685a0cba3ce53be378b3c7874b">And</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a3a2d5fe857d8f9541136a124c2edec6c">Or</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6aa74c05d080620f087c4e523977230666">Not</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a43cfe3c750a08acb91df1e3384548078">Forall</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6afd116e3418522ffc34d7423bc601510d">Isnan</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a1fbc164d3e50b7fd20690a21f1b7b2f2">PositiveSemidefinite</a>
<br />
 }<tr class="memdesc:a6869e7044dd90be5d972ee7dd4e821b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinds of symbolic formulas.  <a href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6869e7044dd90be5d972ee7dd4e821b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a64d57d7f341720760d9ae5f41af02de3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a64d57d7f341720760d9ae5f41af02de3">DecomposeLinearExpressions</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;expressions, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt; M)</td></tr>
<tr class="separator:a64d57d7f341720760d9ae5f41af02de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24485ddd4b9b69340021bd0eb259bf38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a24485ddd4b9b69340021bd0eb259bf38">DecomposeAffineExpressions</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;expressions, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt; M, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt; v)</td></tr>
<tr class="separator:a24485ddd4b9b69340021bd0eb259bf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c01361f464b3eae396f7d1a0e92c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa6c01361f464b3eae396f7d1a0e92c85">DecomposeLinearExpressions</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;expressions, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt; M)</td></tr>
<tr class="memdesc:aa6c01361f464b3eae396f7d1a0e92c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes <code>expressions</code> into <code>M</code> * <code>vars</code>.  <a href="#aa6c01361f464b3eae396f7d1a0e92c85">More...</a><br /></td></tr>
<tr class="separator:aa6c01361f464b3eae396f7d1a0e92c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c152941a4e06624bac5926fac2d4e32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0c152941a4e06624bac5926fac2d4e32">DecomposeAffineExpressions</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;expressions, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt; M, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt; v)</td></tr>
<tr class="memdesc:a0c152941a4e06624bac5926fac2d4e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes <code>expressions</code> into <code>M</code> * <code>vars</code> + <code>v</code>.  <a href="#a0c152941a4e06624bac5926fac2d4e32">More...</a><br /></td></tr>
<tr class="separator:a0c152941a4e06624bac5926fac2d4e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7321fd38348c4842f41b4965bdf4979d"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7321fd38348c4842f41b4965bdf4979d">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;env)</td></tr>
<tr class="separator:a7321fd38348c4842f41b4965bdf4979d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fafcceed185abdb6726cbaf4ff3be3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af8fafcceed185abdb6726cbaf4ff3be3">PopulateRandomVariables</a> (<a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> env, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;variables, <a class="el" href="namespacedrake.html#ab262f8e82f09d8df2990d0dc5869c34f">RandomGenerator</a> *random_generator)</td></tr>
<tr class="memdesc:af8fafcceed185abdb6726cbaf4ff3be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the environment <code>env</code> by sampling values for the unassigned random variables in <code>variables</code> using <code>random_generator</code>.  <a href="#af8fafcceed185abdb6726cbaf4ff3be3">More...</a><br /></td></tr>
<tr class="separator:af8fafcceed185abdb6726cbaf4ff3be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9911fd0881ffc66c0c64e8d727399237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9911fd0881ffc66c0c64e8d727399237">operator&lt;</a> (<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">ExpressionKind</a> k1, <a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">ExpressionKind</a> k2)</td></tr>
<tr class="memdesc:a9911fd0881ffc66c0c64e8d727399237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total ordering between ExpressionKinds.  <a href="#a9911fd0881ffc66c0c64e8d727399237">More...</a><br /></td></tr>
<tr class="separator:a9911fd0881ffc66c0c64e8d727399237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d376b5d0899a705ee72195cde03af1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3d376b5d0899a705ee72195cde03af1c">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a3d376b5d0899a705ee72195cde03af1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b7983f85fe6d5d0e6dd623f630cff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af3b7983f85fe6d5d0e6dd623f630cff2">operator+=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:af3b7983f85fe6d5d0e6dd623f630cff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1474e5a6eadf9c929b552c4a1a774539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1474e5a6eadf9c929b552c4a1a774539">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a1474e5a6eadf9c929b552c4a1a774539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7396940e4ad4279f7e7a984305a051a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac7396940e4ad4279f7e7a984305a051a">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:ac7396940e4ad4279f7e7a984305a051a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160ea247e390cafd990190196c446785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a160ea247e390cafd990190196c446785">operator-=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a160ea247e390cafd990190196c446785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82a0882a250b686c193c81892f8bf34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad82a0882a250b686c193c81892f8bf34">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:ad82a0882a250b686c193c81892f8bf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afe6eb8130d59ffeabe0b6dcc382353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3afe6eb8130d59ffeabe0b6dcc382353">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a3afe6eb8130d59ffeabe0b6dcc382353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702e8b7089a5dd3d5cc22f9da154e1b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a702e8b7089a5dd3d5cc22f9da154e1b2">operator*=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a702e8b7089a5dd3d5cc22f9da154e1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a65c6eae526c1f116f99fa1eba9f73a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9a65c6eae526c1f116f99fa1eba9f73a">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a9a65c6eae526c1f116f99fa1eba9f73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54e8cfb56c376f1e578784d6b68fbf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa54e8cfb56c376f1e578784d6b68fbf1">operator/=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:aa54e8cfb56c376f1e578784d6b68fbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f13e2bea2dfc69ca8f389450a062981"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2f13e2bea2dfc69ca8f389450a062981">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a2f13e2bea2dfc69ca8f389450a062981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11ee8e11a75ed1fa0f970ed7a547add"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa11ee8e11a75ed1fa0f970ed7a547add">CodeGen</a> (const std::string &amp;function_name, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;parameters, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa11ee8e11a75ed1fa0f970ed7a547add"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given symbolic expression <code>e</code>, generates two C functions, <code>function_name</code> and <code>function_name_in</code>.  <a href="#aa11ee8e11a75ed1fa0f970ed7a547add">More...</a><br /></td></tr>
<tr class="separator:aa11ee8e11a75ed1fa0f970ed7a547add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7c9095542cd5f4ef70f50bca1aab7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1c7c9095542cd5f4ef70f50bca1aab7c">log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a1c7c9095542cd5f4ef70f50bca1aab7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e11b5fa4c16951b30b26e43a316569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a44e11b5fa4c16951b30b26e43a316569">abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a44e11b5fa4c16951b30b26e43a316569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e661d9a5f1936f326068b2dea3eecc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a27e661d9a5f1936f326068b2dea3eecc">exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a27e661d9a5f1936f326068b2dea3eecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e1b5d9aadd56991632f40804d4bf93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a79e1b5d9aadd56991632f40804d4bf93">sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a79e1b5d9aadd56991632f40804d4bf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57efef61100945c693ecb05dadf6dcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa57efef61100945c693ecb05dadf6dcf">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:aa57efef61100945c693ecb05dadf6dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cd13d5472028f31c2e70f1b0e08b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af3cd13d5472028f31c2e70f1b0e08b5d">sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:af3cd13d5472028f31c2e70f1b0e08b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d78919127ccba2ba24cdb1b0c57613d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8d78919127ccba2ba24cdb1b0c57613d">cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a8d78919127ccba2ba24cdb1b0c57613d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734f5b457c5a0b898ab8b6f247f0ce76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a734f5b457c5a0b898ab8b6f247f0ce76">tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a734f5b457c5a0b898ab8b6f247f0ce76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f66b1d5e15bec4b2b7f12ade1b3094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a66f66b1d5e15bec4b2b7f12ade1b3094">asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a66f66b1d5e15bec4b2b7f12ade1b3094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008a73e1d2390dc2325d70175fb5410e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a008a73e1d2390dc2325d70175fb5410e">acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a008a73e1d2390dc2325d70175fb5410e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf24c6f256d7360650cb379c22886409"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acf24c6f256d7360650cb379c22886409">atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:acf24c6f256d7360650cb379c22886409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddcc51253066082911475e06b0ac994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9ddcc51253066082911475e06b0ac994">atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a9ddcc51253066082911475e06b0ac994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f5c9f26be9d9eef2784073ac8075e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa5f5c9f26be9d9eef2784073ac8075e0">sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:aa5f5c9f26be9d9eef2784073ac8075e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a345a84e6b273a71aa02ee312f9c51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a27a345a84e6b273a71aa02ee312f9c51">cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a27a345a84e6b273a71aa02ee312f9c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96194d93ad39bcb2b7ed22891f44ec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae96194d93ad39bcb2b7ed22891f44ec7">tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:ae96194d93ad39bcb2b7ed22891f44ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f18b20230d6fd5d6a2c81a278a89edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1f18b20230d6fd5d6a2c81a278a89edc">min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a1f18b20230d6fd5d6a2c81a278a89edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa951d192140621a51f31d68ead6f3e4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa951d192140621a51f31d68ead6f3e4d">max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:aa951d192140621a51f31d68ead6f3e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5ea5116992b4f695c16ad0f297686b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2e5ea5116992b4f695c16ad0f297686b">ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a2e5ea5116992b4f695c16ad0f297686b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cadfe5adda620a40258a84d87081f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a08cadfe5adda620a40258a84d87081f4">floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a08cadfe5adda620a40258a84d87081f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb59d484cb2b6737923c9b53e0ec432c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adb59d484cb2b6737923c9b53e0ec432c">if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f_cond, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e_then, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e_else)</td></tr>
<tr class="separator:adb59d484cb2b6737923c9b53e0ec432c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11eb904ad30c23a3a54c95c38c2f294c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a11eb904ad30c23a3a54c95c38c2f294c">uninterpreted_function</a> (std::string <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; arguments)</td></tr>
<tr class="memdesc:a11eb904ad30c23a3a54c95c38c2f294c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an uninterpreted-function expression with <code>name</code> and <code>arguments</code>.  <a href="#a11eb904ad30c23a3a54c95c38c2f294c">More...</a><br /></td></tr>
<tr class="separator:a11eb904ad30c23a3a54c95c38c2f294c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef926e653145a96fc31416c85e20c14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acef926e653145a96fc31416c85e20c14">is_constant</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acef926e653145a96fc31416c85e20c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a constant expression.  <a href="#acef926e653145a96fc31416c85e20c14">More...</a><br /></td></tr>
<tr class="separator:acef926e653145a96fc31416c85e20c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefc608adef6255f93f6aecf809a8b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abefc608adef6255f93f6aecf809a8b11">is_constant</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, <a class="el" href="classdouble.html">double</a> v)</td></tr>
<tr class="memdesc:abefc608adef6255f93f6aecf809a8b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a constant expression representing <code>v</code>.  <a href="#abefc608adef6255f93f6aecf809a8b11">More...</a><br /></td></tr>
<tr class="separator:abefc608adef6255f93f6aecf809a8b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f09fda9abe80d7b775527445374c06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a07f09fda9abe80d7b775527445374c06">is_zero</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a07f09fda9abe80d7b775527445374c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is 0.0.  <a href="#a07f09fda9abe80d7b775527445374c06">More...</a><br /></td></tr>
<tr class="separator:a07f09fda9abe80d7b775527445374c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f3f42c88b77cf4893385a7a093087c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a28f3f42c88b77cf4893385a7a093087c">is_one</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a28f3f42c88b77cf4893385a7a093087c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is 1.0.  <a href="#a28f3f42c88b77cf4893385a7a093087c">More...</a><br /></td></tr>
<tr class="separator:a28f3f42c88b77cf4893385a7a093087c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4707946faf3b330e3bce6702cf48b2dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4707946faf3b330e3bce6702cf48b2dd">is_neg_one</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a4707946faf3b330e3bce6702cf48b2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is -1.0.  <a href="#a4707946faf3b330e3bce6702cf48b2dd">More...</a><br /></td></tr>
<tr class="separator:a4707946faf3b330e3bce6702cf48b2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9232608f43a586aad546b2a078aeb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1e9232608f43a586aad546b2a078aeb0">is_two</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a1e9232608f43a586aad546b2a078aeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is 2.0.  <a href="#a1e9232608f43a586aad546b2a078aeb0">More...</a><br /></td></tr>
<tr class="separator:a1e9232608f43a586aad546b2a078aeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56597943e81b4b1cb898816104662a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a56597943e81b4b1cb898816104662a16">is_nan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a56597943e81b4b1cb898816104662a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is NaN.  <a href="#a56597943e81b4b1cb898816104662a16">More...</a><br /></td></tr>
<tr class="separator:a56597943e81b4b1cb898816104662a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3313ad6342effa904bba98f1ef811902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3313ad6342effa904bba98f1ef811902">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a3313ad6342effa904bba98f1ef811902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a variable expression.  <a href="#a3313ad6342effa904bba98f1ef811902">More...</a><br /></td></tr>
<tr class="separator:a3313ad6342effa904bba98f1ef811902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8a1e5e59b460cac7c2d8b5cb1e172c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5b8a1e5e59b460cac7c2d8b5cb1e172c">is_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a5b8a1e5e59b460cac7c2d8b5cb1e172c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an addition expression.  <a href="#a5b8a1e5e59b460cac7c2d8b5cb1e172c">More...</a><br /></td></tr>
<tr class="separator:a5b8a1e5e59b460cac7c2d8b5cb1e172c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f74bcd66ba02bc91f3434924a6c8a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad1f74bcd66ba02bc91f3434924a6c8a2">is_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ad1f74bcd66ba02bc91f3434924a6c8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a multiplication expression.  <a href="#ad1f74bcd66ba02bc91f3434924a6c8a2">More...</a><br /></td></tr>
<tr class="separator:ad1f74bcd66ba02bc91f3434924a6c8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab069e1d04f34ba9f9eff1ee8e97cca6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab069e1d04f34ba9f9eff1ee8e97cca6e">is_division</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab069e1d04f34ba9f9eff1ee8e97cca6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a division expression.  <a href="#ab069e1d04f34ba9f9eff1ee8e97cca6e">More...</a><br /></td></tr>
<tr class="separator:ab069e1d04f34ba9f9eff1ee8e97cca6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab049cfca69564b8713a3fd0a0e3bbba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab049cfca69564b8713a3fd0a0e3bbba9">is_log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab049cfca69564b8713a3fd0a0e3bbba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a log expression.  <a href="#ab049cfca69564b8713a3fd0a0e3bbba9">More...</a><br /></td></tr>
<tr class="separator:ab049cfca69564b8713a3fd0a0e3bbba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6046c9bad9a1c5a1ba51ec6157376c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab6046c9bad9a1c5a1ba51ec6157376c3">is_abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab6046c9bad9a1c5a1ba51ec6157376c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an abs expression.  <a href="#ab6046c9bad9a1c5a1ba51ec6157376c3">More...</a><br /></td></tr>
<tr class="separator:ab6046c9bad9a1c5a1ba51ec6157376c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a9ff7a7f105a0e9edf77cace06d9e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a77a9ff7a7f105a0e9edf77cace06d9e9">is_exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a77a9ff7a7f105a0e9edf77cace06d9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an exp expression.  <a href="#a77a9ff7a7f105a0e9edf77cace06d9e9">More...</a><br /></td></tr>
<tr class="separator:a77a9ff7a7f105a0e9edf77cace06d9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88aa92c34154f228b7609c0a1e1f0ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad88aa92c34154f228b7609c0a1e1f0ef">is_sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ad88aa92c34154f228b7609c0a1e1f0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a square-root expression.  <a href="#ad88aa92c34154f228b7609c0a1e1f0ef">More...</a><br /></td></tr>
<tr class="separator:ad88aa92c34154f228b7609c0a1e1f0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8204863236e57c7a074fb90bceb61a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa8204863236e57c7a074fb90bceb61a1">is_pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa8204863236e57c7a074fb90bceb61a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a power-function expression.  <a href="#aa8204863236e57c7a074fb90bceb61a1">More...</a><br /></td></tr>
<tr class="separator:aa8204863236e57c7a074fb90bceb61a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af6fb7d06debf378b3a7446f7ad6f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1af6fb7d06debf378b3a7446f7ad6f26">is_sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a1af6fb7d06debf378b3a7446f7ad6f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a sine expression.  <a href="#a1af6fb7d06debf378b3a7446f7ad6f26">More...</a><br /></td></tr>
<tr class="separator:a1af6fb7d06debf378b3a7446f7ad6f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad1d934168832dc9e42cc388cdaccca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1ad1d934168832dc9e42cc388cdaccca">is_cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a1ad1d934168832dc9e42cc388cdaccca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a cosine expression.  <a href="#a1ad1d934168832dc9e42cc388cdaccca">More...</a><br /></td></tr>
<tr class="separator:a1ad1d934168832dc9e42cc388cdaccca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a2c288d79cc175a23093bfe33a033a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa4a2c288d79cc175a23093bfe33a033a">is_tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa4a2c288d79cc175a23093bfe33a033a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a tangent expression.  <a href="#aa4a2c288d79cc175a23093bfe33a033a">More...</a><br /></td></tr>
<tr class="separator:aa4a2c288d79cc175a23093bfe33a033a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b4c96682d9db457216b967fe589b0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a55b4c96682d9db457216b967fe589b0f">is_asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a55b4c96682d9db457216b967fe589b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an arcsine expression.  <a href="#a55b4c96682d9db457216b967fe589b0f">More...</a><br /></td></tr>
<tr class="separator:a55b4c96682d9db457216b967fe589b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a4e8165bee3d62bd4df8a68226098c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a40a4e8165bee3d62bd4df8a68226098c">is_acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a40a4e8165bee3d62bd4df8a68226098c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an arccosine expression.  <a href="#a40a4e8165bee3d62bd4df8a68226098c">More...</a><br /></td></tr>
<tr class="separator:a40a4e8165bee3d62bd4df8a68226098c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8137a62cd95401854de0b108ceb9ad6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8137a62cd95401854de0b108ceb9ad6b">is_atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a8137a62cd95401854de0b108ceb9ad6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an arctangent expression.  <a href="#a8137a62cd95401854de0b108ceb9ad6b">More...</a><br /></td></tr>
<tr class="separator:a8137a62cd95401854de0b108ceb9ad6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623309330fb0ecf31d8d9607e9da1215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a623309330fb0ecf31d8d9607e9da1215">is_atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a623309330fb0ecf31d8d9607e9da1215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an arctangent2 expression.  <a href="#a623309330fb0ecf31d8d9607e9da1215">More...</a><br /></td></tr>
<tr class="separator:a623309330fb0ecf31d8d9607e9da1215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e18537f0fba7c1c6c87b20644caf9af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4e18537f0fba7c1c6c87b20644caf9af">is_sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a4e18537f0fba7c1c6c87b20644caf9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a hyperbolic-sine expression.  <a href="#a4e18537f0fba7c1c6c87b20644caf9af">More...</a><br /></td></tr>
<tr class="separator:a4e18537f0fba7c1c6c87b20644caf9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab296e6587d7bf86a4f1b54b5005df4a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab296e6587d7bf86a4f1b54b5005df4a6">is_cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab296e6587d7bf86a4f1b54b5005df4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a hyperbolic-cosine expression.  <a href="#ab296e6587d7bf86a4f1b54b5005df4a6">More...</a><br /></td></tr>
<tr class="separator:ab296e6587d7bf86a4f1b54b5005df4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabae426c9b32ec48a5655f1e2bafd44c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aabae426c9b32ec48a5655f1e2bafd44c">is_tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aabae426c9b32ec48a5655f1e2bafd44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a hyperbolic-tangent expression.  <a href="#aabae426c9b32ec48a5655f1e2bafd44c">More...</a><br /></td></tr>
<tr class="separator:aabae426c9b32ec48a5655f1e2bafd44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad138a32ee051ed06353da9b4d26374ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad138a32ee051ed06353da9b4d26374ed">is_min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ad138a32ee051ed06353da9b4d26374ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a min expression.  <a href="#ad138a32ee051ed06353da9b4d26374ed">More...</a><br /></td></tr>
<tr class="separator:ad138a32ee051ed06353da9b4d26374ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f8d47e7843b3aabbe95d6651b7c85f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a30f8d47e7843b3aabbe95d6651b7c85f">is_max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a30f8d47e7843b3aabbe95d6651b7c85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a max expression.  <a href="#a30f8d47e7843b3aabbe95d6651b7c85f">More...</a><br /></td></tr>
<tr class="separator:a30f8d47e7843b3aabbe95d6651b7c85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af208e5f109a14eae18e12eb779e11c28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af208e5f109a14eae18e12eb779e11c28">is_ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:af208e5f109a14eae18e12eb779e11c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a ceil expression.  <a href="#af208e5f109a14eae18e12eb779e11c28">More...</a><br /></td></tr>
<tr class="separator:af208e5f109a14eae18e12eb779e11c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc1f48deb39118a12ed30496c2a0a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2fc1f48deb39118a12ed30496c2a0a33">is_floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a2fc1f48deb39118a12ed30496c2a0a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a floor expression.  <a href="#a2fc1f48deb39118a12ed30496c2a0a33">More...</a><br /></td></tr>
<tr class="separator:a2fc1f48deb39118a12ed30496c2a0a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5490fa85a0978930d5966dad1c6ba54b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5490fa85a0978930d5966dad1c6ba54b">is_if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a5490fa85a0978930d5966dad1c6ba54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an if-then-else expression.  <a href="#a5490fa85a0978930d5966dad1c6ba54b">More...</a><br /></td></tr>
<tr class="separator:a5490fa85a0978930d5966dad1c6ba54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19665aa37ff4c0aff7aa1ca142eff46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa19665aa37ff4c0aff7aa1ca142eff46">is_uninterpreted_function</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa19665aa37ff4c0aff7aa1ca142eff46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an uninterpreted-function expression.  <a href="#aa19665aa37ff4c0aff7aa1ca142eff46">More...</a><br /></td></tr>
<tr class="separator:aa19665aa37ff4c0aff7aa1ca142eff46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5165b4cdadcd273d3faad9dffd2bcc7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5165b4cdadcd273d3faad9dffd2bcc7e">get_constant_value</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a5165b4cdadcd273d3faad9dffd2bcc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant value of the constant expression <code>e</code>.  <a href="#a5165b4cdadcd273d3faad9dffd2bcc7e">More...</a><br /></td></tr>
<tr class="separator:a5165b4cdadcd273d3faad9dffd2bcc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d53e917f4fd1da3301aa00ee90bb8b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af3d53e917f4fd1da3301aa00ee90bb8b">get_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:af3d53e917f4fd1da3301aa00ee90bb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the embedded variable in the variable expression <code>e</code>.  <a href="#af3d53e917f4fd1da3301aa00ee90bb8b">More...</a><br /></td></tr>
<tr class="separator:af3d53e917f4fd1da3301aa00ee90bb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3445a75a8296154f264bf7177f9e85ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3445a75a8296154f264bf7177f9e85ab">get_argument</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a3445a75a8296154f264bf7177f9e85ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the argument in the unary expression <code>e</code>.  <a href="#a3445a75a8296154f264bf7177f9e85ab">More...</a><br /></td></tr>
<tr class="separator:a3445a75a8296154f264bf7177f9e85ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447067b42b3ed05358bbbbf227e4d1d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a447067b42b3ed05358bbbbf227e4d1d8">get_first_argument</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a447067b42b3ed05358bbbbf227e4d1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first argument of the binary expression <code>e</code>.  <a href="#a447067b42b3ed05358bbbbf227e4d1d8">More...</a><br /></td></tr>
<tr class="separator:a447067b42b3ed05358bbbbf227e4d1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e891509f0e836fd647f1ea1d8e9f86b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4e891509f0e836fd647f1ea1d8e9f86b">get_second_argument</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a4e891509f0e836fd647f1ea1d8e9f86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the second argument of the binary expression <code>e</code>.  <a href="#a4e891509f0e836fd647f1ea1d8e9f86b">More...</a><br /></td></tr>
<tr class="separator:a4e891509f0e836fd647f1ea1d8e9f86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657fe44ab4b095f9603a3c9429098981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a657fe44ab4b095f9603a3c9429098981">get_constant_in_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a657fe44ab4b095f9603a3c9429098981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant part of the addition expression <code>e</code>.  <a href="#a657fe44ab4b095f9603a3c9429098981">More...</a><br /></td></tr>
<tr class="separator:a657fe44ab4b095f9603a3c9429098981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c96dfd079cf8490a85e9f087f6aab2d"><td class="memItemLeft" align="right" valign="top">const map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0c96dfd079cf8490a85e9f087f6aab2d">get_expr_to_coeff_map_in_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a0c96dfd079cf8490a85e9f087f6aab2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map from an expression to its coefficient in the addition expression <code>e</code>.  <a href="#a0c96dfd079cf8490a85e9f087f6aab2d">More...</a><br /></td></tr>
<tr class="separator:a0c96dfd079cf8490a85e9f087f6aab2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f447c509e16ebf85df16216af97882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae1f447c509e16ebf85df16216af97882">get_constant_in_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ae1f447c509e16ebf85df16216af97882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant part of the multiplication expression <code>e</code>.  <a href="#ae1f447c509e16ebf85df16216af97882">More...</a><br /></td></tr>
<tr class="separator:ae1f447c509e16ebf85df16216af97882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abf9c0b485045bd9a88c6bda2706e3d"><td class="memItemLeft" align="right" valign="top">const map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9abf9c0b485045bd9a88c6bda2706e3d">get_base_to_exponent_map_in_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a9abf9c0b485045bd9a88c6bda2706e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map from a base expression to its exponent expression in the multiplication expression <code>e</code>.  <a href="#a9abf9c0b485045bd9a88c6bda2706e3d">More...</a><br /></td></tr>
<tr class="separator:a9abf9c0b485045bd9a88c6bda2706e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a54f523f3f3f991c16bea9f3466e2d5"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0a54f523f3f3f991c16bea9f3466e2d5">get_uninterpreted_function_name</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a0a54f523f3f3f991c16bea9f3466e2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of an uninterpreted-function expression <code>e</code>.  <a href="#a0a54f523f3f3f991c16bea9f3466e2d5">More...</a><br /></td></tr>
<tr class="separator:a0a54f523f3f3f991c16bea9f3466e2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4249d71cfbc5fe0260cd14fdc4bcf0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">vector</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8d4249d71cfbc5fe0260cd14fdc4bcf0">get_uninterpreted_function_arguments</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a8d4249d71cfbc5fe0260cd14fdc4bcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arguments of an uninterpreted-function expression <code>e</code>.  <a href="#a8d4249d71cfbc5fe0260cd14fdc4bcf0">More...</a><br /></td></tr>
<tr class="separator:a8d4249d71cfbc5fe0260cd14fdc4bcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e045ae61515d2b1a9206abc2ca5412"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a90e045ae61515d2b1a9206abc2ca5412">get_conditional_formula</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a90e045ae61515d2b1a9206abc2ca5412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conditional formula in the if-then-else expression <code>e</code>.  <a href="#a90e045ae61515d2b1a9206abc2ca5412">More...</a><br /></td></tr>
<tr class="separator:a90e045ae61515d2b1a9206abc2ca5412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc636cd4593a513941cc0431eb086e2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4fc636cd4593a513941cc0431eb086e2">get_then_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a4fc636cd4593a513941cc0431eb086e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'then' expression in the if-then-else expression <code>e</code>.  <a href="#a4fc636cd4593a513941cc0431eb086e2">More...</a><br /></td></tr>
<tr class="separator:a4fc636cd4593a513941cc0431eb086e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93333785c7a6b3a8cf3b517eadaf982a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a93333785c7a6b3a8cf3b517eadaf982a">get_else_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a93333785c7a6b3a8cf3b517eadaf982a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'else' expression in the if-then-else expression <code>e</code>.  <a href="#a93333785c7a6b3a8cf3b517eadaf982a">More...</a><br /></td></tr>
<tr class="separator:a93333785c7a6b3a8cf3b517eadaf982a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cd62f14d17b199df485d5a4c2c976a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a62cd62f14d17b199df485d5a4c2c976a">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="separator:a62cd62f14d17b199df485d5a4c2c976a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dd79861957477e088534110c2604a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a95dd79861957477e088534110c2604a1">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="separator:a95dd79861957477e088534110c2604a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442134af949ec9f659dcf48604b0a7c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a442134af949ec9f659dcf48604b0a7c9">GetVariableVector</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;evec)</td></tr>
<tr class="memdesc:a442134af949ec9f659dcf48604b0a7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a vector of variables from the vector of variable expressions.  <a href="#a442134af949ec9f659dcf48604b0a7c9">More...</a><br /></td></tr>
<tr class="separator:a442134af949ec9f659dcf48604b0a7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174c9bcab8eac6dd29f913d7d32f8da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a174c9bcab8eac6dd29f913d7d32f8da6">Jacobian</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;f, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a174c9bcab8eac6dd29f913d7d32f8da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>.  <a href="#a174c9bcab8eac6dd29f913d7d32f8da6">More...</a><br /></td></tr>
<tr class="separator:a174c9bcab8eac6dd29f913d7d32f8da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2676aafe3ce897d4a66bbad500c67c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2d2676aafe3ce897d4a66bbad500c67c">Jacobian</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;f, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a2d2676aafe3ce897d4a66bbad500c67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>.  <a href="#a2d2676aafe3ce897d4a66bbad500c67c">More...</a><br /></td></tr>
<tr class="separator:a2d2676aafe3ce897d4a66bbad500c67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd176811046c1f4fab6d56404b270d66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abd176811046c1f4fab6d56404b270d66">TaylorExpand</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;a, <a class="el" href="classint.html">int</a> order)</td></tr>
<tr class="memdesc:abd176811046c1f4fab6d56404b270d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Taylor series expansion of <code>f</code> around <code>a</code> of order <code>order</code>.  <a href="#abd176811046c1f4fab6d56404b270d66">More...</a><br /></td></tr>
<tr class="separator:abd176811046c1f4fab6d56404b270d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836d137e81878da91a559c330b8e7f18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a836d137e81878da91a559c330b8e7f18">GetDistinctVariables</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:a836d137e81878da91a559c330b8e7f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distinct variables in the matrix of expressions.  <a href="#a836d137e81878da91a559c330b8e7f18">More...</a><br /></td></tr>
<tr class="separator:a836d137e81878da91a559c330b8e7f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78354ef5dda9c52bbc103d57712c303e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a78354ef5dda9c52bbc103d57712c303e">swap</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;a, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;b)</td></tr>
<tr class="separator:a78354ef5dda9c52bbc103d57712c303e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1166bfbd5975c08fbae15fdc32eee58"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:aa1166bfbd5975c08fbae15fdc32eee58"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename MatrixR::Scalar, <a class="el" href="classdouble.html">double</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa1166bfbd5975c08fbae15fdc32eee58">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:aa1166bfbd5975c08fbae15fdc32eee58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#aa1166bfbd5975c08fbae15fdc32eee58">More...</a><br /></td></tr>
<tr class="separator:aa1166bfbd5975c08fbae15fdc32eee58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dc956184f0c8d7466e78369dd6f595"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a99dc956184f0c8d7466e78369dd6f595"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename MatrixL::Scalar, <a class="el" href="classdouble.html">double</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a99dc956184f0c8d7466e78369dd6f595">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a99dc956184f0c8d7466e78369dd6f595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#a99dc956184f0c8d7466e78369dd6f595">More...</a><br /></td></tr>
<tr class="separator:a99dc956184f0c8d7466e78369dd6f595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180fa037912fdc61df2ea9247c4c62e3"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a180fa037912fdc61df2ea9247c4c62e3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a180fa037912fdc61df2ea9247c4c62e3">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a180fa037912fdc61df2ea9247c4c62e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#a180fa037912fdc61df2ea9247c4c62e3">More...</a><br /></td></tr>
<tr class="separator:a180fa037912fdc61df2ea9247c4c62e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9037545f678181c097e5337a93bedf8f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a9037545f678181c097e5337a93bedf8f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9037545f678181c097e5337a93bedf8f">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a9037545f678181c097e5337a93bedf8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#a9037545f678181c097e5337a93bedf8f">More...</a><br /></td></tr>
<tr class="separator:a9037545f678181c097e5337a93bedf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75d66dc4baea3c6fc9f8f44a938f3a4"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:ab75d66dc4baea3c6fc9f8f44a938f3a4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename MatrixR::Scalar, <a class="el" href="classdouble.html">double</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab75d66dc4baea3c6fc9f8f44a938f3a4">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:ab75d66dc4baea3c6fc9f8f44a938f3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#ab75d66dc4baea3c6fc9f8f44a938f3a4">More...</a><br /></td></tr>
<tr class="separator:ab75d66dc4baea3c6fc9f8f44a938f3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdcb02c85dcc269afeca65eef0cbfec"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:afcdcb02c85dcc269afeca65eef0cbfec"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename MatrixL::Scalar, <a class="el" href="classdouble.html">double</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afcdcb02c85dcc269afeca65eef0cbfec">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:afcdcb02c85dcc269afeca65eef0cbfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#afcdcb02c85dcc269afeca65eef0cbfec">More...</a><br /></td></tr>
<tr class="separator:afcdcb02c85dcc269afeca65eef0cbfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8520617218403e519e010ad94a6fb64"><td class="memTemplParams" colspan="2">template&lt;int Dim, int LhsMode, int RhsMode, int LhsOptions, int RhsOptions&gt; </td></tr>
<tr class="memitem:af8520617218403e519e010ad94a6fb64"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af8520617218403e519e010ad94a6fb64">operator*</a> (const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, LhsMode, LhsOptions &gt; &amp;t1, const Eigen::Transform&lt; <a class="el" href="classdouble.html">double</a>, Dim, RhsMode, RhsOptions &gt; &amp;t2)</td></tr>
<tr class="memdesc:af8520617218403e519e010ad94a6fb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform&lt;double&gt; * Transform&lt;Expression&gt; =&gt; Transform&lt;Expression&gt;  <a href="#af8520617218403e519e010ad94a6fb64">More...</a><br /></td></tr>
<tr class="separator:af8520617218403e519e010ad94a6fb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac432e3e03086d5b147620673ed357a7c"><td class="memTemplParams" colspan="2">template&lt;int Dim, int LhsMode, int RhsMode, int LhsOptions, int RhsOptions&gt; </td></tr>
<tr class="memitem:ac432e3e03086d5b147620673ed357a7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac432e3e03086d5b147620673ed357a7c">operator*</a> (const Eigen::Transform&lt; <a class="el" href="classdouble.html">double</a>, Dim, LhsMode, LhsOptions &gt; &amp;t1, const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, RhsMode, RhsOptions &gt; &amp;t2)</td></tr>
<tr class="memdesc:ac432e3e03086d5b147620673ed357a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform&lt;Expression&gt; * Transform&lt;double&gt; =&gt; Transform&lt;Expression&gt;  <a href="#ac432e3e03086d5b147620673ed357a7c">More...</a><br /></td></tr>
<tr class="separator:ac432e3e03086d5b147620673ed357a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a166b0ad9f629567d453d875562e571"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a2a166b0ad9f629567d453d875562e571"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2a166b0ad9f629567d453d875562e571">Evaluate</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;env, <a class="el" href="namespacedrake.html#ab262f8e82f09d8df2990d0dc5869c34f">RandomGenerator</a> *random_generator=nullptr)</td></tr>
<tr class="memdesc:a2a166b0ad9f629567d453d875562e571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a symbolic matrix <code>m</code> using <code>env</code> and <code>random_generator</code>.  <a href="#a2a166b0ad9f629567d453d875562e571">More...</a><br /></td></tr>
<tr class="separator:a2a166b0ad9f629567d453d875562e571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d55ec6a55f554174d9bc45d7ed7f5c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ac3d55ec6a55f554174d9bc45d7ed7f5c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; DerivedA &gt;, DerivedA &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; DerivedB &gt;, DerivedB &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename DerivedA::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename DerivedB::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac3d55ec6a55f554174d9bc45d7ed7f5c">CheckStructuralEquality</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:ac3d55ec6a55f554174d9bc45d7ed7f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two Eigen::Matrix&lt;Expression&gt; <code>m1</code> and <code>m2</code> are structurally equal.  <a href="#ac3d55ec6a55f554174d9bc45d7ed7f5c">More...</a><br /></td></tr>
<tr class="separator:ac3d55ec6a55f554174d9bc45d7ed7f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcc9cee448290213f39d874307af7e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8dcc9cee448290213f39d874307af7e2">is_integer</a> (const <a class="el" href="classdouble.html">double</a> v)</td></tr>
<tr class="separator:a8dcc9cee448290213f39d874307af7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d47fd14fcffc0a4c50b95ae4f218131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9d47fd14fcffc0a4c50b95ae4f218131">is_positive_integer</a> (const <a class="el" href="classdouble.html">double</a> v)</td></tr>
<tr class="separator:a9d47fd14fcffc0a4c50b95ae4f218131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab388ce9f2353410c61688c6849a66adc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab388ce9f2353410c61688c6849a66adc">is_non_negative_integer</a> (const <a class="el" href="classdouble.html">double</a> v)</td></tr>
<tr class="separator:ab388ce9f2353410c61688c6849a66adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570d64c719d45bb9a809103d95f70583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a570d64c719d45bb9a809103d95f70583">DifferentiatePow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;g, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>)</td></tr>
<tr class="separator:a570d64c719d45bb9a809103d95f70583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae309a5818657ba86c33b0f46bbe0d393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae309a5818657ba86c33b0f46bbe0d393">is_constant</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ae309a5818657ba86c33b0f46bbe0d393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a constant expression.  <a href="#ae309a5818657ba86c33b0f46bbe0d393">More...</a><br /></td></tr>
<tr class="separator:ae309a5818657ba86c33b0f46bbe0d393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1044a1ad5d60045c18502cec5121149c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1044a1ad5d60045c18502cec5121149c">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a1044a1ad5d60045c18502cec5121149c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a variable expression.  <a href="#a1044a1ad5d60045c18502cec5121149c">More...</a><br /></td></tr>
<tr class="separator:a1044a1ad5d60045c18502cec5121149c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5c270803005a40362fb97997347098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8b5c270803005a40362fb97997347098">is_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a8b5c270803005a40362fb97997347098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an addition expression.  <a href="#a8b5c270803005a40362fb97997347098">More...</a><br /></td></tr>
<tr class="separator:a8b5c270803005a40362fb97997347098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbd20b990ba883bca7f6188c26ba861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3fbd20b990ba883bca7f6188c26ba861">is_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a3fbd20b990ba883bca7f6188c26ba861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an multiplication expression.  <a href="#a3fbd20b990ba883bca7f6188c26ba861">More...</a><br /></td></tr>
<tr class="separator:a3fbd20b990ba883bca7f6188c26ba861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef7767ed74e24d55ada8b380bcd22d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1ef7767ed74e24d55ada8b380bcd22d8">is_division</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a1ef7767ed74e24d55ada8b380bcd22d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a division expression.  <a href="#a1ef7767ed74e24d55ada8b380bcd22d8">More...</a><br /></td></tr>
<tr class="separator:a1ef7767ed74e24d55ada8b380bcd22d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fc6d7808fa4484507ddbb2471deb80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a81fc6d7808fa4484507ddbb2471deb80">is_log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a81fc6d7808fa4484507ddbb2471deb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a log expression.  <a href="#a81fc6d7808fa4484507ddbb2471deb80">More...</a><br /></td></tr>
<tr class="separator:a81fc6d7808fa4484507ddbb2471deb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d9027559c1c3c683711d50fc7ff48f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a98d9027559c1c3c683711d50fc7ff48f">is_abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a98d9027559c1c3c683711d50fc7ff48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an absolute-value-function expression.  <a href="#a98d9027559c1c3c683711d50fc7ff48f">More...</a><br /></td></tr>
<tr class="separator:a98d9027559c1c3c683711d50fc7ff48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1af4fb44735c433e6742487abbdf9eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa1af4fb44735c433e6742487abbdf9eb">is_exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:aa1af4fb44735c433e6742487abbdf9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an exp expression.  <a href="#aa1af4fb44735c433e6742487abbdf9eb">More...</a><br /></td></tr>
<tr class="separator:aa1af4fb44735c433e6742487abbdf9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12582d9a26dfcad1e0f38d7cb252c278"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a12582d9a26dfcad1e0f38d7cb252c278">is_sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a12582d9a26dfcad1e0f38d7cb252c278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a square-root expression.  <a href="#a12582d9a26dfcad1e0f38d7cb252c278">More...</a><br /></td></tr>
<tr class="separator:a12582d9a26dfcad1e0f38d7cb252c278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e3f155f5ffb14a784c8c6ba45eda79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a78e3f155f5ffb14a784c8c6ba45eda79">is_pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a78e3f155f5ffb14a784c8c6ba45eda79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a power-function expression.  <a href="#a78e3f155f5ffb14a784c8c6ba45eda79">More...</a><br /></td></tr>
<tr class="separator:a78e3f155f5ffb14a784c8c6ba45eda79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9333b59cea2e2d4fd444a236883efc19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9333b59cea2e2d4fd444a236883efc19">is_sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a9333b59cea2e2d4fd444a236883efc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a sine expression.  <a href="#a9333b59cea2e2d4fd444a236883efc19">More...</a><br /></td></tr>
<tr class="separator:a9333b59cea2e2d4fd444a236883efc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91183d02aeaa64b9f83cf61cede3d013"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a91183d02aeaa64b9f83cf61cede3d013">is_cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a91183d02aeaa64b9f83cf61cede3d013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a cosine expression.  <a href="#a91183d02aeaa64b9f83cf61cede3d013">More...</a><br /></td></tr>
<tr class="separator:a91183d02aeaa64b9f83cf61cede3d013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d440af755e098914afb44da35f0bc41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7d440af755e098914afb44da35f0bc41">is_tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a7d440af755e098914afb44da35f0bc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a tangent expression.  <a href="#a7d440af755e098914afb44da35f0bc41">More...</a><br /></td></tr>
<tr class="separator:a7d440af755e098914afb44da35f0bc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede8001df8d3301fef461d03dd2d859d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aede8001df8d3301fef461d03dd2d859d">is_asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:aede8001df8d3301fef461d03dd2d859d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an arcsine expression.  <a href="#aede8001df8d3301fef461d03dd2d859d">More...</a><br /></td></tr>
<tr class="separator:aede8001df8d3301fef461d03dd2d859d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5508dd313a8bc04ddcd2ce645fa2e821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5508dd313a8bc04ddcd2ce645fa2e821">is_acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a5508dd313a8bc04ddcd2ce645fa2e821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an arccosine expression.  <a href="#a5508dd313a8bc04ddcd2ce645fa2e821">More...</a><br /></td></tr>
<tr class="separator:a5508dd313a8bc04ddcd2ce645fa2e821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05b78fd26fef2a243bdfe6530c59dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae05b78fd26fef2a243bdfe6530c59dc5">is_atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ae05b78fd26fef2a243bdfe6530c59dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an arctangent expression.  <a href="#ae05b78fd26fef2a243bdfe6530c59dc5">More...</a><br /></td></tr>
<tr class="separator:ae05b78fd26fef2a243bdfe6530c59dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8916c566e17be2178816265ade645d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9d8916c566e17be2178816265ade645d">is_atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a9d8916c566e17be2178816265ade645d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a arctangent2 expression.  <a href="#a9d8916c566e17be2178816265ade645d">More...</a><br /></td></tr>
<tr class="separator:a9d8916c566e17be2178816265ade645d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b7051855909d23cb2364be81055f4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a39b7051855909d23cb2364be81055f4d">is_sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a39b7051855909d23cb2364be81055f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a hyperbolic-sine expression.  <a href="#a39b7051855909d23cb2364be81055f4d">More...</a><br /></td></tr>
<tr class="separator:a39b7051855909d23cb2364be81055f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db9c4002b15345dce271d95cf5ead8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5db9c4002b15345dce271d95cf5ead8b">is_cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a5db9c4002b15345dce271d95cf5ead8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a hyperbolic-cosine expression.  <a href="#a5db9c4002b15345dce271d95cf5ead8b">More...</a><br /></td></tr>
<tr class="separator:a5db9c4002b15345dce271d95cf5ead8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9046d3df24ec467a11723f4d93a2b2b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9046d3df24ec467a11723f4d93a2b2b0">is_tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a9046d3df24ec467a11723f4d93a2b2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a hyperbolic-tangent expression.  <a href="#a9046d3df24ec467a11723f4d93a2b2b0">More...</a><br /></td></tr>
<tr class="separator:a9046d3df24ec467a11723f4d93a2b2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07604bda8201f0e20706eb90227c1237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a07604bda8201f0e20706eb90227c1237">is_min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a07604bda8201f0e20706eb90227c1237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a min expression.  <a href="#a07604bda8201f0e20706eb90227c1237">More...</a><br /></td></tr>
<tr class="separator:a07604bda8201f0e20706eb90227c1237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb4d01316fdb9323695db004bb8253b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adfb4d01316fdb9323695db004bb8253b">is_max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:adfb4d01316fdb9323695db004bb8253b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a max expression.  <a href="#adfb4d01316fdb9323695db004bb8253b">More...</a><br /></td></tr>
<tr class="separator:adfb4d01316fdb9323695db004bb8253b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21641bf62f5605ddf8818f445fcdfa4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a21641bf62f5605ddf8818f445fcdfa4a">is_ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a21641bf62f5605ddf8818f445fcdfa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a ceil expression.  <a href="#a21641bf62f5605ddf8818f445fcdfa4a">More...</a><br /></td></tr>
<tr class="separator:a21641bf62f5605ddf8818f445fcdfa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fb80a81ab38fa64a9cc84c5dd3a71d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a20fb80a81ab38fa64a9cc84c5dd3a71d">is_floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a20fb80a81ab38fa64a9cc84c5dd3a71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a floor expression.  <a href="#a20fb80a81ab38fa64a9cc84c5dd3a71d">More...</a><br /></td></tr>
<tr class="separator:a20fb80a81ab38fa64a9cc84c5dd3a71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19b1f2d76056a8e9ee91ca1d14ee822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab19b1f2d76056a8e9ee91ca1d14ee822">is_if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ab19b1f2d76056a8e9ee91ca1d14ee822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an if-then-else expression.  <a href="#ab19b1f2d76056a8e9ee91ca1d14ee822">More...</a><br /></td></tr>
<tr class="separator:ab19b1f2d76056a8e9ee91ca1d14ee822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accafe113c53c148891d12dcabc66dddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#accafe113c53c148891d12dcabc66dddc">is_uninterpreted_function</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:accafe113c53c148891d12dcabc66dddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an uninterpreted-function expression.  <a href="#accafe113c53c148891d12dcabc66dddc">More...</a><br /></td></tr>
<tr class="separator:accafe113c53c148891d12dcabc66dddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab173345396120a34b973d67e09a4e118"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab173345396120a34b973d67e09a4e118">to_constant</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:ab173345396120a34b973d67e09a4e118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff64b176576a46d93b35472d756a41ed"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aff64b176576a46d93b35472d756a41ed">to_constant</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aff64b176576a46d93b35472d756a41ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionConstant&gt;</code>.  <a href="#aff64b176576a46d93b35472d756a41ed">More...</a><br /></td></tr>
<tr class="separator:aff64b176576a46d93b35472d756a41ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ed8ef83d2c0ee2ea7b86b31b6d4d6c"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a12ed8ef83d2c0ee2ea7b86b31b6d4d6c">to_variable</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:a12ed8ef83d2c0ee2ea7b86b31b6d4d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedfc5e119e32b8efce785e2f7988589"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abedfc5e119e32b8efce785e2f7988589">to_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:abedfc5e119e32b8efce785e2f7988589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionVar&gt;</code>.  <a href="#abedfc5e119e32b8efce785e2f7988589">More...</a><br /></td></tr>
<tr class="separator:abedfc5e119e32b8efce785e2f7988589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85468c26b36fd6389631543b62860b0"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac85468c26b36fd6389631543b62860b0">to_unary</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:ac85468c26b36fd6389631543b62860b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3563b6e32a254c6c408b178df6247bbb"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3563b6e32a254c6c408b178df6247bbb">to_unary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a3563b6e32a254c6c408b178df6247bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const UnaryExpressionCell&gt;</code>.  <a href="#a3563b6e32a254c6c408b178df6247bbb">More...</a><br /></td></tr>
<tr class="separator:a3563b6e32a254c6c408b178df6247bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af704f97cf07efcfc490be6d40484f56c"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af704f97cf07efcfc490be6d40484f56c">to_binary</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:af704f97cf07efcfc490be6d40484f56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fe17fda2fdf667c37d3fed600bee77"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a16fe17fda2fdf667c37d3fed600bee77">to_binary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a16fe17fda2fdf667c37d3fed600bee77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const BinaryExpressionCell&gt;</code>.  <a href="#a16fe17fda2fdf667c37d3fed600bee77">More...</a><br /></td></tr>
<tr class="separator:a16fe17fda2fdf667c37d3fed600bee77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb177db59b2642563f112cf82082e75f"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acb177db59b2642563f112cf82082e75f">to_addition</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:acb177db59b2642563f112cf82082e75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89454de321806c07cefbe531599ea0a1"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a89454de321806c07cefbe531599ea0a1">to_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a89454de321806c07cefbe531599ea0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAdd&gt;</code>.  <a href="#a89454de321806c07cefbe531599ea0a1">More...</a><br /></td></tr>
<tr class="separator:a89454de321806c07cefbe531599ea0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b4589fbe79f55fa7f4aebff04f35f3"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad7b4589fbe79f55fa7f4aebff04f35f3">to_multiplication</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:ad7b4589fbe79f55fa7f4aebff04f35f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503da5eae8bea0353d398db76fae5fab"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a503da5eae8bea0353d398db76fae5fab">to_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a503da5eae8bea0353d398db76fae5fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionMul&gt;</code>.  <a href="#a503da5eae8bea0353d398db76fae5fab">More...</a><br /></td></tr>
<tr class="separator:a503da5eae8bea0353d398db76fae5fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ccf3c04d940873a47e363ba0684bee"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a12ccf3c04d940873a47e363ba0684bee">to_division</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:a12ccf3c04d940873a47e363ba0684bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a50ed0d408693195e39e107616adacb"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4a50ed0d408693195e39e107616adacb">to_division</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a4a50ed0d408693195e39e107616adacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionDiv&gt;</code>.  <a href="#a4a50ed0d408693195e39e107616adacb">More...</a><br /></td></tr>
<tr class="separator:a4a50ed0d408693195e39e107616adacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97088377f3a8efb9b0af0432e91c8c4e"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a97088377f3a8efb9b0af0432e91c8c4e">to_log</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:a97088377f3a8efb9b0af0432e91c8c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b7ab14755ddf1331e1e60ba2ea886d"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab0b7ab14755ddf1331e1e60ba2ea886d">to_log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab0b7ab14755ddf1331e1e60ba2ea886d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionLog&gt;</code>.  <a href="#ab0b7ab14755ddf1331e1e60ba2ea886d">More...</a><br /></td></tr>
<tr class="separator:ab0b7ab14755ddf1331e1e60ba2ea886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfc573d7a3e1d1e870418bfcbdb7c19"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adcfc573d7a3e1d1e870418bfcbdb7c19">to_abs</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:adcfc573d7a3e1d1e870418bfcbdb7c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7876e58c70a1eb0d8f6ecade9e2a3a93"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7876e58c70a1eb0d8f6ecade9e2a3a93">to_abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a7876e58c70a1eb0d8f6ecade9e2a3a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAbs&gt;</code>.  <a href="#a7876e58c70a1eb0d8f6ecade9e2a3a93">More...</a><br /></td></tr>
<tr class="separator:a7876e58c70a1eb0d8f6ecade9e2a3a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54ee1bb70605fa6daf7b346ad4a5b95"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac54ee1bb70605fa6daf7b346ad4a5b95">to_exp</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:ac54ee1bb70605fa6daf7b346ad4a5b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918dcfa4e1c6bf30473602e582553fb7"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a918dcfa4e1c6bf30473602e582553fb7">to_exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a918dcfa4e1c6bf30473602e582553fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionExp&gt;</code>.  <a href="#a918dcfa4e1c6bf30473602e582553fb7">More...</a><br /></td></tr>
<tr class="separator:a918dcfa4e1c6bf30473602e582553fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2919c3ee769b86ade12f697595677cd4"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2919c3ee769b86ade12f697595677cd4">to_sqrt</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:a2919c3ee769b86ade12f697595677cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcee80a4ff4020269290f1821bd52e48"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adcee80a4ff4020269290f1821bd52e48">to_sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:adcee80a4ff4020269290f1821bd52e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionSqrt&gt;</code>.  <a href="#adcee80a4ff4020269290f1821bd52e48">More...</a><br /></td></tr>
<tr class="separator:adcee80a4ff4020269290f1821bd52e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4faacc0d3200d980c7100d7d9fcb0a5"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad4faacc0d3200d980c7100d7d9fcb0a5">to_pow</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:ad4faacc0d3200d980c7100d7d9fcb0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d6f38cabd766d108e510bee9b6a1ff"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a90d6f38cabd766d108e510bee9b6a1ff">to_pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a90d6f38cabd766d108e510bee9b6a1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionPow&gt;</code>.  <a href="#a90d6f38cabd766d108e510bee9b6a1ff">More...</a><br /></td></tr>
<tr class="separator:a90d6f38cabd766d108e510bee9b6a1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf94b8b2c744d25ae77e7109efec49e5"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abf94b8b2c744d25ae77e7109efec49e5">to_sin</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:abf94b8b2c744d25ae77e7109efec49e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48ec7d6f61858007ea12fe4bd2f198f"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac48ec7d6f61858007ea12fe4bd2f198f">to_sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ac48ec7d6f61858007ea12fe4bd2f198f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionSin&gt;</code>.  <a href="#ac48ec7d6f61858007ea12fe4bd2f198f">More...</a><br /></td></tr>
<tr class="separator:ac48ec7d6f61858007ea12fe4bd2f198f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d18323eef861cb26667b20481df01b8"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8d18323eef861cb26667b20481df01b8">to_cos</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:a8d18323eef861cb26667b20481df01b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafbfc4b20f88b307115ddaf1063df50"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acafbfc4b20f88b307115ddaf1063df50">to_cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acafbfc4b20f88b307115ddaf1063df50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionCos&gt;</code>.  <a href="#acafbfc4b20f88b307115ddaf1063df50">More...</a><br /></td></tr>
<tr class="separator:acafbfc4b20f88b307115ddaf1063df50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e65298d73925240f33e082ce1a84ba"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a77e65298d73925240f33e082ce1a84ba">to_tan</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:a77e65298d73925240f33e082ce1a84ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276670b46c5a9290466973b296f624eb"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a276670b46c5a9290466973b296f624eb">to_tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a276670b46c5a9290466973b296f624eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionTan&gt;</code>.  <a href="#a276670b46c5a9290466973b296f624eb">More...</a><br /></td></tr>
<tr class="separator:a276670b46c5a9290466973b296f624eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6023473c2a8b73c15d42b647733e2cdc"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6023473c2a8b73c15d42b647733e2cdc">to_asin</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:a6023473c2a8b73c15d42b647733e2cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d2f2b8f1fc3014c246798dce76150c"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a05d2f2b8f1fc3014c246798dce76150c">to_asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a05d2f2b8f1fc3014c246798dce76150c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAsin&gt;</code>.  <a href="#a05d2f2b8f1fc3014c246798dce76150c">More...</a><br /></td></tr>
<tr class="separator:a05d2f2b8f1fc3014c246798dce76150c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16e9de9e6e03bbcff2e0759e89b89de"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab16e9de9e6e03bbcff2e0759e89b89de">to_acos</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:ab16e9de9e6e03bbcff2e0759e89b89de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ff35111676293b0cec78a988ac7884"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a41ff35111676293b0cec78a988ac7884">to_acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a41ff35111676293b0cec78a988ac7884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAcos&gt;</code>.  <a href="#a41ff35111676293b0cec78a988ac7884">More...</a><br /></td></tr>
<tr class="separator:a41ff35111676293b0cec78a988ac7884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435b708a6dabaf72549f32d637302929"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a435b708a6dabaf72549f32d637302929">to_atan</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:a435b708a6dabaf72549f32d637302929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191a6ac5b31e0ae64cb40f3b99426b47"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a191a6ac5b31e0ae64cb40f3b99426b47">to_atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a191a6ac5b31e0ae64cb40f3b99426b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAtan&gt;</code>.  <a href="#a191a6ac5b31e0ae64cb40f3b99426b47">More...</a><br /></td></tr>
<tr class="separator:a191a6ac5b31e0ae64cb40f3b99426b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddc03d1da152b0250cb7b73b1d5becf"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0ddc03d1da152b0250cb7b73b1d5becf">to_atan2</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:a0ddc03d1da152b0250cb7b73b1d5becf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea842a56331d58894d509f927e243d5"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acea842a56331d58894d509f927e243d5">to_atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acea842a56331d58894d509f927e243d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAtan2&gt;</code>.  <a href="#acea842a56331d58894d509f927e243d5">More...</a><br /></td></tr>
<tr class="separator:acea842a56331d58894d509f927e243d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f16be7ba2d4ea771d99bbf40cabead"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a73f16be7ba2d4ea771d99bbf40cabead">to_sinh</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:a73f16be7ba2d4ea771d99bbf40cabead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f56a3c541437d21a7763fef7e1125a"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a04f56a3c541437d21a7763fef7e1125a">to_sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a04f56a3c541437d21a7763fef7e1125a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionSinh&gt;</code>.  <a href="#a04f56a3c541437d21a7763fef7e1125a">More...</a><br /></td></tr>
<tr class="separator:a04f56a3c541437d21a7763fef7e1125a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa995f16b51f89afbaa97860d042f5f5d"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa995f16b51f89afbaa97860d042f5f5d">to_cosh</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:aa995f16b51f89afbaa97860d042f5f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c6a4777295d48f381f234b2eb65e67"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae8c6a4777295d48f381f234b2eb65e67">to_cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ae8c6a4777295d48f381f234b2eb65e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionCosh&gt;</code>.  <a href="#ae8c6a4777295d48f381f234b2eb65e67">More...</a><br /></td></tr>
<tr class="separator:ae8c6a4777295d48f381f234b2eb65e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d074a84a5b907d9986e66da619b3ad"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab4d074a84a5b907d9986e66da619b3ad">to_tanh</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:ab4d074a84a5b907d9986e66da619b3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d059a53b8fc02e3fbdf7dc704b18bd9"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1d059a53b8fc02e3fbdf7dc704b18bd9">to_tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a1d059a53b8fc02e3fbdf7dc704b18bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionTanh&gt;</code>.  <a href="#a1d059a53b8fc02e3fbdf7dc704b18bd9">More...</a><br /></td></tr>
<tr class="separator:a1d059a53b8fc02e3fbdf7dc704b18bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac4083d7e0066180fccfbd10c85877d"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abac4083d7e0066180fccfbd10c85877d">to_min</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:abac4083d7e0066180fccfbd10c85877d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38da0e44547bf21a3c380e710415f317"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a38da0e44547bf21a3c380e710415f317">to_min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a38da0e44547bf21a3c380e710415f317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionMin&gt;</code>.  <a href="#a38da0e44547bf21a3c380e710415f317">More...</a><br /></td></tr>
<tr class="separator:a38da0e44547bf21a3c380e710415f317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcf53ee7c5eaf28a73b9e3bc1373923"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9bcf53ee7c5eaf28a73b9e3bc1373923">to_max</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:a9bcf53ee7c5eaf28a73b9e3bc1373923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4903cdd87eacec1443bab30c08a3193"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af4903cdd87eacec1443bab30c08a3193">to_max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:af4903cdd87eacec1443bab30c08a3193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionMax&gt;</code>.  <a href="#af4903cdd87eacec1443bab30c08a3193">More...</a><br /></td></tr>
<tr class="separator:af4903cdd87eacec1443bab30c08a3193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c9cfb4bd08050990d594029bdf3c96"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af1c9cfb4bd08050990d594029bdf3c96">to_ceil</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:af1c9cfb4bd08050990d594029bdf3c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a8cd6da59eab6b58591a4e26262a96"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a98a8cd6da59eab6b58591a4e26262a96">to_ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a98a8cd6da59eab6b58591a4e26262a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionCeiling&gt;</code>.  <a href="#a98a8cd6da59eab6b58591a4e26262a96">More...</a><br /></td></tr>
<tr class="separator:a98a8cd6da59eab6b58591a4e26262a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e895935101e75043c3468b034e1eff"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac3e895935101e75043c3468b034e1eff">to_floor</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:ac3e895935101e75043c3468b034e1eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1509e24662d4b4facbca5d8ad13eb4"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2b1509e24662d4b4facbca5d8ad13eb4">to_floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a2b1509e24662d4b4facbca5d8ad13eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionFloor&gt;</code>.  <a href="#a2b1509e24662d4b4facbca5d8ad13eb4">More...</a><br /></td></tr>
<tr class="separator:a2b1509e24662d4b4facbca5d8ad13eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09a2aae3694e048b16141585c8a1d22"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af09a2aae3694e048b16141585c8a1d22">to_if_then_else</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:af09a2aae3694e048b16141585c8a1d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dba4e642a84aab82a5c0e643e477448"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9dba4e642a84aab82a5c0e643e477448">to_if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a9dba4e642a84aab82a5c0e643e477448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionIfThenElse&gt;</code>.  <a href="#a9dba4e642a84aab82a5c0e643e477448">More...</a><br /></td></tr>
<tr class="separator:a9dba4e642a84aab82a5c0e643e477448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe49b247802df966f88f7114263c1d33"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afe49b247802df966f88f7114263c1d33">to_uninterpreted_function</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="separator:afe49b247802df966f88f7114263c1d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92766f8f05c318ff662b7911e1e82551"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a92766f8f05c318ff662b7911e1e82551">to_uninterpreted_function</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a92766f8f05c318ff662b7911e1e82551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionUninterpretedFunction&gt;</code>.  <a href="#a92766f8f05c318ff662b7911e1e82551">More...</a><br /></td></tr>
<tr class="separator:a92766f8f05c318ff662b7911e1e82551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347598837c2c976b8b183712a4e7c9b8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a347598837c2c976b8b183712a4e7c9b8">to_constant</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a347598837c2c976b8b183712a4e7c9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionConstant&gt;</code>.  <a href="#a347598837c2c976b8b183712a4e7c9b8">More...</a><br /></td></tr>
<tr class="separator:a347598837c2c976b8b183712a4e7c9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404e60e7e4eb9ac124318f5e272a6e89"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a404e60e7e4eb9ac124318f5e272a6e89">to_variable</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a404e60e7e4eb9ac124318f5e272a6e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionVar&gt;</code>.  <a href="#a404e60e7e4eb9ac124318f5e272a6e89">More...</a><br /></td></tr>
<tr class="separator:a404e60e7e4eb9ac124318f5e272a6e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e7ca792871e4872f470d189cf39c72"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a88e7ca792871e4872f470d189cf39c72">to_unary</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a88e7ca792871e4872f470d189cf39c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const UnaryExpressionCell&gt;</code>.  <a href="#a88e7ca792871e4872f470d189cf39c72">More...</a><br /></td></tr>
<tr class="separator:a88e7ca792871e4872f470d189cf39c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dae9d0e38fb883bf2bebd3a83df11a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae9dae9d0e38fb883bf2bebd3a83df11a">to_binary</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:ae9dae9d0e38fb883bf2bebd3a83df11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const BinaryExpressionCell&gt;</code>.  <a href="#ae9dae9d0e38fb883bf2bebd3a83df11a">More...</a><br /></td></tr>
<tr class="separator:ae9dae9d0e38fb883bf2bebd3a83df11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2798d06705e060ab4913f5b9e45b0fb7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2798d06705e060ab4913f5b9e45b0fb7">to_addition</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a2798d06705e060ab4913f5b9e45b0fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionAdd&gt;</code>.  <a href="#a2798d06705e060ab4913f5b9e45b0fb7">More...</a><br /></td></tr>
<tr class="separator:a2798d06705e060ab4913f5b9e45b0fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747fde5cedfadb1c6b2ca0303577008b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a747fde5cedfadb1c6b2ca0303577008b">to_multiplication</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a747fde5cedfadb1c6b2ca0303577008b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionMul&gt;</code>.  <a href="#a747fde5cedfadb1c6b2ca0303577008b">More...</a><br /></td></tr>
<tr class="separator:a747fde5cedfadb1c6b2ca0303577008b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07eec84289aec7d32403e1573845e7c1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a07eec84289aec7d32403e1573845e7c1">to_division</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a07eec84289aec7d32403e1573845e7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionDiv&gt;</code>.  <a href="#a07eec84289aec7d32403e1573845e7c1">More...</a><br /></td></tr>
<tr class="separator:a07eec84289aec7d32403e1573845e7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78113a7b60ef7b5032f8b0a4484803c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab78113a7b60ef7b5032f8b0a4484803c">to_log</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:ab78113a7b60ef7b5032f8b0a4484803c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionLog&gt;</code>.  <a href="#ab78113a7b60ef7b5032f8b0a4484803c">More...</a><br /></td></tr>
<tr class="separator:ab78113a7b60ef7b5032f8b0a4484803c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06990aa7d5a28abd53fe48a4afd1d410"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a06990aa7d5a28abd53fe48a4afd1d410">to_exp</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a06990aa7d5a28abd53fe48a4afd1d410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionExp&gt;</code>.  <a href="#a06990aa7d5a28abd53fe48a4afd1d410">More...</a><br /></td></tr>
<tr class="separator:a06990aa7d5a28abd53fe48a4afd1d410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d97da134da81a02ca4a380d9108b5fe"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8d97da134da81a02ca4a380d9108b5fe">to_abs</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a8d97da134da81a02ca4a380d9108b5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionAbs&gt;</code>.  <a href="#a8d97da134da81a02ca4a380d9108b5fe">More...</a><br /></td></tr>
<tr class="separator:a8d97da134da81a02ca4a380d9108b5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202b74d640b89e6ccafff3737e50bdaf"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a202b74d640b89e6ccafff3737e50bdaf">to_sqrt</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a202b74d640b89e6ccafff3737e50bdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionSqrt&gt;</code>.  <a href="#a202b74d640b89e6ccafff3737e50bdaf">More...</a><br /></td></tr>
<tr class="separator:a202b74d640b89e6ccafff3737e50bdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98e9d74c3d2118919747d30eaef6f66"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa98e9d74c3d2118919747d30eaef6f66">to_pow</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:aa98e9d74c3d2118919747d30eaef6f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionPow&gt;</code>.  <a href="#aa98e9d74c3d2118919747d30eaef6f66">More...</a><br /></td></tr>
<tr class="separator:aa98e9d74c3d2118919747d30eaef6f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a1bb3f74a9b0753ddd11c85e5bbfc7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a15a1bb3f74a9b0753ddd11c85e5bbfc7">to_sin</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a15a1bb3f74a9b0753ddd11c85e5bbfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionSin&gt;</code>.  <a href="#a15a1bb3f74a9b0753ddd11c85e5bbfc7">More...</a><br /></td></tr>
<tr class="separator:a15a1bb3f74a9b0753ddd11c85e5bbfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb71bf253046e78b2a7d5b4a671faaff"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afb71bf253046e78b2a7d5b4a671faaff">to_cos</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:afb71bf253046e78b2a7d5b4a671faaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionCos&gt;</code>.  <a href="#afb71bf253046e78b2a7d5b4a671faaff">More...</a><br /></td></tr>
<tr class="separator:afb71bf253046e78b2a7d5b4a671faaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d719a8fad661940daea51767953b78b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3d719a8fad661940daea51767953b78b">to_tan</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a3d719a8fad661940daea51767953b78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionTan&gt;</code>.  <a href="#a3d719a8fad661940daea51767953b78b">More...</a><br /></td></tr>
<tr class="separator:a3d719a8fad661940daea51767953b78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff5917c939267b83024ec0135b0ec90"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acff5917c939267b83024ec0135b0ec90">to_asin</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:acff5917c939267b83024ec0135b0ec90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionAsin&gt;</code>.  <a href="#acff5917c939267b83024ec0135b0ec90">More...</a><br /></td></tr>
<tr class="separator:acff5917c939267b83024ec0135b0ec90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c27aea1e7e7c3c076f5ab2a4127c0f7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4c27aea1e7e7c3c076f5ab2a4127c0f7">to_acos</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a4c27aea1e7e7c3c076f5ab2a4127c0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionAcos&gt;</code>.  <a href="#a4c27aea1e7e7c3c076f5ab2a4127c0f7">More...</a><br /></td></tr>
<tr class="separator:a4c27aea1e7e7c3c076f5ab2a4127c0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940feca9814d759f8f1bab0d82b6d08b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a940feca9814d759f8f1bab0d82b6d08b">to_atan</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a940feca9814d759f8f1bab0d82b6d08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionAtan&gt;</code>.  <a href="#a940feca9814d759f8f1bab0d82b6d08b">More...</a><br /></td></tr>
<tr class="separator:a940feca9814d759f8f1bab0d82b6d08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336b4874629043250d9eee8715d7e3f1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a336b4874629043250d9eee8715d7e3f1">to_atan2</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a336b4874629043250d9eee8715d7e3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionAtan2&gt;</code>.  <a href="#a336b4874629043250d9eee8715d7e3f1">More...</a><br /></td></tr>
<tr class="separator:a336b4874629043250d9eee8715d7e3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f76b800adf4e30797cfe1efe7f72fc"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a11f76b800adf4e30797cfe1efe7f72fc">to_sinh</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a11f76b800adf4e30797cfe1efe7f72fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionSinh&gt;</code>.  <a href="#a11f76b800adf4e30797cfe1efe7f72fc">More...</a><br /></td></tr>
<tr class="separator:a11f76b800adf4e30797cfe1efe7f72fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5844998206a3fa1c5a0e12658bea21"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7f5844998206a3fa1c5a0e12658bea21">to_cosh</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a7f5844998206a3fa1c5a0e12658bea21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionCosh&gt;</code>.  <a href="#a7f5844998206a3fa1c5a0e12658bea21">More...</a><br /></td></tr>
<tr class="separator:a7f5844998206a3fa1c5a0e12658bea21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278a55d0595da33908569b0da0020ff9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a278a55d0595da33908569b0da0020ff9">to_tanh</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a278a55d0595da33908569b0da0020ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionTanh&gt;</code>.  <a href="#a278a55d0595da33908569b0da0020ff9">More...</a><br /></td></tr>
<tr class="separator:a278a55d0595da33908569b0da0020ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382a9e36a860d150e7d739666a438296"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a382a9e36a860d150e7d739666a438296">to_min</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a382a9e36a860d150e7d739666a438296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionMin&gt;</code>.  <a href="#a382a9e36a860d150e7d739666a438296">More...</a><br /></td></tr>
<tr class="separator:a382a9e36a860d150e7d739666a438296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec7c1e5c20559f7fc914c1ce6eb3626"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adec7c1e5c20559f7fc914c1ce6eb3626">to_max</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:adec7c1e5c20559f7fc914c1ce6eb3626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionMax&gt;</code>.  <a href="#adec7c1e5c20559f7fc914c1ce6eb3626">More...</a><br /></td></tr>
<tr class="separator:adec7c1e5c20559f7fc914c1ce6eb3626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a222e3cd56d97d9f921089338a2a1f8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3a222e3cd56d97d9f921089338a2a1f8">to_ceil</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a3a222e3cd56d97d9f921089338a2a1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionCeiling&gt;</code>.  <a href="#a3a222e3cd56d97d9f921089338a2a1f8">More...</a><br /></td></tr>
<tr class="separator:a3a222e3cd56d97d9f921089338a2a1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126c7e1054532413b0bc816d8755c085"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a126c7e1054532413b0bc816d8755c085">to_floor</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a126c7e1054532413b0bc816d8755c085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionFloor&gt;</code>.  <a href="#a126c7e1054532413b0bc816d8755c085">More...</a><br /></td></tr>
<tr class="separator:a126c7e1054532413b0bc816d8755c085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17f0ee5f13da0796155fc00ba0421da"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac17f0ee5f13da0796155fc00ba0421da">to_if_then_else</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:ac17f0ee5f13da0796155fc00ba0421da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionIfThenElse&gt;</code>.  <a href="#ac17f0ee5f13da0796155fc00ba0421da">More...</a><br /></td></tr>
<tr class="separator:ac17f0ee5f13da0796155fc00ba0421da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af8c6bf55bff287cf9281196c8e684b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5af8c6bf55bff287cf9281196c8e684b">to_uninterpreted_function</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a5af8c6bf55bff287cf9281196c8e684b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionUninterpretedFunction&gt;</code>.  <a href="#a5af8c6bf55bff287cf9281196c8e684b">More...</a><br /></td></tr>
<tr class="separator:a5af8c6bf55bff287cf9281196c8e684b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a61c45c20176e91159639186b26e35e"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Visitor , typename... Args&gt; </td></tr>
<tr class="memitem:a0a61c45c20176e91159639186b26e35e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#aa06fbebac1e1ffc23617b782f072d79b">Result</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0a61c45c20176e91159639186b26e35e">VisitPolynomial</a> (Visitor *v, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0a61c45c20176e91159639186b26e35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls visitor object <code>v</code> with a polynomial symbolic-expression <code>e</code>, and arguments <code>args</code>.  <a href="#a0a61c45c20176e91159639186b26e35e">More...</a><br /></td></tr>
<tr class="separator:a0a61c45c20176e91159639186b26e35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58092344918003fc7e186b1c57bbc7f"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Visitor , typename... Args&gt; </td></tr>
<tr class="memitem:ab58092344918003fc7e186b1c57bbc7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#aa06fbebac1e1ffc23617b782f072d79b">Result</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab58092344918003fc7e186b1c57bbc7f">VisitExpression</a> (Visitor *v, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab58092344918003fc7e186b1c57bbc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls visitor object <code>v</code> with a symbolic-expression <code>e</code>, and arguments <code>args</code>.  <a href="#ab58092344918003fc7e186b1c57bbc7f">More...</a><br /></td></tr>
<tr class="separator:ab58092344918003fc7e186b1c57bbc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5206a4972567789a21f4c05dbbca1bc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5206a4972567789a21f4c05dbbca1bc7">operator&lt;</a> (<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> k1, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> k2)</td></tr>
<tr class="separator:a5206a4972567789a21f4c05dbbca1bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d13fc861c980e5cca95449bb11cbe01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7d13fc861c980e5cca95449bb11cbe01">forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a7d13fc861c980e5cca95449bb11cbe01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a formula <code>f</code>, universally quantified by variables <code>vars</code>.  <a href="#a7d13fc861c980e5cca95449bb11cbe01">More...</a><br /></td></tr>
<tr class="separator:a7d13fc861c980e5cca95449bb11cbe01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad928a3acb97d0b15191fdda370098cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad928a3acb97d0b15191fdda370098cec">make_conjunction</a> (const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;formulas)</td></tr>
<tr class="memdesc:ad928a3acb97d0b15191fdda370098cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a conjunction of <code>formulas</code>.  <a href="#ad928a3acb97d0b15191fdda370098cec">More...</a><br /></td></tr>
<tr class="separator:ad928a3acb97d0b15191fdda370098cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d948f388ac283cd13652db5dd61062"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa3d948f388ac283cd13652db5dd61062">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f1, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f2)</td></tr>
<tr class="separator:aa3d948f388ac283cd13652db5dd61062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439fc52dfc51fdc1038e0b18df80ca60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a439fc52dfc51fdc1038e0b18df80ca60">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="separator:a439fc52dfc51fdc1038e0b18df80ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfdf7ac64d6ce3a42877a1231ee15f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4cfdf7ac64d6ce3a42877a1231ee15f8">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:a4cfdf7ac64d6ce3a42877a1231ee15f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05740a421f5a1c3ff96463eaa65682d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a05740a421f5a1c3ff96463eaa65682d0">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v1, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v2)</td></tr>
<tr class="separator:a05740a421f5a1c3ff96463eaa65682d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a756a422ebc5e372bb1ecc5ccab5be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a10a756a422ebc5e372bb1ecc5ccab5be">make_disjunction</a> (const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;formulas)</td></tr>
<tr class="memdesc:a10a756a422ebc5e372bb1ecc5ccab5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a disjunction of <code>formulas</code>.  <a href="#a10a756a422ebc5e372bb1ecc5ccab5be">More...</a><br /></td></tr>
<tr class="separator:a10a756a422ebc5e372bb1ecc5ccab5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd02ba28125fcb30762312b0361e0790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afd02ba28125fcb30762312b0361e0790">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f1, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f2)</td></tr>
<tr class="separator:afd02ba28125fcb30762312b0361e0790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b37f14ce7a17532970ad74b4182267d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1b37f14ce7a17532970ad74b4182267d">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="separator:a1b37f14ce7a17532970ad74b4182267d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af301dd903e8b79a8584fa3ed0fb3708a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af301dd903e8b79a8584fa3ed0fb3708a">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:af301dd903e8b79a8584fa3ed0fb3708a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c7a845583db868b2d30a66c2616397"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a09c7a845583db868b2d30a66c2616397">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v1, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v2)</td></tr>
<tr class="separator:a09c7a845583db868b2d30a66c2616397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49edb4821b05df85a60fe3d96adf4f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a49edb4821b05df85a60fe3d96adf4f70">operator!</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="separator:a49edb4821b05df85a60fe3d96adf4f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9175736ad1ead8240b9bbc1bd8d4f37f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9175736ad1ead8240b9bbc1bd8d4f37f">operator!</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:a9175736ad1ead8240b9bbc1bd8d4f37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89e30b501eaa9d29d20e912e6aedc34"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae89e30b501eaa9d29d20e912e6aedc34">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="separator:ae89e30b501eaa9d29d20e912e6aedc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28c71d4bee52bfa5e4928605a4ee87d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae28c71d4bee52bfa5e4928605a4ee87d">operator==</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:ae28c71d4bee52bfa5e4928605a4ee87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2a23baf604198889aab8eea8620601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acf2a23baf604198889aab8eea8620601">operator!=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:acf2a23baf604198889aab8eea8620601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9d6243717b5f82e19ace8a5d88f450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aea9d6243717b5f82e19ace8a5d88f450">operator&lt;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:aea9d6243717b5f82e19ace8a5d88f450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91873fce901342b010a449f7952d290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad91873fce901342b010a449f7952d290">operator&lt;=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:ad91873fce901342b010a449f7952d290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047255afbaefd1684cccb967c2ceb1b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a047255afbaefd1684cccb967c2ceb1b7">operator&gt;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a047255afbaefd1684cccb967c2ceb1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f5b0df2a3fecea9d23b24475c7fdca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac8f5b0df2a3fecea9d23b24475c7fdca">operator&gt;=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:ac8f5b0df2a3fecea9d23b24475c7fdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7da5a29fea63347ec7c9fddce7f022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aee7da5a29fea63347ec7c9fddce7f022">isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aee7da5a29fea63347ec7c9fddce7f022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> for the predicate isnan(e) to the given expression.  <a href="#aee7da5a29fea63347ec7c9fddce7f022">More...</a><br /></td></tr>
<tr class="separator:aee7da5a29fea63347ec7c9fddce7f022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566d62c9e145df5946146f1a53c12a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a566d62c9e145df5946146f1a53c12a96">isinf</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a566d62c9e145df5946146f1a53c12a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> determining if the given expression <code>e</code> is a positive or negative infinity.  <a href="#a566d62c9e145df5946146f1a53c12a96">More...</a><br /></td></tr>
<tr class="separator:a566d62c9e145df5946146f1a53c12a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e386e89865ff1db9ac93f7a3e79586"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae2e386e89865ff1db9ac93f7a3e79586">isfinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ae2e386e89865ff1db9ac93f7a3e79586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> determining if the given expression <code>e</code> has a finite value.  <a href="#ae2e386e89865ff1db9ac93f7a3e79586">More...</a><br /></td></tr>
<tr class="separator:ae2e386e89865ff1db9ac93f7a3e79586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0f6e1f6ff658b6a0b46ce0f048a5f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0a0f6e1f6ff658b6a0b46ce0f048a5f3">positive_semidefinite</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;m)</td></tr>
<tr class="memdesc:a0a0f6e1f6ff658b6a0b46ce0f048a5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula constraining <code>m</code> to be a positive-semidefinite matrix.  <a href="#a0a0f6e1f6ff658b6a0b46ce0f048a5f3">More...</a><br /></td></tr>
<tr class="separator:a0a0f6e1f6ff658b6a0b46ce0f048a5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7294a6a837aa476fe079c9d5596f373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab7294a6a837aa476fe079c9d5596f373">positive_semidefinite</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;m, Eigen::UpLoType mode)</td></tr>
<tr class="memdesc:ab7294a6a837aa476fe079c9d5596f373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from <code>m</code>.  <a href="#ab7294a6a837aa476fe079c9d5596f373">More...</a><br /></td></tr>
<tr class="separator:ab7294a6a837aa476fe079c9d5596f373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6545b9866491ab6406d9141903d204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aea6545b9866491ab6406d9141903d204">is_false</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aea6545b9866491ab6406d9141903d204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is structurally equal to False formula.  <a href="#aea6545b9866491ab6406d9141903d204">More...</a><br /></td></tr>
<tr class="separator:aea6545b9866491ab6406d9141903d204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac015488f4fe334717bbe5a47e1f1da87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac015488f4fe334717bbe5a47e1f1da87">is_true</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ac015488f4fe334717bbe5a47e1f1da87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is structurally equal to True formula.  <a href="#ac015488f4fe334717bbe5a47e1f1da87">More...</a><br /></td></tr>
<tr class="separator:ac015488f4fe334717bbe5a47e1f1da87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdc9659eb8cc2eb735925fc4f2828ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aebdc9659eb8cc2eb735925fc4f2828ac">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aebdc9659eb8cc2eb735925fc4f2828ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a variable formula.  <a href="#aebdc9659eb8cc2eb735925fc4f2828ac">More...</a><br /></td></tr>
<tr class="separator:aebdc9659eb8cc2eb735925fc4f2828ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44a7661fef44d4031441019512ef82d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa44a7661fef44d4031441019512ef82d">is_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aa44a7661fef44d4031441019512ef82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing equality (==).  <a href="#aa44a7661fef44d4031441019512ef82d">More...</a><br /></td></tr>
<tr class="separator:aa44a7661fef44d4031441019512ef82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b22d6f9b90847ce4b84be2a5afd1c30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7b22d6f9b90847ce4b84be2a5afd1c30">is_not_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a7b22d6f9b90847ce4b84be2a5afd1c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing disequality (!=).  <a href="#a7b22d6f9b90847ce4b84be2a5afd1c30">More...</a><br /></td></tr>
<tr class="separator:a7b22d6f9b90847ce4b84be2a5afd1c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bef67cdba7a3575080ee23c4a49c24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a25bef67cdba7a3575080ee23c4a49c24">is_greater_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a25bef67cdba7a3575080ee23c4a49c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing greater-than (&gt;).  <a href="#a25bef67cdba7a3575080ee23c4a49c24">More...</a><br /></td></tr>
<tr class="separator:a25bef67cdba7a3575080ee23c4a49c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bd435704910ee83eec832dec9e0ebe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa6bd435704910ee83eec832dec9e0ebe">is_greater_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aa6bd435704910ee83eec832dec9e0ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing greater-than-or-equal-to (&gt;=).  <a href="#aa6bd435704910ee83eec832dec9e0ebe">More...</a><br /></td></tr>
<tr class="separator:aa6bd435704910ee83eec832dec9e0ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9754658b6efb430a95a6ef060573970e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9754658b6efb430a95a6ef060573970e">is_less_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a9754658b6efb430a95a6ef060573970e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing less-than (&lt;).  <a href="#a9754658b6efb430a95a6ef060573970e">More...</a><br /></td></tr>
<tr class="separator:a9754658b6efb430a95a6ef060573970e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1861c52cf99c60f758c0f4bd642ecf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af1861c52cf99c60f758c0f4bd642ecf9">is_less_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:af1861c52cf99c60f758c0f4bd642ecf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing less-than-or-equal-to (&lt;=).  <a href="#af1861c52cf99c60f758c0f4bd642ecf9">More...</a><br /></td></tr>
<tr class="separator:af1861c52cf99c60f758c0f4bd642ecf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48c893fbcf425253c444573d100c3f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab48c893fbcf425253c444573d100c3f2">is_relational</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ab48c893fbcf425253c444573d100c3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}).  <a href="#ab48c893fbcf425253c444573d100c3f2">More...</a><br /></td></tr>
<tr class="separator:ab48c893fbcf425253c444573d100c3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fdb6bef6734fc34b5215e5c7b661df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a70fdb6bef6734fc34b5215e5c7b661df">is_conjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a70fdb6bef6734fc34b5215e5c7b661df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a conjunction (∧).  <a href="#a70fdb6bef6734fc34b5215e5c7b661df">More...</a><br /></td></tr>
<tr class="separator:a70fdb6bef6734fc34b5215e5c7b661df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307cee89f5417dd1c19ba16bb273fb25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a307cee89f5417dd1c19ba16bb273fb25">is_disjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a307cee89f5417dd1c19ba16bb273fb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a disjunction (∨).  <a href="#a307cee89f5417dd1c19ba16bb273fb25">More...</a><br /></td></tr>
<tr class="separator:a307cee89f5417dd1c19ba16bb273fb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d76102c00828325b11b21db606b5a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a63d76102c00828325b11b21db606b5a0">is_nary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a63d76102c00828325b11b21db606b5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a n-ary formula ({∧, ∨}).  <a href="#a63d76102c00828325b11b21db606b5a0">More...</a><br /></td></tr>
<tr class="separator:a63d76102c00828325b11b21db606b5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbcd3f16b91bba700239675e5826a81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afbbcd3f16b91bba700239675e5826a81">is_negation</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:afbbcd3f16b91bba700239675e5826a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a negation (¬).  <a href="#afbbcd3f16b91bba700239675e5826a81">More...</a><br /></td></tr>
<tr class="separator:afbbcd3f16b91bba700239675e5826a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1860e7373cbab3826845de76f4c6fc6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1860e7373cbab3826845de76f4c6fc6a">is_forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a1860e7373cbab3826845de76f4c6fc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a Forall formula (∀).  <a href="#a1860e7373cbab3826845de76f4c6fc6a">More...</a><br /></td></tr>
<tr class="separator:a1860e7373cbab3826845de76f4c6fc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b1751d953407c394e5643f2d1d3f27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a75b1751d953407c394e5643f2d1d3f27">is_isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a75b1751d953407c394e5643f2d1d3f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is an isnan formula.  <a href="#a75b1751d953407c394e5643f2d1d3f27">More...</a><br /></td></tr>
<tr class="separator:a75b1751d953407c394e5643f2d1d3f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31788a703bff17b148b3107beefbc585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a31788a703bff17b148b3107beefbc585">is_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a31788a703bff17b148b3107beefbc585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a positive-semidefinite formula.  <a href="#a31788a703bff17b148b3107beefbc585">More...</a><br /></td></tr>
<tr class="separator:a31788a703bff17b148b3107beefbc585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85376535fc0a875d116702f9186d8f99"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a85376535fc0a875d116702f9186d8f99">get_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a85376535fc0a875d116702f9186d8f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the embedded variable in the variable formula <code>f</code>.  <a href="#a85376535fc0a875d116702f9186d8f99">More...</a><br /></td></tr>
<tr class="separator:a85376535fc0a875d116702f9186d8f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f3d349554a28bfa3f1107bb4adaab6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a77f3d349554a28bfa3f1107bb4adaab6">get_lhs_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a77f3d349554a28bfa3f1107bb4adaab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lhs-argument of a relational formula <code>f</code>.  <a href="#a77f3d349554a28bfa3f1107bb4adaab6">More...</a><br /></td></tr>
<tr class="separator:a77f3d349554a28bfa3f1107bb4adaab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af855c0227ec69f59da11988c82ae4ce2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af855c0227ec69f59da11988c82ae4ce2">get_rhs_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:af855c0227ec69f59da11988c82ae4ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rhs-argument of a relational formula <code>f</code>.  <a href="#af855c0227ec69f59da11988c82ae4ce2">More...</a><br /></td></tr>
<tr class="separator:af855c0227ec69f59da11988c82ae4ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a51076f5f4ab9497965268ceb34e82c"><td class="memItemLeft" align="right" valign="top">const set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5a51076f5f4ab9497965268ceb34e82c">get_operands</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a5a51076f5f4ab9497965268ceb34e82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of formulas in a n-ary formula <code>f</code>.  <a href="#a5a51076f5f4ab9497965268ceb34e82c">More...</a><br /></td></tr>
<tr class="separator:a5a51076f5f4ab9497965268ceb34e82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6409b69e4049b282edaaea65fe1b43"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4d6409b69e4049b282edaaea65fe1b43">get_operand</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a4d6409b69e4049b282edaaea65fe1b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the formula in a negation formula <code>f</code>.  <a href="#a4d6409b69e4049b282edaaea65fe1b43">More...</a><br /></td></tr>
<tr class="separator:a4d6409b69e4049b282edaaea65fe1b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637fea2c6cfc60b582df81b7b1187e94"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a637fea2c6cfc60b582df81b7b1187e94">get_quantified_variables</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a637fea2c6cfc60b582df81b7b1187e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quantified variables in a forall formula <code>f</code>.  <a href="#a637fea2c6cfc60b582df81b7b1187e94">More...</a><br /></td></tr>
<tr class="separator:a637fea2c6cfc60b582df81b7b1187e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5aa689465b2522a75c7dc12fcf1b60"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6d5aa689465b2522a75c7dc12fcf1b60">get_quantified_formula</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a6d5aa689465b2522a75c7dc12fcf1b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quantified formula in a forall formula <code>f</code>.  <a href="#a6d5aa689465b2522a75c7dc12fcf1b60">More...</a><br /></td></tr>
<tr class="separator:a6d5aa689465b2522a75c7dc12fcf1b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77026017746534a08312bf9eb2d4a99"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab77026017746534a08312bf9eb2d4a99">get_matrix_in_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ab77026017746534a08312bf9eb2d4a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matrix in a positive-semidefinite formula <code>f</code>.  <a href="#ab77026017746534a08312bf9eb2d4a99">More...</a><br /></td></tr>
<tr class="separator:ab77026017746534a08312bf9eb2d4a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d948f388ac283cd13652db5dd61062"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa3d948f388ac283cd13652db5dd61062">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f1, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f2)</td></tr>
<tr class="separator:aa3d948f388ac283cd13652db5dd61062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439fc52dfc51fdc1038e0b18df80ca60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a439fc52dfc51fdc1038e0b18df80ca60">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="separator:a439fc52dfc51fdc1038e0b18df80ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfdf7ac64d6ce3a42877a1231ee15f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4cfdf7ac64d6ce3a42877a1231ee15f8">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:a4cfdf7ac64d6ce3a42877a1231ee15f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05740a421f5a1c3ff96463eaa65682d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a05740a421f5a1c3ff96463eaa65682d0">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v1, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v2)</td></tr>
<tr class="separator:a05740a421f5a1c3ff96463eaa65682d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589bce42bdf814187045157a262e8953"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a589bce42bdf814187045157a262e8953"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a589bce42bdf814187045157a262e8953">positive_semidefinite</a> (const Eigen::TriangularView&lt; Derived, Eigen::Lower &gt; &amp;l)</td></tr>
<tr class="memdesc:a589bce42bdf814187045157a262e8953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from a lower triangular-view <code>l</code>.  <a href="#a589bce42bdf814187045157a262e8953">More...</a><br /></td></tr>
<tr class="separator:a589bce42bdf814187045157a262e8953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8fb394a3d4252968bd22740945fed2"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a5f8fb394a3d4252968bd22740945fed2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5f8fb394a3d4252968bd22740945fed2">positive_semidefinite</a> (const Eigen::TriangularView&lt; Derived, Eigen::Upper &gt; &amp;u)</td></tr>
<tr class="memdesc:a5f8fb394a3d4252968bd22740945fed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from an upper triangular-view <code>u</code>.  <a href="#a5f8fb394a3d4252968bd22740945fed2">More...</a><br /></td></tr>
<tr class="separator:a5f8fb394a3d4252968bd22740945fed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb4f53b295b2105a77d9578fff68c5e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a0bb4f53b295b2105a77d9578fff68c5e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar()==typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, typename <a class="el" href="structdrake_1_1symbolic_1_1detail_1_1_relational_op_traits.html">detail::RelationalOpTraits</a>&lt; DerivedA, DerivedB &gt;::ReturnType &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0bb4f53b295b2105a77d9578fff68c5e">operator==</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a0bb4f53b295b2105a77d9578fff68c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise symbolic-equality of two arrays <code>m1</code> and <code>m2</code>.  <a href="#a0bb4f53b295b2105a77d9578fff68c5e">More...</a><br /></td></tr>
<tr class="separator:a0bb4f53b295b2105a77d9578fff68c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebadda4ff0c83bc56fbe0d1a1394c42"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a7ebadda4ff0c83bc56fbe0d1a1394c42"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename Derived::Scalar()==ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7ebadda4ff0c83bc56fbe0d1a1394c42">operator==</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a7ebadda4ff0c83bc56fbe0d1a1394c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using equal-to operator (==).  <a href="#a7ebadda4ff0c83bc56fbe0d1a1394c42">More...</a><br /></td></tr>
<tr class="separator:a7ebadda4ff0c83bc56fbe0d1a1394c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a608496012273ef3a3588c98177334d"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a4a608496012273ef3a3588c98177334d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(ScalarType()==typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4a608496012273ef3a3588c98177334d">operator==</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a4a608496012273ef3a3588c98177334d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> equal-to operator (==).  <a href="#a4a608496012273ef3a3588c98177334d">More...</a><br /></td></tr>
<tr class="separator:a4a608496012273ef3a3588c98177334d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50df56fb87f1e4e2606295e9d8f12941"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a50df56fb87f1e4e2606295e9d8f12941"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar()&lt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, typename <a class="el" href="structdrake_1_1symbolic_1_1detail_1_1_relational_op_traits.html">detail::RelationalOpTraits</a>&lt; DerivedA, DerivedB &gt;::ReturnType &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a50df56fb87f1e4e2606295e9d8f12941">operator&lt;=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a50df56fb87f1e4e2606295e9d8f12941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using less-than-or-equal operator (&lt;=).  <a href="#a50df56fb87f1e4e2606295e9d8f12941">More...</a><br /></td></tr>
<tr class="separator:a50df56fb87f1e4e2606295e9d8f12941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68198826f1753cb1e463c57c42da9dc7"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a68198826f1753cb1e463c57c42da9dc7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename Derived::Scalar()&lt;=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a68198826f1753cb1e463c57c42da9dc7">operator&lt;=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a68198826f1753cb1e463c57c42da9dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using less-than-or-equal operator (&lt;=).  <a href="#a68198826f1753cb1e463c57c42da9dc7">More...</a><br /></td></tr>
<tr class="separator:a68198826f1753cb1e463c57c42da9dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b7debe6add1a90d995b7fe32077e15"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a84b7debe6add1a90d995b7fe32077e15"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(ScalarType()&lt;=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a84b7debe6add1a90d995b7fe32077e15">operator&lt;=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a84b7debe6add1a90d995b7fe32077e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than-or-equal operator (&lt;=).  <a href="#a84b7debe6add1a90d995b7fe32077e15">More...</a><br /></td></tr>
<tr class="separator:a84b7debe6add1a90d995b7fe32077e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2970a5e4acf251820880cc4bee1a84"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a0e2970a5e4acf251820880cc4bee1a84"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar()&lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, typename <a class="el" href="structdrake_1_1symbolic_1_1detail_1_1_relational_op_traits.html">detail::RelationalOpTraits</a>&lt; DerivedA, DerivedB &gt;::ReturnType &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0e2970a5e4acf251820880cc4bee1a84">operator&lt;</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a0e2970a5e4acf251820880cc4bee1a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using less-than operator (&lt;).  <a href="#a0e2970a5e4acf251820880cc4bee1a84">More...</a><br /></td></tr>
<tr class="separator:a0e2970a5e4acf251820880cc4bee1a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986b3544a84c715fba5ba1633845a206"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a986b3544a84c715fba5ba1633845a206"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename Derived::Scalar()&lt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a986b3544a84c715fba5ba1633845a206">operator&lt;</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a986b3544a84c715fba5ba1633845a206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using less-than operator (&lt;).  <a href="#a986b3544a84c715fba5ba1633845a206">More...</a><br /></td></tr>
<tr class="separator:a986b3544a84c715fba5ba1633845a206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c9b1d47ba70ed1290375ef56166d13"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:ae3c9b1d47ba70ed1290375ef56166d13"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(ScalarType()&lt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae3c9b1d47ba70ed1290375ef56166d13">operator&lt;</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:ae3c9b1d47ba70ed1290375ef56166d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than operator (&lt;).  <a href="#ae3c9b1d47ba70ed1290375ef56166d13">More...</a><br /></td></tr>
<tr class="separator:ae3c9b1d47ba70ed1290375ef56166d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35508f64c9d760287426d5958a94454"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ad35508f64c9d760287426d5958a94454"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar() &gt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, typename <a class="el" href="structdrake_1_1symbolic_1_1detail_1_1_relational_op_traits.html">detail::RelationalOpTraits</a>&lt; DerivedA, DerivedB &gt;::ReturnType &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad35508f64c9d760287426d5958a94454">operator&gt;=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:ad35508f64c9d760287426d5958a94454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using greater-than-or-equal operator (&gt;=).  <a href="#ad35508f64c9d760287426d5958a94454">More...</a><br /></td></tr>
<tr class="separator:ad35508f64c9d760287426d5958a94454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b826253c8e91199f4b45732ba4bf2b"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a04b826253c8e91199f4b45732ba4bf2b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename Derived::Scalar() &gt;=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a04b826253c8e91199f4b45732ba4bf2b">operator&gt;=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a04b826253c8e91199f4b45732ba4bf2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using greater-than-or-equal operator (&gt;=).  <a href="#a04b826253c8e91199f4b45732ba4bf2b">More...</a><br /></td></tr>
<tr class="separator:a04b826253c8e91199f4b45732ba4bf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405bf4ecc90c0dc8aa47223422d4ed52"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a405bf4ecc90c0dc8aa47223422d4ed52"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(ScalarType() &gt;=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a405bf4ecc90c0dc8aa47223422d4ed52">operator&gt;=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a405bf4ecc90c0dc8aa47223422d4ed52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than-or-equal operator (&lt;=) instead of greater-than-or-equal operator (&gt;=).  <a href="#a405bf4ecc90c0dc8aa47223422d4ed52">More...</a><br /></td></tr>
<tr class="separator:a405bf4ecc90c0dc8aa47223422d4ed52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd6bb55d96be271f1a64cfd26ffa286"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a1fd6bb55d96be271f1a64cfd26ffa286"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, typename <a class="el" href="structdrake_1_1symbolic_1_1detail_1_1_relational_op_traits.html">detail::RelationalOpTraits</a>&lt; DerivedA, DerivedB &gt;::ReturnType &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1fd6bb55d96be271f1a64cfd26ffa286">operator&gt;</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a1fd6bb55d96be271f1a64cfd26ffa286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using greater-than operator (&gt;).  <a href="#a1fd6bb55d96be271f1a64cfd26ffa286">More...</a><br /></td></tr>
<tr class="separator:a1fd6bb55d96be271f1a64cfd26ffa286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a0bb42e093d46cbd74a0c263c0d61a"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:ac3a0bb42e093d46cbd74a0c263c0d61a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename Derived::Scalar() &gt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac3a0bb42e093d46cbd74a0c263c0d61a">operator&gt;</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:ac3a0bb42e093d46cbd74a0c263c0d61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using greater-than operator (&gt;).  <a href="#ac3a0bb42e093d46cbd74a0c263c0d61a">More...</a><br /></td></tr>
<tr class="separator:ac3a0bb42e093d46cbd74a0c263c0d61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e63a21e3a4861f1a6fccbc7667cd298"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a0e63a21e3a4861f1a6fccbc7667cd298"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(ScalarType() &gt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0e63a21e3a4861f1a6fccbc7667cd298">operator&gt;</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a0e63a21e3a4861f1a6fccbc7667cd298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than operator (&lt;) instead of greater-than operator (&gt;).  <a href="#a0e63a21e3a4861f1a6fccbc7667cd298">More...</a><br /></td></tr>
<tr class="separator:a0e63a21e3a4861f1a6fccbc7667cd298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609ddf9b3fff35b5451473ce3d51f294"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a609ddf9b3fff35b5451473ce3d51f294"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar() !=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, typename <a class="el" href="structdrake_1_1symbolic_1_1detail_1_1_relational_op_traits.html">detail::RelationalOpTraits</a>&lt; DerivedA, DerivedB &gt;::ReturnType &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a609ddf9b3fff35b5451473ce3d51f294">operator!=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a609ddf9b3fff35b5451473ce3d51f294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using not-equal operator (!=).  <a href="#a609ddf9b3fff35b5451473ce3d51f294">More...</a><br /></td></tr>
<tr class="separator:a609ddf9b3fff35b5451473ce3d51f294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29162801f264334d6292daf5830f9f78"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a29162801f264334d6292daf5830f9f78"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename Derived::Scalar() !=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a29162801f264334d6292daf5830f9f78">operator!=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a29162801f264334d6292daf5830f9f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using not-equal operator (!=).  <a href="#a29162801f264334d6292daf5830f9f78">More...</a><br /></td></tr>
<tr class="separator:a29162801f264334d6292daf5830f9f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4d5abce6202d5c1e711750cf6d4fb6"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a1d4d5abce6202d5c1e711750cf6d4fb6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(ScalarType() !=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1d4d5abce6202d5c1e711750cf6d4fb6">operator!=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a1d4d5abce6202d5c1e711750cf6d4fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> not-equal operator (!=).  <a href="#a1d4d5abce6202d5c1e711750cf6d4fb6">More...</a><br /></td></tr>
<tr class="separator:a1d4d5abce6202d5c1e711750cf6d4fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2f78812963ed2e8e95b5807249efbc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a2f2f78812963ed2e8e95b5807249efbc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar()==typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2f2f78812963ed2e8e95b5807249efbc">operator==</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a2f2f78812963ed2e8e95b5807249efbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula checking if two matrices <code>m1</code> and <code>m2</code> are equal.  <a href="#a2f2f78812963ed2e8e95b5807249efbc">More...</a><br /></td></tr>
<tr class="separator:a2f2f78812963ed2e8e95b5807249efbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72b431bb035e5035d4a5ca5c1aedb02"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ac72b431bb035e5035d4a5ca5c1aedb02"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar() !=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac72b431bb035e5035d4a5ca5c1aedb02">operator!=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:ac72b431bb035e5035d4a5ca5c1aedb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing the condition whether <code>m1</code> and <code>m2</code> are not the same.  <a href="#ac72b431bb035e5035d4a5ca5c1aedb02">More...</a><br /></td></tr>
<tr class="separator:ac72b431bb035e5035d4a5ca5c1aedb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fb24103c168ad624e3416b15f206ae"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a41fb24103c168ad624e3416b15f206ae"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar()&lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a41fb24103c168ad624e3416b15f206ae">operator&lt;</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a41fb24103c168ad624e3416b15f206ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using less-than (&lt;) operator.  <a href="#a41fb24103c168ad624e3416b15f206ae">More...</a><br /></td></tr>
<tr class="separator:a41fb24103c168ad624e3416b15f206ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382f5863e12e1c5357b9e40a42a1787d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a382f5863e12e1c5357b9e40a42a1787d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar()&lt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a382f5863e12e1c5357b9e40a42a1787d">operator&lt;=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a382f5863e12e1c5357b9e40a42a1787d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using less-than-or-equal operator (&lt;=).  <a href="#a382f5863e12e1c5357b9e40a42a1787d">More...</a><br /></td></tr>
<tr class="separator:a382f5863e12e1c5357b9e40a42a1787d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6112c67bd713407a1da5a46df61f0ba"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ad6112c67bd713407a1da5a46df61f0ba"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad6112c67bd713407a1da5a46df61f0ba">operator&gt;</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:ad6112c67bd713407a1da5a46df61f0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using greater-than operator (&gt;).  <a href="#ad6112c67bd713407a1da5a46df61f0ba">More...</a><br /></td></tr>
<tr class="separator:ad6112c67bd713407a1da5a46df61f0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56de2d077a42329f2c508a71e7e52ca9"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a56de2d077a42329f2c508a71e7e52ca9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar() &gt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a56de2d077a42329f2c508a71e7e52ca9">operator&gt;=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a56de2d077a42329f2c508a71e7e52ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using greater-than-or-equal operator (&gt;=).  <a href="#a56de2d077a42329f2c508a71e7e52ca9">More...</a><br /></td></tr>
<tr class="separator:a56de2d077a42329f2c508a71e7e52ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8bf1c901b65947ce83086ab0921b13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8a8bf1c901b65947ce83086ab0921b13">is_false</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a8a8bf1c901b65947ce83086ab0921b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is structurally equal to False formula.  <a href="#a8a8bf1c901b65947ce83086ab0921b13">More...</a><br /></td></tr>
<tr class="separator:a8a8bf1c901b65947ce83086ab0921b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1159580703bc95a8f14848e38cb659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2f1159580703bc95a8f14848e38cb659">is_true</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a2f1159580703bc95a8f14848e38cb659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is structurally equal to True formula.  <a href="#a2f1159580703bc95a8f14848e38cb659">More...</a><br /></td></tr>
<tr class="separator:a2f1159580703bc95a8f14848e38cb659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d18c58b79582620cb6b8ff37ec1e85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a14d18c58b79582620cb6b8ff37ec1e85">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a14d18c58b79582620cb6b8ff37ec1e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a variable formula.  <a href="#a14d18c58b79582620cb6b8ff37ec1e85">More...</a><br /></td></tr>
<tr class="separator:a14d18c58b79582620cb6b8ff37ec1e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d37d1e3097c7a898d706aee5066f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a37d37d1e3097c7a898d706aee5066f90">is_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a37d37d1e3097c7a898d706aee5066f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing equality (==).  <a href="#a37d37d1e3097c7a898d706aee5066f90">More...</a><br /></td></tr>
<tr class="separator:a37d37d1e3097c7a898d706aee5066f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c4eae26a98b1345c997e579ed0709a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a08c4eae26a98b1345c997e579ed0709a">is_not_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a08c4eae26a98b1345c997e579ed0709a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing disequality (!=).  <a href="#a08c4eae26a98b1345c997e579ed0709a">More...</a><br /></td></tr>
<tr class="separator:a08c4eae26a98b1345c997e579ed0709a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf04cff26c77f1ef1f11fedc77a31bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aaf04cff26c77f1ef1f11fedc77a31bb5">is_greater_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:aaf04cff26c77f1ef1f11fedc77a31bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing greater-than (&gt;).  <a href="#aaf04cff26c77f1ef1f11fedc77a31bb5">More...</a><br /></td></tr>
<tr class="separator:aaf04cff26c77f1ef1f11fedc77a31bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987c2a9d322549f8617a45997bae8aa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a987c2a9d322549f8617a45997bae8aa6">is_greater_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a987c2a9d322549f8617a45997bae8aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing greater-than-or-equal-to (&gt;=).  <a href="#a987c2a9d322549f8617a45997bae8aa6">More...</a><br /></td></tr>
<tr class="separator:a987c2a9d322549f8617a45997bae8aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e70f747ac0d276d07b39a56d8f2b5b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4e70f747ac0d276d07b39a56d8f2b5b9">is_less_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a4e70f747ac0d276d07b39a56d8f2b5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing less-than (&lt;).  <a href="#a4e70f747ac0d276d07b39a56d8f2b5b9">More...</a><br /></td></tr>
<tr class="separator:a4e70f747ac0d276d07b39a56d8f2b5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bc9328e2893740b71f07cf466f02db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a77bc9328e2893740b71f07cf466f02db">is_less_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a77bc9328e2893740b71f07cf466f02db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing less-than-or-equal-to (&lt;=).  <a href="#a77bc9328e2893740b71f07cf466f02db">More...</a><br /></td></tr>
<tr class="separator:a77bc9328e2893740b71f07cf466f02db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3787e10ce1fe3bb7f6645a0f9ac671"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aba3787e10ce1fe3bb7f6645a0f9ac671">is_relational</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:aba3787e10ce1fe3bb7f6645a0f9ac671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}).  <a href="#aba3787e10ce1fe3bb7f6645a0f9ac671">More...</a><br /></td></tr>
<tr class="separator:aba3787e10ce1fe3bb7f6645a0f9ac671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9074585b52963983223bce6e902efea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9074585b52963983223bce6e902efea7">is_conjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a9074585b52963983223bce6e902efea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a conjunction (∧).  <a href="#a9074585b52963983223bce6e902efea7">More...</a><br /></td></tr>
<tr class="separator:a9074585b52963983223bce6e902efea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8877eff0311bb541c504a56196a591f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8877eff0311bb541c504a56196a591f0">is_disjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a8877eff0311bb541c504a56196a591f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a disjunction (∨).  <a href="#a8877eff0311bb541c504a56196a591f0">More...</a><br /></td></tr>
<tr class="separator:a8877eff0311bb541c504a56196a591f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450bcac9577de0ca8d380d2a70d5fb12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a450bcac9577de0ca8d380d2a70d5fb12">is_nary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="separator:a450bcac9577de0ca8d380d2a70d5fb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3743f22df29090472d034a69b9d7aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adf3743f22df29090472d034a69b9d7aa">is_negation</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:adf3743f22df29090472d034a69b9d7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a negation (¬).  <a href="#adf3743f22df29090472d034a69b9d7aa">More...</a><br /></td></tr>
<tr class="separator:adf3743f22df29090472d034a69b9d7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdcb84785fc3ddf61732a3279ce6d74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7cdcb84785fc3ddf61732a3279ce6d74">is_forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a7cdcb84785fc3ddf61732a3279ce6d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a Forall formula (∀).  <a href="#a7cdcb84785fc3ddf61732a3279ce6d74">More...</a><br /></td></tr>
<tr class="separator:a7cdcb84785fc3ddf61732a3279ce6d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ae3f7e8da7523a075b5adfcb7b788c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa7ae3f7e8da7523a075b5adfcb7b788c">is_isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:aa7ae3f7e8da7523a075b5adfcb7b788c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is an isnan formula.  <a href="#aa7ae3f7e8da7523a075b5adfcb7b788c">More...</a><br /></td></tr>
<tr class="separator:aa7ae3f7e8da7523a075b5adfcb7b788c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0bed602c95290fb77dc45316a1f54d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4c0bed602c95290fb77dc45316a1f54d">is_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a4c0bed602c95290fb77dc45316a1f54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a positive semidefinite formula.  <a href="#a4c0bed602c95290fb77dc45316a1f54d">More...</a><br /></td></tr>
<tr class="separator:a4c0bed602c95290fb77dc45316a1f54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba13814fd3af0fb8b3bf9fef5937259"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0ba13814fd3af0fb8b3bf9fef5937259">to_false</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:a0ba13814fd3af0fb8b3bf9fef5937259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603c9ef6720ddbfd15ac8fa558731f56"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a603c9ef6720ddbfd15ac8fa558731f56">to_false</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a603c9ef6720ddbfd15ac8fa558731f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaFalse&gt;</code>.  <a href="#a603c9ef6720ddbfd15ac8fa558731f56">More...</a><br /></td></tr>
<tr class="separator:a603c9ef6720ddbfd15ac8fa558731f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e042fdf66297be50652148b8f620a6e"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9e042fdf66297be50652148b8f620a6e">to_true</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:a9e042fdf66297be50652148b8f620a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c848a13ba1d151a8426c1f68eccd84"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad1c848a13ba1d151a8426c1f68eccd84">to_true</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ad1c848a13ba1d151a8426c1f68eccd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaTrue&gt;</code>.  <a href="#ad1c848a13ba1d151a8426c1f68eccd84">More...</a><br /></td></tr>
<tr class="separator:ad1c848a13ba1d151a8426c1f68eccd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c33306d129ac11e42cfcab65d442c4e"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8c33306d129ac11e42cfcab65d442c4e">to_variable</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:a8c33306d129ac11e42cfcab65d442c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f8e0af875561b1be3924d5231a4fc5"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab4f8e0af875561b1be3924d5231a4fc5">to_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ab4f8e0af875561b1be3924d5231a4fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaVar&gt;</code>.  <a href="#ab4f8e0af875561b1be3924d5231a4fc5">More...</a><br /></td></tr>
<tr class="separator:ab4f8e0af875561b1be3924d5231a4fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06612e77d2c8f8c3e90b90dd00902b0e"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a06612e77d2c8f8c3e90b90dd00902b0e">to_relational</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:a06612e77d2c8f8c3e90b90dd00902b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5adb166222c87b263d32272950d7450"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad5adb166222c87b263d32272950d7450">to_relational</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ad5adb166222c87b263d32272950d7450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const RelationalFormulaCell&gt;</code>.  <a href="#ad5adb166222c87b263d32272950d7450">More...</a><br /></td></tr>
<tr class="separator:ad5adb166222c87b263d32272950d7450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8dc389d77c6c2a4a850d832d1b6d16"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8f8dc389d77c6c2a4a850d832d1b6d16">to_equal_to</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:a8f8dc389d77c6c2a4a850d832d1b6d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e02a8c0d203f8dc0f6534f0216a6e9"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae7e02a8c0d203f8dc0f6534f0216a6e9">to_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ae7e02a8c0d203f8dc0f6534f0216a6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaEq&gt;</code>.  <a href="#ae7e02a8c0d203f8dc0f6534f0216a6e9">More...</a><br /></td></tr>
<tr class="separator:ae7e02a8c0d203f8dc0f6534f0216a6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753d76e300a5e80cf9266349ee2e9c70"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a753d76e300a5e80cf9266349ee2e9c70">to_not_equal_to</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:a753d76e300a5e80cf9266349ee2e9c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeebc47bad53d0b5dad9a132008babcf"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abeebc47bad53d0b5dad9a132008babcf">to_not_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:abeebc47bad53d0b5dad9a132008babcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaNeq&gt;</code>.  <a href="#abeebc47bad53d0b5dad9a132008babcf">More...</a><br /></td></tr>
<tr class="separator:abeebc47bad53d0b5dad9a132008babcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7111e8d51d064671c73b02af632271ec"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7111e8d51d064671c73b02af632271ec">to_greater_than</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:a7111e8d51d064671c73b02af632271ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4dbcc76c7f19ecd59beb4ce4a4c037"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1c4dbcc76c7f19ecd59beb4ce4a4c037">to_greater_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a1c4dbcc76c7f19ecd59beb4ce4a4c037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaGt&gt;</code>.  <a href="#a1c4dbcc76c7f19ecd59beb4ce4a4c037">More...</a><br /></td></tr>
<tr class="separator:a1c4dbcc76c7f19ecd59beb4ce4a4c037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554eea5921e8e14747886083f8b51657"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a554eea5921e8e14747886083f8b51657">to_greater_than_or_equal_to</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:a554eea5921e8e14747886083f8b51657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad707a3bf5f43859e1b81a6c69df4d6"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5ad707a3bf5f43859e1b81a6c69df4d6">to_greater_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a5ad707a3bf5f43859e1b81a6c69df4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaGeq&gt;</code>.  <a href="#a5ad707a3bf5f43859e1b81a6c69df4d6">More...</a><br /></td></tr>
<tr class="separator:a5ad707a3bf5f43859e1b81a6c69df4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b35a020aceb955d3739bddfbed43c4"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa4b35a020aceb955d3739bddfbed43c4">to_less_than</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:aa4b35a020aceb955d3739bddfbed43c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f364890b2418f79f92eeeee19dafbf"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a61f364890b2418f79f92eeeee19dafbf">to_less_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a61f364890b2418f79f92eeeee19dafbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaLt&gt;</code>.  <a href="#a61f364890b2418f79f92eeeee19dafbf">More...</a><br /></td></tr>
<tr class="separator:a61f364890b2418f79f92eeeee19dafbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdc64fa82f240e639ede034efd51450"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7cdc64fa82f240e639ede034efd51450">to_less_than_or_equal_to</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:a7cdc64fa82f240e639ede034efd51450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa470f5843a651bcd63660f99f85be932"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa470f5843a651bcd63660f99f85be932">to_less_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aa470f5843a651bcd63660f99f85be932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaLeq&gt;</code>.  <a href="#aa470f5843a651bcd63660f99f85be932">More...</a><br /></td></tr>
<tr class="separator:aa470f5843a651bcd63660f99f85be932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd265a5fdecda6e1085bd00f06924b27"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acd265a5fdecda6e1085bd00f06924b27">to_nary</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:acd265a5fdecda6e1085bd00f06924b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd977ff4775f2df5d9e46fa0992ee95"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abbd977ff4775f2df5d9e46fa0992ee95">to_nary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:abbd977ff4775f2df5d9e46fa0992ee95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const NaryFormulaCell&gt;</code>.  <a href="#abbd977ff4775f2df5d9e46fa0992ee95">More...</a><br /></td></tr>
<tr class="separator:abbd977ff4775f2df5d9e46fa0992ee95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480c4ded252898418ac3d288a782927c"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a480c4ded252898418ac3d288a782927c">to_conjunction</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:a480c4ded252898418ac3d288a782927c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26b500eabee827ec26352fc86458fdb"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad26b500eabee827ec26352fc86458fdb">to_conjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ad26b500eabee827ec26352fc86458fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaAnd&gt;</code>.  <a href="#ad26b500eabee827ec26352fc86458fdb">More...</a><br /></td></tr>
<tr class="separator:ad26b500eabee827ec26352fc86458fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc481eb863111b45a30b98728950e819"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adc481eb863111b45a30b98728950e819">to_disjunction</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:adc481eb863111b45a30b98728950e819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc35666075f70ae7805e4569477ceee"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adfc35666075f70ae7805e4569477ceee">to_disjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:adfc35666075f70ae7805e4569477ceee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaOr&gt;</code>.  <a href="#adfc35666075f70ae7805e4569477ceee">More...</a><br /></td></tr>
<tr class="separator:adfc35666075f70ae7805e4569477ceee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6510c4a0f3b3b797cb9d9305f198736c"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6510c4a0f3b3b797cb9d9305f198736c">to_negation</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:a6510c4a0f3b3b797cb9d9305f198736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa10206faf7f90564d9c0a61cc19e2e8"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afa10206faf7f90564d9c0a61cc19e2e8">to_negation</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:afa10206faf7f90564d9c0a61cc19e2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaNot&gt;</code>.  <a href="#afa10206faf7f90564d9c0a61cc19e2e8">More...</a><br /></td></tr>
<tr class="separator:afa10206faf7f90564d9c0a61cc19e2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55d2adc3de9351c9a833087eca08101"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac55d2adc3de9351c9a833087eca08101">to_forall</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:ac55d2adc3de9351c9a833087eca08101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced8482cbe31d08f479d245b2cc96da3"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aced8482cbe31d08f479d245b2cc96da3">to_forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aced8482cbe31d08f479d245b2cc96da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaForall&gt;</code>.  <a href="#aced8482cbe31d08f479d245b2cc96da3">More...</a><br /></td></tr>
<tr class="separator:aced8482cbe31d08f479d245b2cc96da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bde08c6491c195f6e1231beb4fdbea"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a36bde08c6491c195f6e1231beb4fdbea">to_isnan</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:a36bde08c6491c195f6e1231beb4fdbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df47ce76878738dcd7bdc4a5ce45d4b"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6df47ce76878738dcd7bdc4a5ce45d4b">to_isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a6df47ce76878738dcd7bdc4a5ce45d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaIsnan&gt;</code>.  <a href="#a6df47ce76878738dcd7bdc4a5ce45d4b">More...</a><br /></td></tr>
<tr class="separator:a6df47ce76878738dcd7bdc4a5ce45d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0858148ff6232150b209c71074031439"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0858148ff6232150b209c71074031439">to_positive_semidefinite</a> (const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="separator:a0858148ff6232150b209c71074031439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18206d9f3709de478fe53f8a54cc83ca"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a18206d9f3709de478fe53f8a54cc83ca">to_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a18206d9f3709de478fe53f8a54cc83ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaPositiveSemidefinite&gt;</code>.  <a href="#a18206d9f3709de478fe53f8a54cc83ca">More...</a><br /></td></tr>
<tr class="separator:a18206d9f3709de478fe53f8a54cc83ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba2673fe37620dcc2a3b06ab7b72bec"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1ba2673fe37620dcc2a3b06ab7b72bec">to_false</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a1ba2673fe37620dcc2a3b06ab7b72bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaFalse&gt;</code>.  <a href="#a1ba2673fe37620dcc2a3b06ab7b72bec">More...</a><br /></td></tr>
<tr class="separator:a1ba2673fe37620dcc2a3b06ab7b72bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85772f75f073405ed82017151b4cb279"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a85772f75f073405ed82017151b4cb279">to_true</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a85772f75f073405ed82017151b4cb279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaTrue&gt;</code>.  <a href="#a85772f75f073405ed82017151b4cb279">More...</a><br /></td></tr>
<tr class="separator:a85772f75f073405ed82017151b4cb279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b78dde9ca32fe1ee12cc232a9a4e85c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3b78dde9ca32fe1ee12cc232a9a4e85c">to_variable</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a3b78dde9ca32fe1ee12cc232a9a4e85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaVar&gt;</code>.  <a href="#a3b78dde9ca32fe1ee12cc232a9a4e85c">More...</a><br /></td></tr>
<tr class="separator:a3b78dde9ca32fe1ee12cc232a9a4e85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259612bbd9405f24d4ac3b60d54575e6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a259612bbd9405f24d4ac3b60d54575e6">to_relational</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a259612bbd9405f24d4ac3b60d54575e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const RelationalFormulaCell&gt;</code>.  <a href="#a259612bbd9405f24d4ac3b60d54575e6">More...</a><br /></td></tr>
<tr class="separator:a259612bbd9405f24d4ac3b60d54575e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a6204418091c1fbf26c9d2ad03389f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a10a6204418091c1fbf26c9d2ad03389f">to_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a10a6204418091c1fbf26c9d2ad03389f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaEq&gt;</code>.  <a href="#a10a6204418091c1fbf26c9d2ad03389f">More...</a><br /></td></tr>
<tr class="separator:a10a6204418091c1fbf26c9d2ad03389f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e880ce60c41c7e65085dbf911edded"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a70e880ce60c41c7e65085dbf911edded">to_not_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a70e880ce60c41c7e65085dbf911edded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaNeq&gt;</code>.  <a href="#a70e880ce60c41c7e65085dbf911edded">More...</a><br /></td></tr>
<tr class="separator:a70e880ce60c41c7e65085dbf911edded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352fe19778d77b7095580950d8e298b4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a352fe19778d77b7095580950d8e298b4">to_greater_than</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a352fe19778d77b7095580950d8e298b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaGt&gt;</code>.  <a href="#a352fe19778d77b7095580950d8e298b4">More...</a><br /></td></tr>
<tr class="separator:a352fe19778d77b7095580950d8e298b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8cbb802de92188843f8531d6b05827"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7f8cbb802de92188843f8531d6b05827">to_greater_than_or_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a7f8cbb802de92188843f8531d6b05827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaGeq&gt;</code>.  <a href="#a7f8cbb802de92188843f8531d6b05827">More...</a><br /></td></tr>
<tr class="separator:a7f8cbb802de92188843f8531d6b05827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7488de67ca4d6bc69cec3bb0f67ae4c3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7488de67ca4d6bc69cec3bb0f67ae4c3">to_less_than</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a7488de67ca4d6bc69cec3bb0f67ae4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaLt&gt;</code>.  <a href="#a7488de67ca4d6bc69cec3bb0f67ae4c3">More...</a><br /></td></tr>
<tr class="separator:a7488de67ca4d6bc69cec3bb0f67ae4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb39c33945b763922fe0fcacc6c369b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acfb39c33945b763922fe0fcacc6c369b">to_less_than_or_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:acfb39c33945b763922fe0fcacc6c369b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaLeq&gt;</code>.  <a href="#acfb39c33945b763922fe0fcacc6c369b">More...</a><br /></td></tr>
<tr class="separator:acfb39c33945b763922fe0fcacc6c369b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180aa6c7637801b158099a87a59a4185"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a180aa6c7637801b158099a87a59a4185">to_conjunction</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a180aa6c7637801b158099a87a59a4185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaAnd&gt;</code>.  <a href="#a180aa6c7637801b158099a87a59a4185">More...</a><br /></td></tr>
<tr class="separator:a180aa6c7637801b158099a87a59a4185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0758b788047cb3d6b4737c6d54cee2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0b0758b788047cb3d6b4737c6d54cee2">to_disjunction</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a0b0758b788047cb3d6b4737c6d54cee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaOr&gt;</code>.  <a href="#a0b0758b788047cb3d6b4737c6d54cee2">More...</a><br /></td></tr>
<tr class="separator:a0b0758b788047cb3d6b4737c6d54cee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f9249b5c150485c3c7cff61d5c0416"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad0f9249b5c150485c3c7cff61d5c0416">to_nary</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:ad0f9249b5c150485c3c7cff61d5c0416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const NaryFormulaCell&gt;</code>.  <a href="#ad0f9249b5c150485c3c7cff61d5c0416">More...</a><br /></td></tr>
<tr class="separator:ad0f9249b5c150485c3c7cff61d5c0416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceef2c41a1ce6c5f7eed83c1d2df9381"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aceef2c41a1ce6c5f7eed83c1d2df9381">to_negation</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:aceef2c41a1ce6c5f7eed83c1d2df9381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaNot&gt;</code>.  <a href="#aceef2c41a1ce6c5f7eed83c1d2df9381">More...</a><br /></td></tr>
<tr class="separator:aceef2c41a1ce6c5f7eed83c1d2df9381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c587017789ff28f462e87ba0a44872d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7c587017789ff28f462e87ba0a44872d">to_forall</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a7c587017789ff28f462e87ba0a44872d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaForall&gt;</code>.  <a href="#a7c587017789ff28f462e87ba0a44872d">More...</a><br /></td></tr>
<tr class="separator:a7c587017789ff28f462e87ba0a44872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f46f5ae1e9130eb9214a2ae0611f52"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad4f46f5ae1e9130eb9214a2ae0611f52">to_isnan</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:ad4f46f5ae1e9130eb9214a2ae0611f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaIsnan&gt;</code>.  <a href="#ad4f46f5ae1e9130eb9214a2ae0611f52">More...</a><br /></td></tr>
<tr class="separator:ad4f46f5ae1e9130eb9214a2ae0611f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6854fa16fb68d99c3cbe16d2c9afc584"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6854fa16fb68d99c3cbe16d2c9afc584">to_positive_semidefinite</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a6854fa16fb68d99c3cbe16d2c9afc584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaPositiveSemidefinite&gt;</code>.  <a href="#a6854fa16fb68d99c3cbe16d2c9afc584">More...</a><br /></td></tr>
<tr class="separator:a6854fa16fb68d99c3cbe16d2c9afc584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2748b5dc34bc17a6c6e98ac1d0cc1ad"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Visitor , typename... Args&gt; </td></tr>
<tr class="memitem:aa2748b5dc34bc17a6c6e98ac1d0cc1ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#aa06fbebac1e1ffc23617b782f072d79b">Result</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa2748b5dc34bc17a6c6e98ac1d0cc1ad">VisitFormula</a> (Visitor *v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa2748b5dc34bc17a6c6e98ac1d0cc1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls visitor object <code>v</code> with a symbolic formula <code>f</code>, and arguments <code>args</code>.  <a href="#aa2748b5dc34bc17a6c6e98ac1d0cc1ad">More...</a><br /></td></tr>
<tr class="separator:aa2748b5dc34bc17a6c6e98ac1d0cc1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23c192a89e3cca0185cf101d2e4e9d1"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa23c192a89e3cca0185cf101d2e4e9d1">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:aa23c192a89e3cca0185cf101d2e4e9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eb41b274605738d8049c0f0440c9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad5eb41b274605738d8049c0f0440c9ec">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m2)</td></tr>
<tr class="memdesc:ad5eb41b274605738d8049c0f0440c9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a multiplication of two monomials, <code>m1</code> and <code>m2</code>.  <a href="#ad5eb41b274605738d8049c0f0440c9ec">More...</a><br /></td></tr>
<tr class="separator:ad5eb41b274605738d8049c0f0440c9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fccbdfb814f10727e3b23ef0b6a20f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad9fccbdfb814f10727e3b23ef0b6a20f">pow</a> (<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> m, <a class="el" href="classint.html">int</a> p)</td></tr>
<tr class="memdesc:ad9fccbdfb814f10727e3b23ef0b6a20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>m1</code> raised to <code>p</code>.  <a href="#ad9fccbdfb814f10727e3b23ef0b6a20f">More...</a><br /></td></tr>
<tr class="separator:ad9fccbdfb814f10727e3b23ef0b6a20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6302f8ed7ce764202bffb915277dc2"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adc6302f8ed7ce764202bffb915277dc2">MonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>, <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="memdesc:adc6302f8ed7ce764202bffb915277dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all monomials up to a given degree under the graded reverse lexicographic order.  <a href="#adc6302f8ed7ce764202bffb915277dc2">More...</a><br /></td></tr>
<tr class="separator:adc6302f8ed7ce764202bffb915277dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40528027cce753aacb377913342f536"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa40528027cce753aacb377913342f536">NChooseK</a> (<a class="el" href="classint.html">int</a> n, <a class="el" href="classint.html">int</a> k)</td></tr>
<tr class="separator:aa40528027cce753aacb377913342f536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af297794f22c0458592aeea637cce060a"><td class="memTemplParams" colspan="2">template&lt;int n, int degree&gt; </td></tr>
<tr class="memitem:af297794f22c0458592aeea637cce060a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, <a class="el" href="namespacedrake_1_1symbolic.html#aa40528027cce753aacb377913342f536">NChooseK</a>(n+degree, degree), 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af297794f22c0458592aeea637cce060a">MonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:af297794f22c0458592aeea637cce060a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all monomials up to a given degree under the graded reverse lexicographic order.  <a href="#af297794f22c0458592aeea637cce060a">More...</a><br /></td></tr>
<tr class="separator:af297794f22c0458592aeea637cce060a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3fa831fe8133b44fb872c4dd1994f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6d3fa831fe8133b44fb872c4dd1994f3">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="memdesc:a6d3fa831fe8133b44fb872c4dd1994f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operation for polynomial.  <a href="#a6d3fa831fe8133b44fb872c4dd1994f3">More...</a><br /></td></tr>
<tr class="separator:a6d3fa831fe8133b44fb872c4dd1994f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24522315ccc26ae75f90fe52edf75f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af24522315ccc26ae75f90fe52edf75f8">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p2)</td></tr>
<tr class="separator:af24522315ccc26ae75f90fe52edf75f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e385d568eb0ddc41d5b2dac2e081be0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1e385d568eb0ddc41d5b2dac2e081be0">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a1e385d568eb0ddc41d5b2dac2e081be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f71e04c7645cc414e256fd4dd5bb868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8f71e04c7645cc414e256fd4dd5bb868">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:a8f71e04c7645cc414e256fd4dd5bb868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3624f7d482fabd5c332896a9c5c94734"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3624f7d482fabd5c332896a9c5c94734">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m2)</td></tr>
<tr class="separator:a3624f7d482fabd5c332896a9c5c94734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d57ab48e0f05c15c1f1ca7b548d28a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac6d57ab48e0f05c15c1f1ca7b548d28a">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:ac6d57ab48e0f05c15c1f1ca7b548d28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01286b53b3a9fcbb6fd0f86b21f4835"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af01286b53b3a9fcbb6fd0f86b21f4835">operator+</a> (const <a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:af01286b53b3a9fcbb6fd0f86b21f4835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923b6c6ade771a8ba39ee1d077e88c86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a923b6c6ade771a8ba39ee1d077e88c86">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, const <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a923b6c6ade771a8ba39ee1d077e88c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32bf5f5b50f389fce559dd9df0ae5bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae32bf5f5b50f389fce559dd9df0ae5bc">operator+</a> (const <a class="el" href="classdouble.html">double</a> c, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:ae32bf5f5b50f389fce559dd9df0ae5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5b784ac8ef76dc1d5295d1d4d6f89a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2e5b784ac8ef76dc1d5295d1d4d6f89a">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p2)</td></tr>
<tr class="separator:a2e5b784ac8ef76dc1d5295d1d4d6f89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ad706c6f9ac6d8413383d8152c4b51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a47ad706c6f9ac6d8413383d8152c4b51">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a47ad706c6f9ac6d8413383d8152c4b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f70ed5b694fb54c450571f7e954ca64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4f70ed5b694fb54c450571f7e954ca64">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:a4f70ed5b694fb54c450571f7e954ca64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a25d63b978c1df701182843ce44f0ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3a25d63b978c1df701182843ce44f0ca">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m2)</td></tr>
<tr class="separator:a3a25d63b978c1df701182843ce44f0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576e1c4debb10532b634ce5c7528bfb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a576e1c4debb10532b634ce5c7528bfb8">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a576e1c4debb10532b634ce5c7528bfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19080e6e3ae03a4d4d1c6ec7cf10388a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a19080e6e3ae03a4d4d1c6ec7cf10388a">operator-</a> (const <a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:a19080e6e3ae03a4d4d1c6ec7cf10388a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a23622b0642107b424fe1b5ef265980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3a23622b0642107b424fe1b5ef265980">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, const <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a3a23622b0642107b424fe1b5ef265980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62b510efea342f3bbdbb36944fe42d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab62b510efea342f3bbdbb36944fe42d2">operator-</a> (const <a class="el" href="classdouble.html">double</a> c, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:ab62b510efea342f3bbdbb36944fe42d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c0402d8a4ab5d50003560ddccdb3a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a60c0402d8a4ab5d50003560ddccdb3a6">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p2)</td></tr>
<tr class="separator:a60c0402d8a4ab5d50003560ddccdb3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a1e5c6f989d9eb82b47f06df766264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a82a1e5c6f989d9eb82b47f06df766264">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a82a1e5c6f989d9eb82b47f06df766264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f74794ee4a396e8fd39b44665c2a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a45f74794ee4a396e8fd39b44665c2a62">operator*</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:a45f74794ee4a396e8fd39b44665c2a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99abd45b5e371255adc9d5c8b078b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af99abd45b5e371255adc9d5c8b078b36">operator*</a> (const <a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:af99abd45b5e371255adc9d5c8b078b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51601d6a1010077eb8bcda7be53221b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a51601d6a1010077eb8bcda7be53221b0">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a51601d6a1010077eb8bcda7be53221b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335b835b158bb74b8c176f0a9d0d98b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a335b835b158bb74b8c176f0a9d0d98b3">operator*</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a335b835b158bb74b8c176f0a9d0d98b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e80d8ac3887ff8b4c0368edf473436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a30e80d8ac3887ff8b4c0368edf473436">operator*</a> (<a class="el" href="classdouble.html">double</a> c, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a30e80d8ac3887ff8b4c0368edf473436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2996d1aeb389e57074bef357b2db3585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2996d1aeb389e57074bef357b2db3585">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, <a class="el" href="classint.html">int</a> n)</td></tr>
<tr class="memdesc:a2996d1aeb389e57074bef357b2db3585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns polynomial <code>rasied</code> to <code>n</code>.  <a href="#a2996d1aeb389e57074bef357b2db3585">More...</a><br /></td></tr>
<tr class="separator:a2996d1aeb389e57074bef357b2db3585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd965dfa0e1c7197884ac82fc5f1878"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aacd965dfa0e1c7197884ac82fc5f1878">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:aacd965dfa0e1c7197884ac82fc5f1878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2143c3319c15d24b46cf25471e104011"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a2143c3319c15d24b46cf25471e104011"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2143c3319c15d24b46cf25471e104011">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a2143c3319c15d24b46cf25471e104011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#a2143c3319c15d24b46cf25471e104011">More...</a><br /></td></tr>
<tr class="separator:a2143c3319c15d24b46cf25471e104011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9b8f20b56f0e3d96b76c3a76610ed4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aba9b8f20b56f0e3d96b76c3a76610ed4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f)</td></tr>
<tr class="separator:aba9b8f20b56f0e3d96b76c3a76610ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9d907364da3c18f9f763ea935dcfb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5d9d907364da3c18f9f763ea935dcfb0">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="memdesc:a5d9d907364da3c18f9f763ea935dcfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operation for rational function.  <a href="#a5d9d907364da3c18f9f763ea935dcfb0">More...</a><br /></td></tr>
<tr class="separator:a5d9d907364da3c18f9f763ea935dcfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f257b9087b47d0579d8e7d9631abb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a90f257b9087b47d0579d8e7d9631abb4">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="separator:a90f257b9087b47d0579d8e7d9631abb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab71a213952c1f284526102a4356381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6ab71a213952c1f284526102a4356381">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a6ab71a213952c1f284526102a4356381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0801308a64278437b3734f11cc813da5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0801308a64278437b3734f11cc813da5">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a0801308a64278437b3734f11cc813da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc56bda0a18e846fe326ac025e01a45d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abc56bda0a18e846fe326ac025e01a45d">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:abc56bda0a18e846fe326ac025e01a45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001ec416bb7ee68695e1ec9a65b98720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a001ec416bb7ee68695e1ec9a65b98720">operator+</a> (<a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a001ec416bb7ee68695e1ec9a65b98720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084bf309d07e7c8560b89bcf3f7523a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a084bf309d07e7c8560b89bcf3f7523a2">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="separator:a084bf309d07e7c8560b89bcf3f7523a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cb7637d5591968374ac16f95d7ca68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a42cb7637d5591968374ac16f95d7ca68">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a42cb7637d5591968374ac16f95d7ca68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d07ec1d9258a03df17a869e18842fcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1d07ec1d9258a03df17a869e18842fcd">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a1d07ec1d9258a03df17a869e18842fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dbb91e91fae264abe9d39a6c167fe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a67dbb91e91fae264abe9d39a6c167fe3">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a67dbb91e91fae264abe9d39a6c167fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417daa8f767bb80ebf2b775eede4ad76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a417daa8f767bb80ebf2b775eede4ad76">operator-</a> (<a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a417daa8f767bb80ebf2b775eede4ad76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e353ad2f92e91622a6554945c10190"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a47e353ad2f92e91622a6554945c10190">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="separator:a47e353ad2f92e91622a6554945c10190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da13e9a5ae37fbfea7bd661cc15b3f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5da13e9a5ae37fbfea7bd661cc15b3f8">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a5da13e9a5ae37fbfea7bd661cc15b3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96d8eb0d54db155ab9f2ae5b3057c2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac96d8eb0d54db155ab9f2ae5b3057c2f">operator*</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:ac96d8eb0d54db155ab9f2ae5b3057c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92318b3c84edc12ed69faa7098c9ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab92318b3c84edc12ed69faa7098c9ccc">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:ab92318b3c84edc12ed69faa7098c9ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6654fd307d9348f2baa46da2ff3abd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae6654fd307d9348f2baa46da2ff3abd3">operator*</a> (<a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:ae6654fd307d9348f2baa46da2ff3abd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd63e0afe919c6474d0da57593d8d5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aedd63e0afe919c6474d0da57593d8d5f">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="separator:aedd63e0afe919c6474d0da57593d8d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0bea506f1ba735c18adec70cc049a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6f0bea506f1ba735c18adec70cc049a1">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a6f0bea506f1ba735c18adec70cc049a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b72643a63257ec55447a31a7627b7dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0b72643a63257ec55447a31a7627b7dd">operator/</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f)</td></tr>
<tr class="separator:a0b72643a63257ec55447a31a7627b7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffbde3ace1b49b7df5ec9eb9aa8f956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aeffbde3ace1b49b7df5ec9eb9aa8f956">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:aeffbde3ace1b49b7df5ec9eb9aa8f956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7de309c1619f81c94cfa294e5a9065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9f7de309c1619f81c94cfa294e5a9065">operator/</a> (<a class="el" href="classdouble.html">double</a> c, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f)</td></tr>
<tr class="separator:a9f7de309c1619f81c94cfa294e5a9065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1689f9845acfae35173fede790537df9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1689f9845acfae35173fede790537df9">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f, <a class="el" href="classint.html">int</a> n)</td></tr>
<tr class="memdesc:a1689f9845acfae35173fede790537df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rational function <code>f</code> raised to <code>n</code>.  <a href="#a1689f9845acfae35173fede790537df9">More...</a><br /></td></tr>
<tr class="separator:a1689f9845acfae35173fede790537df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e6a0d904da664f8fa2a665d6db64c2"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a24e6a0d904da664f8fa2a665d6db64c2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a24e6a0d904da664f8fa2a665d6db64c2">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a24e6a0d904da664f8fa2a665d6db64c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following operations:  <a href="#a24e6a0d904da664f8fa2a665d6db64c2">More...</a><br /></td></tr>
<tr class="separator:a24e6a0d904da664f8fa2a665d6db64c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327c04af4b8fa510bd365a1bb7dfe6ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a134e54042165751a5e5369b4631c90eb">Rewriter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a327c04af4b8fa510bd365a1bb7dfe6ed">MakeRuleRewriter</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html">RewritingRule</a> &amp;r)</td></tr>
<tr class="memdesc:a327c04af4b8fa510bd365a1bb7dfe6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rewriter based on a rewriting rule <code>r</code>.  <a href="#a327c04af4b8fa510bd365a1bb7dfe6ed">More...</a><br /></td></tr>
<tr class="separator:a327c04af4b8fa510bd365a1bb7dfe6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17fff2492f7afb4512ed8acfe90bfa6"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af17fff2492f7afb4512ed8acfe90bfa6">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="separator:af17fff2492f7afb4512ed8acfe90bfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e0e8e0c052f5428c78531518c813db"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae4e0e8e0c052f5428c78531518c813db">operator&lt;&lt;</a> (ostream &amp;os, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a> <a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>)</td></tr>
<tr class="separator:ae4e0e8e0c052f5428c78531518c813db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6823e106a6a01aa3fdd6fe2ed827d1e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6823e106a6a01aa3fdd6fe2ed827d1e8">MakeMatrixVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a> <a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>)</td></tr>
<tr class="memdesc:a6823e106a6a01aa3fdd6fe2ed827d1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic variables.  <a href="#a6823e106a6a01aa3fdd6fe2ed827d1e8">More...</a><br /></td></tr>
<tr class="separator:a6823e106a6a01aa3fdd6fe2ed827d1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077c5aa3c1d61b9bf22590e5325af815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a077c5aa3c1d61b9bf22590e5325af815">MakeMatrixBooleanVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a077c5aa3c1d61b9bf22590e5325af815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic Boolean variables.  <a href="#a077c5aa3c1d61b9bf22590e5325af815">More...</a><br /></td></tr>
<tr class="separator:a077c5aa3c1d61b9bf22590e5325af815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40449e991943b02a88f4627fd02c872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac40449e991943b02a88f4627fd02c872">MakeMatrixBinaryVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:ac40449e991943b02a88f4627fd02c872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic binary variables.  <a href="#ac40449e991943b02a88f4627fd02c872">More...</a><br /></td></tr>
<tr class="separator:ac40449e991943b02a88f4627fd02c872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4881156a2dba929854529bbecb7bb2e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4881156a2dba929854529bbecb7bb2e2">MakeMatrixContinuousVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a4881156a2dba929854529bbecb7bb2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic continuous variables.  <a href="#a4881156a2dba929854529bbecb7bb2e2">More...</a><br /></td></tr>
<tr class="separator:a4881156a2dba929854529bbecb7bb2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceffea98cb4dc7da681037dd3448e8a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aceffea98cb4dc7da681037dd3448e8a2">MakeMatrixIntegerVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:aceffea98cb4dc7da681037dd3448e8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic integer variables.  <a href="#aceffea98cb4dc7da681037dd3448e8a2">More...</a><br /></td></tr>
<tr class="separator:aceffea98cb4dc7da681037dd3448e8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4121a7d1fb8d747d147771205bf0fe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae4121a7d1fb8d747d147771205bf0fe4">MakeVectorVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a> <a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>)</td></tr>
<tr class="memdesc:ae4121a7d1fb8d747d147771205bf0fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic variables.  <a href="#ae4121a7d1fb8d747d147771205bf0fe4">More...</a><br /></td></tr>
<tr class="separator:ae4121a7d1fb8d747d147771205bf0fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7fee6b939582c5bd9f0020ebeb2c2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1f7fee6b939582c5bd9f0020ebeb2c2a">MakeVectorBooleanVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a1f7fee6b939582c5bd9f0020ebeb2c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic Boolean variables.  <a href="#a1f7fee6b939582c5bd9f0020ebeb2c2a">More...</a><br /></td></tr>
<tr class="separator:a1f7fee6b939582c5bd9f0020ebeb2c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9341ab1f18ff240083389ccdcb483ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9341ab1f18ff240083389ccdcb483ed3">MakeVectorBinaryVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a9341ab1f18ff240083389ccdcb483ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic binary variables.  <a href="#a9341ab1f18ff240083389ccdcb483ed3">More...</a><br /></td></tr>
<tr class="separator:a9341ab1f18ff240083389ccdcb483ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9512d7058f85f0f5ddcf2ad601768d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9512d7058f85f0f5ddcf2ad601768d54">MakeVectorContinuousVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a9512d7058f85f0f5ddcf2ad601768d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic continuous variables.  <a href="#a9512d7058f85f0f5ddcf2ad601768d54">More...</a><br /></td></tr>
<tr class="separator:a9512d7058f85f0f5ddcf2ad601768d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67f9414a4674809981130f03d1da9c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa67f9414a4674809981130f03d1da9c0">MakeVectorIntegerVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:aa67f9414a4674809981130f03d1da9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic integer variables.  <a href="#aa67f9414a4674809981130f03d1da9c0">More...</a><br /></td></tr>
<tr class="separator:aa67f9414a4674809981130f03d1da9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77055238eec353c7b077cd2fafd83aa7"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a77055238eec353c7b077cd2fafd83aa7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a77055238eec353c7b077cd2fafd83aa7">MakeMatrixVariable</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a> <a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>)</td></tr>
<tr class="memdesc:a77055238eec353c7b077cd2fafd83aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic variables.  <a href="#a77055238eec353c7b077cd2fafd83aa7">More...</a><br /></td></tr>
<tr class="separator:a77055238eec353c7b077cd2fafd83aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab43ed8981b8575f24e83fdf4b26295"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a2ab43ed8981b8575f24e83fdf4b26295"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2ab43ed8981b8575f24e83fdf4b26295">MakeMatrixBooleanVariable</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a2ab43ed8981b8575f24e83fdf4b26295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic Boolean variables.  <a href="#a2ab43ed8981b8575f24e83fdf4b26295">More...</a><br /></td></tr>
<tr class="separator:a2ab43ed8981b8575f24e83fdf4b26295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803dbab92e520549b625dde70f05fe47"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a803dbab92e520549b625dde70f05fe47"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a803dbab92e520549b625dde70f05fe47">MakeMatrixBinaryVariable</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a803dbab92e520549b625dde70f05fe47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic binary variables.  <a href="#a803dbab92e520549b625dde70f05fe47">More...</a><br /></td></tr>
<tr class="separator:a803dbab92e520549b625dde70f05fe47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93b9abfad06da819d5460018eb49b5c"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:ad93b9abfad06da819d5460018eb49b5c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad93b9abfad06da819d5460018eb49b5c">MakeMatrixContinuousVariable</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:ad93b9abfad06da819d5460018eb49b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic continuous variables.  <a href="#ad93b9abfad06da819d5460018eb49b5c">More...</a><br /></td></tr>
<tr class="separator:ad93b9abfad06da819d5460018eb49b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b71b38080ba3cd1d36172c4577ed445"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a6b71b38080ba3cd1d36172c4577ed445"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6b71b38080ba3cd1d36172c4577ed445">MakeMatrixIntegerVariable</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a6b71b38080ba3cd1d36172c4577ed445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic integer variables.  <a href="#a6b71b38080ba3cd1d36172c4577ed445">More...</a><br /></td></tr>
<tr class="separator:a6b71b38080ba3cd1d36172c4577ed445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09c18b98a36a770ab68c048bd70b09c"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:ad09c18b98a36a770ab68c048bd70b09c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad09c18b98a36a770ab68c048bd70b09c">MakeVectorVariable</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a> <a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>)</td></tr>
<tr class="memdesc:ad09c18b98a36a770ab68c048bd70b09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic variables.  <a href="#ad09c18b98a36a770ab68c048bd70b09c">More...</a><br /></td></tr>
<tr class="separator:ad09c18b98a36a770ab68c048bd70b09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2f37fa21183f09e3544a4c6891494b"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a4d2f37fa21183f09e3544a4c6891494b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4d2f37fa21183f09e3544a4c6891494b">MakeVectorBooleanVariable</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a4d2f37fa21183f09e3544a4c6891494b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic Boolean variables.  <a href="#a4d2f37fa21183f09e3544a4c6891494b">More...</a><br /></td></tr>
<tr class="separator:a4d2f37fa21183f09e3544a4c6891494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698dcb5dd4fea36841d305e89f52dd97"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a698dcb5dd4fea36841d305e89f52dd97"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a698dcb5dd4fea36841d305e89f52dd97">MakeVectorBinaryVariable</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a698dcb5dd4fea36841d305e89f52dd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic binary variables.  <a href="#a698dcb5dd4fea36841d305e89f52dd97">More...</a><br /></td></tr>
<tr class="separator:a698dcb5dd4fea36841d305e89f52dd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a6b5840c741f1869738945cef3d8c5"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a86a6b5840c741f1869738945cef3d8c5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a86a6b5840c741f1869738945cef3d8c5">MakeVectorContinuousVariable</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a86a6b5840c741f1869738945cef3d8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic continuous variables.  <a href="#a86a6b5840c741f1869738945cef3d8c5">More...</a><br /></td></tr>
<tr class="separator:a86a6b5840c741f1869738945cef3d8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a22da2ebae3f3ca478d07976adfca85"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a2a22da2ebae3f3ca478d07976adfca85"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2a22da2ebae3f3ca478d07976adfca85">MakeVectorIntegerVariable</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a2a22da2ebae3f3ca478d07976adfca85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic integer variables.  <a href="#a2a22da2ebae3f3ca478d07976adfca85">More...</a><br /></td></tr>
<tr class="separator:a2a22da2ebae3f3ca478d07976adfca85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4a660f10cf9c46c5b8321db227e2e5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a1d4a660f10cf9c46c5b8321db227e2e5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; DerivedA, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;<a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; DerivedB, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1d4a660f10cf9c46c5b8321db227e2e5">CheckStructuralEquality</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a1d4a660f10cf9c46c5b8321db227e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two Eigen::Matrix&lt;Variable&gt; <code>m1</code> and <code>m2</code> are structurally equal.  <a href="#a1d4a660f10cf9c46c5b8321db227e2e5">More...</a><br /></td></tr>
<tr class="separator:a1d4a660f10cf9c46c5b8321db227e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53fca5ee2418025963ba51bb926c779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab53fca5ee2418025963ba51bb926c779">operator==</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="separator:ab53fca5ee2418025963ba51bb926c779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafb11a2f5c2fb7512b3f01bfba8efd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abafb11a2f5c2fb7512b3f01bfba8efd3">operator&lt;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="separator:abafb11a2f5c2fb7512b3f01bfba8efd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d208ecf4085efd38598ff4375b2bda5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8d208ecf4085efd38598ff4375b2bda5">operator+=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:a8d208ecf4085efd38598ff4375b2bda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>var1</code> with the result of set-union(<code>var1</code>, <code>var2</code>).  <a href="#a8d208ecf4085efd38598ff4375b2bda5">More...</a><br /></td></tr>
<tr class="separator:a8d208ecf4085efd38598ff4375b2bda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bf4135713e0549b50c59cade15e961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab4bf4135713e0549b50c59cade15e961">operator+=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:ab4bf4135713e0549b50c59cade15e961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>vars</code> with the result of set-union(<code>vars</code>, { <code>var</code> }).  <a href="#ab4bf4135713e0549b50c59cade15e961">More...</a><br /></td></tr>
<tr class="separator:ab4bf4135713e0549b50c59cade15e961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0176708e0ff133d7166b2f4700832885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0176708e0ff133d7166b2f4700832885">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:a0176708e0ff133d7166b2f4700832885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-union of <code>var1</code> and <code>var2</code>.  <a href="#a0176708e0ff133d7166b2f4700832885">More...</a><br /></td></tr>
<tr class="separator:a0176708e0ff133d7166b2f4700832885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d10380477ac001084ccc42d6aa005b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7d10380477ac001084ccc42d6aa005b6">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> <a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a7d10380477ac001084ccc42d6aa005b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-union of <code>vars</code> and {<code>var}</code>.  <a href="#a7d10380477ac001084ccc42d6aa005b6">More...</a><br /></td></tr>
<tr class="separator:a7d10380477ac001084ccc42d6aa005b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56aaa3de6bd181f40290eb9c9ab264e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac56aaa3de6bd181f40290eb9c9ab264e">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var, <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> <a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:ac56aaa3de6bd181f40290eb9c9ab264e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-union of {<code>var}</code> and <code>vars</code>.  <a href="#ac56aaa3de6bd181f40290eb9c9ab264e">More...</a><br /></td></tr>
<tr class="separator:ac56aaa3de6bd181f40290eb9c9ab264e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec727eec3de8a6935ebc8036b497a82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6ec727eec3de8a6935ebc8036b497a82">operator-=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:a6ec727eec3de8a6935ebc8036b497a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>var1</code> with the result of set-minus(<code>var1</code>, <code>var2</code>).  <a href="#a6ec727eec3de8a6935ebc8036b497a82">More...</a><br /></td></tr>
<tr class="separator:a6ec727eec3de8a6935ebc8036b497a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af039fc6cb2d4d56510e95e74bc4d0a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af039fc6cb2d4d56510e95e74bc4d0a90">operator-=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:af039fc6cb2d4d56510e95e74bc4d0a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>vars</code> with the result of set-minus(<code>vars</code>, {<code>var}</code>).  <a href="#af039fc6cb2d4d56510e95e74bc4d0a90">More...</a><br /></td></tr>
<tr class="separator:af039fc6cb2d4d56510e95e74bc4d0a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15f6e5aa82236dcd5bfb4a310022997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab15f6e5aa82236dcd5bfb4a310022997">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:ab15f6e5aa82236dcd5bfb4a310022997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-minus(<code>var1</code>, <code>vars2</code>).  <a href="#ab15f6e5aa82236dcd5bfb4a310022997">More...</a><br /></td></tr>
<tr class="separator:ab15f6e5aa82236dcd5bfb4a310022997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e3c65798c6801e74fa2bf071c5f589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a24e3c65798c6801e74fa2bf071c5f589">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> <a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a24e3c65798c6801e74fa2bf071c5f589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-minus(<code>vars</code>, { <code>var</code> }).  <a href="#a24e3c65798c6801e74fa2bf071c5f589">More...</a><br /></td></tr>
<tr class="separator:a24e3c65798c6801e74fa2bf071c5f589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfb5367e72dfbaf7a778e6896113f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adbfb5367e72dfbaf7a778e6896113f64">intersect</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:adbfb5367e72dfbaf7a778e6896113f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of <code>vars1</code> and <code>vars2</code>.  <a href="#adbfb5367e72dfbaf7a778e6896113f64">More...</a><br /></td></tr>
<tr class="separator:adbfb5367e72dfbaf7a778e6896113f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f2261706621f73ebb925a00f1aa6a2"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a26f2261706621f73ebb925a00f1aa6a2">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="separator:a26f2261706621f73ebb925a00f1aa6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaa36e4283410d093d70ec5f4e267ed"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:afeaa36e4283410d093d70ec5f4e267ed"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Derived1::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_same&lt; typename Derived2::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afeaa36e4283410d093d70ec5f4e267ed">CompareMatrixWithRationalFunction</a> (const Derived1 &amp;m1, const Derived2 &amp;m2)</td></tr>
<tr class="separator:afeaa36e4283410d093d70ec5f4e267ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642ed2c32acb54d44a4659636facb266"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a642ed2c32acb54d44a4659636facb266"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a642ed2c32acb54d44a4659636facb266">CheckAddition</a> (const Derived1 &amp;m1, const Derived2 &amp;m2)</td></tr>
<tr class="separator:a642ed2c32acb54d44a4659636facb266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b7814f9e2e7afcc7486dc9a282c01d"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:ad8b7814f9e2e7afcc7486dc9a282c01d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad8b7814f9e2e7afcc7486dc9a282c01d">CheckSubtraction</a> (const Derived1 &amp;m1, const Derived2 &amp;m2)</td></tr>
<tr class="separator:ad8b7814f9e2e7afcc7486dc9a282c01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb95389f0962accb138f6ffa55be523f"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:afb95389f0962accb138f6ffa55be523f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afb95389f0962accb138f6ffa55be523f">CheckProduct</a> (const Derived1 &amp;m1, const Derived2 &amp;m2)</td></tr>
<tr class="separator:afb95389f0962accb138f6ffa55be523f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b27edde110c520b600cd2baf57a496b"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a3b27edde110c520b600cd2baf57a496b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; Derived1 &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;<a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; Derived2 &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3b27edde110c520b600cd2baf57a496b">CheckConjugateProdocut</a> (const Derived1 &amp;v1, const Derived2 &amp;v2)</td></tr>
<tr class="separator:a3b27edde110c520b600cd2baf57a496b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeab78f600670a8a0d1b5b4028f1f390"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:aaeab78f600670a8a0d1b5b4028f1f390"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aaeab78f600670a8a0d1b5b4028f1f390">CheckMatrixMatrixBinaryOperations</a> (const Derived1 &amp;m1, const Derived2 &amp;m2)</td></tr>
<tr class="separator:aaeab78f600670a8a0d1b5b4028f1f390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bdc16a6c3b1b4d4c6d9798a38779e8"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a94bdc16a6c3b1b4d4c6d9798a38779e8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; Derived2 &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a94bdc16a6c3b1b4d4c6d9798a38779e8">CheckMatrixVectorBinaryOperations</a> (const Derived1 &amp;m1, const Derived2 &amp;m2)</td></tr>
<tr class="separator:a94bdc16a6c3b1b4d4c6d9798a38779e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0ac837ac504973d752431982bd4c23"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a1e0ac837ac504973d752431982bd4c23"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; Derived1 &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;<a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; Derived2 &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1e0ac837ac504973d752431982bd4c23">CheckVectorVectorBinaryOperations</a> (const Derived1 &amp;m1, const Derived2 &amp;m2)</td></tr>
<tr class="separator:a1e0ac837ac504973d752431982bd4c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0351346c8644e9944ce2a346873dfe6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0351346c8644e9944ce2a346873dfe6c">TEST_F</a> (SymbolicRationalFunctionMatrixTest, RationalFunctionOpRationalFunction)</td></tr>
<tr class="separator:a0351346c8644e9944ce2a346873dfe6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668c2faf856f1e945a2b9785ea73b24b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a668c2faf856f1e945a2b9785ea73b24b">TEST_F</a> (SymbolicRationalFunctionMatrixTest, RationalFunctionOpPolynomial)</td></tr>
<tr class="separator:a668c2faf856f1e945a2b9785ea73b24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaa30d652422efc1f597feec32b9feb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8aaa30d652422efc1f597feec32b9feb">TEST_F</a> (SymbolicRationalFunctionMatrixTest, RationalFunctionOpDouble)</td></tr>
<tr class="separator:a8aaa30d652422efc1f597feec32b9feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aeb27ddf30420e620beb8e6725d83208f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb27ddf30420e620beb8e6725d83208f">&#9670;&nbsp;</a></span>Pattern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1symbolic.html#aeb27ddf30420e620beb8e6725d83208f">Pattern</a> =  <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pattern is an expression which possibly includes variables which represent placeholders. </p>
<p>It is used to construct a <code><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html" title="A RewritingRule, lhs =&gt; rhs, consists of two Patterns lhs and rhs. ">RewritingRule</a></code>. </p>

</div>
</div>
<a id="a134e54042165751a5e5369b4631c90eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134e54042165751a5e5369b4631c90eb">&#9670;&nbsp;</a></span>Rewriter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1symbolic.html#a134e54042165751a5e5369b4631c90eb">Rewriter</a> =  std::function&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>(const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code>Rewriter</code> is a function from an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">Expression</a> to an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">Expression</a>. </p>

</div>
</div>
<a id="acbfe43d34e6c71c503d4de11da53bbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfe43d34e6c71c503d4de11da53bbb7">&#9670;&nbsp;</a></span>Substitution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1symbolic.html#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> =  std::unordered_map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aebde9bdda9a428ef1bab6175954d30fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebde9bdda9a428ef1bab6175954d30fa">&#9670;&nbsp;</a></span>ExpressionKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">ExpressionKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kinds of symbolic expressions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faacb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"><p>constant (double) </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa5a92344ee95acf10c31901b36418be77"></a>Var&#160;</td><td class="fielddoc"><p>variable </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faaec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"><p>addition (+) </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul&#160;</td><td class="fielddoc"><p>multiplication (*) </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa43d11850893d2fe84a1e618121c1cc0a"></a>Div&#160;</td><td class="fielddoc"><p>division (/) </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faace0be71e33226e4c1db2bcea5959f16b"></a>Log&#160;</td><td class="fielddoc"><p>logarithms </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa1e34af023adeb7d5f484f8eb4b9826b6"></a>Abs&#160;</td><td class="fielddoc"><p>absolute value function </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faacad39a154bffb61175f674d6eefaf6d0"></a>Exp&#160;</td><td class="fielddoc"><p>exponentiation </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faaae77f3ad25595e35b327334d89410054"></a>Sqrt&#160;</td><td class="fielddoc"><p>square root </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa8be6d3e955290ee50c00a4bc92aa7749"></a>Pow&#160;</td><td class="fielddoc"><p>power function </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa0986d137604183312e6d3599578bc6cd"></a>Sin&#160;</td><td class="fielddoc"><p>sine </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faaffca562be079b9e4e41ea9d6a86c582b"></a>Cos&#160;</td><td class="fielddoc"><p>cosine </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa1266b4e6f81e60733ec6c717e0181f60"></a>Tan&#160;</td><td class="fielddoc"><p>tangent </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa76cfc54de4e2b9cde17334c821217d11"></a>Asin&#160;</td><td class="fielddoc"><p>arcsine </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faaed4629033ecb516ed7d1536e162030bb"></a>Acos&#160;</td><td class="fielddoc"><p>arccosine </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faac9968ab1fa8103acbb3a4f22265f2def"></a>Atan&#160;</td><td class="fielddoc"><p>arctangent </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa5816dfcaf3b6dbb486ef9c8c006ff613"></a>Atan2&#160;</td><td class="fielddoc"><p>arctangent2 (atan2(y,x) = atan(y/x)) </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa98ed804abf4edd1f3be3fa894fa8cc3d"></a>Sinh&#160;</td><td class="fielddoc"><p>hyperbolic sine </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa4371c3565b771b40c187487cc0190392"></a>Cosh&#160;</td><td class="fielddoc"><p>hyperbolic cosine </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faacc132a41cab5676334f353a22a0aa5c5"></a>Tanh&#160;</td><td class="fielddoc"><p>hyperbolic tangent </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa78d811e98514cd165dda532286610fd2"></a>Min&#160;</td><td class="fielddoc"><p>min </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa6a061313d22e51e0f25b7cd4dc065233"></a>Max&#160;</td><td class="fielddoc"><p>max </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faab95a01ffffa8fcdd2a9af961937c097c"></a>Ceil&#160;</td><td class="fielddoc"><p>ceil </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faaf3f6d0343d56ce88ce7958170ed05cb3"></a>Floor&#160;</td><td class="fielddoc"><p>floor </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faaaff6933d8331eca27edc911467980c9c"></a>IfThenElse&#160;</td><td class="fielddoc"><p>if then else </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa7ecfb3bf076a6a9635f975fe96ac97fd"></a>NaN&#160;</td><td class="fielddoc"><p>NaN. </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa2e59a51ac43bc3415c1b8ce7b3f98579"></a>UninterpretedFunction&#160;</td><td class="fielddoc"><p>Uninterpreted function. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6869e7044dd90be5d972ee7dd4e821b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6869e7044dd90be5d972ee7dd4e821b6">&#9670;&nbsp;</a></span>FormulaKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kinds of symbolic formulas. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6af8320b26d30ab433c5a54546d21f414c"></a>False&#160;</td><td class="fielddoc"><p>⊥ </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6af827cf462f62848df37c5e1e94a4da74"></a>True&#160;</td><td class="fielddoc"><p>⊤ </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a5a92344ee95acf10c31901b36418be77"></a>Var&#160;</td><td class="fielddoc"><p>Boolean <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable. ">Variable</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a3718b5ecf60aa0dba49e150e96cb1fc3"></a>Eq&#160;</td><td class="fielddoc"><p>= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6ae4ecc5da3c6dbb4448f25990dc609727"></a>Neq&#160;</td><td class="fielddoc"><p>!= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a086cb8308e5a36e7c4ed1f8873ad801f"></a>Gt&#160;</td><td class="fielddoc"><p>&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a5dabfebb89e6e45a8cf8573d92746ed3"></a>Geq&#160;</td><td class="fielddoc"><p>&gt;= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a50033c15af7795cd6617f117b29d6922"></a>Lt&#160;</td><td class="fielddoc"><p>&lt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6abe5721bf93d718a79358217ec9b88176"></a>Leq&#160;</td><td class="fielddoc"><p>&lt;= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6ac33315685a0cba3ce53be378b3c7874b"></a>And&#160;</td><td class="fielddoc"><p>Conjunction (∧) </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a3a2d5fe857d8f9541136a124c2edec6c"></a>Or&#160;</td><td class="fielddoc"><p>Disjunction (∨) </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6aa74c05d080620f087c4e523977230666"></a>Not&#160;</td><td class="fielddoc"><p>Negation (¬) </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a43cfe3c750a08acb91df1e3384548078"></a>Forall&#160;</td><td class="fielddoc"><p>Universal quantification (∀) </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6afd116e3418522ffc34d7423bc601510d"></a>Isnan&#160;</td><td class="fielddoc"><p>NaN check predicate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a1fbc164d3e50b7fd20690a21f1b7b2f2"></a>PositiveSemidefinite&#160;</td><td class="fielddoc"><p>Positive semidefinite matrix. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a44e11b5fa4c16951b30b26e43a316569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e11b5fa4c16951b30b26e43a316569">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a008a73e1d2390dc2325d70175fb5410e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008a73e1d2390dc2325d70175fb5410e">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66f66b1d5e15bec4b2b7f12ade1b3094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f66b1d5e15bec4b2b7f12ade1b3094">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf24c6f256d7360650cb379c22886409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf24c6f256d7360650cb379c22886409">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ddcc51253066082911475e06b0ac994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddcc51253066082911475e06b0ac994">&#9670;&nbsp;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e5ea5116992b4f695c16ad0f297686b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5ea5116992b4f695c16ad0f297686b">&#9670;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a642ed2c32acb54d44a4659636facb266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642ed2c32acb54d44a4659636facb266">&#9670;&nbsp;</a></span>CheckAddition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::CheckAddition </td>
          <td>(</td>
          <td class="paramtype">const Derived1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b27edde110c520b600cd2baf57a496b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b27edde110c520b600cd2baf57a496b">&#9670;&nbsp;</a></span>CheckConjugateProdocut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt;Derived1&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt;Derived2&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::CheckConjugateProdocut </td>
          <td>(</td>
          <td class="paramtype">const Derived1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaeab78f600670a8a0d1b5b4028f1f390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeab78f600670a8a0d1b5b4028f1f390">&#9670;&nbsp;</a></span>CheckMatrixMatrixBinaryOperations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::CheckMatrixMatrixBinaryOperations </td>
          <td>(</td>
          <td class="paramtype">const Derived1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94bdc16a6c3b1b4d4c6d9798a38779e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bdc16a6c3b1b4d4c6d9798a38779e8">&#9670;&nbsp;</a></span>CheckMatrixVectorBinaryOperations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt;Derived2&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::CheckMatrixVectorBinaryOperations </td>
          <td>(</td>
          <td class="paramtype">const Derived1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb95389f0962accb138f6ffa55be523f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb95389f0962accb138f6ffa55be523f">&#9670;&nbsp;</a></span>CheckProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::CheckProduct </td>
          <td>(</td>
          <td class="paramtype">const Derived1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d4a660f10cf9c46c5b8321db227e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4a660f10cf9c46c5b8321db227e2e5">&#9670;&nbsp;</a></span>CheckStructuralEquality() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt;DerivedA, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt;DerivedB, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::CheckStructuralEquality </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two Eigen::Matrix&lt;Variable&gt; <code>m1</code> and <code>m2</code> are structurally equal. </p>
<p>That is, it returns true if and only if <code>m1(i, j)</code> is structurally equal to <code>m2(i, j)</code> for all <code>i</code>, <code>j</code>. </p>

</div>
</div>
<a id="ac3d55ec6a55f554174d9bc45d7ed7f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d55ec6a55f554174d9bc45d7ed7f5c">&#9670;&nbsp;</a></span>CheckStructuralEquality() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;DerivedA&gt;, DerivedA&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;DerivedB&gt;, DerivedB&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename DerivedA::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename DerivedB::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::CheckStructuralEquality </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two Eigen::Matrix&lt;Expression&gt; <code>m1</code> and <code>m2</code> are structurally equal. </p>
<p>That is, it returns true if and only if <code>m1(i, j)</code> is structurally equal to <code>m2(i, j)</code> for all <code>i</code>, <code>j</code>. </p>

</div>
</div>
<a id="ad8b7814f9e2e7afcc7486dc9a282c01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b7814f9e2e7afcc7486dc9a282c01d">&#9670;&nbsp;</a></span>CheckSubtraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::CheckSubtraction </td>
          <td>(</td>
          <td class="paramtype">const Derived1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e0ac837ac504973d752431982bd4c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0ac837ac504973d752431982bd4c23">&#9670;&nbsp;</a></span>CheckVectorVectorBinaryOperations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt;Derived1&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt;Derived2&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::CheckVectorVectorBinaryOperations </td>
          <td>(</td>
          <td class="paramtype">const Derived1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa11ee8e11a75ed1fa0f970ed7a547add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11ee8e11a75ed1fa0f970ed7a547add">&#9670;&nbsp;</a></span>CodeGen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string CodeGen </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a given symbolic expression <code>e</code>, generates two C functions, <code>function_name</code> and <code>function_name_in</code>. </p>
<p>The generated <code>function_name</code> takes an array of doubles for parameters and returns an evaluation result. <code>function_name_in</code> returns the length of <code>parameters</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function_name</td><td>Name of the generated C function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>Vector of variables provide the ordering of symbolic variables. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Symbolic expression to codegen.</td></tr>
  </table>
  </dd>
</dl>
<p>For example, <code>Codegen("f", {x, y}, 1 + sin(x) + cos(y))</code> generates the following string.</p>
<pre>
double f(const double* p) {
    return (1 + sin(p[0]) + cos(p[1]));
}
int f_in() {
    return 2;  // size of `{x, y}`.
}
</pre><p>Note that in this example <code>x</code> and <code>y</code> are mapped to <code>p[0]</code> and <code>p[1]</code> respectively because we passed <code>{x, y}</code> to <code>Codegen</code>.</p>
<p>Note that generated code does not include any headers while it may use math functions defined in <code>&lt;math.h&gt;</code> such as sin, cos, exp, and log. A user of generated code is responsible to include <code>&lt;math.h&gt;</code> if needed to compile generated code. </p>
<p>Handle <code>function_name_in</code>. </p>

</div>
</div>
<a id="afeaa36e4283410d093d70ec5f4e267ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeaa36e4283410d093d70ec5f4e267ed">&#9670;&nbsp;</a></span>CompareMatrixWithRationalFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Derived1::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Derived2::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::CompareMatrixWithRationalFunction </td>
          <td>(</td>
          <td class="paramtype">const Derived1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d78919127ccba2ba24cdb1b0c57613d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d78919127ccba2ba24cdb1b0c57613d">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27a345a84e6b273a71aa02ee312f9c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a345a84e6b273a71aa02ee312f9c51">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c152941a4e06624bac5926fac2d4e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c152941a4e06624bac5926fac2d4e32">&#9670;&nbsp;</a></span>DecomposeAffineExpressions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::DecomposeAffineExpressions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes <code>expressions</code> into <code>M</code> * <code>vars</code> + <code>v</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>expressions</code> is not affine in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>M.rows() == expressions.rows() &amp;&amp; M.cols() == vars.rows(). </dd>
<dd>
v.rows() == expressions.rows(). </dd></dl>

</div>
</div>
<a id="a24485ddd4b9b69340021bd0eb259bf38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24485ddd4b9b69340021bd0eb259bf38">&#9670;&nbsp;</a></span>DecomposeAffineExpressions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::DecomposeAffineExpressions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6c01361f464b3eae396f7d1a0e92c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c01361f464b3eae396f7d1a0e92c85">&#9670;&nbsp;</a></span>DecomposeLinearExpressions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::DecomposeLinearExpressions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes <code>expressions</code> into <code>M</code> * <code>vars</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>expressions</code> is not linear in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>M.rows() == expressions.rows() &amp;&amp; M.cols() == vars.rows(). </dd></dl>

</div>
</div>
<a id="a64d57d7f341720760d9ae5f41af02de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d57d7f341720760d9ae5f41af02de3">&#9670;&nbsp;</a></span>DecomposeLinearExpressions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::DecomposeLinearExpressions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a570d64c719d45bb9a809103d95f70583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570d64c719d45bb9a809103d95f70583">&#9670;&nbsp;</a></span>DifferentiatePow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::DifferentiatePow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a166b0ad9f629567d453d875562e571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a166b0ad9f629567d453d875562e571">&#9670;&nbsp;</a></span>Evaluate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::symbolic::Evaluate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#ab262f8e82f09d8df2990d0dc5869c34f">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>random_generator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a symbolic matrix <code>m</code> using <code>env</code> and <code>random_generator</code>. </p>
<p>If there is a random variable in <code>m</code> which is unassigned in <code>env</code>, this function uses <code>random_generator</code> to sample a value and use the value to substitute all occurrences of the random variable in <code>m</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a matrix of double whose size is the size of <code>m</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during evaluation. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>m</code> includes unassigned random variables but <code>random_generator</code> is <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27e661d9a5f1936f326068b2dea3eecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e661d9a5f1936f326068b2dea3eecc">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08cadfe5adda620a40258a84d87081f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cadfe5adda620a40258a84d87081f4">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d13fc861c980e5cca95449bb11cbe01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d13fc861c980e5cca95449bb11cbe01">&#9670;&nbsp;</a></span>forall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a formula <code>f</code>, universally quantified by variables <code>vars</code>. </p>

</div>
</div>
<a id="a3445a75a8296154f264bf7177f9e85ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3445a75a8296154f264bf7177f9e85ab">&#9670;&nbsp;</a></span>get_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_argument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the argument in the unary expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a unary expression.} </dd></dl>

</div>
</div>
<a id="a9abf9c0b485045bd9a88c6bda2706e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abf9c0b485045bd9a88c6bda2706e3d">&#9670;&nbsp;</a></span>get_base_to_exponent_map_in_multiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp; get_base_to_exponent_map_in_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map from a base expression to its exponent expression in the multiplication expression <code>e</code>. </p>
<p>For instance, given 7 * x^2 * y^3 * z^x, the return value maps 'x' to 2, 'y' to 3, and 'z' to 'x'. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a multiplication expression.} </dd></dl>

</div>
</div>
<a id="a90e045ae61515d2b1a9206abc2ca5412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e045ae61515d2b1a9206abc2ca5412">&#9670;&nbsp;</a></span>get_conditional_formula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp; get_conditional_formula </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the conditional formula in the if-then-else expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an if-then-else expression. </dd></dl>

</div>
</div>
<a id="a657fe44ab4b095f9603a3c9429098981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657fe44ab4b095f9603a3c9429098981">&#9670;&nbsp;</a></span>get_constant_in_addition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_constant_in_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant part of the addition expression <code>e</code>. </p>
<p>For instance, given 7 + 2 * x + 3 * y, it returns 7. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is an addition expression.} </dd></dl>

</div>
</div>
<a id="ae1f447c509e16ebf85df16216af97882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f447c509e16ebf85df16216af97882">&#9670;&nbsp;</a></span>get_constant_in_multiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_constant_in_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant part of the multiplication expression <code>e</code>. </p>
<p>For instance, given 7 * x^2 * y^3, it returns 7. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a multiplication expression.} </dd></dl>

</div>
</div>
<a id="a5165b4cdadcd273d3faad9dffd2bcc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5165b4cdadcd273d3faad9dffd2bcc7e">&#9670;&nbsp;</a></span>get_constant_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_constant_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant value of the constant expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a constant expression.} </dd></dl>

</div>
</div>
<a id="a93333785c7a6b3a8cf3b517eadaf982a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93333785c7a6b3a8cf3b517eadaf982a">&#9670;&nbsp;</a></span>get_else_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_else_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 'else' expression in the if-then-else expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an if-then-else expression. </dd></dl>

</div>
</div>
<a id="a0c96dfd079cf8490a85e9f087f6aab2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c96dfd079cf8490a85e9f087f6aab2d">&#9670;&nbsp;</a></span>get_expr_to_coeff_map_in_addition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp; get_expr_to_coeff_map_in_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map from an expression to its coefficient in the addition expression <code>e</code>. </p>
<p>For instance, given 7 + 2 * x + 3 * y, the return value maps 'x' to 2 and 'y' to 3. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is an addition expression.} </dd></dl>

</div>
</div>
<a id="a447067b42b3ed05358bbbbf227e4d1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447067b42b3ed05358bbbbf227e4d1d8">&#9670;&nbsp;</a></span>get_first_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_first_argument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first argument of the binary expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a binary expression.} </dd></dl>

</div>
</div>
<a id="a77f3d349554a28bfa3f1107bb4adaab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f3d349554a28bfa3f1107bb4adaab6">&#9670;&nbsp;</a></span>get_lhs_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_lhs_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the lhs-argument of a relational formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a relational formula.} </dd></dl>

</div>
</div>
<a id="ab77026017746534a08312bf9eb2d4a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77026017746534a08312bf9eb2d4a99">&#9670;&nbsp;</a></span>get_matrix_in_positive_semidefinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp; get_matrix_in_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the matrix in a positive-semidefinite formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a positive-semidefinite formula.} </dd></dl>

</div>
</div>
<a id="a4d6409b69e4049b282edaaea65fe1b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6409b69e4049b282edaaea65fe1b43">&#9670;&nbsp;</a></span>get_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp; get_operand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the formula in a negation formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a negation formula.} </dd></dl>

</div>
</div>
<a id="a5a51076f5f4ab9497965268ceb34e82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a51076f5f4ab9497965268ceb34e82c">&#9670;&nbsp;</a></span>get_operands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp; get_operands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of formulas in a n-ary formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a n-ary formula.} </dd></dl>

</div>
</div>
<a id="a6d5aa689465b2522a75c7dc12fcf1b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5aa689465b2522a75c7dc12fcf1b60">&#9670;&nbsp;</a></span>get_quantified_formula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp; get_quantified_formula </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quantified formula in a forall formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a forall formula.} </dd></dl>

</div>
</div>
<a id="a637fea2c6cfc60b582df81b7b1187e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637fea2c6cfc60b582df81b7b1187e94">&#9670;&nbsp;</a></span>get_quantified_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp; get_quantified_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quantified variables in a forall formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a forall formula.} </dd></dl>

</div>
</div>
<a id="af855c0227ec69f59da11988c82ae4ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af855c0227ec69f59da11988c82ae4ce2">&#9670;&nbsp;</a></span>get_rhs_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_rhs_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rhs-argument of a relational formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a relational formula.} </dd></dl>

</div>
</div>
<a id="a4e891509f0e836fd647f1ea1d8e9f86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e891509f0e836fd647f1ea1d8e9f86b">&#9670;&nbsp;</a></span>get_second_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_second_argument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the second argument of the binary expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a binary expression.} </dd></dl>

</div>
</div>
<a id="a4fc636cd4593a513941cc0431eb086e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc636cd4593a513941cc0431eb086e2">&#9670;&nbsp;</a></span>get_then_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_then_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 'then' expression in the if-then-else expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an if-then-else expression. </dd></dl>

</div>
</div>
<a id="a8d4249d71cfbc5fe0260cd14fdc4bcf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4249d71cfbc5fe0260cd14fdc4bcf0">&#9670;&nbsp;</a></span>get_uninterpreted_function_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp; get_uninterpreted_function_arguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the arguments of an uninterpreted-function expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an uninterpreted-function expression. </dd></dl>

</div>
</div>
<a id="a0a54f523f3f3f991c16bea9f3466e2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a54f523f3f3f991c16bea9f3466e2d5">&#9670;&nbsp;</a></span>get_uninterpreted_function_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; get_uninterpreted_function_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of an uninterpreted-function expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an uninterpreted-function expression. </dd></dl>

</div>
</div>
<a id="a85376535fc0a875d116702f9186d8f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85376535fc0a875d116702f9186d8f99">&#9670;&nbsp;</a></span>get_variable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp; get_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the embedded variable in the variable formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>f</code> is a variable formula. </dd></dl>

</div>
</div>
<a id="af3d53e917f4fd1da3301aa00ee90bb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d53e917f4fd1da3301aa00ee90bb8b">&#9670;&nbsp;</a></span>get_variable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp; get_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the embedded variable in the variable expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a variable expression.} </dd></dl>

</div>
</div>
<a id="a836d137e81878da91a559c330b8e7f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836d137e81878da91a559c330b8e7f18">&#9670;&nbsp;</a></span>GetDistinctVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> GetDistinctVariables </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the distinct variables in the matrix of expressions. </p>

</div>
</div>
<a id="a442134af949ec9f659dcf48604b0a7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442134af949ec9f659dcf48604b0a7c9">&#9670;&nbsp;</a></span>GetVariableVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; GetVariableVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>evec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a vector of variables from the vector of variable expressions. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is an expression in <code>vec</code> which is not a variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb59d484cb2b6737923c9b53e0ec432c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb59d484cb2b6737923c9b53e0ec432c">&#9670;&nbsp;</a></span>if_then_else()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e_then</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e_else</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">  if_then_else(cond, expr_then, expr_else)
</pre><p>The value returned by the above if-then-else expression is <code>expr_then</code> if <code>cond</code> is evaluated to true. Otherwise, it returns <code>expr_else</code>.</p>
<p>The semantics is similar to the C++'s conditional expression constructed by its ternary operator, <code></code>?:. However, there is a key difference between the C++'s conditional expression and our <code>if_then_else</code> expression in a way the arguments are evaluated during the construction.</p>
<ul>
<li>In case of the C++'s conditional expression, <code> cond ? expr_then : expr_else</code>, the then expression <code>expr_then</code> (respectively, the else expression <code>expr_else</code>) is <b>only</b> evaluated when the conditional expression <code>cond</code> is evaluated to <b>true</b> (respectively, when <code>cond</code> is evaluated to <b>false</b>).</li>
<li>In case of the symbolic expression, <code>if_then_else(cond, expr_then, expr_else)</code>, however, <b>both</b> arguments <code>expr_then</code> and <code>expr_else</code> are evaluated first and then passed to the <code>if_then_else</code> function.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function returns an <b>expression</b> and it is different from the C++'s if-then-else <b>statement</b>.</dd>
<dd>
While it is still possible to define <code> min, max, abs</code> math functions using <code>if_then_else</code> expression, it is highly <b>recommended</b> to use the provided native definitions for them because it allows solvers to detect specific math functions and to have a room for special optimizations.</dd>
<dd>
More information about the C++'s conditional expression and ternary operator is available at <a href="http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator">http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator</a>. </dd></dl>

</div>
</div>
<a id="adbfb5367e72dfbaf7a778e6896113f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfb5367e72dfbaf7a778e6896113f64">&#9670;&nbsp;</a></span>intersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the intersection of <code>vars1</code> and <code>vars2</code>. </p>
<p>This function has a time complexity of <code>O(N₁ + N₂)</code> where <code>N₁</code> and <code>N₂</code> are the size of <code>vars1</code> and <code>vars2</code> respectively. </p>

</div>
</div>
<a id="ab6046c9bad9a1c5a1ba51ec6157376c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6046c9bad9a1c5a1ba51ec6157376c3">&#9670;&nbsp;</a></span>is_abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an abs expression. </p>

</div>
</div>
<a id="a98d9027559c1c3c683711d50fc7ff48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d9027559c1c3c683711d50fc7ff48f">&#9670;&nbsp;</a></span>is_abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an absolute-value-function expression. </p>

</div>
</div>
<a id="a40a4e8165bee3d62bd4df8a68226098c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a4e8165bee3d62bd4df8a68226098c">&#9670;&nbsp;</a></span>is_acos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an arccosine expression. </p>

</div>
</div>
<a id="a5508dd313a8bc04ddcd2ce645fa2e821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5508dd313a8bc04ddcd2ce645fa2e821">&#9670;&nbsp;</a></span>is_acos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an arccosine expression. </p>

</div>
</div>
<a id="a5b8a1e5e59b460cac7c2d8b5cb1e172c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8a1e5e59b460cac7c2d8b5cb1e172c">&#9670;&nbsp;</a></span>is_addition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an addition expression. </p>

</div>
</div>
<a id="a8b5c270803005a40362fb97997347098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5c270803005a40362fb97997347098">&#9670;&nbsp;</a></span>is_addition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an addition expression. </p>

</div>
</div>
<a id="a55b4c96682d9db457216b967fe589b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b4c96682d9db457216b967fe589b0f">&#9670;&nbsp;</a></span>is_asin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an arcsine expression. </p>

</div>
</div>
<a id="aede8001df8d3301fef461d03dd2d859d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede8001df8d3301fef461d03dd2d859d">&#9670;&nbsp;</a></span>is_asin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an arcsine expression. </p>

</div>
</div>
<a id="a8137a62cd95401854de0b108ceb9ad6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8137a62cd95401854de0b108ceb9ad6b">&#9670;&nbsp;</a></span>is_atan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an arctangent expression. </p>

</div>
</div>
<a id="ae05b78fd26fef2a243bdfe6530c59dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05b78fd26fef2a243bdfe6530c59dc5">&#9670;&nbsp;</a></span>is_atan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an arctangent expression. </p>

</div>
</div>
<a id="a623309330fb0ecf31d8d9607e9da1215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623309330fb0ecf31d8d9607e9da1215">&#9670;&nbsp;</a></span>is_atan2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an arctangent2 expression. </p>

</div>
</div>
<a id="a9d8916c566e17be2178816265ade645d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8916c566e17be2178816265ade645d">&#9670;&nbsp;</a></span>is_atan2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a arctangent2 expression. </p>

</div>
</div>
<a id="af208e5f109a14eae18e12eb779e11c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af208e5f109a14eae18e12eb779e11c28">&#9670;&nbsp;</a></span>is_ceil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a ceil expression. </p>

</div>
</div>
<a id="a21641bf62f5605ddf8818f445fcdfa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21641bf62f5605ddf8818f445fcdfa4a">&#9670;&nbsp;</a></span>is_ceil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a ceil expression. </p>

</div>
</div>
<a id="a70fdb6bef6734fc34b5215e5c7b661df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fdb6bef6734fc34b5215e5c7b661df">&#9670;&nbsp;</a></span>is_conjunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_conjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a conjunction (∧). </p>

</div>
</div>
<a id="a9074585b52963983223bce6e902efea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9074585b52963983223bce6e902efea7">&#9670;&nbsp;</a></span>is_conjunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_conjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a conjunction (∧). </p>

</div>
</div>
<a id="acef926e653145a96fc31416c85e20c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef926e653145a96fc31416c85e20c14">&#9670;&nbsp;</a></span>is_constant() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a constant expression. </p>

</div>
</div>
<a id="abefc608adef6255f93f6aecf809a8b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefc608adef6255f93f6aecf809a8b11">&#9670;&nbsp;</a></span>is_constant() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a constant expression representing <code>v</code>. </p>

</div>
</div>
<a id="ae309a5818657ba86c33b0f46bbe0d393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae309a5818657ba86c33b0f46bbe0d393">&#9670;&nbsp;</a></span>is_constant() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a constant expression. </p>

</div>
</div>
<a id="a1ad1d934168832dc9e42cc388cdaccca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad1d934168832dc9e42cc388cdaccca">&#9670;&nbsp;</a></span>is_cos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a cosine expression. </p>

</div>
</div>
<a id="a91183d02aeaa64b9f83cf61cede3d013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91183d02aeaa64b9f83cf61cede3d013">&#9670;&nbsp;</a></span>is_cos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a cosine expression. </p>

</div>
</div>
<a id="ab296e6587d7bf86a4f1b54b5005df4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab296e6587d7bf86a4f1b54b5005df4a6">&#9670;&nbsp;</a></span>is_cosh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a hyperbolic-cosine expression. </p>

</div>
</div>
<a id="a5db9c4002b15345dce271d95cf5ead8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db9c4002b15345dce271d95cf5ead8b">&#9670;&nbsp;</a></span>is_cosh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a hyperbolic-cosine expression. </p>

</div>
</div>
<a id="a307cee89f5417dd1c19ba16bb273fb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307cee89f5417dd1c19ba16bb273fb25">&#9670;&nbsp;</a></span>is_disjunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_disjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a disjunction (∨). </p>

</div>
</div>
<a id="a8877eff0311bb541c504a56196a591f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8877eff0311bb541c504a56196a591f0">&#9670;&nbsp;</a></span>is_disjunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_disjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a disjunction (∨). </p>

</div>
</div>
<a id="ab069e1d04f34ba9f9eff1ee8e97cca6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab069e1d04f34ba9f9eff1ee8e97cca6e">&#9670;&nbsp;</a></span>is_division() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_division </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a division expression. </p>

</div>
</div>
<a id="a1ef7767ed74e24d55ada8b380bcd22d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef7767ed74e24d55ada8b380bcd22d8">&#9670;&nbsp;</a></span>is_division() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_division </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a division expression. </p>

</div>
</div>
<a id="aa44a7661fef44d4031441019512ef82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44a7661fef44d4031441019512ef82d">&#9670;&nbsp;</a></span>is_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing equality (==). </p>

</div>
</div>
<a id="a37d37d1e3097c7a898d706aee5066f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d37d1e3097c7a898d706aee5066f90">&#9670;&nbsp;</a></span>is_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing equality (==). </p>

</div>
</div>
<a id="a77a9ff7a7f105a0e9edf77cace06d9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a9ff7a7f105a0e9edf77cace06d9e9">&#9670;&nbsp;</a></span>is_exp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an exp expression. </p>

</div>
</div>
<a id="aa1af4fb44735c433e6742487abbdf9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1af4fb44735c433e6742487abbdf9eb">&#9670;&nbsp;</a></span>is_exp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an exp expression. </p>

</div>
</div>
<a id="aea6545b9866491ab6406d9141903d204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6545b9866491ab6406d9141903d204">&#9670;&nbsp;</a></span>is_false() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_false </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is structurally equal to False formula. </p>

</div>
</div>
<a id="a8a8bf1c901b65947ce83086ab0921b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8bf1c901b65947ce83086ab0921b13">&#9670;&nbsp;</a></span>is_false() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_false </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is structurally equal to False formula. </p>

</div>
</div>
<a id="a2fc1f48deb39118a12ed30496c2a0a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc1f48deb39118a12ed30496c2a0a33">&#9670;&nbsp;</a></span>is_floor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a floor expression. </p>

</div>
</div>
<a id="a20fb80a81ab38fa64a9cc84c5dd3a71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fb80a81ab38fa64a9cc84c5dd3a71d">&#9670;&nbsp;</a></span>is_floor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a floor expression. </p>

</div>
</div>
<a id="a1860e7373cbab3826845de76f4c6fc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1860e7373cbab3826845de76f4c6fc6a">&#9670;&nbsp;</a></span>is_forall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a Forall formula (∀). </p>

</div>
</div>
<a id="a7cdcb84785fc3ddf61732a3279ce6d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdcb84785fc3ddf61732a3279ce6d74">&#9670;&nbsp;</a></span>is_forall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a Forall formula (∀). </p>

</div>
</div>
<a id="a25bef67cdba7a3575080ee23c4a49c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bef67cdba7a3575080ee23c4a49c24">&#9670;&nbsp;</a></span>is_greater_than() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_greater_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing greater-than (&gt;). </p>

</div>
</div>
<a id="aaf04cff26c77f1ef1f11fedc77a31bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf04cff26c77f1ef1f11fedc77a31bb5">&#9670;&nbsp;</a></span>is_greater_than() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_greater_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing greater-than (&gt;). </p>

</div>
</div>
<a id="aa6bd435704910ee83eec832dec9e0ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bd435704910ee83eec832dec9e0ebe">&#9670;&nbsp;</a></span>is_greater_than_or_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing greater-than-or-equal-to (&gt;=). </p>

</div>
</div>
<a id="a987c2a9d322549f8617a45997bae8aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987c2a9d322549f8617a45997bae8aa6">&#9670;&nbsp;</a></span>is_greater_than_or_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing greater-than-or-equal-to (&gt;=). </p>

</div>
</div>
<a id="a5490fa85a0978930d5966dad1c6ba54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5490fa85a0978930d5966dad1c6ba54b">&#9670;&nbsp;</a></span>is_if_then_else() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an if-then-else expression. </p>

</div>
</div>
<a id="ab19b1f2d76056a8e9ee91ca1d14ee822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19b1f2d76056a8e9ee91ca1d14ee822">&#9670;&nbsp;</a></span>is_if_then_else() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an if-then-else expression. </p>

</div>
</div>
<a id="a8dcc9cee448290213f39d874307af7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcc9cee448290213f39d874307af7e2">&#9670;&nbsp;</a></span>is_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75b1751d953407c394e5643f2d1d3f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b1751d953407c394e5643f2d1d3f27">&#9670;&nbsp;</a></span>is_isnan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is an isnan formula. </p>

</div>
</div>
<a id="aa7ae3f7e8da7523a075b5adfcb7b788c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ae3f7e8da7523a075b5adfcb7b788c">&#9670;&nbsp;</a></span>is_isnan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is an isnan formula. </p>

</div>
</div>
<a id="a9754658b6efb430a95a6ef060573970e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9754658b6efb430a95a6ef060573970e">&#9670;&nbsp;</a></span>is_less_than() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing less-than (&lt;). </p>

</div>
</div>
<a id="a4e70f747ac0d276d07b39a56d8f2b5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e70f747ac0d276d07b39a56d8f2b5b9">&#9670;&nbsp;</a></span>is_less_than() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing less-than (&lt;). </p>

</div>
</div>
<a id="af1861c52cf99c60f758c0f4bd642ecf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1861c52cf99c60f758c0f4bd642ecf9">&#9670;&nbsp;</a></span>is_less_than_or_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing less-than-or-equal-to (&lt;=). </p>

</div>
</div>
<a id="a77bc9328e2893740b71f07cf466f02db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bc9328e2893740b71f07cf466f02db">&#9670;&nbsp;</a></span>is_less_than_or_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing less-than-or-equal-to (&lt;=). </p>

</div>
</div>
<a id="ab049cfca69564b8713a3fd0a0e3bbba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab049cfca69564b8713a3fd0a0e3bbba9">&#9670;&nbsp;</a></span>is_log() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a log expression. </p>

</div>
</div>
<a id="a81fc6d7808fa4484507ddbb2471deb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81fc6d7808fa4484507ddbb2471deb80">&#9670;&nbsp;</a></span>is_log() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a log expression. </p>

</div>
</div>
<a id="a30f8d47e7843b3aabbe95d6651b7c85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f8d47e7843b3aabbe95d6651b7c85f">&#9670;&nbsp;</a></span>is_max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a max expression. </p>

</div>
</div>
<a id="adfb4d01316fdb9323695db004bb8253b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb4d01316fdb9323695db004bb8253b">&#9670;&nbsp;</a></span>is_max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a max expression. </p>

</div>
</div>
<a id="ad138a32ee051ed06353da9b4d26374ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad138a32ee051ed06353da9b4d26374ed">&#9670;&nbsp;</a></span>is_min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a min expression. </p>

</div>
</div>
<a id="a07604bda8201f0e20706eb90227c1237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07604bda8201f0e20706eb90227c1237">&#9670;&nbsp;</a></span>is_min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a min expression. </p>

</div>
</div>
<a id="ad1f74bcd66ba02bc91f3434924a6c8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f74bcd66ba02bc91f3434924a6c8a2">&#9670;&nbsp;</a></span>is_multiplication() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a multiplication expression. </p>

</div>
</div>
<a id="a3fbd20b990ba883bca7f6188c26ba861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbd20b990ba883bca7f6188c26ba861">&#9670;&nbsp;</a></span>is_multiplication() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an multiplication expression. </p>

</div>
</div>
<a id="a56597943e81b4b1cb898816104662a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56597943e81b4b1cb898816104662a16">&#9670;&nbsp;</a></span>is_nan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_nan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is NaN. </p>

</div>
</div>
<a id="a63d76102c00828325b11b21db606b5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d76102c00828325b11b21db606b5a0">&#9670;&nbsp;</a></span>is_nary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_nary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a n-ary formula ({∧, ∨}). </p>

</div>
</div>
<a id="a450bcac9577de0ca8d380d2a70d5fb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450bcac9577de0ca8d380d2a70d5fb12">&#9670;&nbsp;</a></span>is_nary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::symbolic::is_nary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4707946faf3b330e3bce6702cf48b2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4707946faf3b330e3bce6702cf48b2dd">&#9670;&nbsp;</a></span>is_neg_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_neg_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is -1.0. </p>

</div>
</div>
<a id="afbbcd3f16b91bba700239675e5826a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbcd3f16b91bba700239675e5826a81">&#9670;&nbsp;</a></span>is_negation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_negation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a negation (¬). </p>

</div>
</div>
<a id="adf3743f22df29090472d034a69b9d7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3743f22df29090472d034a69b9d7aa">&#9670;&nbsp;</a></span>is_negation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_negation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a negation (¬). </p>

</div>
</div>
<a id="ab388ce9f2353410c61688c6849a66adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab388ce9f2353410c61688c6849a66adc">&#9670;&nbsp;</a></span>is_non_negative_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_non_negative_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b22d6f9b90847ce4b84be2a5afd1c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b22d6f9b90847ce4b84be2a5afd1c30">&#9670;&nbsp;</a></span>is_not_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing disequality (!=). </p>

</div>
</div>
<a id="a08c4eae26a98b1345c997e579ed0709a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c4eae26a98b1345c997e579ed0709a">&#9670;&nbsp;</a></span>is_not_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing disequality (!=). </p>

</div>
</div>
<a id="a28f3f42c88b77cf4893385a7a093087c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f3f42c88b77cf4893385a7a093087c">&#9670;&nbsp;</a></span>is_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is 1.0. </p>

</div>
</div>
<a id="a9d47fd14fcffc0a4c50b95ae4f218131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d47fd14fcffc0a4c50b95ae4f218131">&#9670;&nbsp;</a></span>is_positive_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_positive_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31788a703bff17b148b3107beefbc585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31788a703bff17b148b3107beefbc585">&#9670;&nbsp;</a></span>is_positive_semidefinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a positive-semidefinite formula. </p>

</div>
</div>
<a id="a4c0bed602c95290fb77dc45316a1f54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0bed602c95290fb77dc45316a1f54d">&#9670;&nbsp;</a></span>is_positive_semidefinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a positive semidefinite formula. </p>

</div>
</div>
<a id="aa8204863236e57c7a074fb90bceb61a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8204863236e57c7a074fb90bceb61a1">&#9670;&nbsp;</a></span>is_pow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a power-function expression. </p>

</div>
</div>
<a id="a78e3f155f5ffb14a784c8c6ba45eda79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e3f155f5ffb14a784c8c6ba45eda79">&#9670;&nbsp;</a></span>is_pow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a power-function expression. </p>

</div>
</div>
<a id="ab48c893fbcf425253c444573d100c3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48c893fbcf425253c444573d100c3f2">&#9670;&nbsp;</a></span>is_relational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_relational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}). </p>

</div>
</div>
<a id="aba3787e10ce1fe3bb7f6645a0f9ac671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3787e10ce1fe3bb7f6645a0f9ac671">&#9670;&nbsp;</a></span>is_relational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_relational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}). </p>

</div>
</div>
<a id="a1af6fb7d06debf378b3a7446f7ad6f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af6fb7d06debf378b3a7446f7ad6f26">&#9670;&nbsp;</a></span>is_sin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a sine expression. </p>

</div>
</div>
<a id="a9333b59cea2e2d4fd444a236883efc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9333b59cea2e2d4fd444a236883efc19">&#9670;&nbsp;</a></span>is_sin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a sine expression. </p>

</div>
</div>
<a id="a4e18537f0fba7c1c6c87b20644caf9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e18537f0fba7c1c6c87b20644caf9af">&#9670;&nbsp;</a></span>is_sinh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a hyperbolic-sine expression. </p>

</div>
</div>
<a id="a39b7051855909d23cb2364be81055f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b7051855909d23cb2364be81055f4d">&#9670;&nbsp;</a></span>is_sinh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a hyperbolic-sine expression. </p>

</div>
</div>
<a id="ad88aa92c34154f228b7609c0a1e1f0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88aa92c34154f228b7609c0a1e1f0ef">&#9670;&nbsp;</a></span>is_sqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a square-root expression. </p>

</div>
</div>
<a id="a12582d9a26dfcad1e0f38d7cb252c278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12582d9a26dfcad1e0f38d7cb252c278">&#9670;&nbsp;</a></span>is_sqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a square-root expression. </p>

</div>
</div>
<a id="aa4a2c288d79cc175a23093bfe33a033a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a2c288d79cc175a23093bfe33a033a">&#9670;&nbsp;</a></span>is_tan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a tangent expression. </p>

</div>
</div>
<a id="a7d440af755e098914afb44da35f0bc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d440af755e098914afb44da35f0bc41">&#9670;&nbsp;</a></span>is_tan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a tangent expression. </p>

</div>
</div>
<a id="aabae426c9b32ec48a5655f1e2bafd44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabae426c9b32ec48a5655f1e2bafd44c">&#9670;&nbsp;</a></span>is_tanh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a hyperbolic-tangent expression. </p>

</div>
</div>
<a id="a9046d3df24ec467a11723f4d93a2b2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9046d3df24ec467a11723f4d93a2b2b0">&#9670;&nbsp;</a></span>is_tanh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a hyperbolic-tangent expression. </p>

</div>
</div>
<a id="ac015488f4fe334717bbe5a47e1f1da87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac015488f4fe334717bbe5a47e1f1da87">&#9670;&nbsp;</a></span>is_true() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_true </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is structurally equal to True formula. </p>

</div>
</div>
<a id="a2f1159580703bc95a8f14848e38cb659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1159580703bc95a8f14848e38cb659">&#9670;&nbsp;</a></span>is_true() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_true </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is structurally equal to True formula. </p>

</div>
</div>
<a id="a1e9232608f43a586aad546b2a078aeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9232608f43a586aad546b2a078aeb0">&#9670;&nbsp;</a></span>is_two()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_two </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is 2.0. </p>

</div>
</div>
<a id="aa19665aa37ff4c0aff7aa1ca142eff46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19665aa37ff4c0aff7aa1ca142eff46">&#9670;&nbsp;</a></span>is_uninterpreted_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an uninterpreted-function expression. </p>

</div>
</div>
<a id="accafe113c53c148891d12dcabc66dddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accafe113c53c148891d12dcabc66dddc">&#9670;&nbsp;</a></span>is_uninterpreted_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an uninterpreted-function expression. </p>

</div>
</div>
<a id="aebdc9659eb8cc2eb735925fc4f2828ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdc9659eb8cc2eb735925fc4f2828ac">&#9670;&nbsp;</a></span>is_variable() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a variable formula. </p>

</div>
</div>
<a id="a14d18c58b79582620cb6b8ff37ec1e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d18c58b79582620cb6b8ff37ec1e85">&#9670;&nbsp;</a></span>is_variable() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a variable formula. </p>

</div>
</div>
<a id="a3313ad6342effa904bba98f1ef811902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3313ad6342effa904bba98f1ef811902">&#9670;&nbsp;</a></span>is_variable() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a variable expression. </p>

</div>
</div>
<a id="a1044a1ad5d60045c18502cec5121149c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1044a1ad5d60045c18502cec5121149c">&#9670;&nbsp;</a></span>is_variable() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a variable expression. </p>

</div>
</div>
<a id="a07f09fda9abe80d7b775527445374c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f09fda9abe80d7b775527445374c06">&#9670;&nbsp;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is 0.0. </p>

</div>
</div>
<a id="ae2e386e89865ff1db9ac93f7a3e79586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e386e89865ff1db9ac93f7a3e79586">&#9670;&nbsp;</a></span>isfinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> isfinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> determining if the given expression <code>e</code> has a finite value. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a566d62c9e145df5946146f1a53c12a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566d62c9e145df5946146f1a53c12a96">&#9670;&nbsp;</a></span>isinf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> isinf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> determining if the given expression <code>e</code> is a positive or negative infinity. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee7da5a29fea63347ec7c9fddce7f022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7da5a29fea63347ec7c9fddce7f022">&#9670;&nbsp;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> for the predicate isnan(e) to the given expression. </p>
<p>This serves as the argument-dependent lookup related to std::isnan(double). When evaluated, this <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> will return false when the <a class="el" href="namespacedrake_1_1symbolic.html#a2a166b0ad9f629567d453d875562e571" title="Evaluates a symbolic matrix m using env and random_generator. ">e.Evaluate()</a> is not NaN. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a174c9bcab8eac6dd29f913d7d32f8da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174c9bcab8eac6dd29f913d7d32f8da6">&#9670;&nbsp;</a></span>Jacobian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; Jacobian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>. </p>
<p>J(i,j) contains ∂f(i)/∂vars(j).</p>
<p>For example, Jacobian([x * cos(y), x * sin(y), x^2], {x, y}) returns the following 3x2 matrix: </p><pre>
 = |cos(y)   -x * sin(y)|
   |sin(y)    x * cos(y)|
   | 2 * x             0|
 </pre><dl class="section pre"><dt>Precondition</dt><dd>{<code>vars</code> is non-empty}. </dd></dl>

</div>
</div>
<a id="a2d2676aafe3ce897d4a66bbad500c67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2676aafe3ce897d4a66bbad500c67c">&#9670;&nbsp;</a></span>Jacobian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; Jacobian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>. </p>
<p>J(i,j) contains ∂f(i)/∂vars(j).</p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>vars</code> is non-empty}. </dd></dl>

</div>
</div>
<a id="a1c7c9095542cd5f4ef70f50bca1aab7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7c9095542cd5f4ef70f50bca1aab7c">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad928a3acb97d0b15191fdda370098cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad928a3acb97d0b15191fdda370098cec">&#9670;&nbsp;</a></span>make_conjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> make_conjunction </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>formulas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a conjunction of <code>formulas</code>. </p>
<p>It performs the following simplification:</p>
<ul>
<li>make_conjunction({}) returns True.</li>
<li>make_conjunction({f₁}) returns f₁.</li>
<li>If False ∈ <code>formulas</code>, it returns False.</li>
<li>If True ∈ <code>formulas</code>, it will not appear in the return value.</li>
<li>Nested conjunctions will be flattened. For example, make_conjunction({f₁, f₂ ∧ f₃}) returns f₁ ∧ f₂ ∧ f₃. </li>
</ul>

</div>
</div>
<a id="a10a756a422ebc5e372bb1ecc5ccab5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a756a422ebc5e372bb1ecc5ccab5be">&#9670;&nbsp;</a></span>make_disjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> make_disjunction </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>formulas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a disjunction of <code>formulas</code>. </p>
<p>It performs the following simplification:</p>
<ul>
<li>make_disjunction({}) returns False.</li>
<li>make_disjunction({f₁}) returns f₁.</li>
<li>If True ∈ <code>formulas</code>, it returns True.</li>
<li>If False ∈ <code>formulas</code>, it will not appear in the return value.</li>
<li>Nested disjunctions will be flattened. For example, make_disjunction({f₁, f₂ ∨ f₃}) returns f₁ ∨ f₂ ∨ f₃. </li>
</ul>

</div>
</div>
<a id="ac40449e991943b02a88f4627fd02c872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40449e991943b02a88f4627fd02c872">&#9670;&nbsp;</a></span>MakeMatrixBinaryVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeMatrixBinaryVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic binary variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a803dbab92e520549b625dde70f05fe47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803dbab92e520549b625dde70f05fe47">&#9670;&nbsp;</a></span>MakeMatrixBinaryVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixBinaryVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic binary variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a077c5aa3c1d61b9bf22590e5325af815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077c5aa3c1d61b9bf22590e5325af815">&#9670;&nbsp;</a></span>MakeMatrixBooleanVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeMatrixBooleanVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic Boolean variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ab43ed8981b8575f24e83fdf4b26295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab43ed8981b8575f24e83fdf4b26295">&#9670;&nbsp;</a></span>MakeMatrixBooleanVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixBooleanVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic Boolean variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4881156a2dba929854529bbecb7bb2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4881156a2dba929854529bbecb7bb2e2">&#9670;&nbsp;</a></span>MakeMatrixContinuousVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeMatrixContinuousVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic continuous variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad93b9abfad06da819d5460018eb49b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93b9abfad06da819d5460018eb49b5c">&#9670;&nbsp;</a></span>MakeMatrixContinuousVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixContinuousVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic continuous variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aceffea98cb4dc7da681037dd3448e8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceffea98cb4dc7da681037dd3448e8a2">&#9670;&nbsp;</a></span>MakeMatrixIntegerVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeMatrixIntegerVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic integer variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b71b38080ba3cd1d36172c4577ed445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b71b38080ba3cd1d36172c4577ed445">&#9670;&nbsp;</a></span>MakeMatrixIntegerVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic integer variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6823e106a6a01aa3fdd6fe2ed827d1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6823e106a6a01aa3fdd6fe2ed827d1e8">&#9670;&nbsp;</a></span>MakeMatrixVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeMatrixVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77055238eec353c7b077cd2fafd83aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77055238eec353c7b077cd2fafd83aa7">&#9670;&nbsp;</a></span>MakeMatrixVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> matrix of symbolic variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a327c04af4b8fa510bd365a1bb7dfe6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327c04af4b8fa510bd365a1bb7dfe6ed">&#9670;&nbsp;</a></span>MakeRuleRewriter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a134e54042165751a5e5369b4631c90eb">Rewriter</a> MakeRuleRewriter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html">RewritingRule</a> &amp;&#160;</td>
          <td class="paramname"><em>rule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a rewriter based on a rewriting rule <code>r</code>. </p>

</div>
</div>
<a id="a9341ab1f18ff240083389ccdcb483ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9341ab1f18ff240083389ccdcb483ed3">&#9670;&nbsp;</a></span>MakeVectorBinaryVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeVectorBinaryVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic binary variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a698dcb5dd4fea36841d305e89f52dd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698dcb5dd4fea36841d305e89f52dd97">&#9670;&nbsp;</a></span>MakeVectorBinaryVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorBinaryVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic binary variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f7fee6b939582c5bd9f0020ebeb2c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7fee6b939582c5bd9f0020ebeb2c2a">&#9670;&nbsp;</a></span>MakeVectorBooleanVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeVectorBooleanVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic Boolean variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d2f37fa21183f09e3544a4c6891494b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2f37fa21183f09e3544a4c6891494b">&#9670;&nbsp;</a></span>MakeVectorBooleanVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorBooleanVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic Boolean variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9512d7058f85f0f5ddcf2ad601768d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9512d7058f85f0f5ddcf2ad601768d54">&#9670;&nbsp;</a></span>MakeVectorContinuousVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeVectorContinuousVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic continuous variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86a6b5840c741f1869738945cef3d8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a6b5840c741f1869738945cef3d8c5">&#9670;&nbsp;</a></span>MakeVectorContinuousVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorContinuousVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic continuous variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa67f9414a4674809981130f03d1da9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67f9414a4674809981130f03d1da9c0">&#9670;&nbsp;</a></span>MakeVectorIntegerVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeVectorIntegerVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic integer variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a22da2ebae3f3ca478d07976adfca85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a22da2ebae3f3ca478d07976adfca85">&#9670;&nbsp;</a></span>MakeVectorIntegerVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic integer variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4121a7d1fb8d747d147771205bf0fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4121a7d1fb8d747d147771205bf0fe4">&#9670;&nbsp;</a></span>MakeVectorVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeVectorVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad09c18b98a36a770ab68c048bd70b09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09c18b98a36a770ab68c048bd70b09c">&#9670;&nbsp;</a></span>MakeVectorVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized <a class="el" href="namespace_eigen.html">Eigen</a> vector of symbolic variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa951d192140621a51f31d68ead6f3e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa951d192140621a51f31d68ead6f3e4d">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f18b20230d6fd5d6a2c81a278a89edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f18b20230d6fd5d6a2c81a278a89edc">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc6302f8ed7ce764202bffb915277dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6302f8ed7ce764202bffb915277dc2">&#9670;&nbsp;</a></span>MonomialBasis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt; MonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all monomials up to a given degree under the graded reverse lexicographic order. </p>
<p>Note that graded reverse lexicographic order uses the total order among <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable. ">Variable</a> which is based on a variable's unique ID. For example, for a given variable ordering x &gt; y &gt; z, <code>MonomialBasis({x, y, z}, 2)</code> returns a column vector <code>[x^2, xy, y^2, xz, yz, z^2, x, y, z, 1]</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>vars</code> is a non-empty set. </dd>
<dd>
<code>degree</code> is a non-negative integer. </dd></dl>

</div>
</div>
<a id="af297794f22c0458592aeea637cce060a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af297794f22c0458592aeea637cce060a">&#9670;&nbsp;</a></span>MonomialBasis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, <a class="el" href="namespacedrake_1_1symbolic.html#aa40528027cce753aacb377913342f536">NChooseK</a>(n + degree, degree), 1&gt; drake::symbolic::MonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all monomials up to a given degree under the graded reverse lexicographic order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>number of variables. </td></tr>
    <tr><td class="paramname">degree</td><td>maximum total degree of monomials to compute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>vars</code> is a non-empty set. </dd>
<dd>
vars.size() == <code>n</code>. </dd></dl>

</div>
</div>
<a id="aa40528027cce753aacb377913342f536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40528027cce753aacb377913342f536">&#9670;&nbsp;</a></span>NChooseK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> drake::symbolic::NChooseK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3d948f388ac283cd13652db5dd61062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d948f388ac283cd13652db5dd61062">&#9670;&nbsp;</a></span>operator &&() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a439fc52dfc51fdc1038e0b18df80ca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439fc52dfc51fdc1038e0b18df80ca60">&#9670;&nbsp;</a></span>operator &&() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cfdf7ac64d6ce3a42877a1231ee15f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfdf7ac64d6ce3a42877a1231ee15f8">&#9670;&nbsp;</a></span>operator &&() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05740a421f5a1c3ff96463eaa65682d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05740a421f5a1c3ff96463eaa65682d0">&#9670;&nbsp;</a></span>operator &&() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3d948f388ac283cd13652db5dd61062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d948f388ac283cd13652db5dd61062">&#9670;&nbsp;</a></span>operator &&() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a439fc52dfc51fdc1038e0b18df80ca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439fc52dfc51fdc1038e0b18df80ca60">&#9670;&nbsp;</a></span>operator &&() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cfdf7ac64d6ce3a42877a1231ee15f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfdf7ac64d6ce3a42877a1231ee15f8">&#9670;&nbsp;</a></span>operator &&() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05740a421f5a1c3ff96463eaa65682d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05740a421f5a1c3ff96463eaa65682d0">&#9670;&nbsp;</a></span>operator &&() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49edb4821b05df85a60fe3d96adf4f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49edb4821b05df85a60fe3d96adf4f70">&#9670;&nbsp;</a></span>operator!() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9175736ad1ead8240b9bbc1bd8d4f37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9175736ad1ead8240b9bbc1bd8d4f37f">&#9670;&nbsp;</a></span>operator!() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf2a23baf604198889aab8eea8620601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2a23baf604198889aab8eea8620601">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> <a class="el" href="namespacedrake_1_1symbolic.html#a49edb4821b05df85a60fe3d96adf4f70">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a609ddf9b3fff35b5451473ce3d51f294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609ddf9b3fff35b5451473ce3d51f294">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() != typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, typename <a class="el" href="structdrake_1_1symbolic_1_1detail_1_1_relational_op_traits.html">detail::RelationalOpTraits</a>&lt;DerivedA, DerivedB&gt;::ReturnType&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> <a class="el" href="namespacedrake_1_1symbolic.html#a49edb4821b05df85a60fe3d96adf4f70">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using not-equal operator (!=). </p>

</div>
</div>
<a id="a29162801f264334d6292daf5830f9f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29162801f264334d6292daf5830f9f78">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename Derived::Scalar() != ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> <a class="el" href="namespacedrake_1_1symbolic.html#a49edb4821b05df85a60fe3d96adf4f70">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using not-equal operator (!=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a != v)</code> has a symbolic formula <code>a(i, j) != v</code>. </p>

</div>
</div>
<a id="a1d4d5abce6202d5c1e711750cf6d4fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4d5abce6202d5c1e711750cf6d4fb6">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(ScalarType() != typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> <a class="el" href="namespacedrake_1_1symbolic.html#a49edb4821b05df85a60fe3d96adf4f70">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> not-equal operator (!=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v != a)</code> has a symbolic formula <code>v != a(i, j)</code>. </p>

</div>
</div>
<a id="ac72b431bb035e5035d4a5ca5c1aedb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72b431bb035e5035d4a5ca5c1aedb02">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() != typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> <a class="el" href="namespacedrake_1_1symbolic.html#a49edb4821b05df85a60fe3d96adf4f70">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing the condition whether <code>m1</code> and <code>m2</code> are not the same. </p>
<p>The following table describes the return type of <code>m1</code> != <code>m2</code>.</p>
<table class="doxtable">
<tr>
<th>LHS \ RHS </th><th>EM&lt;Expression&gt; </th><th>EM&lt;Variable&gt; </th><th>EM&lt;double&gt;  </th></tr>
<tr>
<td>EM&lt;Expression&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td></tr>
<tr>
<td>EM&lt;Variable&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td></tr>
<tr>
<td>EM&lt;double&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td>bool </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>.</p>
<p>Note that this function does <em>not</em> provide operator overloading for the following case. It returns <code>bool</code> and is provided by <a class="el" href="namespace_eigen.html">Eigen</a>.</p>
<ul>
<li>Eigen::Matrix&lt;double&gt; != Eigen::Matrix&lt;double&gt; </li>
</ul>

</div>
</div>
<a id="a24e6a0d904da664f8fa2a665d6db64c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e6a0d904da664f8fa2a665d6db64c2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; drake::symbolic::operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following operations: </p>
<ul>
<li>Matrix&lt;RF&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;RF&gt;</li>
<li>Matrix&lt;RF&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;RF&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;RF&gt; =&gt; Matrix&lt;RF&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;RF&gt; =&gt; Matrix&lt;RF&gt;</li>
</ul>
<p>where RF is a shorthand for <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html" title="Represents symbolic rational function. ">RationalFunction</a>.</p>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information</dd></dl>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="a47e353ad2f92e91622a6554945c10190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e353ad2f92e91622a6554945c10190">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5da13e9a5ae37fbfea7bd661cc15b3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da13e9a5ae37fbfea7bd661cc15b3f8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac96d8eb0d54db155ab9f2ae5b3057c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96d8eb0d54db155ab9f2ae5b3057c2f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab92318b3c84edc12ed69faa7098c9ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92318b3c84edc12ed69faa7098c9ccc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6654fd307d9348f2baa46da2ff3abd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6654fd307d9348f2baa46da2ff3abd3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2143c3319c15d24b46cf25471e104011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2143c3319c15d24b46cf25471e104011">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; drake::symbolic::operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="ad5eb41b274605738d8049c0f0440c9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5eb41b274605738d8049c0f0440c9ec">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a multiplication of two monomials, <code>m1</code> and <code>m2</code>. </p>

</div>
</div>
<a id="a3afe6eb8130d59ffeabe0b6dcc382353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afe6eb8130d59ffeabe0b6dcc382353">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1166bfbd5975c08fbae15fdc32eee58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1166bfbd5975c08fbae15fdc32eee58">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename MatrixR::Scalar, <a class="el" href="classdouble.html">double</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="a60c0402d8a4ab5d50003560ddccdb3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c0402d8a4ab5d50003560ddccdb3a6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82a1e5c6f989d9eb82b47f06df766264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a1e5c6f989d9eb82b47f06df766264">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45f74794ee4a396e8fd39b44665c2a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f74794ee4a396e8fd39b44665c2a62">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af99abd45b5e371255adc9d5c8b078b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99abd45b5e371255adc9d5c8b078b36">&#9670;&nbsp;</a></span>operator*() <span class="overload">[14/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99dc956184f0c8d7466e78369dd6f595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99dc956184f0c8d7466e78369dd6f595">&#9670;&nbsp;</a></span>operator*() <span class="overload">[15/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename MatrixL::Scalar, <a class="el" href="classdouble.html">double</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="a51601d6a1010077eb8bcda7be53221b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51601d6a1010077eb8bcda7be53221b0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[16/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a335b835b158bb74b8c176f0a9d0d98b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335b835b158bb74b8c176f0a9d0d98b3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[17/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30e80d8ac3887ff8b4c0368edf473436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e80d8ac3887ff8b4c0368edf473436">&#9670;&nbsp;</a></span>operator*() <span class="overload">[18/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a180fa037912fdc61df2ea9247c4c62e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180fa037912fdc61df2ea9247c4c62e3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[19/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="a9037545f678181c097e5337a93bedf8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9037545f678181c097e5337a93bedf8f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[20/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="ab75d66dc4baea3c6fc9f8f44a938f3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75d66dc4baea3c6fc9f8f44a938f3a4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[21/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename MatrixR::Scalar, <a class="el" href="classdouble.html">double</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="afcdcb02c85dcc269afeca65eef0cbfec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdcb02c85dcc269afeca65eef0cbfec">&#9670;&nbsp;</a></span>operator*() <span class="overload">[22/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename MatrixL::Scalar, <a class="el" href="classdouble.html">double</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="af8520617218403e519e010ad94a6fb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8520617218403e519e010ad94a6fb64">&#9670;&nbsp;</a></span>operator*() <span class="overload">[23/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::symbolic::operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, LhsMode, LhsOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; <a class="el" href="classdouble.html">double</a>, Dim, RhsMode, RhsOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform&lt;double&gt; * Transform&lt;Expression&gt; =&gt; Transform&lt;Expression&gt; </p>

</div>
</div>
<a id="ac432e3e03086d5b147620673ed357a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac432e3e03086d5b147620673ed357a7c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[24/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::symbolic::operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; <a class="el" href="classdouble.html">double</a>, Dim, LhsMode, LhsOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, RhsMode, RhsOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform&lt;Expression&gt; * Transform&lt;double&gt; =&gt; Transform&lt;Expression&gt; </p>

</div>
</div>
<a id="a702e8b7089a5dd3d5cc22f9da154e1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702e8b7089a5dd3d5cc22f9da154e1b2">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0176708e0ff133d7166b2f4700832885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0176708e0ff133d7166b2f4700832885">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-union of <code>var1</code> and <code>var2</code>. </p>

</div>
</div>
<a id="a7d10380477ac001084ccc42d6aa005b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d10380477ac001084ccc42d6aa005b6">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-union of <code>vars</code> and {<code>var}</code>. </p>

</div>
</div>
<a id="ac56aaa3de6bd181f40290eb9c9ab264e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56aaa3de6bd181f40290eb9c9ab264e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-union of {<code>var}</code> and <code>vars</code>. </p>

</div>
</div>
<a id="a90f257b9087b47d0579d8e7d9631abb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f257b9087b47d0579d8e7d9631abb4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ab71a213952c1f284526102a4356381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab71a213952c1f284526102a4356381">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0801308a64278437b3734f11cc813da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0801308a64278437b3734f11cc813da5">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc56bda0a18e846fe326ac025e01a45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc56bda0a18e846fe326ac025e01a45d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a001ec416bb7ee68695e1ec9a65b98720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001ec416bb7ee68695e1ec9a65b98720">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d376b5d0899a705ee72195cde03af1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d376b5d0899a705ee72195cde03af1c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1474e5a6eadf9c929b552c4a1a774539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1474e5a6eadf9c929b552c4a1a774539">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af24522315ccc26ae75f90fe52edf75f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24522315ccc26ae75f90fe52edf75f8">&#9670;&nbsp;</a></span>operator+() <span class="overload">[11/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e385d568eb0ddc41d5b2dac2e081be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e385d568eb0ddc41d5b2dac2e081be0">&#9670;&nbsp;</a></span>operator+() <span class="overload">[12/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f71e04c7645cc414e256fd4dd5bb868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f71e04c7645cc414e256fd4dd5bb868">&#9670;&nbsp;</a></span>operator+() <span class="overload">[13/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3624f7d482fabd5c332896a9c5c94734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3624f7d482fabd5c332896a9c5c94734">&#9670;&nbsp;</a></span>operator+() <span class="overload">[14/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6d57ab48e0f05c15c1f1ca7b548d28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d57ab48e0f05c15c1f1ca7b548d28a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[15/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af01286b53b3a9fcbb6fd0f86b21f4835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01286b53b3a9fcbb6fd0f86b21f4835">&#9670;&nbsp;</a></span>operator+() <span class="overload">[16/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a923b6c6ade771a8ba39ee1d077e88c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923b6c6ade771a8ba39ee1d077e88c86">&#9670;&nbsp;</a></span>operator+() <span class="overload">[17/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae32bf5f5b50f389fce559dd9df0ae5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32bf5f5b50f389fce559dd9df0ae5bc">&#9670;&nbsp;</a></span>operator+() <span class="overload">[18/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62cd62f14d17b199df485d5a4c2c976a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cd62f14d17b199df485d5a4c2c976a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[19/19]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d208ecf4085efd38598ff4375b2bda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d208ecf4085efd38598ff4375b2bda5">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>var1</code> with the result of set-union(<code>var1</code>, <code>var2</code>). </p>

</div>
</div>
<a id="ab4bf4135713e0549b50c59cade15e961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bf4135713e0549b50c59cade15e961">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>vars</code> with the result of set-union(<code>vars</code>, { <code>var</code> }). </p>

</div>
</div>
<a id="af3b7983f85fe6d5d0e6dd623f630cff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b7983f85fe6d5d0e6dd623f630cff2">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab15f6e5aa82236dcd5bfb4a310022997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15f6e5aa82236dcd5bfb4a310022997">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-minus(<code>var1</code>, <code>vars2</code>). </p>

</div>
</div>
<a id="a24e3c65798c6801e74fa2bf071c5f589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e3c65798c6801e74fa2bf071c5f589">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-minus(<code>vars</code>, { <code>var</code> }). </p>

</div>
</div>
<a id="a5d9d907364da3c18f9f763ea935dcfb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9d907364da3c18f9f763ea935dcfb0">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unary minus operation for rational function. </p>
<p>if f(x) = p(x) / q(x), then -f(x) = (-p(x)) / q(x) </p>

</div>
</div>
<a id="a084bf309d07e7c8560b89bcf3f7523a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084bf309d07e7c8560b89bcf3f7523a2">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42cb7637d5591968374ac16f95d7ca68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cb7637d5591968374ac16f95d7ca68">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d07ec1d9258a03df17a869e18842fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d07ec1d9258a03df17a869e18842fcd">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67dbb91e91fae264abe9d39a6c167fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67dbb91e91fae264abe9d39a6c167fe3">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a417daa8f767bb80ebf2b775eede4ad76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417daa8f767bb80ebf2b775eede4ad76">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7396940e4ad4279f7e7a984305a051a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7396940e4ad4279f7e7a984305a051a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad82a0882a250b686c193c81892f8bf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82a0882a250b686c193c81892f8bf34">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d3fa831fe8133b44fb872c4dd1994f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3fa831fe8133b44fb872c4dd1994f3">&#9670;&nbsp;</a></span>operator-() <span class="overload">[11/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unary minus operation for polynomial. </p>

</div>
</div>
<a id="a2e5b784ac8ef76dc1d5295d1d4d6f89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5b784ac8ef76dc1d5295d1d4d6f89a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[12/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47ad706c6f9ac6d8413383d8152c4b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ad706c6f9ac6d8413383d8152c4b51">&#9670;&nbsp;</a></span>operator-() <span class="overload">[13/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f70ed5b694fb54c450571f7e954ca64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f70ed5b694fb54c450571f7e954ca64">&#9670;&nbsp;</a></span>operator-() <span class="overload">[14/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a25d63b978c1df701182843ce44f0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a25d63b978c1df701182843ce44f0ca">&#9670;&nbsp;</a></span>operator-() <span class="overload">[15/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a576e1c4debb10532b634ce5c7528bfb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576e1c4debb10532b634ce5c7528bfb8">&#9670;&nbsp;</a></span>operator-() <span class="overload">[16/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19080e6e3ae03a4d4d1c6ec7cf10388a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19080e6e3ae03a4d4d1c6ec7cf10388a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[17/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a23622b0642107b424fe1b5ef265980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a23622b0642107b424fe1b5ef265980">&#9670;&nbsp;</a></span>operator-() <span class="overload">[18/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab62b510efea342f3bbdbb36944fe42d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62b510efea342f3bbdbb36944fe42d2">&#9670;&nbsp;</a></span>operator-() <span class="overload">[19/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95dd79861957477e088534110c2604a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95dd79861957477e088534110c2604a1">&#9670;&nbsp;</a></span>operator-() <span class="overload">[20/20]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ec727eec3de8a6935ebc8036b497a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec727eec3de8a6935ebc8036b497a82">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>var1</code> with the result of set-minus(<code>var1</code>, <code>var2</code>). </p>

</div>
</div>
<a id="af039fc6cb2d4d56510e95e74bc4d0a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af039fc6cb2d4d56510e95e74bc4d0a90">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>vars</code> with the result of set-minus(<code>vars</code>, {<code>var}</code>). </p>

</div>
</div>
<a id="a160ea247e390cafd990190196c446785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160ea247e390cafd990190196c446785">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aedd63e0afe919c6474d0da57593d8d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd63e0afe919c6474d0da57593d8d5f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f0bea506f1ba735c18adec70cc049a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0bea506f1ba735c18adec70cc049a1">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b72643a63257ec55447a31a7627b7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b72643a63257ec55447a31a7627b7dd">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeffbde3ace1b49b7df5ec9eb9aa8f956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffbde3ace1b49b7df5ec9eb9aa8f956">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f7de309c1619f81c94cfa294e5a9065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7de309c1619f81c94cfa294e5a9065">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a65c6eae526c1f116f99fa1eba9f73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a65c6eae526c1f116f99fa1eba9f73a">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa54e8cfb56c376f1e578784d6b68fbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54e8cfb56c376f1e578784d6b68fbf1">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5206a4972567789a21f4c05dbbca1bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5206a4972567789a21f4c05dbbca1bc7">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a>&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a>&#160;</td>
          <td class="paramname"><em>k2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9911fd0881ffc66c0c64e8d727399237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9911fd0881ffc66c0c64e8d727399237">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">ExpressionKind</a>&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">ExpressionKind</a>&#160;</td>
          <td class="paramname"><em>k2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total ordering between ExpressionKinds. </p>

</div>
</div>
<a id="abafb11a2f5c2fb7512b3f01bfba8efd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafb11a2f5c2fb7512b3f01bfba8efd3">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea9d6243717b5f82e19ace8a5d88f450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9d6243717b5f82e19ace8a5d88f450">&#9670;&nbsp;</a></span>operator<() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e2970a5e4acf251820880cc4bee1a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2970a5e4acf251820880cc4bee1a84">&#9670;&nbsp;</a></span>operator<() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, typename <a class="el" href="structdrake_1_1symbolic_1_1detail_1_1_relational_op_traits.html">detail::RelationalOpTraits</a>&lt;DerivedA, DerivedB&gt;::ReturnType&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using less-than operator (&lt;). </p>

</div>
</div>
<a id="a986b3544a84c715fba5ba1633845a206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986b3544a84c715fba5ba1633845a206">&#9670;&nbsp;</a></span>operator<() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename Derived::Scalar() &lt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using less-than operator (&lt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a &lt; v)</code> has a symbolic formula <code>a(i, j) &lt; v</code>. </p>

</div>
</div>
<a id="ae3c9b1d47ba70ed1290375ef56166d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c9b1d47ba70ed1290375ef56166d13">&#9670;&nbsp;</a></span>operator<() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(ScalarType() &lt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than operator (&lt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v &lt; a)</code> has a symbolic formula <code>v &lt; a(i, j)</code>. </p>

</div>
</div>
<a id="a41fb24103c168ad624e3416b15f206ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fb24103c168ad624e3416b15f206ae">&#9670;&nbsp;</a></span>operator<() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using less-than (&lt;) operator. </p>
<p>The following table describes the return type of <code>m1</code> &lt; <code>m2</code>.</p>
<table class="doxtable">
<tr>
<th>LHS \ RHS </th><th>EM&lt;Expression&gt; </th><th>EM&lt;Variable&gt; </th><th>EM&lt;double&gt;  </th></tr>
<tr>
<td>EM&lt;Expression&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td></tr>
<tr>
<td>EM&lt;Variable&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td></tr>
<tr>
<td>EM&lt;double&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td>N/A </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="aba9b8f20b56f0e3d96b76c3a76610ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9b8f20b56f0e3d96b76c3a76610ed4">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af17fff2492f7afb4512ed8acfe90bfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17fff2492f7afb4512ed8acfe90bfa6">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4e0e8e0c052f5428c78531518c813db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e0e8e0c052f5428c78531518c813db">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7321fd38348c4842f41b4965bdf4979d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7321fd38348c4842f41b4965bdf4979d">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26f2261706621f73ebb925a00f1aa6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f2261706621f73ebb925a00f1aa6a2">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae89e30b501eaa9d29d20e912e6aedc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89e30b501eaa9d29d20e912e6aedc34">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa23c192a89e3cca0185cf101d2e4e9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23c192a89e3cca0185cf101d2e4e9d1">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f13e2bea2dfc69ca8f389450a062981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f13e2bea2dfc69ca8f389450a062981">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacd965dfa0e1c7197884ac82fc5f1878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd965dfa0e1c7197884ac82fc5f1878">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad91873fce901342b010a449f7952d290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91873fce901342b010a449f7952d290">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50df56fb87f1e4e2606295e9d8f12941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50df56fb87f1e4e2606295e9d8f12941">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &lt;= typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, typename <a class="el" href="structdrake_1_1symbolic_1_1detail_1_1_relational_op_traits.html">detail::RelationalOpTraits</a>&lt;DerivedA, DerivedB&gt;::ReturnType&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using less-than-or-equal operator (&lt;=). </p>

</div>
</div>
<a id="a68198826f1753cb1e463c57c42da9dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68198826f1753cb1e463c57c42da9dc7">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename Derived::Scalar() &lt;= ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using less-than-or-equal operator (&lt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a &lt;= v)</code> has a symbolic formula <code>a(i, j) &lt;= v</code>. </p>

</div>
</div>
<a id="a84b7debe6add1a90d995b7fe32077e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b7debe6add1a90d995b7fe32077e15">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(ScalarType() &lt;= typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than-or-equal operator (&lt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v &lt;= a)</code> has a symbolic formula <code>v &lt;= a(i, j)</code>. </p>

</div>
</div>
<a id="a382f5863e12e1c5357b9e40a42a1787d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382f5863e12e1c5357b9e40a42a1787d">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &lt;= typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using less-than-or-equal operator (&lt;=). </p>
<p>The following table describes the return type of <code>m1</code> &lt;= <code>m2</code>.</p>
<table class="doxtable">
<tr>
<th>LHS \ RHS </th><th>EM&lt;Expression&gt; </th><th>EM&lt;Variable&gt; </th><th>EM&lt;double&gt;  </th></tr>
<tr>
<td>EM&lt;Expression&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td></tr>
<tr>
<td>EM&lt;Variable&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td></tr>
<tr>
<td>EM&lt;double&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td>N/A </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="ab53fca5ee2418025963ba51bb926c779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53fca5ee2418025963ba51bb926c779">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae28c71d4bee52bfa5e4928605a4ee87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28c71d4bee52bfa5e4928605a4ee87d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bb4f53b295b2105a77d9578fff68c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb4f53b295b2105a77d9578fff68c5e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() == typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, typename <a class="el" href="structdrake_1_1symbolic_1_1detail_1_1_relational_op_traits.html">detail::RelationalOpTraits</a>&lt;DerivedA, DerivedB&gt;::ReturnType&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise symbolic-equality of two arrays <code>m1</code> and <code>m2</code>. </p>
<p>The following table describes the return type of <code>m1</code> == <code>m2</code>.</p>
<table class="doxtable">
<tr>
<th>LHS \ RHS </th><th>EA&lt;Expression&gt; </th><th>EA&lt;Variable&gt; </th><th>EA&lt;double&gt;  </th></tr>
<tr>
<td>EA&lt;Expression&gt; </td><td>EA&lt;Formula&gt; </td><td>EA&lt;Formula&gt; </td><td>EA&lt;Formula&gt; </td></tr>
<tr>
<td>EA&lt;Variable&gt; </td><td>EA&lt;Formula&gt; </td><td>EA&lt;Formula&gt; </td><td>EA&lt;Formula&gt; </td></tr>
<tr>
<td>EA&lt;double&gt; </td><td>EA&lt;Formula&gt; </td><td>EA&lt;Formula&gt; </td><td>EA&lt;bool&gt; </td></tr>
</table>
<p>In the table, <code>EA</code> is a short-hand of <code>Eigen::Array</code>.</p>
<p>Note that this function does <em>not</em> provide operator overloading for the following case. It returns <code>Eigen::Array&lt;bool&gt;</code> and is provided by <a class="el" href="namespace_eigen.html">Eigen</a>.</p>
<ul>
<li>Eigen::Array&lt;double&gt; == Eigen::Array&lt;double&gt; </li>
</ul>

</div>
</div>
<a id="a7ebadda4ff0c83bc56fbe0d1a1394c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebadda4ff0c83bc56fbe0d1a1394c42">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename Derived::Scalar() == ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using equal-to operator (==). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a == v)</code> has a symbolic formula <code>a(i, j) == v</code>.</p>
<p>Here is an example using this operator overloading. </p><div class="fragment"><div class="line">Eigen::Array&lt;Variable, 2, 2&gt; a;</div><div class="line">a &lt;&lt; Variable{<span class="stringliteral">&quot;x&quot;</span>}, Variable{<span class="stringliteral">&quot;y&quot;</span>},</div><div class="line">     Variable{<span class="stringliteral">&quot;z&quot;</span>}, Variable{<span class="stringliteral">&quot;w&quot;</span>};</div><div class="line">Eigen::Array&lt;Formula, 2, 2&gt; f = (a == 3.5);</div><div class="line"><span class="comment">// Here f = |(x == 3.5)  (y == 3.5)|</span></div><div class="line"><span class="comment">//          |(z == 3.5)  (w == 3.5)|.</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a4a608496012273ef3a3588c98177334d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a608496012273ef3a3588c98177334d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(ScalarType() == typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> equal-to operator (==). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v == a)</code> has a symbolic formula <code>v == a(i, j)</code>.</p>
<p>Here is an example using this operator overloading. </p><div class="fragment"><div class="line">Eigen::Array&lt;Variable, 2, 2&gt; a;</div><div class="line">a &lt;&lt; Variable{<span class="stringliteral">&quot;x&quot;</span>}, Variable{<span class="stringliteral">&quot;y&quot;</span>},</div><div class="line">     Variable{<span class="stringliteral">&quot;z&quot;</span>}, Variable{<span class="stringliteral">&quot;w&quot;</span>};</div><div class="line">Eigen::Array&lt;Formula, 2, 2&gt; f = (3.5 == a);</div><div class="line"><span class="comment">// Here f = |(3.5 == x)  (3.5 == y)|</span></div><div class="line"><span class="comment">//          |(3.5 == z)  (3.5 == w)|.</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a2f2f78812963ed2e8e95b5807249efbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2f78812963ed2e8e95b5807249efbc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() == typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula checking if two matrices <code>m1</code> and <code>m2</code> are equal. </p>
<p>The following table describes the return type of <code>m1</code> == <code>m2</code>.</p>
<table class="doxtable">
<tr>
<th>LHS \ RHS </th><th>EM&lt;Expression&gt; </th><th>EM&lt;Variable&gt; </th><th>EM&lt;double&gt;  </th></tr>
<tr>
<td>EM&lt;Expression&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td></tr>
<tr>
<td>EM&lt;Variable&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td></tr>
<tr>
<td>EM&lt;double&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td>bool </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>.</p>
<p>Note that this function does <em>not</em> provide operator overloading for the following case. It returns <code>bool</code> and is provided by <a class="el" href="namespace_eigen.html">Eigen</a>.</p>
<ul>
<li>Eigen::Matrix&lt;double&gt; == Eigen::Matrix&lt;double&gt;</li>
</ul>
<p>Note that this method returns a conjunctive formula which keeps its conjuncts as <code>std::set&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a>&gt;</code> internally. This set is ordered by <code><a class="el" href="classdrake_1_1symbolic_1_1_formula.html#abd2677c76ddb28c10321b8178cfc6292" title="Checks lexicographical ordering between this and e. ">Formula::Less</a></code> and this ordering can be <em>different</em> from the one in inputs. Also, any duplicated formulas are removed in construction. Please check the following example.</p>
<div class="fragment"><div class="line"><span class="comment">// set up v1 = [y x y] and v2 = [1 2 1]</span></div><div class="line">VectorX&lt;Expression&gt; v1{3};</div><div class="line">VectorX&lt;Expression&gt; v2{3};</div><div class="line"><span class="keyword">const</span> Variable <a class="code" href="ipopt__solver_8cc.html#ab0de8209ca91d50f02e57b337ac47611">x</a>{<span class="stringliteral">&quot;x&quot;</span>};</div><div class="line"><span class="keyword">const</span> Variable <a class="code" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>{<span class="stringliteral">&quot;y&quot;</span>};</div><div class="line">v1 &lt;&lt; <a class="code" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>, <a class="code" href="ipopt__solver_8cc.html#ab0de8209ca91d50f02e57b337ac47611">x</a>, <a class="code" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>;</div><div class="line">v2 &lt;&lt; 1, 2, 1;</div><div class="line"><span class="comment">// Here v1_eq_v2 = ((x = 2) ∧ (y = 1))</span></div><div class="line"><span class="keyword">const</span> Formula v1_eq_v2{v1 == v2};</div><div class="line"><span class="keyword">const</span> std::set&lt;Formula&gt; conjuncts{<a class="code" href="namespacedrake_1_1symbolic.html#a5a51076f5f4ab9497965268ceb34e82c">get_operands</a>(v1_eq_v2)};</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> Formula&amp; f : conjuncts) {</div><div class="line">  std::cerr &lt;&lt; f &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"><span class="comment">// The outcome of the above loop is:</span></div><div class="line">(x = 2)</div><div class="line">(y = 1)</div></div><!-- fragment --> 
</div>
</div>
<a id="a047255afbaefd1684cccb967c2ceb1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047255afbaefd1684cccb967c2ceb1b7">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fd6bb55d96be271f1a64cfd26ffa286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd6bb55d96be271f1a64cfd26ffa286">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, typename <a class="el" href="structdrake_1_1symbolic_1_1detail_1_1_relational_op_traits.html">detail::RelationalOpTraits</a>&lt;DerivedA, DerivedB&gt;::ReturnType&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using greater-than operator (&gt;). </p>

</div>
</div>
<a id="ac3a0bb42e093d46cbd74a0c263c0d61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a0bb42e093d46cbd74a0c263c0d61a">&#9670;&nbsp;</a></span>operator>() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename Derived::Scalar() &gt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using greater-than operator (&gt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a &gt; v)</code> has a symbolic formula <code>a(i, j) &gt; v</code>. </p>

</div>
</div>
<a id="a0e63a21e3a4861f1a6fccbc7667cd298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e63a21e3a4861f1a6fccbc7667cd298">&#9670;&nbsp;</a></span>operator>() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(ScalarType() &gt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than operator (&lt;) instead of greater-than operator (&gt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v &gt; a)</code> has a symbolic formula <code>a(i, j) &lt; v</code>.</p>
<p>Note that given <code>v &gt; a</code>, this methods returns the result of <code>a &lt; v</code>. First of all, this formulation is mathematically equivalent to the original formulation. We implement this method in this way to be consistent with <a class="el" href="namespace_eigen.html">Eigen</a>'s semantics. See the definition of <code>EIGEN_MAKE_CWISE_COMP_R_OP</code> in ArrayCwiseBinaryOps.h file in <a class="el" href="namespace_eigen.html">Eigen</a>. </p>

</div>
</div>
<a id="ad6112c67bd713407a1da5a46df61f0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6112c67bd713407a1da5a46df61f0ba">&#9670;&nbsp;</a></span>operator>() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using greater-than operator (&gt;). </p>
<p>The following table describes the return type of <code>m1</code> &gt; <code>m2</code>.</p>
<table class="doxtable">
<tr>
<th>LHS \ RHS </th><th>EM&lt;Expression&gt; </th><th>EM&lt;Variable&gt; </th><th>EM&lt;double&gt;  </th></tr>
<tr>
<td>EM&lt;Expression&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td></tr>
<tr>
<td>EM&lt;Variable&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td></tr>
<tr>
<td>EM&lt;double&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td>N/A </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="ac8f5b0df2a3fecea9d23b24475c7fdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f5b0df2a3fecea9d23b24475c7fdca">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad35508f64c9d760287426d5958a94454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35508f64c9d760287426d5958a94454">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &gt;= typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, typename <a class="el" href="structdrake_1_1symbolic_1_1detail_1_1_relational_op_traits.html">detail::RelationalOpTraits</a>&lt;DerivedA, DerivedB&gt;::ReturnType&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using greater-than-or-equal operator (&gt;=). </p>

</div>
</div>
<a id="a04b826253c8e91199f4b45732ba4bf2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b826253c8e91199f4b45732ba4bf2b">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename Derived::Scalar() &gt;= ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using greater-than-or-equal operator (&gt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a &gt;= v)</code> has a symbolic formula <code>a(i, j) &gt;= v</code>. </p>

</div>
</div>
<a id="a405bf4ecc90c0dc8aa47223422d4ed52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405bf4ecc90c0dc8aa47223422d4ed52">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(ScalarType() &gt;= typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="namespace_eigen.html">Eigen</a> array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than-or-equal operator (&lt;=) instead of greater-than-or-equal operator (&gt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v &gt;= a)</code> has a symbolic formula <code>a(i, j) &lt;= v</code>.</p>
<p>Note that given <code>v &gt;= a</code>, this methods returns the result of <code>a &lt;= v</code>. First of all, this formulation is mathematically equivalent to the original formulation. We implement this method in this way to be consistent with <a class="el" href="namespace_eigen.html">Eigen</a>'s semantics. See the definition of <code>EIGEN_MAKE_CWISE_COMP_R_OP</code> in ArrayCwiseBinaryOps.h file in <a class="el" href="namespace_eigen.html">Eigen</a>. </p>

</div>
</div>
<a id="a56de2d077a42329f2c508a71e7e52ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56de2d077a42329f2c508a71e7e52ca9">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &gt;= typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using greater-than-or-equal operator (&gt;=). </p>
<p>The following table describes the return type of <code>m1</code> &gt;= <code>m2</code>.</p>
<table class="doxtable">
<tr>
<th>LHS \ RHS </th><th>EM&lt;Expression&gt; </th><th>EM&lt;Variable&gt; </th><th>EM&lt;double&gt;  </th></tr>
<tr>
<td>EM&lt;Expression&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td></tr>
<tr>
<td>EM&lt;Variable&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td></tr>
<tr>
<td>EM&lt;double&gt; </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">Formula</a> </td><td>N/A </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="afd02ba28125fcb30762312b0361e0790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd02ba28125fcb30762312b0361e0790">&#9670;&nbsp;</a></span>operator||() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b37f14ce7a17532970ad74b4182267d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b37f14ce7a17532970ad74b4182267d">&#9670;&nbsp;</a></span>operator||() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af301dd903e8b79a8584fa3ed0fb3708a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af301dd903e8b79a8584fa3ed0fb3708a">&#9670;&nbsp;</a></span>operator||() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09c7a845583db868b2d30a66c2616397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c7a845583db868b2d30a66c2616397">&#9670;&nbsp;</a></span>operator||() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8fafcceed185abdb6726cbaf4ff3be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fafcceed185abdb6726cbaf4ff3be3">&#9670;&nbsp;</a></span>PopulateRandomVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> PopulateRandomVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#ab262f8e82f09d8df2990d0dc5869c34f">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>random_generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the environment <code>env</code> by sampling values for the unassigned random variables in <code>variables</code> using <code>random_generator</code>. </p>

</div>
</div>
<a id="a0a0f6e1f6ff658b6a0b46ce0f048a5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0f6e1f6ff658b6a0b46ce0f048a5f3">&#9670;&nbsp;</a></span>positive_semidefinite() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula constraining <code>m</code> to be a positive-semidefinite matrix. </p>
<p>By definition, a symmetric matrix <code>m</code> is positive-semidefinte if xᵀ m x ≥ 0 for all vector x ∈ ℝⁿ.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>m</code> is not symmetric.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method checks if <code>m</code> is symmetric by calling <code><a class="el" href="namespacedrake_1_1math.html#a84760cbea23b50efdbe9a85f3967f098" title="Determines if a matrix is symmetric. ">math::IsSymmetric</a></code> function which can be costly. If you want to avoid it, please consider using <code>positive_semidefinite(m.triangularView&lt;Eigen::Lower&gt;())</code> or <code>positive_semidefinite(m.triangularView&lt;Eigen::Upper&gt;())</code> instead of <code>positive_semidefinite(m)</code>. </dd></dl>

</div>
</div>
<a id="ab7294a6a837aa476fe079c9d5596f373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7294a6a837aa476fe079c9d5596f373">&#9670;&nbsp;</a></span>positive_semidefinite() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::UpLoType&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a symbolic positive-semidefinite formula from <code>m</code>. </p>
<p>If <code>mode</code> is Eigen::Lower, it's using the lower-triangular part of <code>m</code> to construct a positive-semidefinite formula. If <code>mode</code> is Eigen::Upper, the upper-triangular part of <code>m</code> is used. It throws std::runtime_error if <code>has</code> other values. See the following code snippet.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;Expression, 2, 2&gt; m;</div><div class="line">m &lt;&lt; 1.0, 2.0,</div><div class="line">     3.0, 4.0;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Formula psd_l{<a class="code" href="namespacedrake_1_1symbolic.html#a0a0f6e1f6ff658b6a0b46ce0f048a5f3">positive_semidefinite</a>(m, Eigen::Lower)};</div><div class="line"><span class="comment">// psd_l includes [1.0 3.0]</span></div><div class="line"><span class="comment">//                [3.0 4.0].</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Formula psd_u{<a class="code" href="namespacedrake_1_1symbolic.html#a0a0f6e1f6ff658b6a0b46ce0f048a5f3">positive_semidefinite</a>(m, Eigen::Upper)};</div><div class="line"><span class="comment">// psd_u includes [1.0 2.0]</span></div><div class="line"><span class="comment">//                [2.0 4.0].</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a589bce42bdf814187045157a262e8953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589bce42bdf814187045157a262e8953">&#9670;&nbsp;</a></span>positive_semidefinite() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::TriangularView&lt; Derived, Eigen::Lower &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a symbolic positive-semidefinite formula from a lower triangular-view <code>l</code>. </p>
<p>See the following code snippet.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;Expression, 2, 2&gt; m;</div><div class="line">m &lt;&lt; 1.0, 2.0,</div><div class="line">     3.0, 4.0;</div><div class="line"></div><div class="line">Formula psd{<a class="code" href="namespacedrake_1_1symbolic.html#a0a0f6e1f6ff658b6a0b46ce0f048a5f3">positive_semidefinite</a>(m.triangularView&lt;Eigen::Lower&gt;())};</div><div class="line"><span class="comment">// psd includes [1.0 3.0]</span></div><div class="line"><span class="comment">//              [3.0 4.0].</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a5f8fb394a3d4252968bd22740945fed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8fb394a3d4252968bd22740945fed2">&#9670;&nbsp;</a></span>positive_semidefinite() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::MatrixXpr&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::symbolic::positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::TriangularView&lt; Derived, Eigen::Upper &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a symbolic positive-semidefinite formula from an upper triangular-view <code>u</code>. </p>
<p>See the following code snippet.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;Expression, 2, 2&gt; m;</div><div class="line">m &lt;&lt; 1.0, 2.0,</div><div class="line">     3.0, 4.0;</div><div class="line"></div><div class="line">Formula psd{<a class="code" href="namespacedrake_1_1symbolic.html#a0a0f6e1f6ff658b6a0b46ce0f048a5f3">positive_semidefinite</a>(m.triangularView&lt;Eigen::Upper&gt;())};</div><div class="line"><span class="comment">// psd includes [1.0 2.0]</span></div><div class="line"><span class="comment">//              [2.0 4.0].</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a1689f9845acfae35173fede790537df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1689f9845acfae35173fede790537df9">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rational function <code>f</code> raised to <code>n</code>. </p>
<p>If n is positive, (f/g)ⁿ = fⁿ / gⁿ; If n is negative, (f/g)ⁿ = g⁻ⁿ / f⁻ⁿ; (f/g)⁰ = 1 / 1. </p>

</div>
</div>
<a id="ad9fccbdfb814f10727e3b23ef0b6a20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fccbdfb814f10727e3b23ef0b6a20f">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>m1</code> raised to <code>p</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>p</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa57efef61100945c693ecb05dadf6dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57efef61100945c693ecb05dadf6dcf">&#9670;&nbsp;</a></span>pow() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2996d1aeb389e57074bef357b2db3585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2996d1aeb389e57074bef357b2db3585">&#9670;&nbsp;</a></span>pow() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns polynomial <code>rasied</code> to <code>n</code>. </p>

</div>
</div>
<a id="af3cd13d5472028f31c2e70f1b0e08b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cd13d5472028f31c2e70f1b0e08b5d">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5f5c9f26be9d9eef2784073ac8075e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f5c9f26be9d9eef2784073ac8075e0">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79e1b5d9aadd56991632f40804d4bf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e1b5d9aadd56991632f40804d4bf93">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78354ef5dda9c52bbc103d57712c303e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78354ef5dda9c52bbc103d57712c303e">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a734f5b457c5a0b898ab8b6f247f0ce76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734f5b457c5a0b898ab8b6f247f0ce76">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae96194d93ad39bcb2b7ed22891f44ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96194d93ad39bcb2b7ed22891f44ec7">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd176811046c1f4fab6d56404b270d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd176811046c1f4fab6d56404b270d66">&#9670;&nbsp;</a></span>TaylorExpand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> TaylorExpand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Taylor series expansion of <code>f</code> around <code>a</code> of order <code>order</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Symbolic expression to approximate using Taylor series expansion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Symbolic environment which specifies the point of approximation. If a partial environment is provided, the unspecified variables are treated as symbolic variables (e.g. decision variable). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Positive integer which specifies the maximum order of the resulting polynomial approximating <code>f</code> around <code>a</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0351346c8644e9944ce2a346873dfe6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0351346c8644e9944ce2a346873dfe6c">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::symbolic::TEST_F </td>
          <td>(</td>
          <td class="paramtype">SymbolicRationalFunctionMatrixTest&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RationalFunctionOpRationalFunction&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a668c2faf856f1e945a2b9785ea73b24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668c2faf856f1e945a2b9785ea73b24b">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::symbolic::TEST_F </td>
          <td>(</td>
          <td class="paramtype">SymbolicRationalFunctionMatrixTest&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RationalFunctionOpPolynomial&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8aaa30d652422efc1f597feec32b9feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aaa30d652422efc1f597feec32b9feb">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::symbolic::TEST_F </td>
          <td>(</td>
          <td class="paramtype">SymbolicRationalFunctionMatrixTest&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RationalFunctionOpDouble&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d97da134da81a02ca4a380d9108b5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d97da134da81a02ca4a380d9108b5fe">&#9670;&nbsp;</a></span>to_abs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a>&gt; drake::symbolic::to_abs </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionAbs&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html" title="Symbolic expression representing absolute value function. ">ExpressionAbs</a></code>. </dd></dl>

</div>
</div>
<a id="adcfc573d7a3e1d1e870418bfcbdb7c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfc573d7a3e1d1e870418bfcbdb7c19">&#9670;&nbsp;</a></span>to_abs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a>&gt; drake::symbolic::to_abs </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7876e58c70a1eb0d8f6ecade9e2a3a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7876e58c70a1eb0d8f6ecade9e2a3a93">&#9670;&nbsp;</a></span>to_abs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a> &gt; to_abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAbs&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html" title="Symbolic expression representing absolute value function. ">ExpressionAbs</a></code>. </dd></dl>

</div>
</div>
<a id="a4c27aea1e7e7c3c076f5ab2a4127c0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c27aea1e7e7c3c076f5ab2a4127c0f7">&#9670;&nbsp;</a></span>to_acos() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a>&gt; drake::symbolic::to_acos </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionAcos&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html" title="Symbolic expression representing arccosine function. ">ExpressionAcos</a></code>. </dd></dl>

</div>
</div>
<a id="ab16e9de9e6e03bbcff2e0759e89b89de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16e9de9e6e03bbcff2e0759e89b89de">&#9670;&nbsp;</a></span>to_acos() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a>&gt; drake::symbolic::to_acos </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41ff35111676293b0cec78a988ac7884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ff35111676293b0cec78a988ac7884">&#9670;&nbsp;</a></span>to_acos() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a> &gt; to_acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAcos&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html" title="Symbolic expression representing arccosine function. ">ExpressionAcos</a></code>. </dd></dl>

</div>
</div>
<a id="a2798d06705e060ab4913f5b9e45b0fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2798d06705e060ab4913f5b9e45b0fb7">&#9670;&nbsp;</a></span>to_addition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a>&gt; drake::symbolic::to_addition </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionAdd&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html" title="Symbolic expression representing an addition which is a sum of products. ">ExpressionAdd</a></code>. </dd></dl>

</div>
</div>
<a id="acb177db59b2642563f112cf82082e75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb177db59b2642563f112cf82082e75f">&#9670;&nbsp;</a></span>to_addition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a>&gt; drake::symbolic::to_addition </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89454de321806c07cefbe531599ea0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89454de321806c07cefbe531599ea0a1">&#9670;&nbsp;</a></span>to_addition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a> &gt; to_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAdd&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html" title="Symbolic expression representing an addition which is a sum of products. ">ExpressionAdd</a></code>. </dd></dl>

</div>
</div>
<a id="acff5917c939267b83024ec0135b0ec90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff5917c939267b83024ec0135b0ec90">&#9670;&nbsp;</a></span>to_asin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a>&gt; drake::symbolic::to_asin </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionAsin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html" title="Symbolic expression representing arcsine function. ">ExpressionAsin</a></code>. </dd></dl>

</div>
</div>
<a id="a6023473c2a8b73c15d42b647733e2cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6023473c2a8b73c15d42b647733e2cdc">&#9670;&nbsp;</a></span>to_asin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a>&gt; drake::symbolic::to_asin </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05d2f2b8f1fc3014c246798dce76150c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d2f2b8f1fc3014c246798dce76150c">&#9670;&nbsp;</a></span>to_asin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a> &gt; to_asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAsin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html" title="Symbolic expression representing arcsine function. ">ExpressionAsin</a></code>. </dd></dl>

</div>
</div>
<a id="a940feca9814d759f8f1bab0d82b6d08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940feca9814d759f8f1bab0d82b6d08b">&#9670;&nbsp;</a></span>to_atan() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a>&gt; drake::symbolic::to_atan </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionAtan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html" title="Symbolic expression representing arctangent function. ">ExpressionAtan</a></code>. </dd></dl>

</div>
</div>
<a id="a435b708a6dabaf72549f32d637302929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435b708a6dabaf72549f32d637302929">&#9670;&nbsp;</a></span>to_atan() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a>&gt; drake::symbolic::to_atan </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a191a6ac5b31e0ae64cb40f3b99426b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191a6ac5b31e0ae64cb40f3b99426b47">&#9670;&nbsp;</a></span>to_atan() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a> &gt; to_atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAtan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html" title="Symbolic expression representing arctangent function. ">ExpressionAtan</a></code>. </dd></dl>

</div>
</div>
<a id="a336b4874629043250d9eee8715d7e3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336b4874629043250d9eee8715d7e3f1">&#9670;&nbsp;</a></span>to_atan2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a>&gt; drake::symbolic::to_atan2 </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionAtan2&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html" title="Symbolic expression representing atan2 function (arctangent function with two arguments). ">ExpressionAtan2</a></code>. </dd></dl>

</div>
</div>
<a id="a0ddc03d1da152b0250cb7b73b1d5becf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddc03d1da152b0250cb7b73b1d5becf">&#9670;&nbsp;</a></span>to_atan2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a>&gt; drake::symbolic::to_atan2 </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acea842a56331d58894d509f927e243d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea842a56331d58894d509f927e243d5">&#9670;&nbsp;</a></span>to_atan2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a> &gt; to_atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAtan2&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html" title="Symbolic expression representing atan2 function (arctangent function with two arguments). ">ExpressionAtan2</a></code>. </dd></dl>

</div>
</div>
<a id="ae9dae9d0e38fb883bf2bebd3a83df11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9dae9d0e38fb883bf2bebd3a83df11a">&#9670;&nbsp;</a></span>to_binary() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a>&gt; drake::symbolic::to_binary </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const BinaryExpressionCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html" title="Represents the base class for binary expressions. ">BinaryExpressionCell</a></code>. </dd></dl>

</div>
</div>
<a id="af704f97cf07efcfc490be6d40484f56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af704f97cf07efcfc490be6d40484f56c">&#9670;&nbsp;</a></span>to_binary() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a>&gt; drake::symbolic::to_binary </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16fe17fda2fdf667c37d3fed600bee77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16fe17fda2fdf667c37d3fed600bee77">&#9670;&nbsp;</a></span>to_binary() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a> &gt; to_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const BinaryExpressionCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html" title="Represents the base class for binary expressions. ">BinaryExpressionCell</a></code>. </dd></dl>

</div>
</div>
<a id="a3a222e3cd56d97d9f921089338a2a1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a222e3cd56d97d9f921089338a2a1f8">&#9670;&nbsp;</a></span>to_ceil() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a>&gt; drake::symbolic::to_ceil </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionCeiling&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html" title="Symbolic expression representing ceil function. ">ExpressionCeiling</a></code>. </dd></dl>

</div>
</div>
<a id="af1c9cfb4bd08050990d594029bdf3c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c9cfb4bd08050990d594029bdf3c96">&#9670;&nbsp;</a></span>to_ceil() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a>&gt; drake::symbolic::to_ceil </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98a8cd6da59eab6b58591a4e26262a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a8cd6da59eab6b58591a4e26262a96">&#9670;&nbsp;</a></span>to_ceil() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a> &gt; to_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionCeiling&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html" title="Symbolic expression representing ceil function. ">ExpressionCeiling</a></code>. </dd></dl>

</div>
</div>
<a id="a180aa6c7637801b158099a87a59a4185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180aa6c7637801b158099a87a59a4185">&#9670;&nbsp;</a></span>to_conjunction() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a>&gt; drake::symbolic::to_conjunction </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaAnd&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_conjunction(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a480c4ded252898418ac3d288a782927c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480c4ded252898418ac3d288a782927c">&#9670;&nbsp;</a></span>to_conjunction() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a>&gt; drake::symbolic::to_conjunction </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad26b500eabee827ec26352fc86458fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26b500eabee827ec26352fc86458fdb">&#9670;&nbsp;</a></span>to_conjunction() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a> &gt; to_conjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaAnd&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_conjunction(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a347598837c2c976b8b183712a4e7c9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347598837c2c976b8b183712a4e7c9b8">&#9670;&nbsp;</a></span>to_constant() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a>&gt; drake::symbolic::to_constant </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionConstant&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html" title="Symbolic expression representing a constant. ">ExpressionConstant</a></code>. </dd></dl>

</div>
</div>
<a id="ab173345396120a34b973d67e09a4e118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab173345396120a34b973d67e09a4e118">&#9670;&nbsp;</a></span>to_constant() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a>&gt; drake::symbolic::to_constant </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff64b176576a46d93b35472d756a41ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff64b176576a46d93b35472d756a41ed">&#9670;&nbsp;</a></span>to_constant() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a> &gt; to_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionConstant&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html" title="Symbolic expression representing a constant. ">ExpressionConstant</a></code>. </dd></dl>

</div>
</div>
<a id="afb71bf253046e78b2a7d5b4a671faaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb71bf253046e78b2a7d5b4a671faaff">&#9670;&nbsp;</a></span>to_cos() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a>&gt; drake::symbolic::to_cos </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionCos&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html" title="Symbolic expression representing cosine function. ">ExpressionCos</a></code>. </dd></dl>

</div>
</div>
<a id="a8d18323eef861cb26667b20481df01b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d18323eef861cb26667b20481df01b8">&#9670;&nbsp;</a></span>to_cos() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a>&gt; drake::symbolic::to_cos </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acafbfc4b20f88b307115ddaf1063df50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafbfc4b20f88b307115ddaf1063df50">&#9670;&nbsp;</a></span>to_cos() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a> &gt; to_cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionCos&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html" title="Symbolic expression representing cosine function. ">ExpressionCos</a></code>. </dd></dl>

</div>
</div>
<a id="a7f5844998206a3fa1c5a0e12658bea21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5844998206a3fa1c5a0e12658bea21">&#9670;&nbsp;</a></span>to_cosh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a>&gt; drake::symbolic::to_cosh </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionCosh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html" title="Symbolic expression representing hyperbolic cosine function. ">ExpressionCosh</a></code>. </dd></dl>

</div>
</div>
<a id="aa995f16b51f89afbaa97860d042f5f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa995f16b51f89afbaa97860d042f5f5d">&#9670;&nbsp;</a></span>to_cosh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a>&gt; drake::symbolic::to_cosh </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8c6a4777295d48f381f234b2eb65e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c6a4777295d48f381f234b2eb65e67">&#9670;&nbsp;</a></span>to_cosh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a> &gt; to_cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionCosh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html" title="Symbolic expression representing hyperbolic cosine function. ">ExpressionCosh</a></code>. </dd></dl>

</div>
</div>
<a id="a0b0758b788047cb3d6b4737c6d54cee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0758b788047cb3d6b4737c6d54cee2">&#9670;&nbsp;</a></span>to_disjunction() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a>&gt; drake::symbolic::to_disjunction </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaOr&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_disjunction(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="adc481eb863111b45a30b98728950e819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc481eb863111b45a30b98728950e819">&#9670;&nbsp;</a></span>to_disjunction() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a>&gt; drake::symbolic::to_disjunction </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfc35666075f70ae7805e4569477ceee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc35666075f70ae7805e4569477ceee">&#9670;&nbsp;</a></span>to_disjunction() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a> &gt; to_disjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaOr&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_disjunction(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a07eec84289aec7d32403e1573845e7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07eec84289aec7d32403e1573845e7c1">&#9670;&nbsp;</a></span>to_division() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a>&gt; drake::symbolic::to_division </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionDiv&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html" title="Symbolic expression representing division. ">ExpressionDiv</a></code>. </dd></dl>

</div>
</div>
<a id="a12ccf3c04d940873a47e363ba0684bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ccf3c04d940873a47e363ba0684bee">&#9670;&nbsp;</a></span>to_division() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a>&gt; drake::symbolic::to_division </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a50ed0d408693195e39e107616adacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a50ed0d408693195e39e107616adacb">&#9670;&nbsp;</a></span>to_division() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a> &gt; to_division </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionDiv&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html" title="Symbolic expression representing division. ">ExpressionDiv</a></code>. </dd></dl>

</div>
</div>
<a id="a10a6204418091c1fbf26c9d2ad03389f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a6204418091c1fbf26c9d2ad03389f">&#9670;&nbsp;</a></span>to_equal_to() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a>&gt; drake::symbolic::to_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaEq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a8f8dc389d77c6c2a4a850d832d1b6d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8dc389d77c6c2a4a850d832d1b6d16">&#9670;&nbsp;</a></span>to_equal_to() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a>&gt; drake::symbolic::to_equal_to </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7e02a8c0d203f8dc0f6534f0216a6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e02a8c0d203f8dc0f6534f0216a6e9">&#9670;&nbsp;</a></span>to_equal_to() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a> &gt; to_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaEq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_equal_to(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a06990aa7d5a28abd53fe48a4afd1d410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06990aa7d5a28abd53fe48a4afd1d410">&#9670;&nbsp;</a></span>to_exp() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a> &gt; to_exp </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionExp&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html" title="Symbolic expression representing exponentiation using the base of natural logarithms. ">ExpressionExp</a></code>. </dd></dl>

</div>
</div>
<a id="ac54ee1bb70605fa6daf7b346ad4a5b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54ee1bb70605fa6daf7b346ad4a5b95">&#9670;&nbsp;</a></span>to_exp() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a>&gt; drake::symbolic::to_exp </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a918dcfa4e1c6bf30473602e582553fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918dcfa4e1c6bf30473602e582553fb7">&#9670;&nbsp;</a></span>to_exp() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a> &gt; to_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionExp&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html" title="Symbolic expression representing exponentiation using the base of natural logarithms. ">ExpressionExp</a></code>. </dd></dl>

</div>
</div>
<a id="a1ba2673fe37620dcc2a3b06ab7b72bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba2673fe37620dcc2a3b06ab7b72bec">&#9670;&nbsp;</a></span>to_false() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a>&gt; drake::symbolic::to_false </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaFalse&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_false(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a0ba13814fd3af0fb8b3bf9fef5937259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba13814fd3af0fb8b3bf9fef5937259">&#9670;&nbsp;</a></span>to_false() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a>&gt; drake::symbolic::to_false </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a603c9ef6720ddbfd15ac8fa558731f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603c9ef6720ddbfd15ac8fa558731f56">&#9670;&nbsp;</a></span>to_false() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a> &gt; to_false </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaFalse&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_false(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a126c7e1054532413b0bc816d8755c085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126c7e1054532413b0bc816d8755c085">&#9670;&nbsp;</a></span>to_floor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a>&gt; drake::symbolic::to_floor </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionFloor&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html" title="Symbolic expression representing floor function. ">ExpressionFloor</a></code>. </dd></dl>

</div>
</div>
<a id="ac3e895935101e75043c3468b034e1eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e895935101e75043c3468b034e1eff">&#9670;&nbsp;</a></span>to_floor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a>&gt; drake::symbolic::to_floor </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b1509e24662d4b4facbca5d8ad13eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1509e24662d4b4facbca5d8ad13eb4">&#9670;&nbsp;</a></span>to_floor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a> &gt; to_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionFloor&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html" title="Symbolic expression representing floor function. ">ExpressionFloor</a></code>. </dd></dl>

</div>
</div>
<a id="a7c587017789ff28f462e87ba0a44872d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c587017789ff28f462e87ba0a44872d">&#9670;&nbsp;</a></span>to_forall() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a>&gt; drake::symbolic::to_forall </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaForall&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_forall(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="ac55d2adc3de9351c9a833087eca08101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55d2adc3de9351c9a833087eca08101">&#9670;&nbsp;</a></span>to_forall() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a>&gt; drake::symbolic::to_forall </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aced8482cbe31d08f479d245b2cc96da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced8482cbe31d08f479d245b2cc96da3">&#9670;&nbsp;</a></span>to_forall() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a> &gt; to_forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaForall&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_forall(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a352fe19778d77b7095580950d8e298b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352fe19778d77b7095580950d8e298b4">&#9670;&nbsp;</a></span>to_greater_than() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a>&gt; drake::symbolic::to_greater_than </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaGt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_greater_than(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a7111e8d51d064671c73b02af632271ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7111e8d51d064671c73b02af632271ec">&#9670;&nbsp;</a></span>to_greater_than() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a>&gt; drake::symbolic::to_greater_than </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c4dbcc76c7f19ecd59beb4ce4a4c037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4dbcc76c7f19ecd59beb4ce4a4c037">&#9670;&nbsp;</a></span>to_greater_than() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a> &gt; to_greater_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaGt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_greater_than(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a7f8cbb802de92188843f8531d6b05827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8cbb802de92188843f8531d6b05827">&#9670;&nbsp;</a></span>to_greater_than_or_equal_to() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a>&gt; drake::symbolic::to_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaGeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_greater_than_or_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a554eea5921e8e14747886083f8b51657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554eea5921e8e14747886083f8b51657">&#9670;&nbsp;</a></span>to_greater_than_or_equal_to() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a>&gt; drake::symbolic::to_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ad707a3bf5f43859e1b81a6c69df4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad707a3bf5f43859e1b81a6c69df4d6">&#9670;&nbsp;</a></span>to_greater_than_or_equal_to() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a> &gt; to_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaGeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_greater_than_or_equal_to(f)</code> is true. </dd></dl>

</div>
</div>
<a id="ac17f0ee5f13da0796155fc00ba0421da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17f0ee5f13da0796155fc00ba0421da">&#9670;&nbsp;</a></span>to_if_then_else() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a>&gt; drake::symbolic::to_if_then_else </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionIfThenElse&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html" title="Symbolic expression representing if-then-else expression. ">ExpressionIfThenElse</a></code>. </dd></dl>

</div>
</div>
<a id="af09a2aae3694e048b16141585c8a1d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09a2aae3694e048b16141585c8a1d22">&#9670;&nbsp;</a></span>to_if_then_else() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a>&gt; drake::symbolic::to_if_then_else </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dba4e642a84aab82a5c0e643e477448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dba4e642a84aab82a5c0e643e477448">&#9670;&nbsp;</a></span>to_if_then_else() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a> &gt; to_if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionIfThenElse&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html" title="Symbolic expression representing if-then-else expression. ">ExpressionIfThenElse</a></code>. </dd></dl>

</div>
</div>
<a id="ad4f46f5ae1e9130eb9214a2ae0611f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f46f5ae1e9130eb9214a2ae0611f52">&#9670;&nbsp;</a></span>to_isnan() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a>&gt; drake::symbolic::to_isnan </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaIsnan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_isnan(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a36bde08c6491c195f6e1231beb4fdbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bde08c6491c195f6e1231beb4fdbea">&#9670;&nbsp;</a></span>to_isnan() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a>&gt; drake::symbolic::to_isnan </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6df47ce76878738dcd7bdc4a5ce45d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df47ce76878738dcd7bdc4a5ce45d4b">&#9670;&nbsp;</a></span>to_isnan() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a> &gt; to_isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaIsnan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_isnan(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a7488de67ca4d6bc69cec3bb0f67ae4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7488de67ca4d6bc69cec3bb0f67ae4c3">&#9670;&nbsp;</a></span>to_less_than() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a>&gt; drake::symbolic::to_less_than </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaLt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_less_than(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="aa4b35a020aceb955d3739bddfbed43c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b35a020aceb955d3739bddfbed43c4">&#9670;&nbsp;</a></span>to_less_than() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a>&gt; drake::symbolic::to_less_than </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a61f364890b2418f79f92eeeee19dafbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f364890b2418f79f92eeeee19dafbf">&#9670;&nbsp;</a></span>to_less_than() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a> &gt; to_less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaLt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_less_than(f)</code> is true. </dd></dl>

</div>
</div>
<a id="acfb39c33945b763922fe0fcacc6c369b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb39c33945b763922fe0fcacc6c369b">&#9670;&nbsp;</a></span>to_less_than_or_equal_to() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a>&gt; drake::symbolic::to_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaLeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_less_than_or_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a7cdc64fa82f240e639ede034efd51450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdc64fa82f240e639ede034efd51450">&#9670;&nbsp;</a></span>to_less_than_or_equal_to() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a>&gt; drake::symbolic::to_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa470f5843a651bcd63660f99f85be932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa470f5843a651bcd63660f99f85be932">&#9670;&nbsp;</a></span>to_less_than_or_equal_to() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a> &gt; to_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaLeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_less_than_or_equal_to(f)</code> is true. </dd></dl>

</div>
</div>
<a id="ab78113a7b60ef7b5032f8b0a4484803c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78113a7b60ef7b5032f8b0a4484803c">&#9670;&nbsp;</a></span>to_log() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a>&gt; drake::symbolic::to_log </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionLog&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html" title="Symbolic expression representing logarithms. ">ExpressionLog</a></code>. </dd></dl>

</div>
</div>
<a id="a97088377f3a8efb9b0af0432e91c8c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97088377f3a8efb9b0af0432e91c8c4e">&#9670;&nbsp;</a></span>to_log() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a>&gt; drake::symbolic::to_log </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0b7ab14755ddf1331e1e60ba2ea886d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b7ab14755ddf1331e1e60ba2ea886d">&#9670;&nbsp;</a></span>to_log() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a> &gt; to_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionLog&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html" title="Symbolic expression representing logarithms. ">ExpressionLog</a></code>. </dd></dl>

</div>
</div>
<a id="adec7c1e5c20559f7fc914c1ce6eb3626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec7c1e5c20559f7fc914c1ce6eb3626">&#9670;&nbsp;</a></span>to_max() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a>&gt; drake::symbolic::to_max </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionMax&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html" title="Symbolic expression representing max function. ">ExpressionMax</a></code>. </dd></dl>

</div>
</div>
<a id="a9bcf53ee7c5eaf28a73b9e3bc1373923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcf53ee7c5eaf28a73b9e3bc1373923">&#9670;&nbsp;</a></span>to_max() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a>&gt; drake::symbolic::to_max </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4903cdd87eacec1443bab30c08a3193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4903cdd87eacec1443bab30c08a3193">&#9670;&nbsp;</a></span>to_max() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a> &gt; to_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionMax&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html" title="Symbolic expression representing max function. ">ExpressionMax</a></code>. </dd></dl>

</div>
</div>
<a id="a382a9e36a860d150e7d739666a438296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382a9e36a860d150e7d739666a438296">&#9670;&nbsp;</a></span>to_min() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a>&gt; drake::symbolic::to_min </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionMin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html" title="Symbolic expression representing min function. ">ExpressionMin</a></code>. </dd></dl>

</div>
</div>
<a id="abac4083d7e0066180fccfbd10c85877d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac4083d7e0066180fccfbd10c85877d">&#9670;&nbsp;</a></span>to_min() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a>&gt; drake::symbolic::to_min </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38da0e44547bf21a3c380e710415f317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38da0e44547bf21a3c380e710415f317">&#9670;&nbsp;</a></span>to_min() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a> &gt; to_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionMin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html" title="Symbolic expression representing min function. ">ExpressionMin</a></code>. </dd></dl>

</div>
</div>
<a id="a747fde5cedfadb1c6b2ca0303577008b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747fde5cedfadb1c6b2ca0303577008b">&#9670;&nbsp;</a></span>to_multiplication() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a>&gt; drake::symbolic::to_multiplication </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionMul&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html" title="Symbolic expression representing a multiplication of powers. ">ExpressionMul</a></code>. </dd></dl>

</div>
</div>
<a id="ad7b4589fbe79f55fa7f4aebff04f35f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b4589fbe79f55fa7f4aebff04f35f3">&#9670;&nbsp;</a></span>to_multiplication() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a>&gt; drake::symbolic::to_multiplication </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a503da5eae8bea0353d398db76fae5fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503da5eae8bea0353d398db76fae5fab">&#9670;&nbsp;</a></span>to_multiplication() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a> &gt; to_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionMul&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html" title="Symbolic expression representing a multiplication of powers. ">ExpressionMul</a></code>. </dd></dl>

</div>
</div>
<a id="ad0f9249b5c150485c3c7cff61d5c0416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f9249b5c150485c3c7cff61d5c0416">&#9670;&nbsp;</a></span>to_nary() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a>&gt; drake::symbolic::to_nary </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const NaryFormulaCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_nary(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="acd265a5fdecda6e1085bd00f06924b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd265a5fdecda6e1085bd00f06924b27">&#9670;&nbsp;</a></span>to_nary() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a>&gt; drake::symbolic::to_nary </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbd977ff4775f2df5d9e46fa0992ee95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd977ff4775f2df5d9e46fa0992ee95">&#9670;&nbsp;</a></span>to_nary() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a> &gt; to_nary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const NaryFormulaCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_nary(f)</code> is true. </dd></dl>

</div>
</div>
<a id="aceef2c41a1ce6c5f7eed83c1d2df9381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceef2c41a1ce6c5f7eed83c1d2df9381">&#9670;&nbsp;</a></span>to_negation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a>&gt; drake::symbolic::to_negation </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaNot&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_negation(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a6510c4a0f3b3b797cb9d9305f198736c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6510c4a0f3b3b797cb9d9305f198736c">&#9670;&nbsp;</a></span>to_negation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a>&gt; drake::symbolic::to_negation </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa10206faf7f90564d9c0a61cc19e2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa10206faf7f90564d9c0a61cc19e2e8">&#9670;&nbsp;</a></span>to_negation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a> &gt; to_negation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaNot&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_negation(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a70e880ce60c41c7e65085dbf911edded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e880ce60c41c7e65085dbf911edded">&#9670;&nbsp;</a></span>to_not_equal_to() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a>&gt; drake::symbolic::to_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaNeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_not_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a753d76e300a5e80cf9266349ee2e9c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753d76e300a5e80cf9266349ee2e9c70">&#9670;&nbsp;</a></span>to_not_equal_to() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a>&gt; drake::symbolic::to_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abeebc47bad53d0b5dad9a132008babcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeebc47bad53d0b5dad9a132008babcf">&#9670;&nbsp;</a></span>to_not_equal_to() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a> &gt; to_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaNeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_not_equal_to(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a6854fa16fb68d99c3cbe16d2c9afc584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6854fa16fb68d99c3cbe16d2c9afc584">&#9670;&nbsp;</a></span>to_positive_semidefinite() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a>&gt; drake::symbolic::to_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaPositiveSemidefinite&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_positive_semidefinite(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a0858148ff6232150b209c71074031439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0858148ff6232150b209c71074031439">&#9670;&nbsp;</a></span>to_positive_semidefinite() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a>&gt; drake::symbolic::to_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18206d9f3709de478fe53f8a54cc83ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18206d9f3709de478fe53f8a54cc83ca">&#9670;&nbsp;</a></span>to_positive_semidefinite() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a> &gt; to_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaPositiveSemidefinite&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_positive_semidefinite(f)</code> is true. </dd></dl>

</div>
</div>
<a id="aa98e9d74c3d2118919747d30eaef6f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98e9d74c3d2118919747d30eaef6f66">&#9670;&nbsp;</a></span>to_pow() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a>&gt; drake::symbolic::to_pow </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionPow&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html" title="Symbolic expression representing power function. ">ExpressionPow</a></code>. </dd></dl>

</div>
</div>
<a id="ad4faacc0d3200d980c7100d7d9fcb0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4faacc0d3200d980c7100d7d9fcb0a5">&#9670;&nbsp;</a></span>to_pow() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a>&gt; drake::symbolic::to_pow </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90d6f38cabd766d108e510bee9b6a1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d6f38cabd766d108e510bee9b6a1ff">&#9670;&nbsp;</a></span>to_pow() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a> &gt; to_pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionPow&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html" title="Symbolic expression representing power function. ">ExpressionPow</a></code>. </dd></dl>

</div>
</div>
<a id="a259612bbd9405f24d4ac3b60d54575e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259612bbd9405f24d4ac3b60d54575e6">&#9670;&nbsp;</a></span>to_relational() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a>&gt; drake::symbolic::to_relational </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const RelationalFormulaCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_relational(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a06612e77d2c8f8c3e90b90dd00902b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06612e77d2c8f8c3e90b90dd00902b0e">&#9670;&nbsp;</a></span>to_relational() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a>&gt; drake::symbolic::to_relational </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5adb166222c87b263d32272950d7450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5adb166222c87b263d32272950d7450">&#9670;&nbsp;</a></span>to_relational() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a> &gt; to_relational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const RelationalFormulaCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_relational(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a15a1bb3f74a9b0753ddd11c85e5bbfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a1bb3f74a9b0753ddd11c85e5bbfc7">&#9670;&nbsp;</a></span>to_sin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a>&gt; drake::symbolic::to_sin </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionSin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html" title="Symbolic expression representing sine function. ">ExpressionSin</a></code>. </dd></dl>

</div>
</div>
<a id="abf94b8b2c744d25ae77e7109efec49e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf94b8b2c744d25ae77e7109efec49e5">&#9670;&nbsp;</a></span>to_sin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a>&gt; drake::symbolic::to_sin </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac48ec7d6f61858007ea12fe4bd2f198f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48ec7d6f61858007ea12fe4bd2f198f">&#9670;&nbsp;</a></span>to_sin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a> &gt; to_sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionSin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html" title="Symbolic expression representing sine function. ">ExpressionSin</a></code>. </dd></dl>

</div>
</div>
<a id="a11f76b800adf4e30797cfe1efe7f72fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f76b800adf4e30797cfe1efe7f72fc">&#9670;&nbsp;</a></span>to_sinh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a>&gt; drake::symbolic::to_sinh </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionSinh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html" title="Symbolic expression representing hyperbolic sine function. ">ExpressionSinh</a></code>. </dd></dl>

</div>
</div>
<a id="a73f16be7ba2d4ea771d99bbf40cabead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f16be7ba2d4ea771d99bbf40cabead">&#9670;&nbsp;</a></span>to_sinh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a>&gt; drake::symbolic::to_sinh </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04f56a3c541437d21a7763fef7e1125a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f56a3c541437d21a7763fef7e1125a">&#9670;&nbsp;</a></span>to_sinh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a> &gt; to_sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionSinh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html" title="Symbolic expression representing hyperbolic sine function. ">ExpressionSinh</a></code>. </dd></dl>

</div>
</div>
<a id="a202b74d640b89e6ccafff3737e50bdaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202b74d640b89e6ccafff3737e50bdaf">&#9670;&nbsp;</a></span>to_sqrt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a>&gt; drake::symbolic::to_sqrt </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionSqrt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html" title="Symbolic expression representing square-root. ">ExpressionSqrt</a></code>. </dd></dl>

</div>
</div>
<a id="a2919c3ee769b86ade12f697595677cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2919c3ee769b86ade12f697595677cd4">&#9670;&nbsp;</a></span>to_sqrt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a>&gt; drake::symbolic::to_sqrt </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcee80a4ff4020269290f1821bd52e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcee80a4ff4020269290f1821bd52e48">&#9670;&nbsp;</a></span>to_sqrt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a> &gt; to_sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionSqrt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html" title="Symbolic expression representing square-root. ">ExpressionSqrt</a></code>. </dd></dl>

</div>
</div>
<a id="a3d719a8fad661940daea51767953b78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d719a8fad661940daea51767953b78b">&#9670;&nbsp;</a></span>to_tan() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a>&gt; drake::symbolic::to_tan </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionTan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html" title="Symbolic expression representing tangent function. ">ExpressionTan</a></code>. </dd></dl>

</div>
</div>
<a id="a77e65298d73925240f33e082ce1a84ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e65298d73925240f33e082ce1a84ba">&#9670;&nbsp;</a></span>to_tan() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a>&gt; drake::symbolic::to_tan </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a276670b46c5a9290466973b296f624eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276670b46c5a9290466973b296f624eb">&#9670;&nbsp;</a></span>to_tan() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a> &gt; to_tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionTan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html" title="Symbolic expression representing tangent function. ">ExpressionTan</a></code>. </dd></dl>

</div>
</div>
<a id="a278a55d0595da33908569b0da0020ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278a55d0595da33908569b0da0020ff9">&#9670;&nbsp;</a></span>to_tanh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a>&gt; drake::symbolic::to_tanh </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionTanh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html" title="Symbolic expression representing hyperbolic tangent function. ">ExpressionTanh</a></code>. </dd></dl>

</div>
</div>
<a id="ab4d074a84a5b907d9986e66da619b3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d074a84a5b907d9986e66da619b3ad">&#9670;&nbsp;</a></span>to_tanh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a>&gt; drake::symbolic::to_tanh </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d059a53b8fc02e3fbdf7dc704b18bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d059a53b8fc02e3fbdf7dc704b18bd9">&#9670;&nbsp;</a></span>to_tanh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a> &gt; to_tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionTanh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html" title="Symbolic expression representing hyperbolic tangent function. ">ExpressionTanh</a></code>. </dd></dl>

</div>
</div>
<a id="a85772f75f073405ed82017151b4cb279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85772f75f073405ed82017151b4cb279">&#9670;&nbsp;</a></span>to_true() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a>&gt; drake::symbolic::to_true </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaTrue&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_true(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a9e042fdf66297be50652148b8f620a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e042fdf66297be50652148b8f620a6e">&#9670;&nbsp;</a></span>to_true() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a>&gt; drake::symbolic::to_true </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1c848a13ba1d151a8426c1f68eccd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c848a13ba1d151a8426c1f68eccd84">&#9670;&nbsp;</a></span>to_true() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a> &gt; to_true </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaTrue&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_true(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a88e7ca792871e4872f470d189cf39c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e7ca792871e4872f470d189cf39c72">&#9670;&nbsp;</a></span>to_unary() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a>&gt; drake::symbolic::to_unary </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const UnaryExpressionCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html" title="Represents the base class for unary expressions. ">UnaryExpressionCell</a></code>. </dd></dl>

</div>
</div>
<a id="ac85468c26b36fd6389631543b62860b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85468c26b36fd6389631543b62860b0">&#9670;&nbsp;</a></span>to_unary() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a>&gt; drake::symbolic::to_unary </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3563b6e32a254c6c408b178df6247bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3563b6e32a254c6c408b178df6247bbb">&#9670;&nbsp;</a></span>to_unary() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a> &gt; to_unary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const UnaryExpressionCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html" title="Represents the base class for unary expressions. ">UnaryExpressionCell</a></code>. </dd></dl>

</div>
</div>
<a id="a5af8c6bf55bff287cf9281196c8e684b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af8c6bf55bff287cf9281196c8e684b">&#9670;&nbsp;</a></span>to_uninterpreted_function() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a>&gt; drake::symbolic::to_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionUninterpretedFunction&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html" title="Symbolic expression representing an uninterpreted function. ">ExpressionUninterpretedFunction</a></code>. </dd></dl>

</div>
</div>
<a id="afe49b247802df966f88f7114263c1d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe49b247802df966f88f7114263c1d33">&#9670;&nbsp;</a></span>to_uninterpreted_function() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a>&gt; drake::symbolic::to_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92766f8f05c318ff662b7911e1e82551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92766f8f05c318ff662b7911e1e82551">&#9670;&nbsp;</a></span>to_uninterpreted_function() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a> &gt; to_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionUninterpretedFunction&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html" title="Symbolic expression representing an uninterpreted function. ">ExpressionUninterpretedFunction</a></code>. </dd></dl>

</div>
</div>
<a id="a3b78dde9ca32fe1ee12cc232a9a4e85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b78dde9ca32fe1ee12cc232a9a4e85c">&#9670;&nbsp;</a></span>to_variable() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a>&gt; drake::symbolic::to_variable </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaVar&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_variable(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a8c33306d129ac11e42cfcab65d442c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c33306d129ac11e42cfcab65d442c4e">&#9670;&nbsp;</a></span>to_variable() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a>&gt; drake::symbolic::to_variable </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4f8e0af875561b1be3924d5231a4fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f8e0af875561b1be3924d5231a4fc5">&#9670;&nbsp;</a></span>to_variable() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a> &gt; to_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaVar&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_variable(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a404e60e7e4eb9ac124318f5e272a6e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404e60e7e4eb9ac124318f5e272a6e89">&#9670;&nbsp;</a></span>to_variable() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a>&gt; drake::symbolic::to_variable </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;const ExpressionVar&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html" title="Symbolic expression representing a variable. ">ExpressionVar</a></code>. </dd></dl>

</div>
</div>
<a id="a12ed8ef83d2c0ee2ea7b86b31b6d4d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ed8ef83d2c0ee2ea7b86b31b6d4d6c">&#9670;&nbsp;</a></span>to_variable() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a>&gt; drake::symbolic::to_variable </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abedfc5e119e32b8efce785e2f7988589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abedfc5e119e32b8efce785e2f7988589">&#9670;&nbsp;</a></span>to_variable() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a> &gt; to_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionVar&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html" title="Symbolic expression representing a variable. ">ExpressionVar</a></code>. </dd></dl>

</div>
</div>
<a id="a11eb904ad30c23a3a54c95c38c2f294c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11eb904ad30c23a3a54c95c38c2f294c">&#9670;&nbsp;</a></span>uninterpreted_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an uninterpreted-function expression with <code>name</code> and <code>arguments</code>. </p>
<p>An uninterpreted function is an opaque function that has no other property than its name and a list of its arguments. This is useful to applications where it is good enough to provide abstract information of a function without exposing full details. Declaring sparsity of a system is a typical example. </p>

</div>
</div>
<a id="ab58092344918003fc7e186b1c57bbc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58092344918003fc7e186b1c57bbc7f">&#9670;&nbsp;</a></span>VisitExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#aa06fbebac1e1ffc23617b782f072d79b">Result</a> drake::symbolic::VisitExpression </td>
          <td>(</td>
          <td class="paramtype">Visitor *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls visitor object <code>v</code> with a symbolic-expression <code>e</code>, and arguments <code>args</code>. </p>
<p>Visitor object is expected to implement the following methods which take <code>f</code> and <code>args:</code> <code>VisitConstant</code>, <code>VisitVariable</code>, <code>VisitAddition</code>, <code>VisitMultiplication</code>, <code>VisitDivision</code>, <code>VisitLog</code>, <code>VisitAbs</code>, <code>VisitExp</code>, <code>VisitSqrt</code>, <code>VisitPow</code>, <code>VisitSin</code>, <code>VisitCos</code>, <code>VisitTan</code>, <code>VisitAsin</code>, <code>VisitAtan</code>, <code>VisitAtan2</code>, <code>VisitSinh</code>, <code>VisitCosh</code>, <code>VisitTanh</code>, <code>VisitMin</code>, <code>VisitMax</code>, <code>VisitCeil</code>, <code>VisitFloor</code>, <code>VisitIfThenElse</code>, `VisitUninterpretedFunction.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during a visit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2748b5dc34bc17a6c6e98ac1d0cc1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2748b5dc34bc17a6c6e98ac1d0cc1ad">&#9670;&nbsp;</a></span>VisitFormula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#aa06fbebac1e1ffc23617b782f072d79b">Result</a> drake::symbolic::VisitFormula </td>
          <td>(</td>
          <td class="paramtype">Visitor *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls visitor object <code>v</code> with a symbolic formula <code>f</code>, and arguments <code>args</code>. </p>
<p>Visitor object is expected to implement the following methods which take <code>f</code> and <code>args:</code> <code>VisitFalse</code>, <code>VisitTrue</code>, <code>VisitVariable</code>, <code>VisitEqualTo</code>, VisitNotEqualTo, VisitGreaterThan, <code>VisitGreaterThanOrEqualTo</code>, <code>VisitLessThan</code>, <code>VisitLessThanOrEqualTo</code>, <code>VisitConjunction</code>, <code>VisitDisjunction</code>, <code>VisitNegation</code>, <code>VisitForall</code>, <code>VisitIsnan</code>, <code>VisitPositiveSemidefinite</code>.</p>
<p>Check the implementation of <code>NegationNormalFormConverter</code> class in <a class="el" href="symbolic__formula__visitor__test_8cc.html">drake/common/test/symbolic_formula_visitor_test.cc</a> file to find an example. </p>

</div>
</div>
<a id="a0a61c45c20176e91159639186b26e35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a61c45c20176e91159639186b26e35e">&#9670;&nbsp;</a></span>VisitPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#aa06fbebac1e1ffc23617b782f072d79b">Result</a> drake::symbolic::VisitPolynomial </td>
          <td>(</td>
          <td class="paramtype">Visitor *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls visitor object <code>v</code> with a polynomial symbolic-expression <code>e</code>, and arguments <code>args</code>. </p>
<p>Visitor object is expected to implement the following methods which take <code>f</code> and <code>args:</code> <code>VisitConstant</code>, <code>VisitVariable</code>, <code>VisitAddition</code>, <code>VisitMultiplication</code>, <code>VisitDivision</code>, <code>VisitPow</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during a visit.</td></tr>
  </table>
  </dd>
</dl>
<p>See the implementation of <code>DegreeVisitor</code> class and <code>Degree</code> function in <a class="el" href="symbolic__monomial_8cc.html">drake/common/symbolic_monomial.cc</a> as an example usage.</p>
<dl class="section pre"><dt>Precondition</dt><dd>e.is_polynomial() is true. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1symbolic.html">symbolic</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
