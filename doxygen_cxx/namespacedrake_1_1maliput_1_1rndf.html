<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::maliput::rndf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacedrake_1_1maliput_1_1rndf.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">drake::maliput::rndf Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake_1_1maliput_1_1rndf_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1maliput_1_1rndf_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_arc_length_parameterized_spline.html">ArcLengthParameterizedSpline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An extension for ignition::math::Splines that reparameterizes them by path length.  <a href="classdrake_1_1maliput_1_1rndf_1_1_arc_length_parameterized_spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_branch_point.html">BranchPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classdrake_1_1maliput_1_1api_1_1_branch_point.html" title="A BranchPoint is a node in the network of a RoadGeometry at which Lanes connect to one another...">api::BranchPoint</a> for RNDF.  <a href="classdrake_1_1maliput_1_1rndf_1_1_branch_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_builder.html">Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to ease the construction of a <a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_road_geometry.html" title="An api::RoadGeometry implementation for RNDF specification. ">RoadGeometry</a> from <a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_connection.html" title="A container that holds the information needed by a Builder to construct one or more Lane objects...">Connection</a> and <a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_directed_waypoint.html" title="A container that holds the information needed by a Builder to construct a Lane from a sequence of ign...">DirectedWaypoint</a> objects.  <a href="classdrake_1_1maliput_1_1rndf_1_1_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_connection.html">Connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that holds the information needed by a <a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_builder.html" title="A class to ease the construction of a RoadGeometry from Connection and DirectedWaypoint objects...">Builder</a> to construct one or more <a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_lane.html" title="Base class for the RNDF implementation of api::Lane. ">Lane</a> objects.  <a href="classdrake_1_1maliput_1_1rndf_1_1_connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_directed_waypoint.html">DirectedWaypoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that holds the information needed by a <a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_builder.html" title="A class to ease the construction of a RoadGeometry from Connection and DirectedWaypoint objects...">Builder</a> to construct a <a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_lane.html" title="Base class for the RNDF implementation of api::Lane. ">Lane</a> from a sequence of ignition::rndf::Waypoint objects.  <a href="classdrake_1_1maliput_1_1rndf_1_1_directed_waypoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_inverse_function_interpolator.html">InverseFunctionInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear interpolator for arbitrary inverse functions.  <a href="classdrake_1_1maliput_1_1rndf_1_1_inverse_function_interpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_junction.html">Junction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classdrake_1_1maliput_1_1api_1_1_junction.html" title="A Junction is a closed set of Segments which have physically coplanar road surfaces, in the sense that RoadPositions with the same h value (height above surface) in the domains of two Segments map to the same GeoPosition. ">api::Junction</a> implementation for RNDF.  <a href="classdrake_1_1maliput_1_1rndf_1_1_junction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_lane.html">Lane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the RNDF implementation of <a class="el" href="classdrake_1_1maliput_1_1api_1_1_lane.html" title="A Lane represents a lane of travel in a road network. ">api::Lane</a>.  <a href="classdrake_1_1maliput_1_1rndf_1_1_lane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_lane_end_set.html">LaneEndSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_lane_end_set.html" title="An implementation of LaneEndSet for RNDF. ">LaneEndSet</a> for RNDF.  <a href="classdrake_1_1maliput_1_1rndf_1_1_lane_end_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1maliput_1_1rndf_1_1_road_characteristics.html">RoadCharacteristics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds common <a class="el" href="classdrake_1_1maliput_1_1api_1_1_road_geometry.html" title="Abstract API for the geometry of a road network, including both the network topology and the geometry...">api::RoadGeometry</a> characteristics needed to construct one.  <a href="structdrake_1_1maliput_1_1rndf_1_1_road_characteristics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_road_geometry.html">RoadGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classdrake_1_1maliput_1_1api_1_1_road_geometry.html" title="Abstract API for the geometry of a road network, including both the network topology and the geometry...">api::RoadGeometry</a> implementation for RNDF specification.  <a href="classdrake_1_1maliput_1_1rndf_1_1_road_geometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_segment.html">Segment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classdrake_1_1maliput_1_1api_1_1_segment.html" title="A Segment represents a bundle of adjacent Lanes which share a continuously traversable road surface...">api::Segment</a> implementation for RNDF.  <a href="classdrake_1_1maliput_1_1rndf_1_1_segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_spline_lane.html">SplineLane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classdrake_1_1maliput_1_1rndf_1_1_lane.html" title="Base class for the RNDF implementation of api::Lane. ">drake::maliput::rndf::Lane</a> with a spline curve as its reference path.  <a href="classdrake_1_1maliput_1_1rndf_1_1_spline_lane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a40a891fdce1eb4bbf6867c7d2549367b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; const <a class="el" href="classdrake_1_1maliput_1_1api_1_1_road_geometry.html">api::RoadGeometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1maliput_1_1rndf.html#a40a891fdce1eb4bbf6867c7d2549367b">LoadFile</a> (const std::string &amp;filepath)</td></tr>
<tr class="memdesc:a40a891fdce1eb4bbf6867c7d2549367b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a given RNDF at <code>filepath</code> and builds an equivalent api::RoadGeometry.using default <a class="el" href="structdrake_1_1maliput_1_1rndf_1_1_road_characteristics.html" title="Holds common api::RoadGeometry characteristics needed to construct one. ">RoadCharacteristics</a>.  <a href="#a40a891fdce1eb4bbf6867c7d2549367b">More...</a><br /></td></tr>
<tr class="separator:a40a891fdce1eb4bbf6867c7d2549367b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fe0a552b43fe3913f7f7dff67d2248"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; const <a class="el" href="classdrake_1_1maliput_1_1api_1_1_road_geometry.html">api::RoadGeometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1maliput_1_1rndf.html#a04fe0a552b43fe3913f7f7dff67d2248">LoadFile</a> (const std::string &amp;filepath, const <a class="el" href="structdrake_1_1maliput_1_1rndf_1_1_road_characteristics.html">RoadCharacteristics</a> &amp;road_characteristics)</td></tr>
<tr class="memdesc:a04fe0a552b43fe3913f7f7dff67d2248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a given RNDF at <code>filepath</code> and builds an equivalent <a class="el" href="classdrake_1_1maliput_1_1api_1_1_road_geometry.html" title="Abstract API for the geometry of a road network, including both the network topology and the geometry...">api::RoadGeometry</a> with the given <code>road_characteristics</code>.  <a href="#a04fe0a552b43fe3913f7f7dff67d2248">More...</a><br /></td></tr>
<tr class="separator:a04fe0a552b43fe3913f7f7dff67d2248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121f8a5a98df5f91fd6af3d883378206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; ignition::math::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1maliput_1_1rndf.html#a121f8a5a98df5f91fd6af3d883378206">SplineToBezier</a> (const ignition::math::Vector3d &amp;p0, const ignition::math::Vector3d &amp;t0, const ignition::math::Vector3d &amp;p1, const ignition::math::Vector3d &amp;t1)</td></tr>
<tr class="memdesc:a121f8a5a98df5f91fd6af3d883378206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the equivalent set of points in cubic Bezier base from two pairs of points and tangents at the extents of a spline.  <a href="#a121f8a5a98df5f91fd6af3d883378206">More...</a><br /></td></tr>
<tr class="separator:a121f8a5a98df5f91fd6af3d883378206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863c3276fcbc47d8b085ac022c6960f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; ignition::math::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1maliput_1_1rndf.html#a863c3276fcbc47d8b085ac022c6960f4">BezierToSpline</a> (const ignition::math::Vector3d &amp;p0, const ignition::math::Vector3d &amp;p1, const ignition::math::Vector3d &amp;p2, const ignition::math::Vector3d &amp;p3)</td></tr>
<tr class="memdesc:a863c3276fcbc47d8b085ac022c6960f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the equivalent set of points in cubic spline base from four cubic Bezier control points.  <a href="#a863c3276fcbc47d8b085ac022c6960f4">More...</a><br /></td></tr>
<tr class="separator:a863c3276fcbc47d8b085ac022c6960f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca6af8180f01b79e877b3cdf24344d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; ignition::math::Vector3d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1maliput_1_1rndf.html#a7ca6af8180f01b79e877b3cdf24344d6">MakeBezierCurveMonotonic</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; ignition::math::Vector3d &gt; &amp;control_points, <a class="el" href="classdouble.html">double</a> scale)</td></tr>
<tr class="memdesc:a7ca6af8180f01b79e877b3cdf24344d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a conditionally convex and monotonic Bezier curve given a vector of control points <code>control_points</code>.  <a href="#a7ca6af8180f01b79e877b3cdf24344d6">More...</a><br /></td></tr>
<tr class="separator:a7ca6af8180f01b79e877b3cdf24344d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a369824ad03ca072276c8441e28d30d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; ignition::math::Spline &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1maliput_1_1rndf.html#a8a369824ad03ca072276c8441e28d30d">CreatePChipBasedSpline</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; ignition::math::Vector3d &gt; &amp;positions)</td></tr>
<tr class="memdesc:a8a369824ad03ca072276c8441e28d30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ignition::math::Spline from a set of <code>positions</code>.  <a href="#a8a369824ad03ca072276c8441e28d30d">More...</a><br /></td></tr>
<tr class="separator:a8a369824ad03ca072276c8441e28d30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad80d76d1bf53794f563d2b8800173f68"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1maliput_1_1rndf.html#ad80d76d1bf53794f563d2b8800173f68">kFunctionPartitionTreeDegree</a> = 10</td></tr>
<tr class="separator:ad80d76d1bf53794f563d2b8800173f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3499b264b45b23eac0339699208905c4"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1maliput_1_1rndf.html#a3499b264b45b23eac0339699208905c4">kFunctionPartitionTreeMaxDepth</a> = 10</td></tr>
<tr class="separator:a3499b264b45b23eac0339699208905c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb4e2ddff0af85cc9b0e8c371a0a51f"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1maliput_1_1rndf.html#adeb4e2ddff0af85cc9b0e8c371a0a51f">kBezierMatrix</a> [16]</td></tr>
<tr class="separator:adeb4e2ddff0af85cc9b0e8c371a0a51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87072c1422aa6e55355d583b28c1a872"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1maliput_1_1rndf.html#a87072c1422aa6e55355d583b28c1a872">kHermiteMatrix</a> [16]</td></tr>
<tr class="separator:a87072c1422aa6e55355d583b28c1a872"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a863c3276fcbc47d8b085ac022c6960f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863c3276fcbc47d8b085ac022c6960f4">&#9670;&nbsp;</a></span>BezierToSpline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; ignition::math::Vector3d &gt; BezierToSpline </td>
          <td>(</td>
          <td class="paramtype">const ignition::math::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ignition::math::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ignition::math::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ignition::math::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the equivalent set of points in cubic spline base from four cubic Bezier control points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p0</td><td>A vector that describes the starting position of the curve. </td></tr>
    <tr><td class="paramname">p1</td><td>A vector that describes the first control point of the curve. </td></tr>
    <tr><td class="paramname">p2</td><td>A vector that describes the second control point of the curve. </td></tr>
    <tr><td class="paramname">p3</td><td>A vector that describes the last control point of the curve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing four spline control points. The points are returned in the following order:<ol type="1">
<li>index 0 &ndash;&gt; curve position at the beginning.</li>
<li>index 1 &ndash;&gt; curve tangent at the beginning.</li>
<li>index 2 &ndash;&gt; curve position at the ending.</li>
<li>index 3 &ndash;&gt; curve tangent at the ending. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a8a369824ad03ca072276c8441e28d30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a369824ad03ca072276c8441e28d30d">&#9670;&nbsp;</a></span>CreatePChipBasedSpline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; ignition::math::Spline &gt; CreatePChipBasedSpline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; ignition::math::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a ignition::math::Spline from a set of <code>positions</code>. </p>
<p>These positions are the control points where the curve must go through. The final curve is based from a PChip algorithm, which makes the interpolation safe in terms of piecewise convexity and monotonicity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positions</td><td>A vector of position where the spline should go through. It should have more than two points. In addition, two consecutive points that have a length of zero will throw an exception since it's not yet supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ignition's Spline containing as knots the positions vector and as tangent's the PChip's interpolated value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When positions' size is less than three. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>When two consecutive <code>positions'</code> items have a distance of zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40a891fdce1eb4bbf6867c7d2549367b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a891fdce1eb4bbf6867c7d2549367b">&#9670;&nbsp;</a></span>LoadFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; const <a class="el" href="classdrake_1_1maliput_1_1api_1_1_road_geometry.html">api::RoadGeometry</a> &gt; LoadFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a given RNDF at <code>filepath</code> and builds an equivalent api::RoadGeometry.using default <a class="el" href="structdrake_1_1maliput_1_1rndf_1_1_road_characteristics.html" title="Holds common api::RoadGeometry characteristics needed to construct one. ">RoadCharacteristics</a>. </p>
<p>This is an overloaded function provided for convenience. See <a class="el" href="namespacedrake_1_1maliput_1_1rndf.html#a04fe0a552b43fe3913f7f7dff67d2248" title="Loads a given RNDF at filepath and builds an equivalent api::RoadGeometry with the given road_charact...">LoadFile(const std::string&amp;, const RoadCharacteristics&amp;)</a>. </p>

</div>
</div>
<a id="a04fe0a552b43fe3913f7f7dff67d2248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04fe0a552b43fe3913f7f7dff67d2248">&#9670;&nbsp;</a></span>LoadFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; const <a class="el" href="classdrake_1_1maliput_1_1api_1_1_road_geometry.html">api::RoadGeometry</a> &gt; LoadFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1maliput_1_1rndf_1_1_road_characteristics.html">RoadCharacteristics</a> &amp;&#160;</td>
          <td class="paramname"><em>road_characteristics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a given RNDF at <code>filepath</code> and builds an equivalent <a class="el" href="classdrake_1_1maliput_1_1api_1_1_road_geometry.html" title="Abstract API for the geometry of a road network, including both the network topology and the geometry...">api::RoadGeometry</a> with the given <code>road_characteristics</code>. </p>
<p>RNDF waypoints are given in UTM (latitude / longitude) coordinates. In the resulting <a class="el" href="classdrake_1_1maliput_1_1api_1_1_road_geometry.html" title="Abstract API for the geometry of a road network, including both the network topology and the geometry...">api::RoadGeometry</a>, they are mapped to ENU (Cartesian) coordinates whose origin coincides with the location of waypoint '1.1.1'. Note that due to the planar nature of the underlying <a class="el" href="classdrake_1_1maliput_1_1api_1_1_road_geometry.html" title="Abstract API for the geometry of a road network, including both the network topology and the geometry...">api::RoadGeometry</a> implementation, the elevation coordinate will be forced to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>The RNDF path. </td></tr>
    <tr><td class="paramname">road_characteristics</td><td>The common geometrical aspects to comply with when building the <a class="el" href="classdrake_1_1maliput_1_1api_1_1_road_geometry.html" title="Abstract API for the geometry of a road network, including both the network topology and the geometry...">api::RoadGeometry</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The built <a class="el" href="classdrake_1_1maliput_1_1api_1_1_road_geometry.html" title="Abstract API for the geometry of a road network, including both the network topology and the geometry...">api::RoadGeometry</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the given file is not a valid RNDF. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>When the given RNDF doesn't have at least a single lane segment with one or more waypoints. RNDFs containing only zones are not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ca6af8180f01b79e877b3cdf24344d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca6af8180f01b79e877b3cdf24344d6">&#9670;&nbsp;</a></span>MakeBezierCurveMonotonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; ignition::math::Vector3d &gt; MakeBezierCurveMonotonic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; ignition::math::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>control_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a conditionally convex and monotonic Bezier curve given a vector of control points <code>control_points</code>. </p>
<p>First it computes the intersection of the lines represented by point and tangent at the beginning and at the end of the curve. From here we have a a first branch in the behavior, if there is no intersection, we assume that all these curves are 2-D curves over the z = 0.0 <a class="el" href="namespacedrake_1_1maliput_1_1api.html#a6b044f9ec2c231ee2a735c2ca5f14851">api::GeoPosition</a> frame. Then, we create two intermediate control points for them that will provide a S shape to match the curve. The change in convexity is set to be in the mid point of the extents of the curve. In case there is an intersection between the two lines, we find it and this will be the critical point. From this step, there are two types of geometries we can generate but for both, the control points at the extents remain the same. For those control points in between we use the following equations to compute them:</p>
<p><code>control_points</code>[1] = <code>control_points</code>[0] + (±1.0) * <code>scale</code> * (critical_point - control_points[0]) <code>control_points</code>[2] = <code>control_points</code>[3] + (∓1.0) * <code>scale</code> * (critical_point - control_points[3])</p>
<p>When the curve preserves convexity, <code>scale</code> is multiplied by (+1.0) in both cases. However, when it is not, opposite signs are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control_points</td><td>A vector containing four Bezier control points. The first and last points are the extent points of the Bezier curve and the other two are the tangent controlling waypoints. </td></tr>
    <tr><td class="paramname">scale</td><td>A scale factor with a range value between 0.0 and 1.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing four Bezier control points. The first and last points are the extent points of the Bezier curve and the other two are the tangent controlling waypoints. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the size of <code>control_points</code> is different from 4. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>When <code>scale</code> is bigger than 1.0. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>When <code>scale</code> is smaller than 0.0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a121f8a5a98df5f91fd6af3d883378206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121f8a5a98df5f91fd6af3d883378206">&#9670;&nbsp;</a></span>SplineToBezier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; ignition::math::Vector3d &gt; SplineToBezier </td>
          <td>(</td>
          <td class="paramtype">const ignition::math::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ignition::math::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ignition::math::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ignition::math::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>t1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the equivalent set of points in cubic Bezier base from two pairs of points and tangents at the extents of a spline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p0</td><td>A vector that describes the starting position of the curve. </td></tr>
    <tr><td class="paramname">t0</td><td>A vector that describes the tangent at <code>p0</code>. </td></tr>
    <tr><td class="paramname">p1</td><td>A vector that describes the ending position of the curve. </td></tr>
    <tr><td class="paramname">t1</td><td>A vector that describes the tangent at <code>p1</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing four Bezier control points. The first and last points are the extent points of the Bezier curve and the other two are the tangent controlling waypoints. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="adeb4e2ddff0af85cc9b0e8c371a0a51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb4e2ddff0af85cc9b0e8c371a0a51f">&#9670;&nbsp;</a></span>kBezierMatrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classdouble.html">double</a> kBezierMatrix[16]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    1.0, 0.0, 0.0, 0.0,</div><div class="line">    -3.0, 3.0, 0.0, 0.0,</div><div class="line">    3.0, -6.0, 3.0, 0.0,</div><div class="line">    -1.0, 3.0, -3.0, 1.0}</div></div><!-- fragment -->
</div>
</div>
<a id="ad80d76d1bf53794f563d2b8800173f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80d76d1bf53794f563d2b8800173f68">&#9670;&nbsp;</a></span>kFunctionPartitionTreeDegree</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classint.html">int</a> kFunctionPartitionTreeDegree = 10</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3499b264b45b23eac0339699208905c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3499b264b45b23eac0339699208905c4">&#9670;&nbsp;</a></span>kFunctionPartitionTreeMaxDepth</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classint.html">int</a> kFunctionPartitionTreeMaxDepth = 10</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87072c1422aa6e55355d583b28c1a872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87072c1422aa6e55355d583b28c1a872">&#9670;&nbsp;</a></span>kHermiteMatrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classdouble.html">double</a> kHermiteMatrix[16]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">    1.0, 0.0, 0.0, 0.0,</div><div class="line">    0.0, 1.0, 0.0, 0.0,</div><div class="line">    -3.0, -2.0, 3.0, -1.0,</div><div class="line">    2.0, 1.0, -2.0, 1.0}</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1maliput.html">maliput</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1maliput_1_1rndf.html">rndf</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
