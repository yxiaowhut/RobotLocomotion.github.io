<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacedrake.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">drake Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake_1_1assert"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1assert.html">assert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1automotive"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1automotive.html">automotive</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1benchmarks"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1benchmarks.html">benchmarks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1bouncing__ball"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1bouncing__ball.html">bouncing_ball</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1common"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1common.html">common</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1examples"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1examples.html">examples</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1geometry"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html">geometry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1lcm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1lcm.html">lcm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1logging"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1logging.html">logging</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1maliput"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1maliput.html">maliput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1manipulation"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1manipulation.html">manipulation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html">math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1multibody"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1nice__type__name__test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1nice__type__name__test.html">nice_type_name_test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1parsers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1parsers.html">parsers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1perception"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1perception.html">perception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1pydrake"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html">pydrake</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1solvers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html">solvers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1symbolic"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html">symbolic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1systems"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1systems.html">systems</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1trajectories"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1trajectories.html">trajectories</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1util"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1util.html">util</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer with deep copy semantics.  <a href="classdrake_1_1copyable__unique__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1_delegating_hasher.html">DelegatingHasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adapter that forwards the HashAlgorithm::operator(data, length) function concept into a runtime-provided std::function of the same signature.  <a href="structdrake_1_1_delegating_hasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1dummy__value.html">dummy_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a "dummy" value for a ScalarType &ndash; a value that is unlikely to be mistaken for a purposefully-computed value, useful for initializing a value before the true result is available.  <a href="structdrake_1_1dummy__value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1dummy__value_3_01_eigen_1_1_auto_diff_scalar_3_01_der_type_01_4_01_4.html">dummy_value&lt; Eigen::AutoDiffScalar&lt; DerType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <a class="el" href="dummy__value_8h.html">common/dummy_value.h</a>.  <a href="structdrake_1_1dummy__value_3_01_eigen_1_1_auto_diff_scalar_3_01_der_type_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1dummy__value_3_01int_01_4.html">dummy_value&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1dummy__value_3_01symbolic_1_1_expression_01_4.html">dummy_value&lt; symbolic::Expression &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <a class="el" href="dummy__value_8h.html">common/dummy_value.h</a>.  <a href="structdrake_1_1dummy__value_3_01symbolic_1_1_expression_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This wrapper class provides a way to write non-template functions taking raw pointers to <a class="el" href="namespace_eigen.html">Eigen</a> objects as parameters while limiting the number of copies, similar to <code>Eigen::Ref</code>.  <a href="classdrake_1_1_eigen_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1_eigen_size_min_prefer_dynamic.html">EigenSizeMinPreferDynamic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structdrake_1_1_eigen_size_min_prefer_dynamic.html#adfbd84e9619cf3366fb744d3f70c8c23">EigenSizeMinPreferDynamic&lt;a, b&gt;::value</a> gives the min between compile-time sizes <code>a</code> and <code>b</code>.  <a href="structdrake_1_1_eigen_size_min_prefer_dynamic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1_eigen_size_min_prefer_fixed.html">EigenSizeMinPreferFixed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structdrake_1_1_eigen_size_min_prefer_fixed.html" title="EigenSizeMinPreferFixed is a variant of EigenSizeMinPreferDynamic. ">EigenSizeMinPreferFixed</a> is a variant of <a class="el" href="structdrake_1_1_eigen_size_min_prefer_dynamic.html" title="EigenSizeMinPreferDynamic&lt;a, b&gt;::value gives the min between compile-time sizes a and b...">EigenSizeMinPreferDynamic</a>.  <a href="structdrake_1_1_eigen_size_min_prefer_fixed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_find_resource_result.html">FindResourceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models the outcome of <a class="el" href="namespacedrake.html#a1becb3d158eac50e74aa9f1921c3a2b3" title="Attempts to locate a Drake resource named by the given resource_path. ">drake::FindResource</a>.  <a href="classdrake_1_1_find_resource_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__nonvector__expression__double__pair.html">is_eigen_nonvector_expression_double_pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__nonvector__of.html">is_eigen_nonvector_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__type.html">is_eigen_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__vector__expression__double__pair.html">is_eigen_vector_expression_double_pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1_multiply_eigen_sizes.html">MultiplyEigenSizes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MultiplyEigenSizes&lt;a, b&gt; gives a * b if both of a and b are fixed sizes.  <a href="structdrake_1_1_multiply_eigen_sizes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1never__destroyed.html">never_destroyed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an underlying type T such that its storage is a direct member field of this object (i.e., without any indirection into the heap), but <em>unlike</em> most member fields T's destructor is never invoked.  <a href="classdrake_1_1never__destroyed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_nice_type_name.html">NiceTypeName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains canonicalized, platform-independent, human-readable names for arbitrarily-complicated C++ types.  <a href="classdrake_1_1_nice_type_name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__after__move.html">reset_after_move</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type wrapper that performs value-initialization on the wrapped type, and guarantees that when moving from this type that the donor object is reset to its value-initialized value.  <a href="classdrake_1_1reset__after__move.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type wrapper that performs value-initialization on copy construction or assignment.  <a href="classdrake_1_1reset__on__copy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits struct that describes the return type of predicates over a scalar type (named <code>T</code>).  <a href="structdrake_1_1scalar__predicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is similar to the std::pair class.  <a href="structdrake_1_1_sorted_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1template__single__tag.html">template_single_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a tag for single-parameter templates.  <a href="structdrake_1_1template__single__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1type__at.html">type_at</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the Ith type from a sequence of types.  <a href="structdrake_1_1type__at.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1type__check__different__from.html">type_check_different_from</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a check which returns whether <code>T</code> is different than <code>U</code>.  <a href="structdrake_1_1type__check__different__from.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1type__pack.html">type_pack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a tag to pass a parameter packs for ease of inference.  <a href="structdrake_1_1type__pack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1type__tag.html">type_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a tag to pass a type for ease of inference.  <a href="structdrake_1_1type__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1type__visit__with__default.html">type_visit_with_default</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit a type by constructing its default value.  <a href="structdrake_1_1type__visit__with__default.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1type__visit__with__tag.html">type_visit_with_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visits a type by construct a template tag's default value.  <a href="structdrake_1_1type__visit__with__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-safe non-negative index class.  <a href="classdrake_1_1_type_safe_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1uhash.html">uhash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hashing functor, somewhat like <code>std::hash</code>.  <a href="structdrake_1_1uhash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a49de23e366bad92e3cab9c43a4088725"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49de23e366bad92e3cab9c43a4088725"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a49de23e366bad92e3cab9c43a4088725">type_pack_extract</a> = typename <a class="el" href="structdrake_1_1detail_1_1type__pack__extract__impl.html">detail::type_pack_extract_impl</a>&lt; T &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a></td></tr>
<tr class="memdesc:a49de23e366bad92e3cab9c43a4088725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the inner template arguments (typename only) for a typename which is a template instantiation.  <a href="#a49de23e366bad92e3cab9c43a4088725">More...</a><br /></td></tr>
<tr class="separator:a49de23e366bad92e3cab9c43a4088725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2ad496fcfd4aab65f4f9eaf50759cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca2ad496fcfd4aab65f4f9eaf50759cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#aca2ad496fcfd4aab65f4f9eaf50759cb">type_check_always_true</a> = std::true_type</td></tr>
<tr class="memdesc:aca2ad496fcfd4aab65f4f9eaf50759cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a check which will return true for any type.  <a href="#aca2ad496fcfd4aab65f4f9eaf50759cb">More...</a><br /></td></tr>
<tr class="separator:aca2ad496fcfd4aab65f4f9eaf50759cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b3378e99b86b40c4cb9a9ac0d19e1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18b3378e99b86b40c4cb9a9ac0d19e1f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a18b3378e99b86b40c4cb9a9ac0d19e1f">negation</a> = std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, !<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">T::value</a> &gt;</td></tr>
<tr class="memdesc:a18b3378e99b86b40c4cb9a9ac0d19e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides backport of C++17 <code>std::negation</code>.  <a href="#a18b3378e99b86b40c4cb9a9ac0d19e1f">More...</a><br /></td></tr>
<tr class="separator:a18b3378e99b86b40c4cb9a9ac0d19e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1c657c4d2cf400649123a7c2573d5b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f1c657c4d2cf400649123a7c2573d5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a> = typename <a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt; T &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a></td></tr>
<tr class="memdesc:a1f1c657c4d2cf400649123a7c2573d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for a boolean-like value, conditioned on the scalar type <code>T</code>.  <a href="#a1f1c657c4d2cf400649123a7c2573d5b">More...</a><br /></td></tr>
<tr class="separator:a1f1c657c4d2cf400649123a7c2573d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2ec0f640175b49517f43f37073bfc8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f2ec0f640175b49517f43f37073bfc8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a> = stx::optional&lt; T &gt;</td></tr>
<tr class="separator:a9f2ec0f640175b49517f43f37073bfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98164c05774e687076c1562cf8d7593"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ae98164c05774e687076c1562cf8d7593"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a> = stx::variant&lt; Types... &gt;</td></tr>
<tr class="separator:ae98164c05774e687076c1562cf8d7593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35725b277b02aeb79f24fd7f724e6dbc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> = Eigen::AutoDiffScalar&lt; Eigen::VectorXd &gt;</td></tr>
<tr class="memdesc:a35725b277b02aeb79f24fd7f724e6dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">An autodiff variable with a dynamic number of partials.  <a href="#a35725b277b02aeb79f24fd7f724e6dbc">More...</a><br /></td></tr>
<tr class="separator:a35725b277b02aeb79f24fd7f724e6dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4077c4918078fb55bfb6b73968cb0a"><td class="memTemplParams" colspan="2">template&lt;int num_vars&gt; </td></tr>
<tr class="memitem:a5f4077c4918078fb55bfb6b73968cb0a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a5f4077c4918078fb55bfb6b73968cb0a">AutoDiffd</a> = Eigen::AutoDiffScalar&lt; Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, num_vars, 1 &gt; &gt;</td></tr>
<tr class="memdesc:a5f4077c4918078fb55bfb6b73968cb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An autodiff variable with <code>num_vars</code> partials.  <a href="#a5f4077c4918078fb55bfb6b73968cb0a">More...</a><br /></td></tr>
<tr class="separator:a5f4077c4918078fb55bfb6b73968cb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790a072a62129732864a20e7a4743298"><td class="memTemplParams" colspan="2">template&lt;int num_vars, int rows&gt; </td></tr>
<tr class="memitem:a790a072a62129732864a20e7a4743298"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a790a072a62129732864a20e7a4743298">AutoDiffVecd</a> = Eigen::Matrix&lt; <a class="el" href="namespacedrake.html#a5f4077c4918078fb55bfb6b73968cb0a">AutoDiffd</a>&lt; num_vars &gt;, rows, 1 &gt;</td></tr>
<tr class="memdesc:a790a072a62129732864a20e7a4743298"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of <code>rows</code> autodiff variables, each with <code>num_vars</code> partials.  <a href="#a790a072a62129732864a20e7a4743298">More...</a><br /></td></tr>
<tr class="separator:a790a072a62129732864a20e7a4743298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b13142534d668d5d490b829b917fa16"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacedrake.html#a790a072a62129732864a20e7a4743298">AutoDiffVecd</a>&lt; Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a7b13142534d668d5d490b829b917fa16">AutoDiffVecXd</a></td></tr>
<tr class="memdesc:a7b13142534d668d5d490b829b917fa16"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic-sized vector of autodiff variables, each with a dynamic-sized vector of partials.  <a href="#a7b13142534d668d5d490b829b917fa16">More...</a><br /></td></tr>
<tr class="separator:a7b13142534d668d5d490b829b917fa16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13e10d823b0e212fdfb27cc8f18065a"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:ae13e10d823b0e212fdfb27cc8f18065a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ae13e10d823b0e212fdfb27cc8f18065a">eigen_aligned_std_map</a> = std::map&lt; Key, T, std::less&lt; Key &gt;, Eigen::aligned_allocator&lt; std::pair&lt; Key const, T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ae13e10d823b0e212fdfb27cc8f18065a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::map that uses Eigen::aligned_allocator so that the contained types may be fixed-size <a class="el" href="namespace_eigen.html">Eigen</a> values.  <a href="#ae13e10d823b0e212fdfb27cc8f18065a">More...</a><br /></td></tr>
<tr class="separator:ae13e10d823b0e212fdfb27cc8f18065a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcadf96d397f45d041d01bf17061bc32"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:afcadf96d397f45d041d01bf17061bc32"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#afcadf96d397f45d041d01bf17061bc32">eigen_aligned_std_unordered_map</a> = std::unordered_map&lt; Key, T, std::hash&lt; Key &gt;, std::equal_to&lt; Key &gt;, Eigen::aligned_allocator&lt; std::pair&lt; Key const, T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:afcadf96d397f45d041d01bf17061bc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::unordered_map that uses Eigen::aligned_allocator so that the contained types may be fixed-size <a class="el" href="namespace_eigen.html">Eigen</a> values.  <a href="#afcadf96d397f45d041d01bf17061bc32">More...</a><br /></td></tr>
<tr class="separator:afcadf96d397f45d041d01bf17061bc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4150555527b3cf871fe911f8776f301a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4150555527b3cf871fe911f8776f301a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a4150555527b3cf871fe911f8776f301a">eigen_aligned_std_vector</a> = <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; T, Eigen::aligned_allocator&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a4150555527b3cf871fe911f8776f301a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::vector that uses Eigen::aligned_allocator so that the contained types may be fixed-size <a class="el" href="namespace_eigen.html">Eigen</a> values.  <a href="#a4150555527b3cf871fe911f8776f301a">More...</a><br /></td></tr>
<tr class="separator:a4150555527b3cf871fe911f8776f301a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af359dfdb84d6c13b606bb3ed7b821e23"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af359dfdb84d6c13b606bb3ed7b821e23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#af359dfdb84d6c13b606bb3ed7b821e23">Vector1</a> = Eigen::Matrix&lt; Scalar, 1, 1 &gt;</td></tr>
<tr class="memdesc:af359dfdb84d6c13b606bb3ed7b821e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 1 (that is, a scalar), templated on scalar type.  <a href="#af359dfdb84d6c13b606bb3ed7b821e23">More...</a><br /></td></tr>
<tr class="separator:af359dfdb84d6c13b606bb3ed7b821e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d923e79e6e92c2556edd86520145077"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a6d923e79e6e92c2556edd86520145077">Vector1d</a> = Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, 1, 1 &gt;</td></tr>
<tr class="memdesc:a6d923e79e6e92c2556edd86520145077"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 1 of doubles.  <a href="#a6d923e79e6e92c2556edd86520145077">More...</a><br /></td></tr>
<tr class="separator:a6d923e79e6e92c2556edd86520145077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f8b7dbd727440c2dd207bf43812f1e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ab9f8b7dbd727440c2dd207bf43812f1e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a> = Eigen::Matrix&lt; Scalar, 2, 1 &gt;</td></tr>
<tr class="memdesc:ab9f8b7dbd727440c2dd207bf43812f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 2, templated on scalar type.  <a href="#ab9f8b7dbd727440c2dd207bf43812f1e">More...</a><br /></td></tr>
<tr class="separator:ab9f8b7dbd727440c2dd207bf43812f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad29daab565ce347c4d1c5aae6a76c2"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a0ad29daab565ce347c4d1c5aae6a76c2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a> = Eigen::Matrix&lt; Scalar, 3, 1 &gt;</td></tr>
<tr class="memdesc:a0ad29daab565ce347c4d1c5aae6a76c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 3, templated on scalar type.  <a href="#a0ad29daab565ce347c4d1c5aae6a76c2">More...</a><br /></td></tr>
<tr class="separator:a0ad29daab565ce347c4d1c5aae6a76c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e96394aef85f13f3fc84d3c3c238b3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af7e96394aef85f13f3fc84d3c3c238b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a> = Eigen::Matrix&lt; Scalar, 4, 1 &gt;</td></tr>
<tr class="memdesc:af7e96394aef85f13f3fc84d3c3c238b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 4, templated on scalar type.  <a href="#af7e96394aef85f13f3fc84d3c3c238b3">More...</a><br /></td></tr>
<tr class="separator:af7e96394aef85f13f3fc84d3c3c238b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14aa433aedda321a15238f2d4074d4c3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a14aa433aedda321a15238f2d4074d4c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a> = Eigen::Matrix&lt; Scalar, 6, 1 &gt;</td></tr>
<tr class="memdesc:a14aa433aedda321a15238f2d4074d4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 6.  <a href="#a14aa433aedda321a15238f2d4074d4c3">More...</a><br /></td></tr>
<tr class="separator:a14aa433aedda321a15238f2d4074d4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dd228fb4dd66a2c17dd3f7f38ffd85"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a77dd228fb4dd66a2c17dd3f7f38ffd85"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:a77dd228fb4dd66a2c17dd3f7f38ffd85"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of any size, templated on scalar type.  <a href="#a77dd228fb4dd66a2c17dd3f7f38ffd85">More...</a><br /></td></tr>
<tr class="separator:a77dd228fb4dd66a2c17dd3f7f38ffd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbacdba0566fe8958cfafd659b4373f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:adfbacdba0566fe8958cfafd659b4373f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#adfbacdba0566fe8958cfafd659b4373f">VectorUpTo6</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1, 0, 6, 1 &gt;</td></tr>
<tr class="memdesc:adfbacdba0566fe8958cfafd659b4373f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of dynamic size templated on scalar type, up to a maximum of 6 elements.  <a href="#adfbacdba0566fe8958cfafd659b4373f">More...</a><br /></td></tr>
<tr class="separator:adfbacdba0566fe8958cfafd659b4373f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc54e1f7aa3341a5f6b305705452d9bd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:afc54e1f7aa3341a5f6b305705452d9bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#afc54e1f7aa3341a5f6b305705452d9bd">RowVector2</a> = Eigen::Matrix&lt; Scalar, 1, 2 &gt;</td></tr>
<tr class="memdesc:afc54e1f7aa3341a5f6b305705452d9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of size 2, templated on scalar type.  <a href="#afc54e1f7aa3341a5f6b305705452d9bd">More...</a><br /></td></tr>
<tr class="separator:afc54e1f7aa3341a5f6b305705452d9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4ae0d841ea1629551bf77fd5d9ec9e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aee4ae0d841ea1629551bf77fd5d9ec9e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#aee4ae0d841ea1629551bf77fd5d9ec9e">RowVector3</a> = Eigen::Matrix&lt; Scalar, 1, 3 &gt;</td></tr>
<tr class="memdesc:aee4ae0d841ea1629551bf77fd5d9ec9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of size 3, templated on scalar type.  <a href="#aee4ae0d841ea1629551bf77fd5d9ec9e">More...</a><br /></td></tr>
<tr class="separator:aee4ae0d841ea1629551bf77fd5d9ec9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b373b2971391d9054b431d8a3e4b33"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aa9b373b2971391d9054b431d8a3e4b33"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#aa9b373b2971391d9054b431d8a3e4b33">RowVector4</a> = Eigen::Matrix&lt; Scalar, 1, 4 &gt;</td></tr>
<tr class="memdesc:aa9b373b2971391d9054b431d8a3e4b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of size 4, templated on scalar type.  <a href="#aa9b373b2971391d9054b431d8a3e4b33">More...</a><br /></td></tr>
<tr class="separator:aa9b373b2971391d9054b431d8a3e4b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad88c2d704ccb2899d475d3ae05de14"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a3ad88c2d704ccb2899d475d3ae05de14"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a3ad88c2d704ccb2899d475d3ae05de14">RowVector6</a> = Eigen::Matrix&lt; Scalar, 1, 6 &gt;</td></tr>
<tr class="memdesc:a3ad88c2d704ccb2899d475d3ae05de14"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of size 6.  <a href="#a3ad88c2d704ccb2899d475d3ae05de14">More...</a><br /></td></tr>
<tr class="separator:a3ad88c2d704ccb2899d475d3ae05de14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218f39990d2d9090c7a25c9c18cbf832"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a218f39990d2d9090c7a25c9c18cbf832"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a218f39990d2d9090c7a25c9c18cbf832">RowVectorX</a> = Eigen::Matrix&lt; Scalar, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a218f39990d2d9090c7a25c9c18cbf832"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of any size, templated on scalar type.  <a href="#a218f39990d2d9090c7a25c9c18cbf832">More...</a><br /></td></tr>
<tr class="separator:a218f39990d2d9090c7a25c9c18cbf832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06406a5da633da84f911e2979aa48549"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a06406a5da633da84f911e2979aa48549"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a> = Eigen::Matrix&lt; Scalar, 2, 2 &gt;</td></tr>
<tr class="memdesc:a06406a5da633da84f911e2979aa48549"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 2 rows and 2 columns, templated on scalar type.  <a href="#a06406a5da633da84f911e2979aa48549">More...</a><br /></td></tr>
<tr class="separator:a06406a5da633da84f911e2979aa48549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3922cc0c6264e8ff225a6aa0dd993667"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a3922cc0c6264e8ff225a6aa0dd993667"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a> = Eigen::Matrix&lt; Scalar, 3, 3 &gt;</td></tr>
<tr class="memdesc:a3922cc0c6264e8ff225a6aa0dd993667"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 3 rows and 3 columns, templated on scalar type.  <a href="#a3922cc0c6264e8ff225a6aa0dd993667">More...</a><br /></td></tr>
<tr class="separator:a3922cc0c6264e8ff225a6aa0dd993667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74155a11dfcdaad0adc0349f0956148"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ae74155a11dfcdaad0adc0349f0956148"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a> = Eigen::Matrix&lt; Scalar, 4, 4 &gt;</td></tr>
<tr class="memdesc:ae74155a11dfcdaad0adc0349f0956148"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 4 rows and 4 columns, templated on scalar type.  <a href="#ae74155a11dfcdaad0adc0349f0956148">More...</a><br /></td></tr>
<tr class="separator:ae74155a11dfcdaad0adc0349f0956148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f9aa896d31437a219ed19fa944fe20"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a11f9aa896d31437a219ed19fa944fe20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a> = Eigen::Matrix&lt; Scalar, 6, 6 &gt;</td></tr>
<tr class="memdesc:a11f9aa896d31437a219ed19fa944fe20"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 6 rows and 6 columns, templated on scalar type.  <a href="#a11f9aa896d31437a219ed19fa944fe20">More...</a><br /></td></tr>
<tr class="separator:a11f9aa896d31437a219ed19fa944fe20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13883859324817e6310d04a6d2fe206"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af13883859324817e6310d04a6d2fe206"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#af13883859324817e6310d04a6d2fe206">Matrix2X</a> = Eigen::Matrix&lt; Scalar, 2, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:af13883859324817e6310d04a6d2fe206"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 2 rows, dynamic columns, templated on scalar type.  <a href="#af13883859324817e6310d04a6d2fe206">More...</a><br /></td></tr>
<tr class="separator:af13883859324817e6310d04a6d2fe206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe2dee57bc492bfbd96fe078b65ab00"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:acfe2dee57bc492bfbd96fe078b65ab00"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a> = Eigen::Matrix&lt; Scalar, 3, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:acfe2dee57bc492bfbd96fe078b65ab00"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 3 rows, dynamic columns, templated on scalar type.  <a href="#acfe2dee57bc492bfbd96fe078b65ab00">More...</a><br /></td></tr>
<tr class="separator:acfe2dee57bc492bfbd96fe078b65ab00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585f047d94502e00bfb163347abbc771"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a585f047d94502e00bfb163347abbc771"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a585f047d94502e00bfb163347abbc771">Matrix4X</a> = Eigen::Matrix&lt; Scalar, 4, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a585f047d94502e00bfb163347abbc771"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 4 rows, dynamic columns, templated on scalar type.  <a href="#a585f047d94502e00bfb163347abbc771">More...</a><br /></td></tr>
<tr class="separator:a585f047d94502e00bfb163347abbc771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668e1152f8b876967b9093ae4d95298b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a668e1152f8b876967b9093ae4d95298b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">Matrix6X</a> = Eigen::Matrix&lt; Scalar, 6, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a668e1152f8b876967b9093ae4d95298b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 6 rows, dynamic columns, templated on scalar type.  <a href="#a668e1152f8b876967b9093ae4d95298b">More...</a><br /></td></tr>
<tr class="separator:a668e1152f8b876967b9093ae4d95298b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c58d881c60e96f48a7a4e32a699b95"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a28c58d881c60e96f48a7a4e32a699b95"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a28c58d881c60e96f48a7a4e32a699b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of dynamic size, templated on scalar type.  <a href="#a28c58d881c60e96f48a7a4e32a699b95">More...</a><br /></td></tr>
<tr class="separator:a28c58d881c60e96f48a7a4e32a699b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0efed85a04025fda487f0d59b71d5d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:abc0efed85a04025fda487f0d59b71d5d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#abc0efed85a04025fda487f0d59b71d5d">MatrixUpTo6</a> = Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic, 0, 6, 6 &gt;</td></tr>
<tr class="memdesc:abc0efed85a04025fda487f0d59b71d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of dynamic size templated on scalar type, up to a maximum of 6 rows and 6 columns.  <a href="#abc0efed85a04025fda487f0d59b71d5d">More...</a><br /></td></tr>
<tr class="separator:abc0efed85a04025fda487f0d59b71d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4156bf453a5b323356d7cc784dfdf084"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a4156bf453a5b323356d7cc784dfdf084"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084">Quaternion</a> = Eigen::Quaternion&lt; Scalar &gt;</td></tr>
<tr class="memdesc:a4156bf453a5b323356d7cc784dfdf084"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quaternion templated on scalar type.  <a href="#a4156bf453a5b323356d7cc784dfdf084">More...</a><br /></td></tr>
<tr class="separator:a4156bf453a5b323356d7cc784dfdf084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d91e75997a81a48adea1e83caddde4"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a90d91e75997a81a48adea1e83caddde4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a90d91e75997a81a48adea1e83caddde4">AngleAxis</a> = Eigen::AngleAxis&lt; Scalar &gt;</td></tr>
<tr class="memdesc:a90d91e75997a81a48adea1e83caddde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AngleAxis templated on scalar type.  <a href="#a90d91e75997a81a48adea1e83caddde4">More...</a><br /></td></tr>
<tr class="separator:a90d91e75997a81a48adea1e83caddde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb383d64a842ca9002f66b2e10254aa"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a9eb383d64a842ca9002f66b2e10254aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a> = Eigen::Transform&lt; Scalar, 3, Eigen::Isometry &gt;</td></tr>
<tr class="memdesc:a9eb383d64a842ca9002f66b2e10254aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Isometry templated on scalar type.  <a href="#a9eb383d64a842ca9002f66b2e10254aa">More...</a><br /></td></tr>
<tr class="separator:a9eb383d64a842ca9002f66b2e10254aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f8d19f395776637448f26e734228f6"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a50f8d19f395776637448f26e734228f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a50f8d19f395776637448f26e734228f6">Translation3</a> = Eigen::Translation&lt; Scalar, 3 &gt;</td></tr>
<tr class="memdesc:a50f8d19f395776637448f26e734228f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A translation in 3D templated on scalar type.  <a href="#a50f8d19f395776637448f26e734228f6">More...</a><br /></td></tr>
<tr class="separator:a50f8d19f395776637448f26e734228f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf249fd84580486a877500bed5a0b8e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:afbf249fd84580486a877500bed5a0b8e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">TwistVector</a> = Eigen::Matrix&lt; Scalar, <a class="el" href="namespacedrake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>, 1 &gt;</td></tr>
<tr class="memdesc:afbf249fd84580486a877500bed5a0b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector consisting of one twist.  <a href="#afbf249fd84580486a877500bed5a0b8e">More...</a><br /></td></tr>
<tr class="separator:afbf249fd84580486a877500bed5a0b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30fe85a821bd0e0ab46f2e165c8e480"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af30fe85a821bd0e0ab46f2e165c8e480"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#af30fe85a821bd0e0ab46f2e165c8e480">TwistMatrix</a> = Eigen::Matrix&lt; Scalar, <a class="el" href="namespacedrake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:af30fe85a821bd0e0ab46f2e165c8e480"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix with one twist per column, and dynamically many columns.  <a href="#af30fe85a821bd0e0ab46f2e165c8e480">More...</a><br /></td></tr>
<tr class="separator:af30fe85a821bd0e0ab46f2e165c8e480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa72a15690d6e4db2040ebc8814a74e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a3aa72a15690d6e4db2040ebc8814a74e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a3aa72a15690d6e4db2040ebc8814a74e">SquareTwistMatrix</a> = Eigen::Matrix&lt; Scalar, <a class="el" href="namespacedrake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>, <a class="el" href="namespacedrake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a> &gt;</td></tr>
<tr class="memdesc:a3aa72a15690d6e4db2040ebc8814a74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A six-by-six matrix.  <a href="#a3aa72a15690d6e4db2040ebc8814a74e">More...</a><br /></td></tr>
<tr class="separator:a3aa72a15690d6e4db2040ebc8814a74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98fed5f98c376f4d45fff56bb96c8e1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:af98fed5f98c376f4d45fff56bb96c8e1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#af98fed5f98c376f4d45fff56bb96c8e1">WrenchVector</a> = Eigen::Matrix&lt; Scalar, 6, 1 &gt;</td></tr>
<tr class="memdesc:af98fed5f98c376f4d45fff56bb96c8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector consisting of one wrench (spatial force) = <code>[r X f; f]</code>, where f is a force (translational force) applied at a point <code>P</code> and <code>r</code> is the position vector from a point <code>O</code> (called the "moment center") to point <code>P</code>.  <a href="#af98fed5f98c376f4d45fff56bb96c8e1">More...</a><br /></td></tr>
<tr class="separator:af98fed5f98c376f4d45fff56bb96c8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d93f987a8437295055eb3f46e99cbe"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a91d93f987a8437295055eb3f46e99cbe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a91d93f987a8437295055eb3f46e99cbe">SpatialForce</a> = Eigen::Matrix&lt; Scalar, 6, 1 &gt;</td></tr>
<tr class="memdesc:a91d93f987a8437295055eb3f46e99cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector consisting of a concatenated rotational and translational force.  <a href="#a91d93f987a8437295055eb3f46e99cbe">More...</a><br /></td></tr>
<tr class="separator:a91d93f987a8437295055eb3f46e99cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06fbebac1e1ffc23617b782f072d79b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#aa06fbebac1e1ffc23617b782f072d79b">Result</a> = <a class="el" href="classdrake_1_1_find_resource_result.html">FindResourceResult</a></td></tr>
<tr class="separator:aa06fbebac1e1ffc23617b782f072d79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d31e66897b203da66c76e11df55cd98"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a7d31e66897b203da66c76e11df55cd98">DefaultHasher</a> = <a class="el" href="classdrake_1_1detail_1_1_f_n_v1a_hasher.html">detail::FNV1aHasher</a></td></tr>
<tr class="memdesc:a7d31e66897b203da66c76e11df55cd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default HashAlgorithm concept implementation across Drake.  <a href="#a7d31e66897b203da66c76e11df55cd98">More...</a><br /></td></tr>
<tr class="separator:a7d31e66897b203da66c76e11df55cd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323dc8b0cc629c61d4da8feeaa8cd4f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a323dc8b0cc629c61d4da8feeaa8cd4f5">DefaultHash</a> = <a class="el" href="structdrake_1_1uhash.html">drake::uhash</a>&lt; <a class="el" href="namespacedrake.html#a7d31e66897b203da66c76e11df55cd98">DefaultHasher</a> &gt;</td></tr>
<tr class="memdesc:a323dc8b0cc629c61d4da8feeaa8cd4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default hashing functor, akin to std::hash.  <a href="#a323dc8b0cc629c61d4da8feeaa8cd4f5">More...</a><br /></td></tr>
<tr class="separator:a323dc8b0cc629c61d4da8feeaa8cd4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180d8e6bc7dcb53a32335226b15cca20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a180d8e6bc7dcb53a32335226b15cca20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a180d8e6bc7dcb53a32335226b15cca20">is_cloneable</a> = is_cloneable_detail::is_cloneable_helper&lt; T, void &gt;</td></tr>
<tr class="separator:a180d8e6bc7dcb53a32335226b15cca20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a72383be4710d27584d0821effc6506a5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> { <a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5a3ea9f7aca87fd7b64469a0d1119f0b50">kUniform</a> = 0, 
<a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5ab933cd0242085c2dbf804dbf288ce7f0">kGaussian</a> = 1, 
<a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5a601bf5851ffd28f5e6219c0f1945c8d6">kExponential</a> = 2
 }<tr class="memdesc:a72383be4710d27584d0821effc6506a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drake supports explicit reasoning about a few carefully chosen random distributions.  <a href="namespacedrake.html#a72383be4710d27584d0821effc6506a5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a72383be4710d27584d0821effc6506a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487584d4d770172ae2f665bde7462de2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a487584d4d770172ae2f665bde7462de2">MatrixCompareType</a> { <a class="el" href="namespacedrake.html#a487584d4d770172ae2f665bde7462de2adc4d53aa0d117d8b189b36d161af4e96">absolute</a>, 
<a class="el" href="namespacedrake.html#a487584d4d770172ae2f665bde7462de2a99c483e1d11b1a279a2a1a3960528487">relative</a>
 }</td></tr>
<tr class="separator:a487584d4d770172ae2f665bde7462de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2f8fb09132c1375ac50b011cd4c47559"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class Tpl, typename... Ts&gt; </td></tr>
<tr class="memitem:a2f8fb09132c1375ac50b011cd4c47559"><td class="memTemplItemLeft" align="right" valign="top">Tpl&lt; Ts... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a2f8fb09132c1375ac50b011cd4c47559">type_bind</a> (<a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; Ts... &gt;)</td></tr>
<tr class="memdesc:a2f8fb09132c1375ac50b011cd4c47559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression (only to be used in <code>decltype</code>) for inferring and binding a parameter pack to a template.  <a href="#a2f8fb09132c1375ac50b011cd4c47559">More...</a><br /></td></tr>
<tr class="separator:a2f8fb09132c1375ac50b011cd4c47559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7421f3f5801e3e393c7a52105aeb876e"><td class="memTemplParams" colspan="2">template&lt;class VisitWith  = type_visit_with_default, template&lt; typename &gt; class Predicate = type_check_always_true, typename Visitor  = void, typename ... Ts&gt; </td></tr>
<tr class="memitem:a7421f3f5801e3e393c7a52105aeb876e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a7421f3f5801e3e393c7a52105aeb876e">type_visit</a> (Visitor &amp;&amp;visitor, <a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; Ts... &gt;={}, <a class="el" href="structdrake_1_1template__single__tag.html">template_single_tag</a>&lt; Predicate &gt;={})</td></tr>
<tr class="memdesc:a7421f3f5801e3e393c7a52105aeb876e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visits each type in a type pack.  <a href="#a7421f3f5801e3e393c7a52105aeb876e">More...</a><br /></td></tr>
<tr class="separator:a7421f3f5801e3e393c7a52105aeb876e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e81e154cbda13ce43322ccfcedb7ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23e81e154cbda13ce43322ccfcedb7ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a23e81e154cbda13ce43322ccfcedb7ed">type_hash</a> ()</td></tr>
<tr class="memdesc:a23e81e154cbda13ce43322ccfcedb7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides short-hand for hashing a type.  <a href="#a23e81e154cbda13ce43322ccfcedb7ed">More...</a><br /></td></tr>
<tr class="separator:a23e81e154cbda13ce43322ccfcedb7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9721f3a5897b05ef2168f7a6d886dc8"><td class="memTemplParams" colspan="2">template&lt;typename DerType &gt; </td></tr>
<tr class="memitem:aa9721f3a5897b05ef2168f7a6d886dc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#aa9721f3a5897b05ef2168f7a6d886dc8">ExtractDoubleOrThrow</a> (const Eigen::AutoDiffScalar&lt; DerType &gt; &amp;scalar)</td></tr>
<tr class="memdesc:aa9721f3a5897b05ef2168f7a6d886dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the autodiff scalar's <a class="el" href="wrap__test__util__py_8cc.html#aee90379adb0307effb138f4871edbc5c">value()</a> as a double.  <a href="#aa9721f3a5897b05ef2168f7a6d886dc8">More...</a><br /></td></tr>
<tr class="separator:aa9721f3a5897b05ef2168f7a6d886dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52cba62721f6b29c99a83ec9b192873"><td class="memTemplParams" colspan="2">template&lt;typename DerType1 , typename DerType2 &gt; </td></tr>
<tr class="memitem:af52cba62721f6b29c99a83ec9b192873"><td class="memTemplItemLeft" align="right" valign="top">Eigen::AutoDiffScalar&lt; typename Eigen::internal::remove_all&lt; DerType1 &gt;::type::PlainObject &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#af52cba62721f6b29c99a83ec9b192873">if_then_else</a> (<a class="el" href="classbool.html">bool</a> f_cond, const Eigen::AutoDiffScalar&lt; DerType1 &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>, const Eigen::AutoDiffScalar&lt; DerType2 &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>)</td></tr>
<tr class="memdesc:af52cba62721f6b29c99a83ec9b192873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides if-then-else expression for Eigen::AutoDiffScalar type.  <a href="#af52cba62721f6b29c99a83ec9b192873">More...</a><br /></td></tr>
<tr class="separator:af52cba62721f6b29c99a83ec9b192873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c0e9e4214ab7f97568cc8792859e32"><td class="memTemplParams" colspan="2">template&lt;typename DerType , typename... Rest&gt; </td></tr>
<tr class="memitem:af8c0e9e4214ab7f97568cc8792859e32"><td class="memTemplItemLeft" align="right" valign="top">Eigen::AutoDiffScalar&lt; typename Eigen::internal::remove_all&lt; DerType &gt;::type::PlainObject &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#af8c0e9e4214ab7f97568cc8792859e32">cond</a> (<a class="el" href="classbool.html">bool</a> f_cond, const Eigen::AutoDiffScalar&lt; DerType &gt; &amp;e_then, Rest... rest)</td></tr>
<tr class="memdesc:af8c0e9e4214ab7f97568cc8792859e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides special case of cond expression for Eigen::AutoDiffScalar type.  <a href="#af8c0e9e4214ab7f97568cc8792859e32">More...</a><br /></td></tr>
<tr class="separator:af8c0e9e4214ab7f97568cc8792859e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c86a37d7ac815e5d42ab9d67363c14e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a3c86a37d7ac815e5d42ab9d67363c14e">autodiffxd_make_coherent</a> (const <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &amp;donor, <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> *recipient)</td></tr>
<tr class="memdesc:a3c86a37d7ac815e5d42ab9d67363c14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the derviatives of the recipient coherent with respect to those of the donor variable (see <a class="el" href="autodiffxd_8h.html">drake/common/autodiffxd.h</a>).  <a href="#a3c86a37d7ac815e5d42ab9d67363c14e">More...</a><br /></td></tr>
<tr class="separator:a3c86a37d7ac815e5d42ab9d67363c14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d04dd581311ecdd2bbaaca3c1d1ff34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a1d04dd581311ecdd2bbaaca3c1d1ff34">autodiffxd_make_coherent</a> (const <a class="el" href="classdouble.html">double</a> &amp;, <a class="el" href="classdouble.html">double</a> *)</td></tr>
<tr class="separator:a1d04dd581311ecdd2bbaaca3c1d1ff34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439ef8526114ad731981ac00415e6975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a439ef8526114ad731981ac00415e6975">autodiffxd_make_coherent</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> *)</td></tr>
<tr class="separator:a439ef8526114ad731981ac00415e6975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14dd00683f82b89dc0f08f9adec904e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ad14dd00683f82b89dc0f08f9adec904e">if_then_else</a> (<a class="el" href="classbool.html">bool</a> f_cond, <a class="el" href="classdouble.html">double</a> v_then, <a class="el" href="classdouble.html">double</a> v_else)</td></tr>
<tr class="memdesc:ad14dd00683f82b89dc0f08f9adec904e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides if-then-else expression for double.  <a href="#ad14dd00683f82b89dc0f08f9adec904e">More...</a><br /></td></tr>
<tr class="separator:ad14dd00683f82b89dc0f08f9adec904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc2d90ce6051e150effadd72fac548c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:adcc2d90ce6051e150effadd72fac548c"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#adcc2d90ce6051e150effadd72fac548c">all</a> (const Eigen::DenseBase&lt; Derived &gt; &amp;m)</td></tr>
<tr class="memdesc:adcc2d90ce6051e150effadd72fac548c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks truth for all elements in matrix <code>m</code>.  <a href="#adcc2d90ce6051e150effadd72fac548c">More...</a><br /></td></tr>
<tr class="separator:adcc2d90ce6051e150effadd72fac548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05a0ff629ccf3c38724b6d7f95e3bce"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac05a0ff629ccf3c38724b6d7f95e3bce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ac05a0ff629ccf3c38724b6d7f95e3bce">all_of</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const std::function&lt; <a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;pred)</td></tr>
<tr class="memdesc:ac05a0ff629ccf3c38724b6d7f95e3bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate <code>pred</code> holds for all elements in the matrix <code>m</code>.  <a href="#ac05a0ff629ccf3c38724b6d7f95e3bce">More...</a><br /></td></tr>
<tr class="separator:ac05a0ff629ccf3c38724b6d7f95e3bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624916a36af99a1ddfed08a25047cbea"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a624916a36af99a1ddfed08a25047cbea"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a624916a36af99a1ddfed08a25047cbea">any</a> (const Eigen::DenseBase&lt; Derived &gt; &amp;m)</td></tr>
<tr class="memdesc:a624916a36af99a1ddfed08a25047cbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks truth for at least one element in matrix <code>m</code>.  <a href="#a624916a36af99a1ddfed08a25047cbea">More...</a><br /></td></tr>
<tr class="separator:a624916a36af99a1ddfed08a25047cbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f0ced433e025116cf38c1cf2db6b76"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a66f0ced433e025116cf38c1cf2db6b76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a66f0ced433e025116cf38c1cf2db6b76">any_of</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const std::function&lt; <a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;pred)</td></tr>
<tr class="memdesc:a66f0ced433e025116cf38c1cf2db6b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate <code>pred</code> holds for at least one element in the matrix <code>m</code>.  <a href="#a66f0ced433e025116cf38c1cf2db6b76">More...</a><br /></td></tr>
<tr class="separator:a66f0ced433e025116cf38c1cf2db6b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aa931c5cbfd4b09d847cc4d7b4c699"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a01aa931c5cbfd4b09d847cc4d7b4c699"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a01aa931c5cbfd4b09d847cc4d7b4c699">none</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m)</td></tr>
<tr class="memdesc:a01aa931c5cbfd4b09d847cc4d7b4c699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that no elements of <code>m</code> are true. An empty matrix returns true.  <a href="#a01aa931c5cbfd4b09d847cc4d7b4c699">More...</a><br /></td></tr>
<tr class="separator:a01aa931c5cbfd4b09d847cc4d7b4c699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4011b0ee72e60112bfd3aee950765e8"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ab4011b0ee72e60112bfd3aee950765e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ab4011b0ee72e60112bfd3aee950765e8">none_of</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const std::function&lt; <a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;pred)</td></tr>
<tr class="memdesc:ab4011b0ee72e60112bfd3aee950765e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate <code>pred</code> holds for no elements in the matrix <code>m</code>.  <a href="#ab4011b0ee72e60112bfd3aee950765e8">More...</a><br /></td></tr>
<tr class="separator:ab4011b0ee72e60112bfd3aee950765e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae366b03370cd023e04f43610e658c6ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ae366b03370cd023e04f43610e658c6ae">MaybeGetDrakePath</a> ()</td></tr>
<tr class="memdesc:ae366b03370cd023e04f43610e658c6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns the fully-qualified path to the first folder containing Drake resources as located by FindResource, or nullopt if none is found.  <a href="#ae366b03370cd023e04f43610e658c6ae">More...</a><br /></td></tr>
<tr class="separator:ae366b03370cd023e04f43610e658c6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0a79ab2007d49c4169d9e6b9f7a5ed"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a1c0a79ab2007d49c4169d9e6b9f7a5ed">GetDrakePath</a> ()</td></tr>
<tr class="memdesc:a1c0a79ab2007d49c4169d9e6b9f7a5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fully-qualified path to the root of the <code>drake</code> source tree.  <a href="#a1c0a79ab2007d49c4169d9e6b9f7a5ed">More...</a><br /></td></tr>
<tr class="separator:a1c0a79ab2007d49c4169d9e6b9f7a5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fc6417d486672a49d923f8965b9fd3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76fc6417d486672a49d923f8965b9fd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a76fc6417d486672a49d923f8965b9fd3">ExtractDoubleOrThrow</a> (const T &amp;)</td></tr>
<tr class="memdesc:a76fc6417d486672a49d923f8965b9fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a ScalarType value to a double, failing at runtime (not compile time) if the type cannot be converted to a double.  <a href="#a76fc6417d486672a49d923f8965b9fd3">More...</a><br /></td></tr>
<tr class="separator:a76fc6417d486672a49d923f8965b9fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffe42a683dd67544fb4d499d082b16d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#acffe42a683dd67544fb4d499d082b16d">ExtractDoubleOrThrow</a> (<a class="el" href="classdouble.html">double</a> scalar)</td></tr>
<tr class="memdesc:acffe42a683dd67544fb4d499d082b16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>scalar</code> as a double. Never throws.  <a href="#acffe42a683dd67544fb4d499d082b16d">More...</a><br /></td></tr>
<tr class="separator:acffe42a683dd67544fb4d499d082b16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b89e049057c728694cdc3bceed1c01c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a0b89e049057c728694cdc3bceed1c01c">LoadedLibraryPath</a> (const std::string &amp;library_name)</td></tr>
<tr class="memdesc:a0b89e049057c728694cdc3bceed1c01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the absolute path of the library with the name <code>library_name</code> if that library was loaded in the current running process.  <a href="#a0b89e049057c728694cdc3bceed1c01c">More...</a><br /></td></tr>
<tr class="separator:a0b89e049057c728694cdc3bceed1c01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e39324a7578ec2fbb2f6ab2deb44629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a6e39324a7578ec2fbb2f6ab2deb44629">GetResourceSearchPaths</a> ()</td></tr>
<tr class="memdesc:a6e39324a7578ec2fbb2f6ab2deb44629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets current root directory value from a persistent variable.  <a href="#a6e39324a7578ec2fbb2f6ab2deb44629">More...</a><br /></td></tr>
<tr class="separator:a6e39324a7578ec2fbb2f6ab2deb44629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1da8ce358e8ed8503bf83a0489695fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ae1da8ce358e8ed8503bf83a0489695fa">AddResourceSearchPath</a> (std::string root_directory)</td></tr>
<tr class="memdesc:ae1da8ce358e8ed8503bf83a0489695fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a path in which resources are searched in a persistent variable.  <a href="#ae1da8ce358e8ed8503bf83a0489695fa">More...</a><br /></td></tr>
<tr class="separator:ae1da8ce358e8ed8503bf83a0489695fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1becb3d158eac50e74aa9f1921c3a2b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#aa06fbebac1e1ffc23617b782f072d79b">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a1becb3d158eac50e74aa9f1921c3a2b3">FindResource</a> (std::string resource_path)</td></tr>
<tr class="memdesc:a1becb3d158eac50e74aa9f1921c3a2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to locate a Drake resource named by the given <code>resource_path</code>.  <a href="#a1becb3d158eac50e74aa9f1921c3a2b3">More...</a><br /></td></tr>
<tr class="separator:a1becb3d158eac50e74aa9f1921c3a2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9171553d06ababb5f24e9c9ab26c6c7e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a9171553d06ababb5f24e9c9ab26c6c7e">FindResourceOrThrow</a> (std::string resource_path)</td></tr>
<tr class="memdesc:a9171553d06ababb5f24e9c9ab26c6c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for querying FindResource(resource_path) followed by <a class="el" href="classdrake_1_1_find_resource_result.html#ab0f22ae8e8a755aba48265ffd82e515d" title="Either returns the get_absolute_path() iff the resource was found, or else throws std::runtime_error...">FindResourceResult::get_absolute_path_or_throw()</a>.  <a href="#a9171553d06ababb5f24e9c9ab26c6c7e">More...</a><br /></td></tr>
<tr class="separator:a9171553d06ababb5f24e9c9ab26c6c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820665bdf5332e913c6bf67e38549d6b"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class T &gt; </td></tr>
<tr class="memitem:a820665bdf5332e913c6bf67e38549d6b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a820665bdf5332e913c6bf67e38549d6b">hash_append</a> (HashAlgorithm &amp;hasher, const T &amp;item) noexcept</td></tr>
<tr class="memdesc:a820665bdf5332e913c6bf67e38549d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for integral constants.  <a href="#a820665bdf5332e913c6bf67e38549d6b">More...</a><br /></td></tr>
<tr class="separator:a820665bdf5332e913c6bf67e38549d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51419dc11e1165f062e90cb9241b6dca"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class T &gt; </td></tr>
<tr class="memitem:a51419dc11e1165f062e90cb9241b6dca"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_enum&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a51419dc11e1165f062e90cb9241b6dca">hash_append</a> (HashAlgorithm &amp;hasher, const T &amp;item) noexcept</td></tr>
<tr class="memdesc:a51419dc11e1165f062e90cb9241b6dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for enumerations.  <a href="#a51419dc11e1165f062e90cb9241b6dca">More...</a><br /></td></tr>
<tr class="separator:a51419dc11e1165f062e90cb9241b6dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f077927b3589bef8694c7d92e53710"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class T &gt; </td></tr>
<tr class="memitem:ad7f077927b3589bef8694c7d92e53710"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ad7f077927b3589bef8694c7d92e53710">hash_append</a> (HashAlgorithm &amp;hasher, const T &amp;item) noexcept</td></tr>
<tr class="memdesc:ad7f077927b3589bef8694c7d92e53710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for floating point values.  <a href="#ad7f077927b3589bef8694c7d92e53710">More...</a><br /></td></tr>
<tr class="separator:ad7f077927b3589bef8694c7d92e53710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abcb9a7b5df5dcf6f77d4dd1fa1f05b"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class Traits , class Allocator &gt; </td></tr>
<tr class="memitem:a0abcb9a7b5df5dcf6f77d4dd1fa1f05b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a0abcb9a7b5df5dcf6f77d4dd1fa1f05b">hash_append</a> (HashAlgorithm &amp;hasher, const std::basic_string&lt; char, Traits, Allocator &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:a0abcb9a7b5df5dcf6f77d4dd1fa1f05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::string.  <a href="#a0abcb9a7b5df5dcf6f77d4dd1fa1f05b">More...</a><br /></td></tr>
<tr class="separator:a0abcb9a7b5df5dcf6f77d4dd1fa1f05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746d15e267a6399643c2ffe878f4680c"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a746d15e267a6399643c2ffe878f4680c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a746d15e267a6399643c2ffe878f4680c">hash_append</a> (HashAlgorithm &amp;hasher, const std::pair&lt; T1, T2 &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:a746d15e267a6399643c2ffe878f4680c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::pair.  <a href="#a746d15e267a6399643c2ffe878f4680c">More...</a><br /></td></tr>
<tr class="separator:a746d15e267a6399643c2ffe878f4680c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad834b266cfe39f1cc5b3aaf14f433af8"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class T &gt; </td></tr>
<tr class="memitem:ad834b266cfe39f1cc5b3aaf14f433af8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ad834b266cfe39f1cc5b3aaf14f433af8">hash_append</a> (HashAlgorithm &amp;hasher, const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">drake::optional</a>&lt; T &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:ad834b266cfe39f1cc5b3aaf14f433af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">drake::optional</a>.  <a href="#ad834b266cfe39f1cc5b3aaf14f433af8">More...</a><br /></td></tr>
<tr class="separator:ad834b266cfe39f1cc5b3aaf14f433af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337fbf2124183c6555c2d45989b03b15"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class Iter &gt; </td></tr>
<tr class="memitem:a337fbf2124183c6555c2d45989b03b15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a337fbf2124183c6555c2d45989b03b15">hash_append_range</a> (HashAlgorithm &amp;hasher, Iter begin, Iter <a class="el" href="multilane_2loader_8cc.html#a40411ea85b10f533943a99cb647b796d">end</a>) noexcept</td></tr>
<tr class="memdesc:a337fbf2124183c6555c2d45989b03b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for a range, as given by two iterators.  <a href="#a337fbf2124183c6555c2d45989b03b15">More...</a><br /></td></tr>
<tr class="separator:a337fbf2124183c6555c2d45989b03b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec36c65f95147192214391781b75b08"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class T1 , class T2 , class Compare , class Allocator &gt; </td></tr>
<tr class="memitem:a8ec36c65f95147192214391781b75b08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a8ec36c65f95147192214391781b75b08">hash_append</a> (HashAlgorithm &amp;hasher, const std::map&lt; T1, T2, Compare, Allocator &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:a8ec36c65f95147192214391781b75b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::map.  <a href="#a8ec36c65f95147192214391781b75b08">More...</a><br /></td></tr>
<tr class="separator:a8ec36c65f95147192214391781b75b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d528c457d14bb52a9b3e53e8cb9999"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm , class Key , class Compare , class Allocator &gt; </td></tr>
<tr class="memitem:a33d528c457d14bb52a9b3e53e8cb9999"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a33d528c457d14bb52a9b3e53e8cb9999">hash_append</a> (HashAlgorithm &amp;hasher, const std::set&lt; Key, Compare, Allocator &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:a33d528c457d14bb52a9b3e53e8cb9999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::set.  <a href="#a33d528c457d14bb52a9b3e53e8cb9999">More...</a><br /></td></tr>
<tr class="separator:a33d528c457d14bb52a9b3e53e8cb9999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd8151cc95b5b95de9a9b882e27ed84"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a3cd8151cc95b5b95de9a9b882e27ed84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a3cd8151cc95b5b95de9a9b882e27ed84">is_approx_equal_abstol</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;m1, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;m2, <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>)</td></tr>
<tr class="memdesc:a3cd8151cc95b5b95de9a9b882e27ed84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the two matrices are equal to within a certain absolute elementwise <code>tolerance</code>.  <a href="#a3cd8151cc95b5b95de9a9b882e27ed84">More...</a><br /></td></tr>
<tr class="separator:a3cd8151cc95b5b95de9a9b882e27ed84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c3f5f0514513155be9f674f2c2cd63"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ab8c3f5f0514513155be9f674f2c2cd63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ab8c3f5f0514513155be9f674f2c2cd63">IsApproxEqualAbsTolWithPermutedColumns</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;m1, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;m2, <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>)</td></tr>
<tr class="memdesc:ab8c3f5f0514513155be9f674f2c2cd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if a simple greedy search reveals a permutation of the columns of m2 to make the matrix equal to m1 to within a certain absolute elementwise <code>tolerance</code>.  <a href="#ab8c3f5f0514513155be9f674f2c2cd63">More...</a><br /></td></tr>
<tr class="separator:ab8c3f5f0514513155be9f674f2c2cd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983e5f23fd0a884e01038572bd3e24a2"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a983e5f23fd0a884e01038572bd3e24a2"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a983e5f23fd0a884e01038572bd3e24a2">static_pointer_cast</a> (std::unique_ptr&lt; U &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a983e5f23fd0a884e01038572bd3e24a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the object owned by the std::unique_ptr <code>other</code> from type <code>U</code> to <code>T</code>; no runtime type checking is performed.  <a href="#a983e5f23fd0a884e01038572bd3e24a2">More...</a><br /></td></tr>
<tr class="separator:a983e5f23fd0a884e01038572bd3e24a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53bd4a15e73e524b3f73c625ea88176"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab53bd4a15e73e524b3f73c625ea88176"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ab53bd4a15e73e524b3f73c625ea88176">dynamic_pointer_cast</a> (std::unique_ptr&lt; U &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ab53bd4a15e73e524b3f73c625ea88176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the object owned by the std::unique_ptr <code>other</code> from type <code>U</code> to <code>T</code>; if the cast fails, returns nullptr.  <a href="#ab53bd4a15e73e524b3f73c625ea88176">More...</a><br /></td></tr>
<tr class="separator:ab53bd4a15e73e524b3f73c625ea88176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd10687a188332bb1f67fb3acf28f208"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:acd10687a188332bb1f67fb3acf28f208"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#acd10687a188332bb1f67fb3acf28f208">dynamic_pointer_cast_or_throw</a> (std::unique_ptr&lt; U &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:acd10687a188332bb1f67fb3acf28f208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the object owned by the std::unique_ptr <code>other</code> from type <code>U</code> to <code>T</code>; if <code>other</code> is nullptr or the cast fails, throws a std::logic_error.  <a href="#acd10687a188332bb1f67fb3acf28f208">More...</a><br /></td></tr>
<tr class="separator:acd10687a188332bb1f67fb3acf28f208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd34aab6b779552b501ee5e92d2aff6b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; google::protobuf::io::FileInputStream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#acd34aab6b779552b501ee5e92d2aff6b">MakeFileInputStreamOrThrow</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:acd34aab6b779552b501ee5e92d2aff6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a self-closing FileInputStream for the file at the given <code>path</code>, or else throws std::runtime_error.  <a href="#acd34aab6b779552b501ee5e92d2aff6b">More...</a><br /></td></tr>
<tr class="separator:acd34aab6b779552b501ee5e92d2aff6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b6812b1ccb5ba802e724ef1082569c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae8b6812b1ccb5ba802e724ef1082569c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ae8b6812b1ccb5ba802e724ef1082569c">operator==</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>, const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>)</td></tr>
<tr class="memdesc:ae8b6812b1ccb5ba802e724ef1082569c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two pairs of the same type are equal iff their members are equal after sorting.  <a href="#ae8b6812b1ccb5ba802e724ef1082569c">More...</a><br /></td></tr>
<tr class="separator:ae8b6812b1ccb5ba802e724ef1082569c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfec653508bbfb544860dbfd0677bfa3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abfec653508bbfb544860dbfd0677bfa3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#abfec653508bbfb544860dbfd0677bfa3">operator&lt;</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>, const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>)</td></tr>
<tr class="memdesc:abfec653508bbfb544860dbfd0677bfa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two pairs using lexicographic ordering.  <a href="#abfec653508bbfb544860dbfd0677bfa3">More...</a><br /></td></tr>
<tr class="separator:abfec653508bbfb544860dbfd0677bfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642a411b9ac97aefd67450fd5717a890"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a642a411b9ac97aefd67450fd5717a890"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a642a411b9ac97aefd67450fd5717a890">operator!=</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>, const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>)</td></tr>
<tr class="memdesc:a642a411b9ac97aefd67450fd5717a890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether two <a class="el" href="structdrake_1_1_sorted_pair.html" title="This class is similar to the std::pair class. ">SortedPair</a> objects are not equal using <code>operator==</code>.  <a href="#a642a411b9ac97aefd67450fd5717a890">More...</a><br /></td></tr>
<tr class="separator:a642a411b9ac97aefd67450fd5717a890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140ed52150ccb7d8a9194eec633ba50d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a140ed52150ccb7d8a9194eec633ba50d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a140ed52150ccb7d8a9194eec633ba50d">operator&gt;</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>, const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>)</td></tr>
<tr class="memdesc:a140ed52150ccb7d8a9194eec633ba50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code>x &gt; y</code> using <code>operator&lt;</code>.  <a href="#a140ed52150ccb7d8a9194eec633ba50d">More...</a><br /></td></tr>
<tr class="separator:a140ed52150ccb7d8a9194eec633ba50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d76c69274d87b34a742dae799e2177f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6d76c69274d87b34a742dae799e2177f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a6d76c69274d87b34a742dae799e2177f">operator&lt;=</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>, const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>)</td></tr>
<tr class="memdesc:a6d76c69274d87b34a742dae799e2177f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code>x &lt;= y</code> using <code>operator&lt;</code>.  <a href="#a6d76c69274d87b34a742dae799e2177f">More...</a><br /></td></tr>
<tr class="separator:a6d76c69274d87b34a742dae799e2177f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa975aac6050ca9507bf9761707c383"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aaaa975aac6050ca9507bf9761707c383"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#aaaa975aac6050ca9507bf9761707c383">operator&gt;=</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>, const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>)</td></tr>
<tr class="memdesc:aaaa975aac6050ca9507bf9761707c383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code>x &gt;= y</code> using <code>operator&lt;</code>.  <a href="#aaaa975aac6050ca9507bf9761707c383">More...</a><br /></td></tr>
<tr class="separator:aaaa975aac6050ca9507bf9761707c383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d5210878ec865ee82bb87786eb996d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a87d5210878ec865ee82bb87786eb996d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; typename std::decay&lt; T &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a87d5210878ec865ee82bb87786eb996d">MakeSortedPair</a> (T &amp;&amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>, T &amp;&amp;<a class="el" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>)</td></tr>
<tr class="memdesc:a87d5210878ec865ee82bb87786eb996d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for creating a sorted pair from two objects.  <a href="#a87d5210878ec865ee82bb87786eb996d">More...</a><br /></td></tr>
<tr class="separator:a87d5210878ec865ee82bb87786eb996d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b4f4d56e6ad4e7f40d8d1010c577aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24b4f4d56e6ad4e7f40d8d1010c577aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a24b4f4d56e6ad4e7f40d8d1010c577aa">SortedVectorsHaveIntersection</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; T &gt; &amp;a, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a24b4f4d56e6ad4e7f40d8d1010c577aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for the existence of a non-empty intersection between two sorted <code>std::vector</code>'s.  <a href="#a24b4f4d56e6ad4e7f40d8d1010c577aa">More...</a><br /></td></tr>
<tr class="separator:a24b4f4d56e6ad4e7f40d8d1010c577aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f0b9085e94fbc8908dc1f99327e28b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a77f0b9085e94fbc8908dc1f99327e28b">ExtractDoubleOrThrow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a77f0b9085e94fbc8908dc1f99327e28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the symbolic expression's <a class="el" href="wrap__test__util__py_8cc.html#aee90379adb0307effb138f4871edbc5c">value()</a> as a double.  <a href="#a77f0b9085e94fbc8908dc1f99327e28b">More...</a><br /></td></tr>
<tr class="separator:a77f0b9085e94fbc8908dc1f99327e28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24b40e467980140b850478ea0b9e766"><td class="memTemplParams" colspan="2">template&lt;typename... Rest&gt; </td></tr>
<tr class="memitem:ab24b40e467980140b850478ea0b9e766"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ab24b40e467980140b850478ea0b9e766">cond</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;f_cond, <a class="el" href="classdouble.html">double</a> v_then, Rest... rest)</td></tr>
<tr class="memdesc:ab24b40e467980140b850478ea0b9e766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides specialization of <code>cond</code> function defined in <a class="el" href="cond_8h.html">drake/common/cond.h</a> file.  <a href="#ab24b40e467980140b850478ea0b9e766">More...</a><br /></td></tr>
<tr class="separator:ab24b40e467980140b850478ea0b9e766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848fb0ead47dfe2676e2ef81b8735e83"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a848fb0ead47dfe2676e2ef81b8735e83">temp_directory</a> ()</td></tr>
<tr class="memdesc:a848fb0ead47dfe2676e2ef81b8735e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a directory location suitable for temporary files.  <a href="#a848fb0ead47dfe2676e2ef81b8735e83">More...</a><br /></td></tr>
<tr class="separator:a848fb0ead47dfe2676e2ef81b8735e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a39e405b81569cc3895a2df555cc94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ae9a39e405b81569cc3895a2df555cc94">TEST_F</a> (BoolTestDouble, TypeCheck)</td></tr>
<tr class="separator:ae9a39e405b81569cc3895a2df555cc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bfb3dd9effddfede5e3f3041730ddc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ab4bfb3dd9effddfede5e3f3041730ddc">TEST_F</a> (BoolTestDouble, All)</td></tr>
<tr class="separator:ab4bfb3dd9effddfede5e3f3041730ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a4cb2bc34c0b4e572dc6749a5cacee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a92a4cb2bc34c0b4e572dc6749a5cacee">TEST_F</a> (BoolTestDouble, AllOf)</td></tr>
<tr class="separator:a92a4cb2bc34c0b4e572dc6749a5cacee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2c5dffca12c5f8f26c5bb45b1479eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a2d2c5dffca12c5f8f26c5bb45b1479eb">TEST_F</a> (BoolTestDouble, Any)</td></tr>
<tr class="separator:a2d2c5dffca12c5f8f26c5bb45b1479eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fefb94f6add4b38239872e4dba571cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a2fefb94f6add4b38239872e4dba571cc">TEST_F</a> (BoolTestDouble, AnyOf)</td></tr>
<tr class="separator:a2fefb94f6add4b38239872e4dba571cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638bb357c8971ab4b6ebe8d93f179dc2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a638bb357c8971ab4b6ebe8d93f179dc2">TEST_F</a> (BoolTestDouble, None)</td></tr>
<tr class="separator:a638bb357c8971ab4b6ebe8d93f179dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2c3702b8934972d9e49397ed08396d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a2b2c3702b8934972d9e49397ed08396d">TEST_F</a> (BoolTestDouble, NoneOf)</td></tr>
<tr class="separator:a2b2c3702b8934972d9e49397ed08396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004283903f81d21cc94eb73aa18341a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a004283903f81d21cc94eb73aa18341a5">TEST_F</a> (BoolTestAutoDiffXd, TypeCheck)</td></tr>
<tr class="separator:a004283903f81d21cc94eb73aa18341a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1b1953646f369814ae921ac2ab66c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a4b1b1953646f369814ae921ac2ab66c2">TEST_F</a> (BoolTestAutoDiffXd, AllOf)</td></tr>
<tr class="separator:a4b1b1953646f369814ae921ac2ab66c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17af6d498f61fbfa9257dd9fd42cb229"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a17af6d498f61fbfa9257dd9fd42cb229">TEST_F</a> (BoolTestAutoDiffXd, AnyOf)</td></tr>
<tr class="separator:a17af6d498f61fbfa9257dd9fd42cb229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8eb7eba9e1b2dec720119a653ca8230"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ac8eb7eba9e1b2dec720119a653ca8230">TEST_F</a> (BoolTestAutoDiffXd, NoneOf)</td></tr>
<tr class="separator:ac8eb7eba9e1b2dec720119a653ca8230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1796ec31610987787a90fbbf51f335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#afc1796ec31610987787a90fbbf51f335">TEST_F</a> (BoolTestSymbolic, TypeCheck)</td></tr>
<tr class="separator:afc1796ec31610987787a90fbbf51f335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6901decbab1de5d18defbf0eb6b6be6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a6901decbab1de5d18defbf0eb6b6be6c">TEST_F</a> (BoolTestSymbolic, All)</td></tr>
<tr class="separator:a6901decbab1de5d18defbf0eb6b6be6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d5ebb6dff61d4459fe61fb9439b8b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a55d5ebb6dff61d4459fe61fb9439b8b2">TEST_F</a> (BoolTestSymbolic, AllOf)</td></tr>
<tr class="separator:a55d5ebb6dff61d4459fe61fb9439b8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360b651f14b54e1be8c65c70a509944c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a360b651f14b54e1be8c65c70a509944c">TEST_F</a> (BoolTestSymbolic, Any)</td></tr>
<tr class="separator:a360b651f14b54e1be8c65c70a509944c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6957d642203b1b6f7637a4e18cdb97ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a6957d642203b1b6f7637a4e18cdb97ca">TEST_F</a> (BoolTestSymbolic, AnyOf)</td></tr>
<tr class="separator:a6957d642203b1b6f7637a4e18cdb97ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef09b51a00e8fc71f9dff2eba2c980cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#aef09b51a00e8fc71f9dff2eba2c980cb">TEST_F</a> (BoolTestSymbolic, None)</td></tr>
<tr class="separator:aef09b51a00e8fc71f9dff2eba2c980cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6167980d9923ff27cc21d6039b35773"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#aa6167980d9923ff27cc21d6039b35773">TEST_F</a> (BoolTestSymbolic, NoneOf)</td></tr>
<tr class="separator:aa6167980d9923ff27cc21d6039b35773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b529a6a9ee1d87147690b921194d47"><td class="memItemLeft" align="right" valign="top">::testing::AssertionResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a72b529a6a9ee1d87147690b921194d47">ExpectRotMat</a> (const Eigen::Matrix3d &amp;R, <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>)</td></tr>
<tr class="memdesc:a72b529a6a9ee1d87147690b921194d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expects that a rotation matrix belongs to SO(3): R  SO(3) =&gt; R R = I (orthonormal) det(R) = 1 (right-hand rule)  <a href="#a72b529a6a9ee1d87147690b921194d47">More...</a><br /></td></tr>
<tr class="separator:a72b529a6a9ee1d87147690b921194d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f4bdc9fbf5f6a31c67e1772620eff2"><td class="memItemLeft" align="right" valign="top">::testing::AssertionResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ad6f4bdc9fbf5f6a31c67e1772620eff2">CompareTransforms</a> (const Eigen::Isometry3d &amp;X_expected, const Eigen::Isometry3d &amp;X_actual, <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>)</td></tr>
<tr class="memdesc:ad6f4bdc9fbf5f6a31c67e1772620eff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two SE(3) Transforms.  <a href="#ad6f4bdc9fbf5f6a31c67e1772620eff2">More...</a><br /></td></tr>
<tr class="separator:ad6f4bdc9fbf5f6a31c67e1772620eff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886235c479e3d60c4d088505191293bc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a886235c479e3d60c4d088505191293bc"><td class="memTemplItemLeft" align="right" valign="top">::testing::AssertionResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a886235c479e3d60c4d088505191293bc">CompareMatrices</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;m1, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;m2, <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>=0.0, <a class="el" href="namespacedrake.html#a487584d4d770172ae2f665bde7462de2">MatrixCompareType</a> compare_type=<a class="el" href="namespacedrake.html#a487584d4d770172ae2f665bde7462de2adc4d53aa0d117d8b189b36d161af4e96">MatrixCompareType::absolute</a>)</td></tr>
<tr class="memdesc:a886235c479e3d60c4d088505191293bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two matrices to determine whether they are equal to within a certain threshold.  <a href="#a886235c479e3d60c4d088505191293bc">More...</a><br /></td></tr>
<tr class="separator:a886235c479e3d60c4d088505191293bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9decd0aba05654d37c4d7f3d82655c6"><td class="memTemplParams" colspan="2">template&lt;typename ToType , typename FromType &gt; </td></tr>
<tr class="memitem:ab9decd0aba05654d37c4d7f3d82655c6"><td class="memTemplItemLeft" align="right" valign="top">::testing::AssertionResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ab9decd0aba05654d37c4d7f3d82655c6">is_dynamic_castable</a> (const FromType *ptr)</td></tr>
<tr class="memdesc:ab9decd0aba05654d37c4d7f3d82655c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>ptr</code>, a pointer to <code>FromType</code> class, can be safely converted to a pointer to <code>ToType</code> class.  <a href="#ab9decd0aba05654d37c4d7f3d82655c6">More...</a><br /></td></tr>
<tr class="separator:ab9decd0aba05654d37c4d7f3d82655c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120160cb3dd89c5c7ae2543a3de457e8"><td class="memTemplParams" colspan="2">template&lt;typename ToType , typename FromType &gt; </td></tr>
<tr class="memitem:a120160cb3dd89c5c7ae2543a3de457e8"><td class="memTemplItemLeft" align="right" valign="top">::testing::AssertionResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a120160cb3dd89c5c7ae2543a3de457e8">is_dynamic_castable</a> (std::shared_ptr&lt; FromType &gt; ptr)</td></tr>
<tr class="memdesc:a120160cb3dd89c5c7ae2543a3de457e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>ptr</code>, a shared pointer to <code>FromType</code> class, can be safely converted to a shared pointer to <code>ToType</code> class.  <a href="#a120160cb3dd89c5c7ae2543a3de457e8">More...</a><br /></td></tr>
<tr class="separator:a120160cb3dd89c5c7ae2543a3de457e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada20909a7ef482cf1fecbe11bbcf67d4"><td class="memTemplParams" colspan="2">template&lt;typename ToType , typename FromType &gt; </td></tr>
<tr class="memitem:ada20909a7ef482cf1fecbe11bbcf67d4"><td class="memTemplItemLeft" align="right" valign="top">::testing::AssertionResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ada20909a7ef482cf1fecbe11bbcf67d4">is_dynamic_castable</a> (const std::unique_ptr&lt; FromType &gt; &amp;ptr)</td></tr>
<tr class="memdesc:ada20909a7ef482cf1fecbe11bbcf67d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>ptr</code>, a shared pointer to <code>FromType</code> class, can be safely converted to a shared pointer to <code>ToType</code> class.  <a href="#ada20909a7ef482cf1fecbe11bbcf67d4">More...</a><br /></td></tr>
<tr class="separator:ada20909a7ef482cf1fecbe11bbcf67d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa157c1d75c2e52df3370e5f458022ee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1logging.html#a9cae370466ffb304c10aebea42eca26b">logging::logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#aa157c1d75c2e52df3370e5f458022ee9">log</a> ()</td></tr>
<tr class="memdesc:aa157c1d75c2e52df3370e5f458022ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an instance of a logger to use for logging; for example:  <a href="#aa157c1d75c2e52df3370e5f458022ee9">More...</a><br /></td></tr>
<tr class="separator:aa157c1d75c2e52df3370e5f458022ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284550e79594f3112b7619c3f1be0be9"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename U &gt; </td></tr>
<tr class="memitem:a284550e79594f3112b7619c3f1be0be9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; U &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_unsigned&lt; U &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a284550e79594f3112b7619c3f1be0be9">operator==</a> (const U &amp;<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="separator:a284550e79594f3112b7619c3f1be0be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188637f54c49ee7427a3315f1f1a6f96"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename U &gt; </td></tr>
<tr class="memitem:a188637f54c49ee7427a3315f1f1a6f96"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; U &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_unsigned&lt; U &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a188637f54c49ee7427a3315f1f1a6f96">operator!=</a> (const U &amp;<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="separator:a188637f54c49ee7427a3315f1f1a6f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f92deeaa12f6173717e9f15297ce03f"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename U &gt; </td></tr>
<tr class="memitem:a6f92deeaa12f6173717e9f15297ce03f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; U &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_unsigned&lt; U &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a6f92deeaa12f6173717e9f15297ce03f">operator&lt;</a> (const U &amp;<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="separator:a6f92deeaa12f6173717e9f15297ce03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23da26daef061510be0f06706a4c486d"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename U &gt; </td></tr>
<tr class="memitem:a23da26daef061510be0f06706a4c486d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; U &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_unsigned&lt; U &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a23da26daef061510be0f06706a4c486d">operator&lt;=</a> (const U &amp;<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="separator:a23da26daef061510be0f06706a4c486d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad63634f4f0e3ea3ff76babb7569736b"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename U &gt; </td></tr>
<tr class="memitem:aad63634f4f0e3ea3ff76babb7569736b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; U &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_unsigned&lt; U &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#aad63634f4f0e3ea3ff76babb7569736b">operator&gt;</a> (const U &amp;<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="separator:aad63634f4f0e3ea3ff76babb7569736b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c515436fc115aad7d71d9bd403d0a1"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename U &gt; </td></tr>
<tr class="memitem:af3c515436fc115aad7d71d9bd403d0a1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; U &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;std::is_unsigned&lt; U &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#af3c515436fc115aad7d71d9bd403d0a1">operator&gt;=</a> (const U &amp;<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="separator:af3c515436fc115aad7d71d9bd403d0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade20b7bf635eecb13adbaac4df980af0"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:ade20b7bf635eecb13adbaac4df980af0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ade20b7bf635eecb13adbaac4df980af0">unused</a> (const Args &amp;...)</td></tr>
<tr class="memdesc:ade20b7bf635eecb13adbaac4df980af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documents the argument(s) as unused, placating GCC's -Wunused-parameter warning.  <a href="#ade20b7bf635eecb13adbaac4df980af0">More...</a><br /></td></tr>
<tr class="separator:ade20b7bf635eecb13adbaac4df980af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12856abe0ac8fe06ed302fc9d3db544"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#aa12856abe0ac8fe06ed302fc9d3db544">ComputeRegionOfAttraction</a> ()</td></tr>
<tr class="separator:aa12856abe0ac8fe06ed302fc9d3db544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">cond</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Constructs conditional expression (similar to Lisp's cond).</p>
<pre class="fragment">  cond(cond_1, expr_1,
       cond_2, expr_2,
          ...,   ...,
       cond_n, expr_n,
       expr_{n+1})
</pre><p>The value returned by the above cond expression is <code>expr_1</code> if <code>cond_1</code> is true; else if <code>cond_2</code> is true then <code>expr_2</code>; ... ; else if <code>cond_n</code> is true then <code>expr_n</code>. If none of the conditions are true, it returns <code>expr_{n+1}</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This functions assumes that <code>ScalarType</code> provides <code>operator&lt;</code> and the type of <code>f_cond</code> is the type of the return type of <code>operator&lt;(ScalarType, ScalarType)</code>. For example, <code><a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">symbolic::Expression</a></code> can be used as a <code>ScalarType</code> because it provides <code><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">symbolic::Formula</a> operator&lt;(symbolic::Expression, symbolic::Expression)</code>. </dd></dl>
</div></td></tr>
<tr class="memitem:a0b6d557a3ef060688cb028f17975ffca"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a0b6d557a3ef060688cb028f17975ffca"><td class="memTemplItemLeft" align="right" valign="top">ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a0b6d557a3ef060688cb028f17975ffca">cond</a> (const ScalarType &amp;e)</td></tr>
<tr class="separator:a0b6d557a3ef060688cb028f17975ffca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d122c5050b7d174b5a35e39c52bfb09"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename... Rest&gt; </td></tr>
<tr class="memitem:a1d122c5050b7d174b5a35e39c52bfb09"><td class="memTemplItemLeft" align="right" valign="top">ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a1d122c5050b7d174b5a35e39c52bfb09">cond</a> (const decltype(ScalarType()&lt; ScalarType()) &amp;f_cond, const ScalarType &amp;e_then, Rest... rest)</td></tr>
<tr class="separator:a1d122c5050b7d174b5a35e39c52bfb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a07869e660ffe730425feca7595de2273"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a07869e660ffe730425feca7595de2273">kQuaternionSize</a> = 4</td></tr>
<tr class="separator:a07869e660ffe730425feca7595de2273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af869092c52ed7cc9d2db40ce56050c7c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#af869092c52ed7cc9d2db40ce56050c7c">kSpaceDimension</a> = 3</td></tr>
<tr class="separator:af869092c52ed7cc9d2db40ce56050c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab5b0d99cafc2f6ae5812128cea27a3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#aeab5b0d99cafc2f6ae5812128cea27a3">kRpySize</a> = 3</td></tr>
<tr class="separator:aeab5b0d99cafc2f6ae5812128cea27a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ce1d9cce0ad61dd2f5a295c1a10fc8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a> = 6</td></tr>
<tr class="memdesc:ac9ce1d9cce0ad61dd2f5a295c1a10fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://en.wikipedia.org/wiki/Screw_theory#Twist">https://en.wikipedia.org/wiki/Screw_theory#Twist</a>  <a href="#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">More...</a><br /></td></tr>
<tr class="separator:ac9ce1d9cce0ad61dd2f5a295c1a10fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c55e4d8662e0986e79d11486334486"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a63c55e4d8662e0986e79d11486334486">kHomogeneousTransformSize</a> = 16</td></tr>
<tr class="memdesc:a63c55e4d8662e0986e79d11486334486"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="http://www.euclideanspace.com/maths/geometry/affine/matrix4x4/">http://www.euclideanspace.com/maths/geometry/affine/matrix4x4/</a>  <a href="#a63c55e4d8662e0986e79d11486334486">More...</a><br /></td></tr>
<tr class="separator:a63c55e4d8662e0986e79d11486334486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace32fe90adc0d2100ad4fc9f4bc6f79a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#ace32fe90adc0d2100ad4fc9f4bc6f79a">kRotmatSize</a> = <a class="el" href="namespacedrake.html#af869092c52ed7cc9d2db40ce56050c7c">kSpaceDimension</a> * <a class="el" href="namespacedrake.html#af869092c52ed7cc9d2db40ce56050c7c">kSpaceDimension</a></td></tr>
<tr class="separator:ace32fe90adc0d2100ad4fc9f4bc6f79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd293644b847dc4549de80a090d66625"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#acd293644b847dc4549de80a090d66625">nullopt</a> = stx::nullopt</td></tr>
<tr class="separator:acd293644b847dc4549de80a090d66625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329d1e7afba846a6ea6f8c2638fef7ec"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html#a329d1e7afba846a6ea6f8c2638fef7ec">kDrakeResourceRootEnvironmentVariableName</a></td></tr>
<tr class="memdesc:a329d1e7afba846a6ea6f8c2638fef7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the environment variable that provides the first place where FindResource attempts to look.  <a href="#a329d1e7afba846a6ea6f8c2638fef7ec">More...</a><br /></td></tr>
<tr class="separator:a329d1e7afba846a6ea6f8c2638fef7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a90d91e75997a81a48adea1e83caddde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d91e75997a81a48adea1e83caddde4">&#9670;&nbsp;</a></span>AngleAxis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a90d91e75997a81a48adea1e83caddde4">AngleAxis</a> =  Eigen::AngleAxis&lt;Scalar&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An AngleAxis templated on scalar type. </p>

</div>
</div>
<a id="a5f4077c4918078fb55bfb6b73968cb0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4077c4918078fb55bfb6b73968cb0a">&#9670;&nbsp;</a></span>AutoDiffd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a5f4077c4918078fb55bfb6b73968cb0a">AutoDiffd</a> =  Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, num_vars, 1&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An autodiff variable with <code>num_vars</code> partials. </p>

</div>
</div>
<a id="a790a072a62129732864a20e7a4743298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790a072a62129732864a20e7a4743298">&#9670;&nbsp;</a></span>AutoDiffVecd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a790a072a62129732864a20e7a4743298">AutoDiffVecd</a> =  Eigen::Matrix&lt;<a class="el" href="namespacedrake.html#a5f4077c4918078fb55bfb6b73968cb0a">AutoDiffd</a>&lt;num_vars&gt;, rows, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of <code>rows</code> autodiff variables, each with <code>num_vars</code> partials. </p>

</div>
</div>
<a id="a7b13142534d668d5d490b829b917fa16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b13142534d668d5d490b829b917fa16">&#9670;&nbsp;</a></span>AutoDiffVecXd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacedrake.html#a790a072a62129732864a20e7a4743298">AutoDiffVecd</a>&lt;Eigen::Dynamic, Eigen::Dynamic&gt; <a class="el" href="namespacedrake.html#a7b13142534d668d5d490b829b917fa16">AutoDiffVecXd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A dynamic-sized vector of autodiff variables, each with a dynamic-sized vector of partials. </p>

</div>
</div>
<a id="a35725b277b02aeb79f24fd7f724e6dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35725b277b02aeb79f24fd7f724e6dbc">&#9670;&nbsp;</a></span>AutoDiffXd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> =  Eigen::AutoDiffScalar&lt;Eigen::VectorXd&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An autodiff variable with a dynamic number of partials. </p>

</div>
</div>
<a id="a1f1c657c4d2cf400649123a7c2573d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1c657c4d2cf400649123a7c2573d5b">&#9670;&nbsp;</a></span>boolean</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a> =  typename <a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt;T&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias for a boolean-like value, conditioned on the scalar type <code>T</code>. </p>
<p>In many cases this will be a synonym for <code>bool</code>, e.g., when <code>T = double</code>. When <code>T = <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">symbolic::Expression</a></code>, this is a synonym for <code><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula. ">symbolic::Formula</a></code>. This is a convenience abbreviation for <a class="el" href="structdrake_1_1scalar__predicate.html#a945d5b96b85fa30cf7587ef08b38f3d2" title="The return type of predicates over T. ">scalar_predicate&lt;T&gt;::type</a>. </p>

</div>
</div>
<a id="a323dc8b0cc629c61d4da8feeaa8cd4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323dc8b0cc629c61d4da8feeaa8cd4f5">&#9670;&nbsp;</a></span>DefaultHash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a323dc8b0cc629c61d4da8feeaa8cd4f5">DefaultHash</a> =  <a class="el" href="structdrake_1_1uhash.html">drake::uhash</a>&lt;<a class="el" href="namespacedrake.html#a7d31e66897b203da66c76e11df55cd98">DefaultHasher</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default hashing functor, akin to std::hash. </p>

</div>
</div>
<a id="a7d31e66897b203da66c76e11df55cd98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d31e66897b203da66c76e11df55cd98">&#9670;&nbsp;</a></span>DefaultHasher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a7d31e66897b203da66c76e11df55cd98">DefaultHasher</a> =  <a class="el" href="classdrake_1_1detail_1_1_f_n_v1a_hasher.html">detail::FNV1aHasher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default HashAlgorithm concept implementation across Drake. </p>
<p>This is guaranteed to have a result_type of size_t to be compatible with std::hash. </p>

</div>
</div>
<a id="ae13e10d823b0e212fdfb27cc8f18065a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13e10d823b0e212fdfb27cc8f18065a">&#9670;&nbsp;</a></span>eigen_aligned_std_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#ae13e10d823b0e212fdfb27cc8f18065a">eigen_aligned_std_map</a> =  std::map&lt;Key, T, std::less&lt;Key&gt;, Eigen::aligned_allocator&lt;std::pair&lt;Key const, T&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A std::map that uses Eigen::aligned_allocator so that the contained types may be fixed-size <a class="el" href="namespace_eigen.html">Eigen</a> values. </p>

</div>
</div>
<a id="afcadf96d397f45d041d01bf17061bc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcadf96d397f45d041d01bf17061bc32">&#9670;&nbsp;</a></span>eigen_aligned_std_unordered_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#afcadf96d397f45d041d01bf17061bc32">eigen_aligned_std_unordered_map</a> =  std::unordered_map&lt;Key, T, std::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Eigen::aligned_allocator&lt;std::pair&lt;Key const, T&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A std::unordered_map that uses Eigen::aligned_allocator so that the contained types may be fixed-size <a class="el" href="namespace_eigen.html">Eigen</a> values. </p>

</div>
</div>
<a id="a4150555527b3cf871fe911f8776f301a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4150555527b3cf871fe911f8776f301a">&#9670;&nbsp;</a></span>eigen_aligned_std_vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a4150555527b3cf871fe911f8776f301a">eigen_aligned_std_vector</a> =  <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;T, Eigen::aligned_allocator&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A std::vector that uses Eigen::aligned_allocator so that the contained types may be fixed-size <a class="el" href="namespace_eigen.html">Eigen</a> values. </p>

</div>
</div>
<a id="a180d8e6bc7dcb53a32335226b15cca20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180d8e6bc7dcb53a32335226b15cca20">&#9670;&nbsp;</a></span>is_cloneable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a180d8e6bc7dcb53a32335226b15cca20">is_cloneable</a> =  is_cloneable_detail::is_cloneable_helper&lt;T, void&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="is_cloneable_doc"></a>Provides method for determining at run time if a class is "cloneable".</p>
<p><b>Usage</b></p>
<p>This gets used like <code>type_traits</code> functions (e.g., <code>is_copy_constructible</code>, <code>is_same</code>, etc.) To determine if a class is cloneable simply invoke:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="wrap__test__util__py_8cc.html#aee90379adb0307effb138f4871edbc5c">value</a> = <a class="code" href="namespacedrake.html#a180d8e6bc7dcb53a32335226b15cca20">drake::is_cloneable&lt;Foo&gt;::value</a>;</div></div><!-- fragment --><p>If <code>Foo</code> is cloneable, it will evaluate to true. It can also be used in compile-time tests (e.g., SFINAE and <code>static_assert</code>s):</p>
<div class="fragment"><div class="line">static_assert(<a class="code" href="wrap__test__util__py_8cc.html#aee90379adb0307effb138f4871edbc5c">is_cloneable&lt;Foo&gt;::value</a>, <span class="stringliteral">&quot;This method requires its classes to &quot;</span></div><div class="line">                                        <span class="stringliteral">&quot;be cloneable.&quot;</span>);</div></div><!-- fragment --><p><b>Definition of "cloneability"</b></p>
<p>To be cloneable, the class <code>Foo</code> must have a <em>public</em> method of the form: </p><div class="fragment"><div class="line">unique_ptr&lt;Foo&gt; Foo::Clone() <span class="keyword">const</span>;</div></div><!-- fragment --><p> Note that "friend" access for the is_cloneable-using class is not sufficient. The <code>Foo::Clone()</code> method must actually be public.</p>
<p>The pointer contained in the returned <code>unique_ptr</code> must point to a heap-allocated deep copy of the <em>concrete</em> object. This test can confirm the proper signature, but cannot confirm the heap-allocated deep copy. A Clone() method that doesn't return such a copy of the <em>concrete</em> object should be considered a malformed function.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is important to note, that a <code>Clone()</code> method that returns a <code>unique_ptr</code> to a <em>super</em> class is <em>not</em> sufficient to be cloneable. In other words the presence of: <div class="fragment"><div class="line">unique_ptr&lt;Base&gt; Derived::Clone() <span class="keyword">const</span>;</div></div><!-- fragment --> will not make the <code>Derived</code> class cloneable.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The class to test for cloneability. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9eb383d64a842ca9002f66b2e10254aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb383d64a842ca9002f66b2e10254aa">&#9670;&nbsp;</a></span>Isometry3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a> =  Eigen::Transform&lt;Scalar, 3, Eigen::Isometry&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Isometry templated on scalar type. </p>

</div>
</div>
<a id="a06406a5da633da84f911e2979aa48549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06406a5da633da84f911e2979aa48549">&#9670;&nbsp;</a></span>Matrix2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a> =  Eigen::Matrix&lt;Scalar, 2, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 2 rows and 2 columns, templated on scalar type. </p>

</div>
</div>
<a id="af13883859324817e6310d04a6d2fe206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13883859324817e6310d04a6d2fe206">&#9670;&nbsp;</a></span>Matrix2X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#af13883859324817e6310d04a6d2fe206">Matrix2X</a> =  Eigen::Matrix&lt;Scalar, 2, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 2 rows, dynamic columns, templated on scalar type. </p>

</div>
</div>
<a id="a3922cc0c6264e8ff225a6aa0dd993667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3922cc0c6264e8ff225a6aa0dd993667">&#9670;&nbsp;</a></span>Matrix3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a> =  Eigen::Matrix&lt;Scalar, 3, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 3 rows and 3 columns, templated on scalar type. </p>

</div>
</div>
<a id="acfe2dee57bc492bfbd96fe078b65ab00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe2dee57bc492bfbd96fe078b65ab00">&#9670;&nbsp;</a></span>Matrix3X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a> =  Eigen::Matrix&lt;Scalar, 3, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 3 rows, dynamic columns, templated on scalar type. </p>

</div>
</div>
<a id="ae74155a11dfcdaad0adc0349f0956148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74155a11dfcdaad0adc0349f0956148">&#9670;&nbsp;</a></span>Matrix4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a> =  Eigen::Matrix&lt;Scalar, 4, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 4 rows and 4 columns, templated on scalar type. </p>

</div>
</div>
<a id="a585f047d94502e00bfb163347abbc771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585f047d94502e00bfb163347abbc771">&#9670;&nbsp;</a></span>Matrix4X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a585f047d94502e00bfb163347abbc771">Matrix4X</a> =  Eigen::Matrix&lt;Scalar, 4, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 4 rows, dynamic columns, templated on scalar type. </p>

</div>
</div>
<a id="a11f9aa896d31437a219ed19fa944fe20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f9aa896d31437a219ed19fa944fe20">&#9670;&nbsp;</a></span>Matrix6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a> =  Eigen::Matrix&lt;Scalar, 6, 6&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 6 rows and 6 columns, templated on scalar type. </p>

</div>
</div>
<a id="a668e1152f8b876967b9093ae4d95298b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668e1152f8b876967b9093ae4d95298b">&#9670;&nbsp;</a></span>Matrix6X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a668e1152f8b876967b9093ae4d95298b">Matrix6X</a> =  Eigen::Matrix&lt;Scalar, 6, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 6 rows, dynamic columns, templated on scalar type. </p>

</div>
</div>
<a id="abc0efed85a04025fda487f0d59b71d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0efed85a04025fda487f0d59b71d5d">&#9670;&nbsp;</a></span>MatrixUpTo6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#abc0efed85a04025fda487f0d59b71d5d">MatrixUpTo6</a> =  Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic, 0, 6, 6&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of dynamic size templated on scalar type, up to a maximum of 6 rows and 6 columns. </p>
<p>Rectangular matrices, with different number of rows and columns, are allowed. </p>

</div>
</div>
<a id="a28c58d881c60e96f48a7a4e32a699b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c58d881c60e96f48a7a4e32a699b95">&#9670;&nbsp;</a></span>MatrixX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a> =  Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of dynamic size, templated on scalar type. </p>

</div>
</div>
<a id="a18b3378e99b86b40c4cb9a9ac0d19e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b3378e99b86b40c4cb9a9ac0d19e1f">&#9670;&nbsp;</a></span>negation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a18b3378e99b86b40c4cb9a9ac0d19e1f">negation</a> =  std::integral_constant&lt;<a class="el" href="classbool.html">bool</a>, !<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">T::value</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides backport of C++17 <code>std::negation</code>. </p>

</div>
</div>
<a id="a9f2ec0f640175b49517f43f37073bfc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2ec0f640175b49517f43f37073bfc8">&#9670;&nbsp;</a></span>optional</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a> =  stx::optional&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4156bf453a5b323356d7cc784dfdf084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4156bf453a5b323356d7cc784dfdf084">&#9670;&nbsp;</a></span>Quaternion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084">Quaternion</a> =  Eigen::Quaternion&lt;Scalar&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A quaternion templated on scalar type. </p>

</div>
</div>
<a id="aa06fbebac1e1ffc23617b782f072d79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06fbebac1e1ffc23617b782f072d79b">&#9670;&nbsp;</a></span>Result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#aa06fbebac1e1ffc23617b782f072d79b">Result</a> =  <a class="el" href="classdrake_1_1_find_resource_result.html">FindResourceResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc54e1f7aa3341a5f6b305705452d9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc54e1f7aa3341a5f6b305705452d9bd">&#9670;&nbsp;</a></span>RowVector2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#afc54e1f7aa3341a5f6b305705452d9bd">RowVector2</a> =  Eigen::Matrix&lt;Scalar, 1, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of size 2, templated on scalar type. </p>

</div>
</div>
<a id="aee4ae0d841ea1629551bf77fd5d9ec9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4ae0d841ea1629551bf77fd5d9ec9e">&#9670;&nbsp;</a></span>RowVector3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#aee4ae0d841ea1629551bf77fd5d9ec9e">RowVector3</a> =  Eigen::Matrix&lt;Scalar, 1, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of size 3, templated on scalar type. </p>

</div>
</div>
<a id="aa9b373b2971391d9054b431d8a3e4b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b373b2971391d9054b431d8a3e4b33">&#9670;&nbsp;</a></span>RowVector4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#aa9b373b2971391d9054b431d8a3e4b33">RowVector4</a> =  Eigen::Matrix&lt;Scalar, 1, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of size 4, templated on scalar type. </p>

</div>
</div>
<a id="a3ad88c2d704ccb2899d475d3ae05de14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad88c2d704ccb2899d475d3ae05de14">&#9670;&nbsp;</a></span>RowVector6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a3ad88c2d704ccb2899d475d3ae05de14">RowVector6</a> =  Eigen::Matrix&lt;Scalar, 1, 6&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of size 6. </p>

</div>
</div>
<a id="a218f39990d2d9090c7a25c9c18cbf832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218f39990d2d9090c7a25c9c18cbf832">&#9670;&nbsp;</a></span>RowVectorX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a218f39990d2d9090c7a25c9c18cbf832">RowVectorX</a> =  Eigen::Matrix&lt;Scalar, 1, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of any size, templated on scalar type. </p>

</div>
</div>
<a id="a91d93f987a8437295055eb3f46e99cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d93f987a8437295055eb3f46e99cbe">&#9670;&nbsp;</a></span>SpatialForce</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a91d93f987a8437295055eb3f46e99cbe">SpatialForce</a> =  Eigen::Matrix&lt;Scalar, 6, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector consisting of a concatenated rotational and translational force. </p>
<p>The wrench is a special case of a SpatialForce. For a general SpatialForce the rotational force can be a pure torque or the accumulation of moments and need not necessarily be a function of the force term. </p>

</div>
</div>
<a id="a3aa72a15690d6e4db2040ebc8814a74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa72a15690d6e4db2040ebc8814a74e">&#9670;&nbsp;</a></span>SquareTwistMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a3aa72a15690d6e4db2040ebc8814a74e">SquareTwistMatrix</a> =  Eigen::Matrix&lt;Scalar, <a class="el" href="namespacedrake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>, <a class="el" href="namespacedrake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A six-by-six matrix. </p>

</div>
</div>
<a id="a50f8d19f395776637448f26e734228f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f8d19f395776637448f26e734228f6">&#9670;&nbsp;</a></span>Translation3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a50f8d19f395776637448f26e734228f6">Translation3</a> =  Eigen::Translation&lt;Scalar, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A translation in 3D templated on scalar type. </p>

</div>
</div>
<a id="af30fe85a821bd0e0ab46f2e165c8e480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30fe85a821bd0e0ab46f2e165c8e480">&#9670;&nbsp;</a></span>TwistMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#af30fe85a821bd0e0ab46f2e165c8e480">TwistMatrix</a> =  Eigen::Matrix&lt;Scalar, <a class="el" href="namespacedrake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix with one twist per column, and dynamically many columns. </p>

</div>
</div>
<a id="afbf249fd84580486a877500bed5a0b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf249fd84580486a877500bed5a0b8e">&#9670;&nbsp;</a></span>TwistVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#afbf249fd84580486a877500bed5a0b8e">TwistVector</a> =  Eigen::Matrix&lt;Scalar, <a class="el" href="namespacedrake.html#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">kTwistSize</a>, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector consisting of one twist. </p>

</div>
</div>
<a id="aca2ad496fcfd4aab65f4f9eaf50759cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2ad496fcfd4aab65f4f9eaf50759cb">&#9670;&nbsp;</a></span>type_check_always_true</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#aca2ad496fcfd4aab65f4f9eaf50759cb">type_check_always_true</a> =  std::true_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a check which will return true for any type. </p>

</div>
</div>
<a id="a49de23e366bad92e3cab9c43a4088725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49de23e366bad92e3cab9c43a4088725">&#9670;&nbsp;</a></span>type_pack_extract</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a49de23e366bad92e3cab9c43a4088725">type_pack_extract</a> =  typename <a class="el" href="structdrake_1_1detail_1_1type__pack__extract__impl.html">detail::type_pack_extract_impl</a>&lt;T&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the inner template arguments (typename only) for a typename which is a template instantiation. </p>

</div>
</div>
<a id="ae98164c05774e687076c1562cf8d7593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98164c05774e687076c1562cf8d7593">&#9670;&nbsp;</a></span>variant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a> =  stx::variant&lt;Types...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af359dfdb84d6c13b606bb3ed7b821e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af359dfdb84d6c13b606bb3ed7b821e23">&#9670;&nbsp;</a></span>Vector1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#af359dfdb84d6c13b606bb3ed7b821e23">Vector1</a> =  Eigen::Matrix&lt;Scalar, 1, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 1 (that is, a scalar), templated on scalar type. </p>

</div>
</div>
<a id="a6d923e79e6e92c2556edd86520145077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d923e79e6e92c2556edd86520145077">&#9670;&nbsp;</a></span>Vector1d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a6d923e79e6e92c2556edd86520145077">Vector1d</a> =  Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, 1, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 1 of doubles. </p>

</div>
</div>
<a id="ab9f8b7dbd727440c2dd207bf43812f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f8b7dbd727440c2dd207bf43812f1e">&#9670;&nbsp;</a></span>Vector2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a> =  Eigen::Matrix&lt;Scalar, 2, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 2, templated on scalar type. </p>

</div>
</div>
<a id="a0ad29daab565ce347c4d1c5aae6a76c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad29daab565ce347c4d1c5aae6a76c2">&#9670;&nbsp;</a></span>Vector3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a> =  Eigen::Matrix&lt;Scalar, 3, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 3, templated on scalar type. </p>

</div>
</div>
<a id="af7e96394aef85f13f3fc84d3c3c238b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e96394aef85f13f3fc84d3c3c238b3">&#9670;&nbsp;</a></span>Vector4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a> =  Eigen::Matrix&lt;Scalar, 4, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 4, templated on scalar type. </p>

</div>
</div>
<a id="a14aa433aedda321a15238f2d4074d4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14aa433aedda321a15238f2d4074d4c3">&#9670;&nbsp;</a></span>Vector6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a> =  Eigen::Matrix&lt;Scalar, 6, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 6. </p>

</div>
</div>
<a id="adfbacdba0566fe8958cfafd659b4373f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbacdba0566fe8958cfafd659b4373f">&#9670;&nbsp;</a></span>VectorUpTo6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#adfbacdba0566fe8958cfafd659b4373f">VectorUpTo6</a> =  Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1, 0, 6, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of dynamic size templated on scalar type, up to a maximum of 6 elements. </p>

</div>
</div>
<a id="a77dd228fb4dd66a2c17dd3f7f38ffd85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77dd228fb4dd66a2c17dd3f7f38ffd85">&#9670;&nbsp;</a></span>VectorX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a> =  Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of any size, templated on scalar type. </p>

</div>
</div>
<a id="af98fed5f98c376f4d45fff56bb96c8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98fed5f98c376f4d45fff56bb96c8e1">&#9670;&nbsp;</a></span>WrenchVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake.html#af98fed5f98c376f4d45fff56bb96c8e1">WrenchVector</a> =  Eigen::Matrix&lt;Scalar, 6, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector consisting of one wrench (spatial force) = <code>[r X f; f]</code>, where f is a force (translational force) applied at a point <code>P</code> and <code>r</code> is the position vector from a point <code>O</code> (called the "moment center") to point <code>P</code>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a487584d4d770172ae2f665bde7462de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487584d4d770172ae2f665bde7462de2">&#9670;&nbsp;</a></span>MatrixCompareType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake.html#a487584d4d770172ae2f665bde7462de2">MatrixCompareType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a487584d4d770172ae2f665bde7462de2adc4d53aa0d117d8b189b36d161af4e96"></a>absolute&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a487584d4d770172ae2f665bde7462de2a99c483e1d11b1a279a2a1a3960528487"></a>relative&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a72383be4710d27584d0821effc6506a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72383be4710d27584d0821effc6506a5">&#9670;&nbsp;</a></span>RandomDistribution</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drake supports explicit reasoning about a few carefully chosen random distributions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a72383be4710d27584d0821effc6506a5a3ea9f7aca87fd7b64469a0d1119f0b50"></a>kUniform&#160;</td><td class="fielddoc"><p>Vector elements are independent and uniformly distributed  [0,1]. </p>
</td></tr>
<tr><td class="fieldname"><a id="a72383be4710d27584d0821effc6506a5ab933cd0242085c2dbf804dbf288ce7f0"></a>kGaussian&#160;</td><td class="fielddoc"><p>Vector elements are independent and drawn from a mean-zero, unit-variance normal distribution. </p>
</td></tr>
<tr><td class="fieldname"><a id="a72383be4710d27584d0821effc6506a5a601bf5851ffd28f5e6219c0f1945c8d6"></a>kExponential&#160;</td><td class="fielddoc"><p>Vector elements are independent and drawn from an exponential distribution with =1. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae1da8ce358e8ed8503bf83a0489695fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1da8ce358e8ed8503bf83a0489695fa">&#9670;&nbsp;</a></span>AddResourceSearchPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddResourceSearchPath </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>root_directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a path in which resources are searched in a persistent variable. </p>
<p>Paths are accumulated each time this function is called. It is searched after the path given by the environment variable but before the path that can be found with the sentinel <code>.drake-resource-sentinel</code>. This can be used to find data in installed distributions of drake (or in <code>pydrake</code>). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the given path is not absolute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcc2d90ce6051e150effadd72fac548c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc2d90ce6051e150effadd72fac548c">&#9670;&nbsp;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar drake::all </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks truth for all elements in matrix <code>m</code>. </p>
<p>This is identical to <code><a class="el" href="namespacedrake.html#adcc2d90ce6051e150effadd72fac548c" title="Checks truth for all elements in matrix m. ">Eigen::DenseBase::all()</a></code>, except this function allows for lazy evaluation, so works even when <a class="el" href="structdrake_1_1scalar__predicate.html#ab6fdcd06e06c892b3492eb6ea8f15be2" title="Whether type is bool. ">scalar_predicate&lt;&gt;::is_bool</a> does not hold. An empty matrix returns true. </p>

</div>
</div>
<a id="ac05a0ff629ccf3c38724b6d7f95e3bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05a0ff629ccf3c38724b6d7f95e3bce">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;typename Derived::Scalar&gt; drake::all_of </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate <code>pred</code> holds for all elements in the matrix <code>m</code>. </p>
<p>An empty matrix returns true. </p>

</div>
</div>
<a id="a624916a36af99a1ddfed08a25047cbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624916a36af99a1ddfed08a25047cbea">&#9670;&nbsp;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar drake::any </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks truth for at least one element in matrix <code>m</code>. </p>
<p>This is identical to <code><a class="el" href="namespacedrake.html#a624916a36af99a1ddfed08a25047cbea" title="Checks truth for at least one element in matrix m. ">Eigen::DenseBase::any()</a></code>, except this function allows for lazy evaluation, so works even when <a class="el" href="structdrake_1_1scalar__predicate.html#ab6fdcd06e06c892b3492eb6ea8f15be2" title="Whether type is bool. ">scalar_predicate&lt;&gt;::is_bool</a> does not hold. An empty matrix returns false. </p>

</div>
</div>
<a id="a66f0ced433e025116cf38c1cf2db6b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f0ced433e025116cf38c1cf2db6b76">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;typename Derived::Scalar&gt; drake::any_of </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate <code>pred</code> holds for at least one element in the matrix <code>m</code>. </p>
<p>An empty matrix returns false. </p>

</div>
</div>
<a id="a3c86a37d7ac815e5d42ab9d67363c14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c86a37d7ac815e5d42ab9d67363c14e">&#9670;&nbsp;</a></span>autodiffxd_make_coherent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drake::autodiffxd_make_coherent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &amp;&#160;</td>
          <td class="paramname"><em>donor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> *&#160;</td>
          <td class="paramname"><em>recipient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the derviatives of the recipient coherent with respect to those of the donor variable (see <a class="el" href="autodiffxd_8h.html">drake/common/autodiffxd.h</a>). </p>
<p>If the recipient's derivatives are already populated with a vector of the same size as that of the donor, variables pass through unchanged. An exception is thrown when there are nonempty vectors of different sizes. </p>

</div>
</div>
<a id="a1d04dd581311ecdd2bbaaca3c1d1ff34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d04dd581311ecdd2bbaaca3c1d1ff34">&#9670;&nbsp;</a></span>autodiffxd_make_coherent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drake::autodiffxd_make_coherent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a439ef8526114ad731981ac00415e6975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439ef8526114ad731981ac00415e6975">&#9670;&nbsp;</a></span>autodiffxd_make_coherent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drake::autodiffxd_make_coherent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a886235c479e3d60c4d088505191293bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886235c479e3d60c4d088505191293bc">&#9670;&nbsp;</a></span>CompareMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::testing::AssertionResult drake::CompareMatrices </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a487584d4d770172ae2f665bde7462de2">MatrixCompareType</a>&#160;</td>
          <td class="paramname"><em>compare_type</em> = <code><a class="el" href="namespacedrake.html#a487584d4d770172ae2f665bde7462de2adc4d53aa0d117d8b189b36d161af4e96">MatrixCompareType::absolute</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two matrices to determine whether they are equal to within a certain threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The first matrix to compare. </td></tr>
    <tr><td class="paramname">m2</td><td>The second matrix to compare. </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance for determining equivalence. </td></tr>
    <tr><td class="paramname">compare_type</td><td>Whether the tolereance is absolute or relative. </td></tr>
    <tr><td class="paramname">explanation</td><td>A pointer to a string variable for saving an explanation of why <code>m1</code> and <code>m2</code> are unequal. This parameter is optional and defaults to <code>nullptr</code>. If this is <code>nullptr</code> and <code>m1</code> and <code>m2</code> are not equal, an explanation is logged as an error message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two matrices are equal based on the specified tolerance. </dd></dl>

</div>
</div>
<a id="ad6f4bdc9fbf5f6a31c67e1772620eff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f4bdc9fbf5f6a31c67e1772620eff2">&#9670;&nbsp;</a></span>CompareTransforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">testing::AssertionResult CompareTransforms </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Isometry3d &amp;&#160;</td>
          <td class="paramname"><em>X_expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Isometry3d &amp;&#160;</td>
          <td class="paramname"><em>X_actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two SE(3) Transforms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X_expected</td><td>Expected SE(3) transform. </td></tr>
    <tr><td class="paramname">X_actual</td><td>Actual SE(3) transform. </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance for determining equivalence for the rotation matrix cases (using ExpectRotMat) and comparing both transforms as matrices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa12856abe0ac8fe06ed302fc9d3db544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12856abe0ac8fe06ed302fc9d3db544">&#9670;&nbsp;</a></span>ComputeRegionOfAttraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::ComputeRegionOfAttraction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b6d557a3ef060688cb028f17975ffca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6d557a3ef060688cb028f17975ffca">&#9670;&nbsp;</a></span>cond() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarType drake::cond </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d122c5050b7d174b5a35e39c52bfb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d122c5050b7d174b5a35e39c52bfb09">&#9670;&nbsp;</a></span>cond() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScalarType drake::cond </td>
          <td>(</td>
          <td class="paramtype">const decltype(ScalarType()&lt; ScalarType()) &amp;&#160;</td>
          <td class="paramname"><em>f_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>e_then</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8c0e9e4214ab7f97568cc8792859e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c0e9e4214ab7f97568cc8792859e32">&#9670;&nbsp;</a></span>cond() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::AutoDiffScalar&lt; typename Eigen::internal::remove_all&lt;DerType&gt;::type::PlainObject&gt; drake::cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>f_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::AutoDiffScalar&lt; DerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>e_then</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides special case of cond expression for Eigen::AutoDiffScalar type. </p>

</div>
</div>
<a id="ab24b40e467980140b850478ea0b9e766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24b40e467980140b850478ea0b9e766">&#9670;&nbsp;</a></span>cond() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> drake::cond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v_then</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides specialization of <code>cond</code> function defined in <a class="el" href="cond_8h.html">drake/common/cond.h</a> file. </p>
<p>This specialization is required to handle <code>double</code> to <code><a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">symbolic::Expression</a></code> conversion so that we can write one such as <code>cond(x &gt; 0.0, 1.0, -1.0)</code>. </p>

</div>
</div>
<a id="ab53bd4a15e73e524b3f73c625ea88176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53bd4a15e73e524b3f73c625ea88176">&#9670;&nbsp;</a></span>dynamic_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; drake::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the object owned by the std::unique_ptr <code>other</code> from type <code>U</code> to <code>T</code>; if the cast fails, returns nullptr. </p>
<p>Casting is performed using <code>dynamic_cast</code> on the managed value (i.e., the result of <code>other.get()</code>). On success, <code>other</code>'s managed value is transferred to the result and <code>other</code> is empty; on failure, <code>other</code> will retain its original managed value and the result is empty. As with <code>dynamic_cast</code>, casting nullptr to anything always succeeds, so a nullptr result could indicate either that the argument was nullptr or that the cast failed.</p>
<p>This method is analogous to the built-in std::dynamic_pointer_cast that operates on a std::shared_ptr.</p>
<p>Note that this function only supports default deleters. </p>

</div>
</div>
<a id="acd10687a188332bb1f67fb3acf28f208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd10687a188332bb1f67fb3acf28f208">&#9670;&nbsp;</a></span>dynamic_pointer_cast_or_throw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; drake::dynamic_pointer_cast_or_throw </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts the object owned by the std::unique_ptr <code>other</code> from type <code>U</code> to <code>T</code>; if <code>other</code> is nullptr or the cast fails, throws a std::logic_error. </p>
<p>Casting is performed using <code>dynamic_cast</code> on the managed value (i.e., the result of <code>other.get()</code>). On success, <code>other</code>'s managed value is transferred to the result and <code>other</code> is empty; on failure, <code>other</code> will retain its original managed value.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the cast fails.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this function only supports default deleters. </p>

</div>
</div>
<a id="a72b529a6a9ee1d87147690b921194d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b529a6a9ee1d87147690b921194d47">&#9670;&nbsp;</a></span>ExpectRotMat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">testing::AssertionResult ExpectRotMat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix3d &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expects that a rotation matrix belongs to SO(3): R  SO(3) =&gt; R R = I (orthonormal) det(R) = 1 (right-hand rule) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>Rotation matrix. </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance for determining equivalence for the orthonormal and right-hand rule cases. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76fc6417d486672a49d923f8965b9fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fc6417d486672a49d923f8965b9fd3">&#9670;&nbsp;</a></span>ExtractDoubleOrThrow() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> drake::ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a ScalarType value to a double, failing at runtime (not compile time) if the type cannot be converted to a double. </p>
<p>This function is useful for writing ScalarType-generic code that (1) can reasonably discard any supplemental scalar data, e.g., the derivatives of an AutoDiffScalar, and (2) is reasonable to fail at runtime if the extraction fails.</p>
<p>The default implementation throws an exception. ScalarTypes that can hold a numeric value must overload this method to provide an appropriate extraction. An overload for <code>double</code> is already provided.</p>
<p>See <a class="el" href="autodiff__overloads_8h.html" title="Overloads for STL mathematical operations on AutoDiffScalar. ">autodiff_overloads.h</a> to use this with <a class="el" href="namespace_eigen.html">Eigen</a>'s AutoDiffScalar. See <a class="el" href="symbolic__expression_8h.html">symbolic_expression.h</a> to use this with <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">symbolic::Expression</a>. </p>

</div>
</div>
<a id="acffe42a683dd67544fb4d499d082b16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffe42a683dd67544fb4d499d082b16d">&#9670;&nbsp;</a></span>ExtractDoubleOrThrow() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> drake::ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>scalar</code> as a double. Never throws. </p>

</div>
</div>
<a id="aa9721f3a5897b05ef2168f7a6d886dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9721f3a5897b05ef2168f7a6d886dc8">&#9670;&nbsp;</a></span>ExtractDoubleOrThrow() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> drake::ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype">const Eigen::AutoDiffScalar&lt; DerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the autodiff scalar's <a class="el" href="wrap__test__util__py_8cc.html#aee90379adb0307effb138f4871edbc5c">value()</a> as a double. </p>
<p>Never throws. Overloads ExtractDoubleOrThrow from <a class="el" href="extract__double_8h.html">common/extract_double.h</a>. </p>

</div>
</div>
<a id="a77f0b9085e94fbc8908dc1f99327e28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f0b9085e94fbc8908dc1f99327e28b">&#9670;&nbsp;</a></span>ExtractDoubleOrThrow() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the symbolic expression's <a class="el" href="wrap__test__util__py_8cc.html#aee90379adb0307effb138f4871edbc5c">value()</a> as a double. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if it is not possible to evaluate the symbolic expression with an empty environment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1becb3d158eac50e74aa9f1921c3a2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1becb3d158eac50e74aa9f1921c3a2b3">&#9670;&nbsp;</a></span>FindResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_find_resource_result.html">FindResourceResult</a> FindResource </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>resource_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to locate a Drake resource named by the given <code>resource_path</code>. </p>
<p>The <code>resource_path</code> refers to the relative path within the Drake source repository, prepended with <code>drake/</code>. For example, to find the source file <code>examples/pendulum/Pendulum.urdf</code>, the <code>resource_path</code> would be <code>drake/examples/pendulum/Pendulum.urdf</code>. Paths that do not start with <code>drake/</code> will return a failed result.</p>
<p>The search scans for the resource in the following places and in the following order:</p>
<ol type="1">
<li>In the DRAKE_RESOURCE_ROOT environment variable</li>
<li>In the directories specified by <code><a class="el" href="namespacedrake.html#ae1da8ce358e8ed8503bf83a0489695fa" title="Adds a path in which resources are searched in a persistent variable. ">AddResourceSearchPath()</a></code> and</li>
<li>In the drake source workspace.</li>
</ol>
<p>If all of these are unavailable, or do not have the resource, then it will return a failed result. </p>

</div>
</div>
<a id="a9171553d06ababb5f24e9c9ab26c6c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9171553d06ababb5f24e9c9ab26c6c7e">&#9670;&nbsp;</a></span>FindResourceOrThrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string FindResourceOrThrow </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>resource_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient wrapper for querying FindResource(resource_path) followed by <a class="el" href="classdrake_1_1_find_resource_result.html#ab0f22ae8e8a755aba48265ffd82e515d" title="Either returns the get_absolute_path() iff the resource was found, or else throws std::runtime_error...">FindResourceResult::get_absolute_path_or_throw()</a>. </p>

</div>
</div>
<a id="a1c0a79ab2007d49c4169d9e6b9f7a5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0a79ab2007d49c4169d9e6b9f7a5ed">&#9670;&nbsp;</a></span>GetDrakePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetDrakePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the fully-qualified path to the root of the <code>drake</code> source tree. </p>

</div>
</div>
<a id="a6e39324a7578ec2fbb2f6ab2deb44629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e39324a7578ec2fbb2f6ab2deb44629">&#9670;&nbsp;</a></span>GetResourceSearchPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; std::string &gt; GetResourceSearchPaths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets current root directory value from a persistent variable. </p>

</div>
</div>
<a id="a820665bdf5332e913c6bf67e38549d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820665bdf5332e913c6bf67e38549d6b">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_integral&lt;T&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>&gt; drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for integral constants. </p>

</div>
</div>
<a id="a51419dc11e1165f062e90cb9241b6dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51419dc11e1165f062e90cb9241b6dca">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_enum&lt;T&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>&gt; drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for enumerations. </p>

</div>
</div>
<a id="ad7f077927b3589bef8694c7d92e53710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f077927b3589bef8694c7d92e53710">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point&lt;T&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>&gt; drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for floating point values. </p>

</div>
</div>
<a id="a0abcb9a7b5df5dcf6f77d4dd1fa1f05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abcb9a7b5df5dcf6f77d4dd1fa1f05b">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; char, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::string. </p>
<p>(Technically, any string based on <code>CharT = char</code>.) </p>

</div>
</div>
<a id="a746d15e267a6399643c2ffe878f4680c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746d15e267a6399643c2ffe878f4680c">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::pair. </p>

</div>
</div>
<a id="ad834b266cfe39f1cc5b3aaf14f433af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad834b266cfe39f1cc5b3aaf14f433af8">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">drake::optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">drake::optional</a>. </p>
<p>Note that <code>std::hash&lt;std::optional&lt;T&gt;&gt;</code> provides the peculiar invariant that the hash of an <code>optional</code> bearing a value <code>v</code> shall evaluate to the same hash as that of the value <code>v</code> itself. Hash operations implemented with this <code>hash_append</code> do <em>not</em> provide that invariant. </p>

</div>
</div>
<a id="a8ec36c65f95147192214391781b75b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec36c65f95147192214391781b75b08">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; T1, T2, Compare, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::map. </p>
<p>Note that there is no <code>hash_append</code> overload for <code>std::unordered_map</code>, and such an overload must never appear. See n3980.html::unordered for details. </p>

</div>
</div>
<a id="a33d528c457d14bb52a9b3e53e8cb9999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d528c457d14bb52a9b3e53e8cb9999">&#9670;&nbsp;</a></span>hash_append() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drake::hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; Key, Compare, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::set. </p>
<p>Note that there is no <code>hash_append</code> overload for <code>std::unordered_set</code>, and such an overload must never appear. See n3980.html::unordered for details. </p>

</div>
</div>
<a id="a337fbf2124183c6555c2d45989b03b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337fbf2124183c6555c2d45989b03b15">&#9670;&nbsp;</a></span>hash_append_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drake::hash_append_range </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for a range, as given by two iterators. </p>

</div>
</div>
<a id="ad14dd00683f82b89dc0f08f9adec904e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14dd00683f82b89dc0f08f9adec904e">&#9670;&nbsp;</a></span>if_then_else() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> drake::if_then_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>f_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v_then</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v_else</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides if-then-else expression for double. </p>
<p>The value returned by the if-then-else expression is <code>v_then</code> if <code>f_cond</code> is <code>true</code>. Otherwise, it returns <code>v_else</code>. The semantics is similar but not exactly the same as C++'s conditional expression constructed by its ternary operator, <code></code>?:. In <code>if_then_else(f_cond, v_then, v_else)</code>, both of <code>v_then</code> and <code>v_else</code> are evaluated regardless of the evaluation of <code>f_cond</code>. In contrast, only one of <code>v_then</code> or <code>v_else</code> is evaluated in C++'s conditional expression <code>f_cond ? v_then : v_else</code>. </p>

</div>
</div>
<a id="af52cba62721f6b29c99a83ec9b192873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52cba62721f6b29c99a83ec9b192873">&#9670;&nbsp;</a></span>if_then_else() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::AutoDiffScalar&lt; typename Eigen::internal::remove_all&lt;DerType1&gt;::type::PlainObject&gt; drake::if_then_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>f_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::AutoDiffScalar&lt; DerType1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::AutoDiffScalar&lt; DerType2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides if-then-else expression for Eigen::AutoDiffScalar type. </p>
<p>To support <a class="el" href="namespace_eigen.html">Eigen</a>'s generic expressions, we use casting to the plain object after applying Eigen::internal::remove_all. It is based on the <a class="el" href="namespace_eigen.html">Eigen</a>'s implementation of min/max function for AutoDiffScalar type (<a href="https://bitbucket.org/eigen/eigen/src/10a1de58614569c9250df88bdfc6402024687bc6/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h?at=default&fileviewer=file-view-default#AutoDiffScalar.h-546">https://bitbucket.org/eigen/eigen/src/10a1de58614569c9250df88bdfc6402024687bc6/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h?at=default&amp;fileviewer=file-view-default#AutoDiffScalar.h-546</a>). </p>

</div>
</div>
<a id="a3cd8151cc95b5b95de9a9b882e27ed84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd8151cc95b5b95de9a9b882e27ed84">&#9670;&nbsp;</a></span>is_approx_equal_abstol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::is_approx_equal_abstol </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if and only if the two matrices are equal to within a certain absolute elementwise <code>tolerance</code>. </p>
<p>Special values (infinities, NaN, etc.) do not compare as equal elements. </p>

</div>
</div>
<a id="ab9decd0aba05654d37c4d7f3d82655c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9decd0aba05654d37c4d7f3d82655c6">&#9670;&nbsp;</a></span>is_dynamic_castable() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::testing::AssertionResult drake::is_dynamic_castable </td>
          <td>(</td>
          <td class="paramtype">const FromType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>ptr</code>, a pointer to <code>FromType</code> class, can be safely converted to a pointer to <code>ToType</code> class. </p>
<p>Our motivation is to provide a good diagnostic for what <code>ptr</code> <em>actually</em> was when the test fails.</p>
<p>Here is an illustrative code snippet. We assume that <code>Prius</code> and <code>Camry</code> are derived classes of <code>Car</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Car* prius = <span class="keyword">new</span> Prius{};</div><div class="line"></div><div class="line"><span class="comment">// The following assertion fails without diagnostic info.</span></div><div class="line">EXPECT_TRUE(dynamic_cast&lt;Camry&gt;(ptr) != <span class="keyword">nullptr</span>)</div><div class="line"></div><div class="line"><span class="comment">// The following assertion returns `::testing::AssertionFailure()` with</span></div><div class="line"><span class="comment">// diagnostic info attached.</span></div><div class="line">EXPECT_TRUE(<a class="code" href="namespacedrake.html#ab9decd0aba05654d37c4d7f3d82655c6">is_dynamic_castable</a>&lt;Camry&gt;(prius));</div><div class="line"><span class="comment">// Output:</span></div><div class="line"><span class="comment">// Value of: is_dynamic_castable&lt;Camry&gt;(prius)</span></div><div class="line"><span class="comment">// Actual: false (is_dynamic_castable&lt;Camry&gt;(Car* ptr) failed</span></div><div class="line"><span class="comment">//                because ptr is of dynamic type Prius.)</span></div><div class="line"><span class="comment">// Expected: true</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a120160cb3dd89c5c7ae2543a3de457e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120160cb3dd89c5c7ae2543a3de457e8">&#9670;&nbsp;</a></span>is_dynamic_castable() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::testing::AssertionResult drake::is_dynamic_castable </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; FromType &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>ptr</code>, a shared pointer to <code>FromType</code> class, can be safely converted to a shared pointer to <code>ToType</code> class. </p>
<p>Our motivation is to provide a good diagnostic for what <code>ptr</code> <em>actually</em> was when the test fails. </p>

</div>
</div>
<a id="ada20909a7ef482cf1fecbe11bbcf67d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada20909a7ef482cf1fecbe11bbcf67d4">&#9670;&nbsp;</a></span>is_dynamic_castable() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">::testing::AssertionResult drake::is_dynamic_castable </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; FromType &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>ptr</code>, a shared pointer to <code>FromType</code> class, can be safely converted to a shared pointer to <code>ToType</code> class. </p>
<p>Our motivation is to provide a good diagnostic for what <code>ptr</code> <em>actually</em> was when the test fails. </p>

</div>
</div>
<a id="ab8c3f5f0514513155be9f674f2c2cd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c3f5f0514513155be9f674f2c2cd63">&#9670;&nbsp;</a></span>IsApproxEqualAbsTolWithPermutedColumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::IsApproxEqualAbsTolWithPermutedColumns </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if and only if a simple greedy search reveals a permutation of the columns of m2 to make the matrix equal to m1 to within a certain absolute elementwise <code>tolerance</code>. </p>
<p>E.g., there exists a P such that </p><pre>
   forall i,j,  |m1 - m2*P|_{i,j} &lt;= tolerance
   where P is a permutation matrix:
      P(i,j)={0,1}, sum_i P(i,j)=1, sum_j P(i,j)=1.
</pre><p> Note: Returns false for matrices of different sizes. Note: The current implementation is O(n^2) in the number of columns. Note: In marginal cases (with similar but not identical columns) this algorithm can fail to find a permutation P even if it exists because it accepts the first column match (m1(i),m2(j)) and removes m2(j) from the pool. It is possible that other columns of m2 would also match m1(i) but that m2(j) is the only match possible for a later column of m1. </p>

</div>
</div>
<a id="a0b89e049057c728694cdc3bceed1c01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b89e049057c728694cdc3bceed1c01c">&#9670;&nbsp;</a></span>LoadedLibraryPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; std::string &gt; LoadedLibraryPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>library_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the absolute path of the library with the name <code>library_name</code> if that library was loaded in the current running process. </p>
<p>Otherwise it returns an empty optional. </p>

</div>
</div>
<a id="aa157c1d75c2e52df3370e5f458022ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa157c1d75c2e52df3370e5f458022ee9">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1logging.html#a9cae370466ffb304c10aebea42eca26b">logging::logger</a> * log </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an instance of a logger to use for logging; for example: </p>
<pre>
  <a class="el" href="namespacedrake.html#aa157c1d75c2e52df3370e5f458022ee9" title="Retrieve an instance of a logger to use for logging; for example: ">drake::log()</a>-&gt;info("potato!")
</pre><p>See the <a class="el" href="text__logging_8h.html" title="This is the entry point for all text logging within Drake. ">text_logging.h</a> documentation for a short tutorial. </p>

</div>
</div>
<a id="acd34aab6b779552b501ee5e92d2aff6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd34aab6b779552b501ee5e92d2aff6b">&#9670;&nbsp;</a></span>MakeFileInputStreamOrThrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; google::protobuf::io::FileInputStream &gt; MakeFileInputStreamOrThrow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a self-closing FileInputStream for the file at the given <code>path</code>, or else throws std::runtime_error. </p>

</div>
</div>
<a id="a87d5210878ec865ee82bb87786eb996d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d5210878ec865ee82bb87786eb996d">&#9670;&nbsp;</a></span>MakeSortedPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt;typename std::decay&lt;T&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&gt; drake::MakeSortedPair </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for creating a sorted pair from two objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first_ object. </td></tr>
    <tr><td class="paramname">y</td><td>The second_ object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly-constructed <a class="el" href="structdrake_1_1_sorted_pair.html" title="This class is similar to the std::pair class. ">SortedPair</a> object. </dd></dl>

</div>
</div>
<a id="ae366b03370cd023e04f43610e658c6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae366b03370cd023e04f43610e658c6ae">&#9670;&nbsp;</a></span>MaybeGetDrakePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; std::string &gt; MaybeGetDrakePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Returns the fully-qualified path to the first folder containing Drake resources as located by FindResource, or nullopt if none is found. </p>
<p>For example <code>${result}/examples/pendulum/Pendulum.urdf</code> would be the path to the Pendulum example's URDF resource.</p>
<p>Most users should prefer <a class="el" href="namespacedrake.html#a1becb3d158eac50e74aa9f1921c3a2b3" title="Attempts to locate a Drake resource named by the given resource_path. ">FindResource()</a> or <a class="el" href="namespacedrake.html#a9171553d06ababb5f24e9c9ab26c6c7e" title="Convenient wrapper for querying FindResource(resource_path) followed by FindResourceResult::get_absol...">FindResourceOrThrow()</a> to locate Drake resources for a specific resource filename. This method only exists for legacy compatibility reasons, and might eventually be removed. </p>

</div>
</div>
<a id="a01aa931c5cbfd4b09d847cc4d7b4c699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01aa931c5cbfd4b09d847cc4d7b4c699">&#9670;&nbsp;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar drake::none </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that no elements of <code>m</code> are true. An empty matrix returns true. </p>

</div>
</div>
<a id="ab4011b0ee72e60112bfd3aee950765e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4011b0ee72e60112bfd3aee950765e8">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;typename Derived::Scalar&gt; drake::none_of </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate <code>pred</code> holds for no elements in the matrix <code>m</code>. </p>
<p>An empty matrix returns true. </p>

</div>
</div>
<a id="a642a411b9ac97aefd67450fd5717a890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642a411b9ac97aefd67450fd5717a890">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether two <a class="el" href="structdrake_1_1_sorted_pair.html" title="This class is similar to the std::pair class. ">SortedPair</a> objects are not equal using <code>operator==</code>. </p>

</div>
</div>
<a id="a188637f54c49ee7427a3315f1f1a6f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188637f54c49ee7427a3315f1f1a6f96">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt;U&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_unsigned&lt;U&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::operator!= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abfec653508bbfb544860dbfd0677bfa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfec653508bbfb544860dbfd0677bfa3">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two pairs using lexicographic ordering. </p>

</div>
</div>
<a id="a6f92deeaa12f6173717e9f15297ce03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f92deeaa12f6173717e9f15297ce03f">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt;U&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_unsigned&lt;U&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d76c69274d87b34a742dae799e2177f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d76c69274d87b34a742dae799e2177f">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code>x &lt;= y</code> using <code>operator&lt;</code>. </p>

</div>
</div>
<a id="a23da26daef061510be0f06706a4c486d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23da26daef061510be0f06706a4c486d">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt;U&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_unsigned&lt;U&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8b6812b1ccb5ba802e724ef1082569c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b6812b1ccb5ba802e724ef1082569c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Two pairs of the same type are equal iff their members are equal after sorting. </p>

</div>
</div>
<a id="a284550e79594f3112b7619c3f1be0be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284550e79594f3112b7619c3f1be0be9">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt;U&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_unsigned&lt;U&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::operator== </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a140ed52150ccb7d8a9194eec633ba50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140ed52150ccb7d8a9194eec633ba50d">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code>x &gt; y</code> using <code>operator&lt;</code>. </p>

</div>
</div>
<a id="aad63634f4f0e3ea3ff76babb7569736b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad63634f4f0e3ea3ff76babb7569736b">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt;U&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_unsigned&lt;U&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaaa975aac6050ca9507bf9761707c383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa975aac6050ca9507bf9761707c383">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <code>x &gt;= y</code> using <code>operator&lt;</code>. </p>

</div>
</div>
<a id="af3c515436fc115aad7d71d9bd403d0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c515436fc115aad7d71d9bd403d0a1">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt;U&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; std::is_unsigned&lt;U&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classbool.html">bool</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24b4f4d56e6ad4e7f40d8d1010c577aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b4f4d56e6ad4e7f40d8d1010c577aa">&#9670;&nbsp;</a></span>SortedVectorsHaveIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::SortedVectorsHaveIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for the existence of a non-empty intersection between two sorted <code>std::vector</code>'s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements in the input vectors <code>a</code> and <code>b</code>. This is expected to be an integral type or a pointer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there is a non-empty intersection between vectors; <code>false</code> otherwise.</dd></dl>
<p>Elements are compared using <code>operator&lt;</code> and the vectors must be sorted with respect to the same operator.</p>
<p>This algorithm only works on <code>std::vector</code>'s to take advantage of their fast and random access.</p>
<p>Entries can be repeated as long as they are sorted. For vector <code>a</code> of size <code>Na</code> and vector <code>b</code> of size <code>Nb</code> the complexity is at most Order(Na + Nb). The algorithm executes in constant time for vectors with disjoint entries. An example of the worst case scenario is given below: </p><pre class="fragment"> a = (10, 20, 30)
 b = (15, 25, 35)
</pre><p>In this case the algorithm needs to scan both vectors from start to end. </p>

</div>
</div>
<a id="a983e5f23fd0a884e01038572bd3e24a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983e5f23fd0a884e01038572bd3e24a2">&#9670;&nbsp;</a></span>static_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; drake::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the object owned by the std::unique_ptr <code>other</code> from type <code>U</code> to <code>T</code>; no runtime type checking is performed. </p>
<p>This method is analogous to the built-in std::static_pointer_cast that operates on a std::shared_ptr.</p>
<p>Note that this function only supports default deleters. </p>

</div>
</div>
<a id="a848fb0ead47dfe2676e2ef81b8735e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848fb0ead47dfe2676e2ef81b8735e83">&#9670;&nbsp;</a></span>temp_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string temp_directory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a directory location suitable for temporary files. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the environment variable TEST_TMPDIR if defined or otherwise ${TMPDIR:-/tmp}/robotlocomotion_drake_XXXXXX where each X is replaced by a character from the portable filename character set. Any trailing / will be stripped from the output. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the path referred to by TEST_TMPDIR or ${TMPDIR:-/tmp}/robotlocomotion_drake_XXXXXX cannot be created, does not exist, or is not a directory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9a39e405b81569cc3895a2df555cc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a39e405b81569cc3895a2df555cc94">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestDouble&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeCheck&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4bfb3dd9effddfede5e3f3041730ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bfb3dd9effddfede5e3f3041730ddc">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestDouble&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">All&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92a4cb2bc34c0b4e572dc6749a5cacee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a4cb2bc34c0b4e572dc6749a5cacee">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestDouble&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllOf&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d2c5dffca12c5f8f26c5bb45b1479eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2c5dffca12c5f8f26c5bb45b1479eb">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestDouble&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fefb94f6add4b38239872e4dba571cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fefb94f6add4b38239872e4dba571cc">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestDouble&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyOf&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a638bb357c8971ab4b6ebe8d93f179dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638bb357c8971ab4b6ebe8d93f179dc2">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestDouble&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">None&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b2c3702b8934972d9e49397ed08396d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2c3702b8934972d9e49397ed08396d">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestDouble&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NoneOf&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a004283903f81d21cc94eb73aa18341a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004283903f81d21cc94eb73aa18341a5">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestAutoDiffXd&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeCheck&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b1b1953646f369814ae921ac2ab66c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1b1953646f369814ae921ac2ab66c2">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestAutoDiffXd&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllOf&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17af6d498f61fbfa9257dd9fd42cb229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17af6d498f61fbfa9257dd9fd42cb229">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestAutoDiffXd&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyOf&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8eb7eba9e1b2dec720119a653ca8230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8eb7eba9e1b2dec720119a653ca8230">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestAutoDiffXd&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NoneOf&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc1796ec31610987787a90fbbf51f335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1796ec31610987787a90fbbf51f335">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestSymbolic&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeCheck&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6901decbab1de5d18defbf0eb6b6be6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6901decbab1de5d18defbf0eb6b6be6c">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestSymbolic&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">All&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55d5ebb6dff61d4459fe61fb9439b8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d5ebb6dff61d4459fe61fb9439b8b2">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestSymbolic&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllOf&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a360b651f14b54e1be8c65c70a509944c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360b651f14b54e1be8c65c70a509944c">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestSymbolic&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6957d642203b1b6f7637a4e18cdb97ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6957d642203b1b6f7637a4e18cdb97ca">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestSymbolic&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyOf&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef09b51a00e8fc71f9dff2eba2c980cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef09b51a00e8fc71f9dff2eba2c980cb">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestSymbolic&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">None&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6167980d9923ff27cc21d6039b35773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6167980d9923ff27cc21d6039b35773">&#9670;&nbsp;</a></span>TEST_F() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::TEST_F </td>
          <td>(</td>
          <td class="paramtype">BoolTestSymbolic&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NoneOf&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f8fb09132c1375ac50b011cd4c47559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8fb09132c1375ac50b011cd4c47559">&#9670;&nbsp;</a></span>type_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tpl&lt;Ts...&gt; drake::type_bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; Ts... &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an expression (only to be used in <code>decltype</code>) for inferring and binding a parameter pack to a template. </p>

</div>
</div>
<a id="a23e81e154cbda13ce43322ccfcedb7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e81e154cbda13ce43322ccfcedb7ed">&#9670;&nbsp;</a></span>type_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t drake::type_hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides short-hand for hashing a type. </p>

</div>
</div>
<a id="a7421f3f5801e3e393c7a52105aeb876e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7421f3f5801e3e393c7a52105aeb876e">&#9670;&nbsp;</a></span>type_visit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::type_visit </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; Ts... &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdrake_1_1template__single__tag.html">template_single_tag</a>&lt; Predicate &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visits each type in a type pack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VisitWith</td><td>Visit helper. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structdrake_1_1type__visit__with__default.html" title="Visit a type by constructing its default value. ">type_visit_with_default</a></code>, <code><a class="el" href="structdrake_1_1type__visit__with__tag.html" title="Visits a type by construct a template tag&#39;s default value. ">type_visit_with_tag</a></code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Predicate</td><td>Predicate operating on the type dictated by <code>VisitWith</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>Lambda or functor for visiting a type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade20b7bf635eecb13adbaac4df980af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade20b7bf635eecb13adbaac4df980af0">&#9670;&nbsp;</a></span>unused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::unused </td>
          <td>(</td>
          <td class="paramtype">const Args &amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Documents the argument(s) as unused, placating GCC's -Wunused-parameter warning. </p>
<p>This can be called within function bodies to mark that certain parameters are unused.</p>
<p>When possible, removing the unused parameter is better than placating the warning. However, in some cases the parameter is part of a virtual API or template concept that is used elsewhere, so we can't remove it. In those cases, this function might be an appropriate work-around.</p>
<p>Here's rough advice on how to fix Wunused-parameter warnings:</p>
<p>(1) If the parameter can be removed entirely, prefer that as the first choice. (This may not be possible if, e.g., a method must match some virtual API or template concept.)</p>
<p>(2) Unless the parameter name has acute value, prefer to omit the name of the parameter, leaving only the type, e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Print(<span class="keyword">const</span> State&amp; state)<span class="keyword"> override </span>{ <span class="comment">/* No state to print. */</span> }</div></div><!-- fragment --><p> changes to </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Print(<span class="keyword">const</span> State&amp;)<span class="keyword"> override </span>{ <span class="comment">/* No state to print. */</span>}</div></div><!-- fragment --><p> This no longer triggers the warning and further makes it clear that a parameter required by the API is definitively unused in the function.</p>
<p>This is an especially good solution in the context of method definitions (vs declarations); the parameter name used in a definition is entirely irrelevant to Doxygen and most readers.</p>
<p>(3) When leaving the parameter name intact has acute value, it is acceptable to keep the name and mark it <code>unused</code>. For example, when the name appears as part of a virtual method's base class declaration, the name is used by Doxygen to document the method, e.g., </p><div class="fragment"><div class="line"><span class="comment">   /** Sets the default State of a System.  This default implementation is to</span></div><div class="line"><span class="comment">*      set all zeros.  Subclasses may override to use non-zero defaults.  The</span></div><div class="line"><span class="comment">*      custom defaults may be based on the given @p context, when relevant.  */</span></div><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">void</span> SetDefault(<span class="keyword">const</span> Context&lt;T&gt;&amp; context, State&lt;T&gt;* state)<span class="keyword"> const </span>{</div><div class="line">     <a class="code" href="namespacedrake.html#ade20b7bf635eecb13adbaac4df980af0">unused</a>(context);</div><div class="line">     state-&gt;SetZero();</div><div class="line">   }</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a329d1e7afba846a6ea6f8c2638fef7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329d1e7afba846a6ea6f8c2638fef7ec">&#9670;&nbsp;</a></span>kDrakeResourceRootEnvironmentVariableName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char *const kDrakeResourceRootEnvironmentVariableName</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <span class="stringliteral">&quot;DRAKE_RESOURCE_ROOT&quot;</span></div></div><!-- fragment -->
<p>The name of the environment variable that provides the first place where FindResource attempts to look. </p>
<p>The environment variable is allowed to be unset or empty; in that case, FindResource will attempt to use other locations without complaint.</p>
<p>The value is guaranteed to be "DRAKE_RESOURCE_ROOT". (For some users, it may be easier to hard-code a value than refer to this constant.)</p>
<p>When the environment variable is set, resources are sought in relation to it by appending the <a class="el" href="namespacedrake.html#a1becb3d158eac50e74aa9f1921c3a2b3" title="Attempts to locate a Drake resource named by the given resource_path. ">FindResource()</a> <code>resource_path</code> to the environment variable (with an intermediate <code>/</code> as appropriate). For example, if the <code>resource_path</code> is <code>drake/examples/pendulum/Pendulum.urdf</code> and the <code>DRAKE_RESOURCE_ROOT</code> is set to <code>/home/someuser/foo</code> then the resource will be sought at <code>/home/someuser/foo/drake/examples/pendulum/Pendulum.urdf</code>.</p>
<p>The intended use of this variable is to seek resources from an installed copy of Drake, in case other methods have failed. </p>

</div>
</div>
<a id="a63c55e4d8662e0986e79d11486334486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c55e4d8662e0986e79d11486334486">&#9670;&nbsp;</a></span>kHomogeneousTransformSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> kHomogeneousTransformSize = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a href="http://www.euclideanspace.com/maths/geometry/affine/matrix4x4/">http://www.euclideanspace.com/maths/geometry/affine/matrix4x4/</a> </p>

</div>
</div>
<a id="a07869e660ffe730425feca7595de2273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07869e660ffe730425feca7595de2273">&#9670;&nbsp;</a></span>kQuaternionSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> kQuaternionSize = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace32fe90adc0d2100ad4fc9f4bc6f79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace32fe90adc0d2100ad4fc9f4bc6f79a">&#9670;&nbsp;</a></span>kRotmatSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classint.html">int</a> kRotmatSize = <a class="el" href="namespacedrake.html#af869092c52ed7cc9d2db40ce56050c7c">kSpaceDimension</a> * <a class="el" href="namespacedrake.html#af869092c52ed7cc9d2db40ce56050c7c">kSpaceDimension</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeab5b0d99cafc2f6ae5812128cea27a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab5b0d99cafc2f6ae5812128cea27a3">&#9670;&nbsp;</a></span>kRpySize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> kRpySize = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af869092c52ed7cc9d2db40ce56050c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af869092c52ed7cc9d2db40ce56050c7c">&#9670;&nbsp;</a></span>kSpaceDimension</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> kSpaceDimension = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9ce1d9cce0ad61dd2f5a295c1a10fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ce1d9cce0ad61dd2f5a295c1a10fc8">&#9670;&nbsp;</a></span>kTwistSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> kTwistSize = 6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a href="https://en.wikipedia.org/wiki/Screw_theory#Twist">https://en.wikipedia.org/wiki/Screw_theory#Twist</a> </p>

</div>
</div>
<a id="acd293644b847dc4549de80a090d66625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd293644b847dc4549de80a090d66625">&#9670;&nbsp;</a></span>nullopt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto nullopt = stx::nullopt</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
