<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: RotationMatrix&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1math_1_1_rotation_matrix.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classdrake_1_1math_1_1_rotation_matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RotationMatrix&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure users create valid rotation matrices.  
 <a href="classdrake_1_1math_1_1_rotation_matrix.html#details">More...</a></p>

<p><code>#include &lt;drake/math/rotation_matrix.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a10729b40d2b64359d6b25c64fb6297e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a10729b40d2b64359d6b25c64fb6297e0">RotationMatrix</a> ()</td></tr>
<tr class="memdesc:a10729b40d2b64359d6b25c64fb6297e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a 3x3 identity RotationMatrix &ndash; which corresponds to aligning two frames (so that unit vectors Ax = Bx, Ay = By, Az = Bz).  <a href="#a10729b40d2b64359d6b25c64fb6297e0">More...</a><br /></td></tr>
<tr class="separator:a10729b40d2b64359d6b25c64fb6297e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02349fa508ba55fd7df957169498e824"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a02349fa508ba55fd7df957169498e824">RotationMatrix</a> (const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R)</td></tr>
<tr class="memdesc:a02349fa508ba55fd7df957169498e824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RotationMatrix from a Matrix3.  <a href="#a02349fa508ba55fd7df957169498e824">More...</a><br /></td></tr>
<tr class="separator:a02349fa508ba55fd7df957169498e824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6eb5993bd83412f92e82aa49873ae6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7f6eb5993bd83412f92e82aa49873ae6">RotationMatrix</a> (const Eigen::Quaternion&lt; T &gt; &amp;quaternion)</td></tr>
<tr class="memdesc:a7f6eb5993bd83412f92e82aa49873ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RotationMatrix from an Eigen::Quaternion.  <a href="#a7f6eb5993bd83412f92e82aa49873ae6">More...</a><br /></td></tr>
<tr class="separator:a7f6eb5993bd83412f92e82aa49873ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8205e6418bc644739b23879344135b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#aeb8205e6418bc644739b23879344135b">RotationMatrix</a> (const Eigen::AngleAxis&lt; T &gt; &amp;theta_lambda)</td></tr>
<tr class="memdesc:aeb8205e6418bc644739b23879344135b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RotationMatrix from an Eigen::AngleAxis.  <a href="#aeb8205e6418bc644739b23879344135b">More...</a><br /></td></tr>
<tr class="separator:aeb8205e6418bc644739b23879344135b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05183386f55111df27e380877a9f11b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a05183386f55111df27e380877a9f11b2">RotationMatrix</a> (const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>&lt; T &gt; &amp;<a class="el" href="rgbd__camera__publish__lcm__example_8cc.html#adcd24d59c62f70778c30dd0d4466b202">rpy</a>)</td></tr>
<tr class="memdesc:a05183386f55111df27e380877a9f11b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RotationMatrix from an RollPitchYaw.  <a href="#a05183386f55111df27e380877a9f11b2">More...</a><br /></td></tr>
<tr class="separator:a05183386f55111df27e380877a9f11b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cc72469524b8fe0750e667ab9adc6b"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a78cc72469524b8fe0750e667ab9adc6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a78cc72469524b8fe0750e667ab9adc6b">cast</a> () const</td></tr>
<tr class="memdesc:a78cc72469524b8fe0750e667ab9adc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a RotationMatrix templatized on a scalar type U from a RotationMatrix templatized on scalar type T.  <a href="#a78cc72469524b8fe0750e667ab9adc6b">More...</a><br /></td></tr>
<tr class="separator:a78cc72469524b8fe0750e667ab9adc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60056885860280930e13e7fdc70c5ea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a60056885860280930e13e7fdc70c5ea9">set</a> (const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R)</td></tr>
<tr class="memdesc:a60056885860280930e13e7fdc70c5ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> RotationMatrix from a Matrix3.  <a href="#a60056885860280930e13e7fdc70c5ea9">More...</a><br /></td></tr>
<tr class="separator:a60056885860280930e13e7fdc70c5ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0f1ec6a175a2d827ff3140f9d9966a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a3b0f1ec6a175a2d827ff3140f9d9966a">inverse</a> () const</td></tr>
<tr class="memdesc:a3b0f1ec6a175a2d827ff3140f9d9966a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>R_BA = R_AB⁻¹</code>, the inverse (transpose) of this RotationMatrix.  <a href="#a3b0f1ec6a175a2d827ff3140f9d9966a">More...</a><br /></td></tr>
<tr class="separator:a3b0f1ec6a175a2d827ff3140f9d9966a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3f1ea791e60612a37e57dcf8b4187c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#afa3f1ea791e60612a37e57dcf8b4187c">matrix</a> () const</td></tr>
<tr class="memdesc:afa3f1ea791e60612a37e57dcf8b4187c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Matrix3 underlying a RotationMatrix.  <a href="#afa3f1ea791e60612a37e57dcf8b4187c">More...</a><br /></td></tr>
<tr class="separator:afa3f1ea791e60612a37e57dcf8b4187c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941efa73d6aa26217b8703cdea1595a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a941efa73d6aa26217b8703cdea1595a0">operator*=</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a941efa73d6aa26217b8703cdea1595a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place multiply of <code>this</code> rotation matrix <code>R_AB</code> by <code>other</code> rotation matrix <code>R_BC</code>.  <a href="#a941efa73d6aa26217b8703cdea1595a0">More...</a><br /></td></tr>
<tr class="separator:a941efa73d6aa26217b8703cdea1595a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69939ed5d38ae5be67152393f80d8379"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a69939ed5d38ae5be67152393f80d8379">operator*</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:a69939ed5d38ae5be67152393f80d8379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <code>this</code> rotation matrix <code>R_AB</code> multiplied by <code>other</code> rotation matrix <code>R_BC</code>, returning the composition <code>R_AB * R_BC</code>.  <a href="#a69939ed5d38ae5be67152393f80d8379">More...</a><br /></td></tr>
<tr class="separator:a69939ed5d38ae5be67152393f80d8379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc8d7c964ca22cb2070e9506a3c6719"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a0fc8d7c964ca22cb2070e9506a3c6719">operator*</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;v) const</td></tr>
<tr class="memdesc:a0fc8d7c964ca22cb2070e9506a3c6719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <code>this</code> rotation matrix R multiplied by an arbitrary Vector3.  <a href="#a0fc8d7c964ca22cb2070e9506a3c6719">More...</a><br /></td></tr>
<tr class="separator:a0fc8d7c964ca22cb2070e9506a3c6719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0397fe475999596a9edb1797a418432a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a0397fe475999596a9edb1797a418432a">IsValid</a> () const</td></tr>
<tr class="memdesc:a0397fe475999596a9edb1797a418432a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if <code>this</code> rotation matrix R is a proper orthonormal rotation matrix to within the threshold of <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a20d41963e2c1b3fe99e04abd23d88f36" title="Returns an internal tolerance that checks rotation matrix orthonormality. ">get_internal_tolerance_for_orthonormality()</a>.  <a href="#a0397fe475999596a9edb1797a418432a">More...</a><br /></td></tr>
<tr class="separator:a0397fe475999596a9edb1797a418432a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac804feef1db1925cdb41771475381a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#ac804feef1db1925cdb41771475381a17">IsExactlyIdentity</a> () const</td></tr>
<tr class="memdesc:ac804feef1db1925cdb41771475381a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>this</code> is exactly equal to the identity matrix.  <a href="#ac804feef1db1925cdb41771475381a17">More...</a><br /></td></tr>
<tr class="separator:ac804feef1db1925cdb41771475381a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143570ba23e5a444790c7070a7447f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a143570ba23e5a444790c7070a7447f09">IsIdentityToInternalTolerance</a> () const</td></tr>
<tr class="memdesc:a143570ba23e5a444790c7070a7447f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>this</code> is equal to the identity matrix to within the threshold of <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a20d41963e2c1b3fe99e04abd23d88f36" title="Returns an internal tolerance that checks rotation matrix orthonormality. ">get_internal_tolerance_for_orthonormality()</a>.  <a href="#a143570ba23e5a444790c7070a7447f09">More...</a><br /></td></tr>
<tr class="separator:a143570ba23e5a444790c7070a7447f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d5438bbed70f2290a46a73e91cc78a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#aa5d5438bbed70f2290a46a73e91cc78a">IsNearlyEqualTo</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;other, <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>) const</td></tr>
<tr class="memdesc:aa5d5438bbed70f2290a46a73e91cc78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares each element of <code>this</code> to the corresponding element of <code>other</code> to check if they are the same to within a specified <code>tolerance</code>.  <a href="#aa5d5438bbed70f2290a46a73e91cc78a">More...</a><br /></td></tr>
<tr class="separator:aa5d5438bbed70f2290a46a73e91cc78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e459fd356a7fcb1bc27257a8f9df1fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a6e459fd356a7fcb1bc27257a8f9df1fa">IsExactlyEqualTo</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:a6e459fd356a7fcb1bc27257a8f9df1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares each element of <code>this</code> to the corresponding element of <code>other</code> to check if they are exactly the same.  <a href="#a6e459fd356a7fcb1bc27257a8f9df1fa">More...</a><br /></td></tr>
<tr class="separator:a6e459fd356a7fcb1bc27257a8f9df1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f554d89721df33e9d6fd2a2fb73ff9"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a94f554d89721df33e9d6fd2a2fb73ff9">GetMaximumAbsoluteDifference</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:a94f554d89721df33e9d6fd2a2fb73ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the infinity norm of <code>this</code> - <code>other</code> (i.e., the maximum absolute value of the difference between the elements of <code>this</code> and <code>other</code>).  <a href="#a94f554d89721df33e9d6fd2a2fb73ff9">More...</a><br /></td></tr>
<tr class="separator:a94f554d89721df33e9d6fd2a2fb73ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978a8b146ac3388416fc5c72b553f91a"><td class="memItemLeft" align="right" valign="top">Eigen::Quaternion&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a978a8b146ac3388416fc5c72b553f91a">ToQuaternion</a> () const</td></tr>
<tr class="memdesc:a978a8b146ac3388416fc5c72b553f91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a quaternion q that represents <code>this</code> RotationMatrix.  <a href="#a978a8b146ac3388416fc5c72b553f91a">More...</a><br /></td></tr>
<tr class="separator:a978a8b146ac3388416fc5c72b553f91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910cd85b8df9b3955bf70771cf37ec53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a910cd85b8df9b3955bf70771cf37ec53">ToQuaternionAsVector4</a> () const</td></tr>
<tr class="memdesc:a910cd85b8df9b3955bf70771cf37ec53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to return the Vector4 associated with <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a978a8b146ac3388416fc5c72b553f91a" title="Returns a quaternion q that represents this RotationMatrix. ">ToQuaternion()</a>.  <a href="#a910cd85b8df9b3955bf70771cf37ec53">More...</a><br /></td></tr>
<tr class="separator:a910cd85b8df9b3955bf70771cf37ec53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baddfa26e9183d21c69cc1f55a17521"><td class="memItemLeft" align="right" valign="top">Eigen::AngleAxis&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a6baddfa26e9183d21c69cc1f55a17521">ToAngleAxis</a> () const</td></tr>
<tr class="memdesc:a6baddfa26e9183d21c69cc1f55a17521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an AngleAxis <code>theta_lambda</code> containing an angle <code>theta</code> and unit vector (axis direction) <code>lambda</code> that represents <code>this</code> RotationMatrix.  <a href="#a6baddfa26e9183d21c69cc1f55a17521">More...</a><br /></td></tr>
<tr class="separator:a6baddfa26e9183d21c69cc1f55a17521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a64fa29fa97b01b5f9fd75720fad74f7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a64fa29fa97b01b5f9fd75720fad74f7f">RotationMatrix</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> &amp;)=default</td></tr>
<tr class="separator:a64fa29fa97b01b5f9fd75720fad74f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3deaaa5800a824dbc47f832c60dc3915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a3deaaa5800a824dbc47f832c60dc3915">operator=</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> &amp;)=default</td></tr>
<tr class="separator:a3deaaa5800a824dbc47f832c60dc3915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22247b3e379fee1e9b9dda9952d78fd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a22247b3e379fee1e9b9dda9952d78fd9">RotationMatrix</a> (<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a22247b3e379fee1e9b9dda9952d78fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5347f3aae9669cd2242300fb05104ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#ac5347f3aae9669cd2242300fb05104ef">operator=</a> (<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ac5347f3aae9669cd2242300fb05104ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa1890eaa31728581cedbf2bd40457560"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#aa1890eaa31728581cedbf2bd40457560">MakeFromOrthonormalColumns</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;Bx, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;By, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;Bz)</td></tr>
<tr class="memdesc:aa1890eaa31728581cedbf2bd40457560"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Makes the RotationMatrix <code>R_AB</code> from right-handed orthogonal unit vectors <code>Bx</code>, <code>By</code>, <code>Bz</code> so the columns of <code>R_AB</code> are <code>[Bx, By, Bz]</code>.  <a href="#aa1890eaa31728581cedbf2bd40457560">More...</a><br /></td></tr>
<tr class="separator:aa1890eaa31728581cedbf2bd40457560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b686ab545dd2e1fb9bf4fb28aac8560"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a8b686ab545dd2e1fb9bf4fb28aac8560">MakeFromOrthonormalRows</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;Ax, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;Ay, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;Az)</td></tr>
<tr class="memdesc:a8b686ab545dd2e1fb9bf4fb28aac8560"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Makes the RotationMatrix <code>R_AB</code> from right-handed orthogonal unit vectors <code>Ax</code>, <code>Ay</code>, <code>Az</code> so the rows of <code>R_AB</code> are <code>[Ax, Ay, Az]</code>.  <a href="#a8b686ab545dd2e1fb9bf4fb28aac8560">More...</a><br /></td></tr>
<tr class="separator:a8b686ab545dd2e1fb9bf4fb28aac8560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1141e549f6e5d8a195f24c8c95e91797"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a1141e549f6e5d8a195f24c8c95e91797">MakeXRotation</a> (const T &amp;theta)</td></tr>
<tr class="memdesc:a1141e549f6e5d8a195f24c8c95e91797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the RotationMatrix <code>R_AB</code> associated with rotating a frame B relative to a frame A by an angle <code>theta</code> about unit vector <code>Ax = Bx</code>.  <a href="#a1141e549f6e5d8a195f24c8c95e91797">More...</a><br /></td></tr>
<tr class="separator:a1141e549f6e5d8a195f24c8c95e91797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd982e9a592eef1b86ff6db747f01098"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#abd982e9a592eef1b86ff6db747f01098">MakeYRotation</a> (const T &amp;theta)</td></tr>
<tr class="memdesc:abd982e9a592eef1b86ff6db747f01098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the RotationMatrix <code>R_AB</code> associated with rotating a frame B relative to a frame A by an angle <code>theta</code> about unit vector <code>Ay = By</code>.  <a href="#abd982e9a592eef1b86ff6db747f01098">More...</a><br /></td></tr>
<tr class="separator:abd982e9a592eef1b86ff6db747f01098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceeffb4f32ea6d3eb8e17c2919d5cfe9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#aceeffb4f32ea6d3eb8e17c2919d5cfe9">MakeZRotation</a> (const T &amp;theta)</td></tr>
<tr class="memdesc:aceeffb4f32ea6d3eb8e17c2919d5cfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the RotationMatrix <code>R_AB</code> associated with rotating a frame B relative to a frame A by an angle <code>theta</code> about unit vector <code>Az = Bz</code>.  <a href="#aceeffb4f32ea6d3eb8e17c2919d5cfe9">More...</a><br /></td></tr>
<tr class="separator:aceeffb4f32ea6d3eb8e17c2919d5cfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0441681fa380dda6c70fe5b5a001bb90"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a0441681fa380dda6c70fe5b5a001bb90">Identity</a> ()</td></tr>
<tr class="memdesc:a0441681fa380dda6c70fe5b5a001bb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3x3 identity RotationMatrix.  <a href="#a0441681fa380dda6c70fe5b5a001bb90">More...</a><br /></td></tr>
<tr class="separator:a0441681fa380dda6c70fe5b5a001bb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca9317cbeb6cef80d12e0dee4fd179d"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a6ca9317cbeb6cef80d12e0dee4fd179d">GetMeasureOfOrthonormality</a> (const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R)</td></tr>
<tr class="memdesc:a6ca9317cbeb6cef80d12e0dee4fd179d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how close the matrix R is to to being a 3x3 orthonormal matrix by computing <code>‖R ⋅ Rᵀ - I‖∞</code> (i.e., the maximum absolute value of the difference between the elements of R ⋅ Rᵀ and the 3x3 identity matrix).  <a href="#a6ca9317cbeb6cef80d12e0dee4fd179d">More...</a><br /></td></tr>
<tr class="separator:a6ca9317cbeb6cef80d12e0dee4fd179d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5e8235ea5f9bb34bfa71b745546864"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7a5e8235ea5f9bb34bfa71b745546864">IsOrthonormal</a> (const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R, <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>)</td></tr>
<tr class="memdesc:a7a5e8235ea5f9bb34bfa71b745546864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if a generic Matrix3 has orthonormal vectors to within the threshold specified by <code>tolerance</code>.  <a href="#a7a5e8235ea5f9bb34bfa71b745546864">More...</a><br /></td></tr>
<tr class="separator:a7a5e8235ea5f9bb34bfa71b745546864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecdff2808f2ecf66cc0fe97f5173b98"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a1ecdff2808f2ecf66cc0fe97f5173b98">IsValid</a> (const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R, <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>)</td></tr>
<tr class="memdesc:a1ecdff2808f2ecf66cc0fe97f5173b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if a generic Matrix3 seems to be a proper orthonormal rotation matrix to within the threshold specified by <code>tolerance</code>.  <a href="#a1ecdff2808f2ecf66cc0fe97f5173b98">More...</a><br /></td></tr>
<tr class="separator:a1ecdff2808f2ecf66cc0fe97f5173b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6346cc9235f2cedd86a802d0d4a8451"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#af6346cc9235f2cedd86a802d0d4a8451">IsValid</a> (const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R)</td></tr>
<tr class="memdesc:af6346cc9235f2cedd86a802d0d4a8451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if a generic Matrix3 is a proper orthonormal rotation matrix to within the threshold of <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a20d41963e2c1b3fe99e04abd23d88f36" title="Returns an internal tolerance that checks rotation matrix orthonormality. ">get_internal_tolerance_for_orthonormality()</a>.  <a href="#af6346cc9235f2cedd86a802d0d4a8451">More...</a><br /></td></tr>
<tr class="separator:af6346cc9235f2cedd86a802d0d4a8451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d51dc7c0ba0f0cf4747d47e9203255f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7d51dc7c0ba0f0cf4747d47e9203255f">ProjectToRotationMatrix</a> (const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;M, T *quality_factor=nullptr)</td></tr>
<tr class="memdesc:a7d51dc7c0ba0f0cf4747d47e9203255f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an approximate rotation matrix M, finds the RotationMatrix R closest to M.  <a href="#a7d51dc7c0ba0f0cf4747d47e9203255f">More...</a><br /></td></tr>
<tr class="separator:a7d51dc7c0ba0f0cf4747d47e9203255f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d41963e2c1b3fe99e04abd23d88f36"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a20d41963e2c1b3fe99e04abd23d88f36">get_internal_tolerance_for_orthonormality</a> ()</td></tr>
<tr class="memdesc:a20d41963e2c1b3fe99e04abd23d88f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an internal tolerance that checks rotation matrix orthonormality.  <a href="#a20d41963e2c1b3fe99e04abd23d88f36">More...</a><br /></td></tr>
<tr class="separator:a20d41963e2c1b3fe99e04abd23d88f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456c2f7787024658a08d612eea90c0d4"><td class="memItemLeft" align="right" valign="top">static Eigen::Quaternion&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a456c2f7787024658a08d612eea90c0d4">ToQuaternion</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt;&gt; &amp;M)</td></tr>
<tr class="memdesc:a456c2f7787024658a08d612eea90c0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unit quaternion q associated with the 3x3 matrix M.  <a href="#a456c2f7787024658a08d612eea90c0d4">More...</a><br /></td></tr>
<tr class="separator:a456c2f7787024658a08d612eea90c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b70e5f1c037ab68afdb2551c49ac517"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a0b70e5f1c037ab68afdb2551c49ac517">ToQuaternionAsVector4</a> (const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:a0b70e5f1c037ab68afdb2551c49ac517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to return the Vector4 associated with ToQuaternion(M).  <a href="#a0b70e5f1c037ab68afdb2551c49ac517">More...</a><br /></td></tr>
<tr class="separator:a0b70e5f1c037ab68afdb2551c49ac517"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a876971dbbbcca2807eccb07b068df383"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a876971dbbbcca2807eccb07b068df383"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a876971dbbbcca2807eccb07b068df383">RotationMatrix</a></td></tr>
<tr class="separator:a876971dbbbcca2807eccb07b068df383"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a9771c03401395a6e30c398f5663799ed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a9771c03401395a6e30c398f5663799ed">RotationMatrixd</a> = <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;</td></tr>
<tr class="memdesc:a9771c03401395a6e30c398f5663799ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation (alias/typedef) for a <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> double scalar type.  <a href="#a9771c03401395a6e30c398f5663799ed">More...</a><br /></td></tr>
<tr class="separator:a9771c03401395a6e30c398f5663799ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::math::RotationMatrix&lt; T &gt;</h3>

<p>This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure users create valid rotation matrices. </p>
<p>This class relates right-handed orthogonal unit vectors Ax, Ay, Az fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz fixed in frame B. The monogram notation for the rotation matrix relating A to B is <code>R_AB</code>. An example that gives context to this rotation matrix is <code>v_A = R_AB * v_B</code>, where <code>v_B</code> denotes an arbitrary vector v expressed in terms of Bx, By, Bz and <code>v_A</code> denotes vector v expressed in terms of Ax, Ay, Az. See <a class="el" href="group__multibody__quantities.html">Multibody Quantities</a> for monogram notation for dynamics. See <a class="el" href="group__multibody__spatial__pose.html#orientation_discussion">a discussion on rotation matrices</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This class does not store the frames associated with a rotation matrix nor does it enforce strict proper usage of this class with vectors.</dd>
<dd>
When DRAKE_ASSERT_IS_ARMED is defined, several methods in this class do a validity check and throw an exception (std::logic_error) if the rotation matrix is invalid. When DRAKE_ASSERT_IS_ARMED is not defined, many of these validity checks are skipped (which helps improve speed). In addition, these validity tests are only performed for scalar types for which <a class="el" href="structdrake_1_1scalar__predicate.html#ab6fdcd06e06c892b3492eb6ea8f15be2" title="Whether type is bool. ">drake::scalar_predicate&lt;T&gt;::is_bool</a> is <code>true</code>. For instance, validity checks are not performed when T is <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">symbolic::Expression</a>.</dd></dl>
<dl class="section author"><dt>Authors</dt><dd>Paul Mitiguy (2018) Original author. </dd>
<dd>
Drake team (see <a href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The underlying scalar type. Must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar.</td></tr>
  </table>
  </dd>
</dl>
<p>Instantiated templates for the following kinds of T's are provided:</p>
<ul>
<li>double</li>
<li>AutoDiffXd</li>
<li><a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">symbolic::Expression</a> </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a64fa29fa97b01b5f9fd75720fad74f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fa29fa97b01b5f9fd75720fad74f7f">&#9670;&nbsp;</a></span>RotationMatrix() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22247b3e379fee1e9b9dda9952d78fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22247b3e379fee1e9b9dda9952d78fd9">&#9670;&nbsp;</a></span>RotationMatrix() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10729b40d2b64359d6b25c64fb6297e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10729b40d2b64359d6b25c64fb6297e0">&#9670;&nbsp;</a></span>RotationMatrix() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a 3x3 identity RotationMatrix &ndash; which corresponds to aligning two frames (so that unit vectors Ax = Bx, Ay = By, Az = Bz). </p>

</div>
</div>
<a id="a02349fa508ba55fd7df957169498e824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02349fa508ba55fd7df957169498e824">&#9670;&nbsp;</a></span>RotationMatrix() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RotationMatrix from a Matrix3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>an allegedly valid rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>in debug builds if R fails IsValid(R). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f6eb5993bd83412f92e82aa49873ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6eb5993bd83412f92e82aa49873ae6">&#9670;&nbsp;</a></span>RotationMatrix() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RotationMatrix from an Eigen::Quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quaternion</td><td>a non-zero, finite quaternion which may or may not have unit length [i.e., <code>quaternion.norm()</code> does not have to be 1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>in debug builds if the rotation matrix R that is built from <code>quaternion</code> fails IsValid(R). For example, an exception is thrown if <code>quaternion</code> is zero or contains a NaN or infinity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method has the effect of normalizing its <code>quaternion</code> argument, without the inefficiency of the square-root associated with normalization. </dd></dl>

</div>
</div>
<a id="aeb8205e6418bc644739b23879344135b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8205e6418bc644739b23879344135b">&#9670;&nbsp;</a></span>RotationMatrix() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::AngleAxis&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RotationMatrix from an Eigen::AngleAxis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_lambda</td><td>an Eigen::AngleAxis whose associated axis (vector direction herein called <code>lambda</code>) is non-zero and finite, but which may or may not have unit length [i.e., <code>lambda.norm()</code> does not have to be 1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>in debug builds if the rotation matrix R that is built from <code>theta_lambda</code> fails IsValid(R). For example, an exception is thrown if <code>lambda</code> is zero or contains a NaN or infinity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05183386f55111df27e380877a9f11b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05183386f55111df27e380877a9f11b2">&#9670;&nbsp;</a></span>RotationMatrix() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rpy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RotationMatrix from an RollPitchYaw. </p>
<p>In other words, makes the RotationMatrix for a Space-fixed (extrinsic) X-Y-Z rotation by "roll-pitch-yaw" angles <code>[r, p, y]</code>, which is equivalent to a Body-fixed (intrinsic) Z-Y-X rotation by "yaw-pitch-roll" angles <code>[y, p, r]</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rpy</td><td>radian measures of three angles [roll, pitch, yaw]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rpy</td><td>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation with "roll-pitch-yaw" angles <code>[r, p, y]</code> or equivalently a Body- fixed (intrinsic) Z-Y-X rotation with "yaw-pitch-roll" angles <code>[y, p, r]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Denoting roll <code>r</code>, pitch <code>p</code>, yaw <code>y</code>, this method returns a rotation matrix <code>R_AD</code> equal to the matrix multiplication shown below. <div class="fragment"><div class="line">       ⎡cos(<a class="code" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>) -<a class="code" href="namespacedrake_1_1symbolic.html#af3cd13d5472028f31c2e70f1b0e08b5d">sin</a>(<a class="code" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>)  0⎤   ⎡ <a class="code" href="namespacedrake_1_1symbolic.html#a8d78919127ccba2ba24cdb1b0c57613d">cos</a>(p)  0  <a class="code" href="namespacedrake_1_1symbolic.html#af3cd13d5472028f31c2e70f1b0e08b5d">sin</a>(p)⎤   ⎡1      0        0 ⎤</div><div class="line">R_AD = ⎢sin(<a class="code" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>)  <a class="code" href="namespacedrake_1_1symbolic.html#a8d78919127ccba2ba24cdb1b0c57613d">cos</a>(<a class="code" href="vtk__util__test_8cc.html#ab927965981178aa1fba979a37168db2a">y</a>)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  <a class="code" href="namespacedrake_1_1symbolic.html#a8d78919127ccba2ba24cdb1b0c57613d">cos</a>(r)  -<a class="code" href="namespacedrake_1_1symbolic.html#af3cd13d5472028f31c2e70f1b0e08b5d">sin</a>(r)⎥</div><div class="line">       ⎣    0       0   1⎦   ⎣-<a class="code" href="namespacedrake_1_1symbolic.html#af3cd13d5472028f31c2e70f1b0e08b5d">sin</a>(p)  0  <a class="code" href="namespacedrake_1_1symbolic.html#a8d78919127ccba2ba24cdb1b0c57613d">cos</a>(p)⎦   ⎣0  <a class="code" href="namespacedrake_1_1symbolic.html#af3cd13d5472028f31c2e70f1b0e08b5d">sin</a>(r)   <a class="code" href="namespacedrake_1_1symbolic.html#a8d78919127ccba2ba24cdb1b0c57613d">cos</a>(r)⎦</div><div class="line">     =       R_AB          *        R_BC          *        R_CD</div></div><!-- fragment --> </dd>
<dd>
In this discussion, A is the Space frame and D is the Body frame. One way to visualize this rotation sequence is by introducing intermediate frames B and C (useful constructs to understand this rotation sequence). Initially, the frames are aligned so <code>Di = Ci = Bi = Ai (i = x, y, z)</code>. Then D is subjected to successive right-handed rotations relative to A. <ul>
<li>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a roll angle <code>r</code> about <code>Dx = Cx</code>. Note: D and C are no longer aligned. </li>
<li>2nd rotation R_BC: Frames D, C (collectively &ndash; as if welded together) rotate relative to frame B, A by a pitch angle <code>p</code> about <code>Cy = By</code>. Note: C and B are no longer aligned. </li>
<li>3rd rotation R_AB: Frames D, C, B (collectively &ndash; as if welded) rotate relative to frame A by a roll angle <code>y</code> about <code>Bz = Az</code>. Note: B and A are no longer aligned. </li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a78cc72469524b8fe0750e667ab9adc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cc72469524b8fe0750e667ab9adc6b">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;U&gt; cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a RotationMatrix templatized on a scalar type U from a RotationMatrix templatized on scalar type T. </p>
<p>For example, </p><div class="fragment"><div class="line">RotationMatrix&lt;double&gt; source = <a class="code" href="classdrake_1_1math_1_1_rotation_matrix.html#a0441681fa380dda6c70fe5b5a001bb90">RotationMatrix&lt;double&gt;::Identity</a>();</div><div class="line">RotationMatrix&lt;AutoDiffXd&gt; foo = source.cast&lt;<a class="code" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>&gt;();</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Scalar type on which the returned RotationMatrix is templated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a>&lt;From&gt;::cast&lt;To&gt;()</code> creates a new <code><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a>&lt;To&gt;</code> from a <code><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a>&lt;From&gt;</code> but only if type <code>To</code> is constructible from type <code>From</code>. This cast method works in accordance with <a class="el" href="namespace_eigen.html">Eigen</a>'s cast method for <a class="el" href="namespace_eigen.html">Eigen</a>'s Matrix3 that underlies this RotationMatrix. For example, <a class="el" href="namespace_eigen.html">Eigen</a> currently allows cast from type double to AutoDiffXd, but not vice-versa. </dd></dl>

</div>
</div>
<a id="a20d41963e2c1b3fe99e04abd23d88f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d41963e2c1b3fe99e04abd23d88f36">&#9670;&nbsp;</a></span>get_internal_tolerance_for_orthonormality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdouble.html">double</a> get_internal_tolerance_for_orthonormality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an internal tolerance that checks rotation matrix orthonormality. </p>
<dl class="section return"><dt>Returns</dt><dd>internal tolerance (small multiplier of double-precision epsilon) used to check whether or not a rotation matrix is orthonormal. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The tolerance is chosen by developers to ensure a reasonably valid (orthonormal) rotation matrix. </dd>
<dd>
To orthonormalize a 3x3 matrix, use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7d51dc7c0ba0f0cf4747d47e9203255f" title="Given an approximate rotation matrix M, finds the RotationMatrix R closest to M. ">ProjectToRotationMatrix()</a>. </dd></dl>

</div>
</div>
<a id="a94f554d89721df33e9d6fd2a2fb73ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f554d89721df33e9d6fd2a2fb73ff9">&#9670;&nbsp;</a></span>GetMaximumAbsoluteDifference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T GetMaximumAbsoluteDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the infinity norm of <code>this</code> - <code>other</code> (i.e., the maximum absolute value of the difference between the elements of <code>this</code> and <code>other</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RotationMatrix to subtract from <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>‖this - other‖∞</code> </dd></dl>

</div>
</div>
<a id="a6ca9317cbeb6cef80d12e0dee4fd179d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca9317cbeb6cef80d12e0dee4fd179d">&#9670;&nbsp;</a></span>GetMeasureOfOrthonormality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T GetMeasureOfOrthonormality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns how close the matrix R is to to being a 3x3 orthonormal matrix by computing <code>‖R ⋅ Rᵀ - I‖∞</code> (i.e., the maximum absolute value of the difference between the elements of R ⋅ Rᵀ and the 3x3 identity matrix). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>matrix being checked for orthonormality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>‖R ⋅ Rᵀ - I‖∞</code> </dd></dl>

</div>
</div>
<a id="a0441681fa380dda6c70fe5b5a001bb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0441681fa380dda6c70fe5b5a001bb90">&#9670;&nbsp;</a></span>Identity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp; Identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 3x3 identity RotationMatrix. </p>

</div>
</div>
<a id="a3b0f1ec6a175a2d827ff3140f9d9966a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0f1ec6a175a2d827ff3140f9d9966a">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt; inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>R_BA = R_AB⁻¹</code>, the inverse (transpose) of this RotationMatrix. </p>
<dl class="section note"><dt>Note</dt><dd>For a valid rotation matrix <code>R_BA = R_AB⁻¹ = R_ABᵀ</code>. </dd></dl>

</div>
</div>
<a id="a6e459fd356a7fcb1bc27257a8f9df1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e459fd356a7fcb1bc27257a8f9df1fa">&#9670;&nbsp;</a></span>IsExactlyEqualTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsExactlyEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares each element of <code>this</code> to the corresponding element of <code>other</code> to check if they are exactly the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RotationMatrix to compare to <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if each element of <code>this</code> is exactly equal to the corresponding element in <code>other</code>. </dd></dl>

</div>
</div>
<a id="ac804feef1db1925cdb41771475381a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac804feef1db1925cdb41771475381a17">&#9670;&nbsp;</a></span>IsExactlyIdentity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsExactlyIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>this</code> is exactly equal to the identity matrix. </p>

</div>
</div>
<a id="a143570ba23e5a444790c7070a7447f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143570ba23e5a444790c7070a7447f09">&#9670;&nbsp;</a></span>IsIdentityToInternalTolerance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsIdentityToInternalTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>this</code> is equal to the identity matrix to within the threshold of <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a20d41963e2c1b3fe99e04abd23d88f36" title="Returns an internal tolerance that checks rotation matrix orthonormality. ">get_internal_tolerance_for_orthonormality()</a>. </p>

</div>
</div>
<a id="aa5d5438bbed70f2290a46a73e91cc78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d5438bbed70f2290a46a73e91cc78a">&#9670;&nbsp;</a></span>IsNearlyEqualTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsNearlyEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares each element of <code>this</code> to the corresponding element of <code>other</code> to check if they are the same to within a specified <code>tolerance</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RotationMatrix to compare to <code>this</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>maximum allowable absolute difference between the matrix elements in <code>this</code> and <code>other</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>‖this - other‖∞ &lt;= tolerance</code>. </dd></dl>

</div>
</div>
<a id="a7a5e8235ea5f9bb34bfa71b745546864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5e8235ea5f9bb34bfa71b745546864">&#9670;&nbsp;</a></span>IsOrthonormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsOrthonormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if a generic Matrix3 has orthonormal vectors to within the threshold specified by <code>tolerance</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>an allegedly orthonormal rotation matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>maximum allowable absolute difference between R * Rᵀ and the identity matrix I, i.e., checks if <code>‖R ⋅ Rᵀ - I‖∞ &lt;= tolerance</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if R is an orthonormal matrix. </dd></dl>

</div>
</div>
<a id="a1ecdff2808f2ecf66cc0fe97f5173b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecdff2808f2ecf66cc0fe97f5173b98">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if a generic Matrix3 seems to be a proper orthonormal rotation matrix to within the threshold specified by <code>tolerance</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>an allegedly valid rotation matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>maximum allowable absolute difference of <code>R * Rᵀ</code> and the identity matrix I (i.e., checks if <code>‖R ⋅ Rᵀ - I‖∞ &lt;= tolerance</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if R is a valid rotation matrix. </dd></dl>

</div>
</div>
<a id="af6346cc9235f2cedd86a802d0d4a8451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6346cc9235f2cedd86a802d0d4a8451">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if a generic Matrix3 is a proper orthonormal rotation matrix to within the threshold of <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a20d41963e2c1b3fe99e04abd23d88f36" title="Returns an internal tolerance that checks rotation matrix orthonormality. ">get_internal_tolerance_for_orthonormality()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>an allegedly valid rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if R is a valid rotation matrix. </dd></dl>

</div>
</div>
<a id="a0397fe475999596a9edb1797a418432a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0397fe475999596a9edb1797a418432a">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if <code>this</code> rotation matrix R is a proper orthonormal rotation matrix to within the threshold of <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a20d41963e2c1b3fe99e04abd23d88f36" title="Returns an internal tolerance that checks rotation matrix orthonormality. ">get_internal_tolerance_for_orthonormality()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>this</code> is a valid rotation matrix. </dd></dl>

</div>
</div>
<a id="aa1890eaa31728581cedbf2bd40457560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1890eaa31728581cedbf2bd40457560">&#9670;&nbsp;</a></span>MakeFromOrthonormalColumns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt; MakeFromOrthonormalColumns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>By</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Bz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Makes the RotationMatrix <code>R_AB</code> from right-handed orthogonal unit vectors <code>Bx</code>, <code>By</code>, <code>Bz</code> so the columns of <code>R_AB</code> are <code>[Bx, By, Bz]</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Bx</td><td>first unit vector in right-handed orthogonal set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">By</td><td>second unit vector in right-handed orthogonal set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Bz</td><td>third unit vector in right-handed orthogonal set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>in debug builds if <code>R_AB</code> fails IsValid(R_AB). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In release builds, the caller can subsequently test if <code>R_AB</code> is, in fact, a valid RotationMatrix by calling <code>R_AB.IsValid()</code>. </dd>
<dd>
The rotation matrix <code>R_AB</code> relates two sets of right-handed orthogonal unit vectors, namely Ax, Ay, Az and Bx, By, Bz. The rows of <code>R_AB</code> are Ax, Ay, Az expressed in frame B (i.e.,<code>Ax_B</code>, <code>Ay_B</code>, <code>Az_B</code>). The columns of <code>R_AB</code> are Bx, By, Bz expressed in frame A (i.e., <code>Bx_A</code>, <code>By_A</code>, <code>Bz_A</code>). </dd></dl>

</div>
</div>
<a id="a8b686ab545dd2e1fb9bf4fb28aac8560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b686ab545dd2e1fb9bf4fb28aac8560">&#9670;&nbsp;</a></span>MakeFromOrthonormalRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt; MakeFromOrthonormalRows </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Az</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Makes the RotationMatrix <code>R_AB</code> from right-handed orthogonal unit vectors <code>Ax</code>, <code>Ay</code>, <code>Az</code> so the rows of <code>R_AB</code> are <code>[Ax, Ay, Az]</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax</td><td>first unit vector in right-handed orthogonal set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ay</td><td>second unit vector in right-handed orthogonal set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Az</td><td>third unit vector in right-handed orthogonal set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>in debug builds if <code>R_AB</code> fails IsValid(R_AB). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In release builds, the caller can subsequently test if <code>R_AB</code> is, in fact, a valid RotationMatrix by calling <code>R_AB.IsValid()</code>. </dd>
<dd>
The rotation matrix <code>R_AB</code> relates two sets of right-handed orthogonal unit vectors, namely Ax, Ay, Az and Bx, By, Bz. The rows of <code>R_AB</code> are Ax, Ay, Az expressed in frame B (i.e.,<code>Ax_B</code>, <code>Ay_B</code>, <code>Az_B</code>). The columns of <code>R_AB</code> are Bx, By, Bz expressed in frame A (i.e., <code>Bx_A</code>, <code>By_A</code>, <code>Bz_A</code>). </dd></dl>

</div>
</div>
<a id="a1141e549f6e5d8a195f24c8c95e91797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1141e549f6e5d8a195f24c8c95e91797">&#9670;&nbsp;</a></span>MakeXRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt; MakeXRotation </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the RotationMatrix <code>R_AB</code> associated with rotating a frame B relative to a frame A by an angle <code>theta</code> about unit vector <code>Ax = Bx</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>radian measure of rotation angle about Ax. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta, Vector3d::UnitX(). </dd>
<dd>
<code>R_AB</code> relates two frames A and B having unit vectors Ax, Ay, Az and Bx, By, Bz. Initially, <code>Bx = Ax</code>, <code>By = Ay</code>, <code>Bz = Az</code>, then B undergoes a right-handed rotation relative to A by an angle <code>theta</code> about <code>Ax = Bx</code>. <div class="fragment"><div class="line">       ⎡ 1       0                 0  ⎤</div><div class="line">R_AB = ⎢ 0   <a class="code" href="namespacedrake_1_1symbolic.html#a8d78919127ccba2ba24cdb1b0c57613d">cos</a>(theta)   -<a class="code" href="namespacedrake_1_1symbolic.html#af3cd13d5472028f31c2e70f1b0e08b5d">sin</a>(theta) ⎥</div><div class="line">       ⎣ 0   <a class="code" href="namespacedrake_1_1symbolic.html#af3cd13d5472028f31c2e70f1b0e08b5d">sin</a>(theta)    <a class="code" href="namespacedrake_1_1symbolic.html#a8d78919127ccba2ba24cdb1b0c57613d">cos</a>(theta) ⎦</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="abd982e9a592eef1b86ff6db747f01098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd982e9a592eef1b86ff6db747f01098">&#9670;&nbsp;</a></span>MakeYRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt; MakeYRotation </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the RotationMatrix <code>R_AB</code> associated with rotating a frame B relative to a frame A by an angle <code>theta</code> about unit vector <code>Ay = By</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>radian measure of rotation angle about Ay. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta, Vector3d::UnitY(). </dd>
<dd>
<code>R_AB</code> relates two frames A and B having unit vectors Ax, Ay, Az and Bx, By, Bz. Initially, <code>Bx = Ax</code>, <code>By = Ay</code>, <code>Bz = Az</code>, then B undergoes a right-handed rotation relative to A by an angle <code>theta</code> about <code>Ay = By</code>. <div class="fragment"><div class="line">       ⎡  <a class="code" href="namespacedrake_1_1symbolic.html#a8d78919127ccba2ba24cdb1b0c57613d">cos</a>(theta)   0   <a class="code" href="namespacedrake_1_1symbolic.html#af3cd13d5472028f31c2e70f1b0e08b5d">sin</a>(theta) ⎤</div><div class="line">R_AB = ⎢          0    1           0  ⎥</div><div class="line">       ⎣ -<a class="code" href="namespacedrake_1_1symbolic.html#af3cd13d5472028f31c2e70f1b0e08b5d">sin</a>(theta)   0   <a class="code" href="namespacedrake_1_1symbolic.html#a8d78919127ccba2ba24cdb1b0c57613d">cos</a>(theta) ⎦</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aceeffb4f32ea6d3eb8e17c2919d5cfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceeffb4f32ea6d3eb8e17c2919d5cfe9">&#9670;&nbsp;</a></span>MakeZRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt; MakeZRotation </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the RotationMatrix <code>R_AB</code> associated with rotating a frame B relative to a frame A by an angle <code>theta</code> about unit vector <code>Az = Bz</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>radian measure of rotation angle about Az. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta, Vector3d::UnitZ(). </dd>
<dd>
<code>R_AB</code> relates two frames A and B having unit vectors Ax, Ay, Az and Bx, By, Bz. Initially, <code>Bx = Ax</code>, <code>By = Ay</code>, <code>Bz = Az</code>, then B undergoes a right-handed rotation relative to A by an angle <code>theta</code> about <code>Az = Bz</code>. <div class="fragment"><div class="line">       ⎡ <a class="code" href="namespacedrake_1_1symbolic.html#a8d78919127ccba2ba24cdb1b0c57613d">cos</a>(theta)  -<a class="code" href="namespacedrake_1_1symbolic.html#af3cd13d5472028f31c2e70f1b0e08b5d">sin</a>(theta)   0 ⎤</div><div class="line">R_AB = ⎢ <a class="code" href="namespacedrake_1_1symbolic.html#af3cd13d5472028f31c2e70f1b0e08b5d">sin</a>(theta)   <a class="code" href="namespacedrake_1_1symbolic.html#a8d78919127ccba2ba24cdb1b0c57613d">cos</a>(theta)   0 ⎥</div><div class="line">       ⎣         0            0    1 ⎦</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="afa3f1ea791e60612a37e57dcf8b4187c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3f1ea791e60612a37e57dcf8b4187c">&#9670;&nbsp;</a></span>matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt;T&gt;&amp; matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Matrix3 underlying a RotationMatrix. </p>

</div>
</div>
<a id="a69939ed5d38ae5be67152393f80d8379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69939ed5d38ae5be67152393f80d8379">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates <code>this</code> rotation matrix <code>R_AB</code> multiplied by <code>other</code> rotation matrix <code>R_BC</code>, returning the composition <code>R_AB * R_BC</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RotationMatrix that post-multiplies <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rotation matrix that results from <code>this</code> multiplied by <code>other</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is possible (albeit improbable) to create an invalid rotation matrix by accumulating round-off error with a large number of multiplies. </dd></dl>

</div>
</div>
<a id="a0fc8d7c964ca22cb2070e9506a3c6719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc8d7c964ca22cb2070e9506a3c6719">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates <code>this</code> rotation matrix R multiplied by an arbitrary Vector3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>3x1 vector that post-multiplies <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3x1 vector that results from <code>R * v</code>. </dd></dl>

</div>
</div>
<a id="a941efa73d6aa26217b8703cdea1595a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941efa73d6aa26217b8703cdea1595a0">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place multiply of <code>this</code> rotation matrix <code>R_AB</code> by <code>other</code> rotation matrix <code>R_BC</code>. </p>
<p>On return, <code>this</code> is set to equal <code>R_AB * R_BC</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RotationMatrix that post-multiplies <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> rotation matrix which has been multiplied by <code>other</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is possible (albeit improbable) to create an invalid rotation matrix by accumulating round-off error with a large number of multiplies. </dd></dl>

</div>
</div>
<a id="ac5347f3aae9669cd2242300fb05104ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5347f3aae9669cd2242300fb05104ef">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3deaaa5800a824dbc47f832c60dc3915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3deaaa5800a824dbc47f832c60dc3915">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d51dc7c0ba0f0cf4747d47e9203255f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d51dc7c0ba0f0cf4747d47e9203255f">&#9670;&nbsp;</a></span>ProjectToRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt; ProjectToRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>quality_factor</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an approximate rotation matrix M, finds the RotationMatrix R closest to M. </p>
<p>Closeness is measured with a matrix-2 norm (or equivalently with a Frobenius norm). Hence, this method creates a RotationMatrix R from a 3x3 matrix M by minimizing <code>‖R - M‖₂</code> (the matrix-2 norm of (R-M)) subject to <code>R * Rᵀ = I</code>, where I is the 3x3 identity matrix. For this problem, closeness can also be measured by forming the orthonormal matrix R whose elements minimize the double-summation <code>∑ᵢ ∑ⱼ (R(i,j) - M(i,j))²</code> where <code>i = 1:3, j = 1:3</code>, subject to <code>R * Rᵀ = I</code>. The square-root of this double-summation is called the Frobenius norm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>a 3x3 matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">quality_factor.</td><td>The quality of M as a rotation matrix. <code>quality_factor</code> = 1 is perfect (M = R). <code>quality_factor</code> = 1.25 means that when M multiplies a unit vector (magnitude 1), a vector of magnitude as large as 1.25 may result. <code>quality_factor</code> = 0.8 means that when M multiplies a unit vector, a vector of magnitude as small as 0.8 may result. <code>quality_factor</code> = 0 means M is singular, so at least one of the bases related by matrix M does not span 3D space (when M multiples a unit vector, a vector of magnitude as small as 0 may result). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>proper orthonormal matrix R that is closest to M. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if R fails IsValid(R). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>William Kahan (UC Berkeley) and Hongkai Dai (Toyota Research Institute) proved that for this problem, the same R that minimizes the Frobenius norm also minimizes the matrix-2 norm (a.k.a an induced-2 norm), which is defined [Dahleh, Section 4.2] as the column matrix u which maximizes <code>‖(R - M) u‖ / ‖u‖</code>, where <code>u ≠ 0</code>. Since the matrix-2 norm of any matrix A is equal to the maximum singular value of A, minimizing the matrix-2 norm of (R - M) is equivalent to minimizing the maximum singular value of (R - M).</dd></dl>
<ul>
<li>[Dahleh] "Lectures on Dynamic Systems and Controls: Electrical
Engineering and Computer Science, Massachusetts Institute of Technology" <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf</a> </li>
</ul>

</div>
</div>
<a id="a60056885860280930e13e7fdc70c5ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60056885860280930e13e7fdc70c5ea9">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>this</code> RotationMatrix from a Matrix3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>an allegedly valid rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>in debug builds if R fails IsValid(R). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6baddfa26e9183d21c69cc1f55a17521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6baddfa26e9183d21c69cc1f55a17521">&#9670;&nbsp;</a></span>ToAngleAxis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::AngleAxis&lt;T&gt; ToAngleAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an AngleAxis <code>theta_lambda</code> containing an angle <code>theta</code> and unit vector (axis direction) <code>lambda</code> that represents <code>this</code> RotationMatrix. </p>
<dl class="section note"><dt>Note</dt><dd>The orientation and RotationMatrix associated with <code>theta * lambda</code> is identical to that of <code>(-theta) * (-lambda)</code>. The AngleAxis returned by this method chooses to have <code>0 &lt;= theta &lt;= pi</code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an AngleAxis with <code>0 &lt;= theta &lt;= pi</code> and a unit vector <code>lambda</code>. </dd></dl>

</div>
</div>
<a id="a978a8b146ac3388416fc5c72b553f91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978a8b146ac3388416fc5c72b553f91a">&#9670;&nbsp;</a></span>ToQuaternion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt;T&gt; ToQuaternion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a quaternion q that represents <code>this</code> RotationMatrix. </p>
<p>Since the quaternion <code>q</code> and <code>-q</code> represent the same RotationMatrix, the quaternion returned by this method chooses the quaternion with q(0) &gt;= 0. </p>

</div>
</div>
<a id="a456c2f7787024658a08d612eea90c0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456c2f7787024658a08d612eea90c0d4">&#9670;&nbsp;</a></span>ToQuaternion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::Quaternion&lt;T&gt; ToQuaternion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a unit quaternion q associated with the 3x3 matrix M. </p>
<p>Since the quaternion <code>q</code> and <code>-q</code> represent the same RotationMatrix, the quaternion returned by this method chooses the quaternion with q(0) &gt;= 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>3x3 matrix to be made into a quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a unit quaternion q. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>in debug builds if the quaternion <code>q</code> returned by this method cannot construct a valid RotationMatrix. For example, if <code>M</code> contains NaNs, <code>q</code> will not be a valid quaternion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a910cd85b8df9b3955bf70771cf37ec53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910cd85b8df9b3955bf70771cf37ec53">&#9670;&nbsp;</a></span>ToQuaternionAsVector4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt;T&gt; ToQuaternionAsVector4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility method to return the Vector4 associated with <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a978a8b146ac3388416fc5c72b553f91a" title="Returns a quaternion q that represents this RotationMatrix. ">ToQuaternion()</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a978a8b146ac3388416fc5c72b553f91a" title="Returns a quaternion q that represents this RotationMatrix. ">ToQuaternion()</a>. </dd></dl>

</div>
</div>
<a id="a0b70e5f1c037ab68afdb2551c49ac517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b70e5f1c037ab68afdb2551c49ac517">&#9670;&nbsp;</a></span>ToQuaternionAsVector4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt;T&gt; ToQuaternionAsVector4 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility method to return the Vector4 associated with ToQuaternion(M). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>3x3 matrix to be made into a quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a978a8b146ac3388416fc5c72b553f91a" title="Returns a quaternion q that represents this RotationMatrix. ">ToQuaternion()</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a876971dbbbcca2807eccb07b068df383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876971dbbbcca2807eccb07b068df383">&#9670;&nbsp;</a></span>RotationMatrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9771c03401395a6e30c398f5663799ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9771c03401395a6e30c398f5663799ed">&#9670;&nbsp;</a></span>RotationMatrixd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a9771c03401395a6e30c398f5663799ed">RotationMatrixd</a> =  <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abbreviation (alias/typedef) for a <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> double scalar type. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/math/<a class="el" href="roll__pitch__yaw_8h.html">roll_pitch_yaw.h</a></li>
<li>drake/math/<a class="el" href="rotation__matrix_8h.html">rotation_matrix.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1math.html">math</a></li><li class="navelem"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
