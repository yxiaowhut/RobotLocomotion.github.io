<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: RigidTransform&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1math_1_1_rigid_transform.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classdrake_1_1math_1_1_rigid_transform-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RigidTransform&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents a proper rigid transform between two frames which can be regarded in two ways.  
 <a href="classdrake_1_1math_1_1_rigid_transform.html#details">More...</a></p>

<p><code>#include &lt;drake/math/rigid_transform.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa71b78707a3d79cbcb1a8f3cc854bee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aaa71b78707a3d79cbcb1a8f3cc854bee">RigidTransform</a> ()</td></tr>
<tr class="memdesc:aaa71b78707a3d79cbcb1a8f3cc854bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the RigidTransform that corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo.  <a href="#aaa71b78707a3d79cbcb1a8f3cc854bee">More...</a><br /></td></tr>
<tr class="separator:aaa71b78707a3d79cbcb1a8f3cc854bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ca01bad5c04328237cfc47c73f7c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a079ca01bad5c04328237cfc47c73f7c6">RigidTransform</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;R, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a079ca01bad5c04328237cfc47c73f7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a rotation matrix and a position vector.  <a href="#a079ca01bad5c04328237cfc47c73f7c6">More...</a><br /></td></tr>
<tr class="separator:a079ca01bad5c04328237cfc47c73f7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadac43ad1559a232d321b36e501605fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aadac43ad1559a232d321b36e501605fe">RigidTransform</a> (const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>&lt; T &gt; &amp;<a class="el" href="rgbd__camera__publish__lcm__example_8cc.html#adcd24d59c62f70778c30dd0d4466b202">rpy</a>, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:aadac43ad1559a232d321b36e501605fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html" title="This class represents the orientation between two arbitrary frames A and D associated with a Space-fi...">RollPitchYaw</a> and a position vector.  <a href="#aadac43ad1559a232d321b36e501605fe">More...</a><br /></td></tr>
<tr class="separator:aadac43ad1559a232d321b36e501605fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391249f5a5f48f189c7ff6572d6e3a19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a391249f5a5f48f189c7ff6572d6e3a19">RigidTransform</a> (const Eigen::Quaternion&lt; T &gt; &amp;quaternion, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a391249f5a5f48f189c7ff6572d6e3a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a Quaternion and a position vector.  <a href="#a391249f5a5f48f189c7ff6572d6e3a19">More...</a><br /></td></tr>
<tr class="separator:a391249f5a5f48f189c7ff6572d6e3a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0780a9ce724867fa65c009f0fbf82dc5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a0780a9ce724867fa65c009f0fbf82dc5">RigidTransform</a> (const Eigen::AngleAxis&lt; T &gt; &amp;theta_lambda, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a0780a9ce724867fa65c009f0fbf82dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a AngleAxis and a position vector.  <a href="#a0780a9ce724867fa65c009f0fbf82dc5">More...</a><br /></td></tr>
<tr class="separator:a0780a9ce724867fa65c009f0fbf82dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d99e85efd9f05d378ea0ecb922fcfa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ab8d99e85efd9f05d378ea0ecb922fcfa">RigidTransform</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;R)</td></tr>
<tr class="memdesc:ab8d99e85efd9f05d378ea0ecb922fcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform with a given <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a zero position vector.  <a href="#ab8d99e85efd9f05d378ea0ecb922fcfa">More...</a><br /></td></tr>
<tr class="separator:ab8d99e85efd9f05d378ea0ecb922fcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbab39c825ec784b6162682de5e4cdf1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#afbab39c825ec784b6162682de5e4cdf1">RigidTransform</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:afbab39c825ec784b6162682de5e4cdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform with an identity <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a given position vector 'p'.  <a href="#afbab39c825ec784b6162682de5e4cdf1">More...</a><br /></td></tr>
<tr class="separator:afbab39c825ec784b6162682de5e4cdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36e94d338e3be24e9fde24f1d58a4fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aa36e94d338e3be24e9fde24f1d58a4fb">RigidTransform</a> (const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;<a class="el" href="pose__smoother__test_8cc.html#a52d2d9a6c62244da2b2367bf389d0546">pose</a>)</td></tr>
<tr class="memdesc:aa36e94d338e3be24e9fde24f1d58a4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from an <a class="el" href="namespace_eigen.html">Eigen</a> Isometry3.  <a href="#aa36e94d338e3be24e9fde24f1d58a4fb">More...</a><br /></td></tr>
<tr class="separator:aa36e94d338e3be24e9fde24f1d58a4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31756c2694bacdfdf6b0c75602d498b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ae31756c2694bacdfdf6b0c75602d498b">set</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;R, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:ae31756c2694bacdfdf6b0c75602d498b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a position vector.  <a href="#ae31756c2694bacdfdf6b0c75602d498b">More...</a><br /></td></tr>
<tr class="separator:ae31756c2694bacdfdf6b0c75602d498b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e77b1e5fde8184fd5d18a62d00297bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a6e77b1e5fde8184fd5d18a62d00297bf">SetFromIsometry3</a> (const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;<a class="el" href="pose__smoother__test_8cc.html#a52d2d9a6c62244da2b2367bf389d0546">pose</a>)</td></tr>
<tr class="memdesc:a6e77b1e5fde8184fd5d18a62d00297bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> RigidTransform from an <a class="el" href="namespace_eigen.html">Eigen</a> Isometry3.  <a href="#a6e77b1e5fde8184fd5d18a62d00297bf">More...</a><br /></td></tr>
<tr class="separator:a6e77b1e5fde8184fd5d18a62d00297bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc2d96e26802c52ea92f21a40540681"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a1bc2d96e26802c52ea92f21a40540681"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a1bc2d96e26802c52ea92f21a40540681">cast</a> () const</td></tr>
<tr class="memdesc:a1bc2d96e26802c52ea92f21a40540681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a RigidTransform templatized on a scalar type U from a RigidTransform templatized on scalar type T.  <a href="#a1bc2d96e26802c52ea92f21a40540681">More...</a><br /></td></tr>
<tr class="separator:a1bc2d96e26802c52ea92f21a40540681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb70b2d5e20b8e9a4ffe2e21c7bf8fd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#acbb70b2d5e20b8e9a4ffe2e21c7bf8fd">rotation</a> () const</td></tr>
<tr class="memdesc:acbb70b2d5e20b8e9a4ffe2e21c7bf8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns R_AB, the rotation matrix portion of <code>this</code> RigidTransform.  <a href="#acbb70b2d5e20b8e9a4ffe2e21c7bf8fd">More...</a><br /></td></tr>
<tr class="separator:acbb70b2d5e20b8e9a4ffe2e21c7bf8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e953a8287f40248d4d2c1030ef72cef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a3e953a8287f40248d4d2c1030ef72cef">set_rotation</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;R)</td></tr>
<tr class="memdesc:a3e953a8287f40248d4d2c1030ef72cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the RotationMatrix portion of <code>this</code> RigidTransform.  <a href="#a3e953a8287f40248d4d2c1030ef72cef">More...</a><br /></td></tr>
<tr class="separator:a3e953a8287f40248d4d2c1030ef72cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee702d4bdc143681fe2b84270e609f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a3ee702d4bdc143681fe2b84270e609f2">translation</a> () const</td></tr>
<tr class="memdesc:a3ee702d4bdc143681fe2b84270e609f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p_AoBo_A</code>, the position vector portion of <code>this</code> RigidTransform, i.e., position vector from Ao (frame A's origin) to Bo (frame B's origin).  <a href="#a3ee702d4bdc143681fe2b84270e609f2">More...</a><br /></td></tr>
<tr class="separator:a3ee702d4bdc143681fe2b84270e609f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe4dc36c56c493ac1e956ec185bdfea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a1fe4dc36c56c493ac1e956ec185bdfea">set_translation</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a1fe4dc36c56c493ac1e956ec185bdfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position vector portion of <code>this</code> RigidTransform.  <a href="#a1fe4dc36c56c493ac1e956ec185bdfea">More...</a><br /></td></tr>
<tr class="separator:a1fe4dc36c56c493ac1e956ec185bdfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605ec47e36e257f4661d7c86a7f2ac8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a605ec47e36e257f4661d7c86a7f2ac8c">GetAsMatrix4</a> () const</td></tr>
<tr class="memdesc:a605ec47e36e257f4661d7c86a7f2ac8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 matrix associated with this RigidTransform, i.e., X_AB.  <a href="#a605ec47e36e257f4661d7c86a7f2ac8c">More...</a><br /></td></tr>
<tr class="separator:a605ec47e36e257f4661d7c86a7f2ac8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d3b170a7e3621ad02fe72ee7218a10"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 3, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a89d3b170a7e3621ad02fe72ee7218a10">GetAsMatrix34</a> () const</td></tr>
<tr class="memdesc:a89d3b170a7e3621ad02fe72ee7218a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3x4 matrix associated with this RigidTransform, i.e., X_AB.  <a href="#a89d3b170a7e3621ad02fe72ee7218a10">More...</a><br /></td></tr>
<tr class="separator:a89d3b170a7e3621ad02fe72ee7218a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58717dcdc71536116684f6dc53bab9b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a58717dcdc71536116684f6dc53bab9b9">GetAsIsometry3</a> () const</td></tr>
<tr class="memdesc:a58717dcdc71536116684f6dc53bab9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the isometry in ℜ³ that is equivalent to a RigidTransform.  <a href="#a58717dcdc71536116684f6dc53bab9b9">More...</a><br /></td></tr>
<tr class="separator:a58717dcdc71536116684f6dc53bab9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd964513cdca714478e29210f7e9cf31"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#abd964513cdca714478e29210f7e9cf31">SetIdentity</a> ()</td></tr>
<tr class="memdesc:abd964513cdca714478e29210f7e9cf31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> RigidTransform so it corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo.  <a href="#abd964513cdca714478e29210f7e9cf31">More...</a><br /></td></tr>
<tr class="separator:abd964513cdca714478e29210f7e9cf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac804feef1db1925cdb41771475381a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ac804feef1db1925cdb41771475381a17">IsExactlyIdentity</a> () const</td></tr>
<tr class="memdesc:ac804feef1db1925cdb41771475381a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>this</code> is exactly the identity RigidTransform.  <a href="#ac804feef1db1925cdb41771475381a17">More...</a><br /></td></tr>
<tr class="separator:ac804feef1db1925cdb41771475381a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c29dcfbeeb594af24ae82cff87f35f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ae4c29dcfbeeb594af24ae82cff87f35f">IsIdentityToEpsilon</a> (<a class="el" href="classdouble.html">double</a> translation_tolerance) const</td></tr>
<tr class="memdesc:ae4c29dcfbeeb594af24ae82cff87f35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>this</code> is within tolerance of the identity RigidTransform.  <a href="#ae4c29dcfbeeb594af24ae82cff87f35f">More...</a><br /></td></tr>
<tr class="separator:ae4c29dcfbeeb594af24ae82cff87f35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adbc50055d9a59126602077013cf04e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a5adbc50055d9a59126602077013cf04e">inverse</a> () const</td></tr>
<tr class="memdesc:a5adbc50055d9a59126602077013cf04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns X_BA = X_AB⁻¹, the inverse of <code>this</code> RigidTransform.  <a href="#a5adbc50055d9a59126602077013cf04e">More...</a><br /></td></tr>
<tr class="separator:a5adbc50055d9a59126602077013cf04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e707a792e7418486a4c286cc517f528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a2e707a792e7418486a4c286cc517f528">operator*=</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a2e707a792e7418486a4c286cc517f528"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place multiply of <code>this</code> RigidTransform <code>X_AB</code> by <code>other</code> RigidTransform <code>X_BC</code>.  <a href="#a2e707a792e7418486a4c286cc517f528">More...</a><br /></td></tr>
<tr class="separator:a2e707a792e7418486a4c286cc517f528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad499a35e296e980d5018b462352284ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ad499a35e296e980d5018b462352284ab">operator*</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:ad499a35e296e980d5018b462352284ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <code>this</code> RigidTransform <code>X_AB</code> multiplied by <code>other</code> RigidTransform <code>X_BC</code>.  <a href="#ad499a35e296e980d5018b462352284ab">More...</a><br /></td></tr>
<tr class="separator:ad499a35e296e980d5018b462352284ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade664b3208dbb3d22c045207104cac5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ade664b3208dbb3d22c045207104cac5b">operator*</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_BoQ_B) const</td></tr>
<tr class="memdesc:ade664b3208dbb3d22c045207104cac5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates <code>this</code> RigidTransform <code>X_AB</code> multiplied by the position vector 'p_BoQ_B` which is from Bo (B's origin) to an arbitrary point Q.  <a href="#ade664b3208dbb3d22c045207104cac5b">More...</a><br /></td></tr>
<tr class="separator:ade664b3208dbb3d22c045207104cac5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5015553d30ad4312a6b0cbb56c4d1d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a5015553d30ad4312a6b0cbb56c4d1d4c">IsNearlyEqualTo</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;other, <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>) const</td></tr>
<tr class="memdesc:a5015553d30ad4312a6b0cbb56c4d1d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares each element of <code>this</code> to the corresponding element of <code>other</code> to check if they are the same to within a specified <code>tolerance</code>.  <a href="#a5015553d30ad4312a6b0cbb56c4d1d4c">More...</a><br /></td></tr>
<tr class="separator:a5015553d30ad4312a6b0cbb56c4d1d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff306c43d124f530d5dfbf6793a3741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a2ff306c43d124f530d5dfbf6793a3741">IsExactlyEqualTo</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:a2ff306c43d124f530d5dfbf6793a3741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>this</code> is exactly equal to <code>other</code>.  <a href="#a2ff306c43d124f530d5dfbf6793a3741">More...</a><br /></td></tr>
<tr class="separator:a2ff306c43d124f530d5dfbf6793a3741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d583e730b5dd2193c7ff9f1293fcde"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aa6d583e730b5dd2193c7ff9f1293fcde">GetMaximumAbsoluteDifference</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:aa6d583e730b5dd2193c7ff9f1293fcde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the infinity norm of <code>this</code> - <code>other</code> (i.e., the maximum absolute value of the difference between the elements of <code>this</code> and <code>other</code>).  <a href="#aa6d583e730b5dd2193c7ff9f1293fcde">More...</a><br /></td></tr>
<tr class="separator:aa6d583e730b5dd2193c7ff9f1293fcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b1205e300a07901a70079bbbd1e566"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aa8b1205e300a07901a70079bbbd1e566">GetMaximumAbsoluteTranslationDifference</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:aa8b1205e300a07901a70079bbbd1e566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum absolute value of the difference in the position vectors (translation) in <code>this</code> and <code>other</code>.  <a href="#aa8b1205e300a07901a70079bbbd1e566">More...</a><br /></td></tr>
<tr class="separator:aa8b1205e300a07901a70079bbbd1e566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:aaac6934d2979499ff35457a8583ce60a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aaac6934d2979499ff35457a8583ce60a">RigidTransform</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> &amp;)=default</td></tr>
<tr class="separator:aaac6934d2979499ff35457a8583ce60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814b6772b29ffd1c2bbc34befae3667d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a814b6772b29ffd1c2bbc34befae3667d">operator=</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> &amp;)=default</td></tr>
<tr class="separator:a814b6772b29ffd1c2bbc34befae3667d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1d92575e2e4beb3bfa036983c33923"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ada1d92575e2e4beb3bfa036983c33923">RigidTransform</a> (<a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ada1d92575e2e4beb3bfa036983c33923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257f755b0f58f8958f8827b0651e205c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a257f755b0f58f8958f8827b0651e205c">operator=</a> (<a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a257f755b0f58f8958f8827b0651e205c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9af123d3a901431db4b446e542b55b98"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a9af123d3a901431db4b446e542b55b98">Identity</a> ()</td></tr>
<tr class="memdesc:a9af123d3a901431db4b446e542b55b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identity RigidTransform (corresponds to coincident frames).  <a href="#a9af123d3a901431db4b446e542b55b98">More...</a><br /></td></tr>
<tr class="separator:a9af123d3a901431db4b446e542b55b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8bedd8c483aaf5bc48587d10d7a3d485"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a8bedd8c483aaf5bc48587d10d7a3d485"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a></td></tr>
<tr class="separator:a8bedd8c483aaf5bc48587d10d7a3d485"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:afdc48b2f77bba9b5873dc56ec1b7248d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#afdc48b2f77bba9b5873dc56ec1b7248d">RigidTransformd</a> = <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;</td></tr>
<tr class="memdesc:afdc48b2f77bba9b5873dc56ec1b7248d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation (alias/typedef) for a <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways...">RigidTransform</a> double scalar type.  <a href="#afdc48b2f77bba9b5873dc56ec1b7248d">More...</a><br /></td></tr>
<tr class="separator:afdc48b2f77bba9b5873dc56ec1b7248d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::math::RigidTransform&lt; T &gt;</h3>

<p>This class represents a proper rigid transform between two frames which can be regarded in two ways. </p>
<p>It can be regarded as a distance-preserving linear operator that can rotate and/or translate a rigid body without changing its shape or size (rigid) and without mirroring/reflecting the body (proper), e.g., it can add one position vector to another and express the result in a particular basis as <code>p_AoQ_A = X_AB * p_BoQ_B</code> (Q is any point). Alternately, a rigid transform describes the pose between two frames A and B (i.e., the relative orientation and position of A to B). Herein, the terms rotation/orientation and translation/position are used interchangeably. The class stores a <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> that relates right-handed orthogonal unit vectors Ax, Ay, Az fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz fixed in frame B. The class also stores a position vector from Ao (the origin of frame A) to Bo (the origin of frame B). The position vector is expressed in frame A. The monogram notation for the transform relating frame A to B is <code>X_AB</code>. The monogram notation for the rotation matrix relating A to B is <code>R_AB</code>. The monogram notation for the position vector from Ao to Bo is <code>p_AoBo_A</code>. See <a class="el" href="group__multibody__quantities.html">Multibody Quantities</a> for monogram notation for dynamics.</p>
<dl class="section note"><dt>Note</dt><dd>This class does not store the frames associated with the transform and cannot enforce correct usage of this class. For example, it makes sense to multiply RigidTransforms as <code>X_AB * X_BC</code>, but not <code>X_AB * X_CB</code>.</dd>
<dd>
This class is not a 4x4 transformation matrix &ndash; even though its <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ad499a35e296e980d5018b462352284ab" title="Calculates this RigidTransform X_AB multiplied by other RigidTransform X_BC. ">operator*()</a> methods act like 4x4 matrix multiplication. Instead, this class contains a rotation matrix class as well as a 3x1 position vector. To form a 4x4 matrix, use GetAsMatrix(). GetAsIsometry() is treated similarly. </dd>
<dd>
An isometry is sometimes regarded as synonymous with rigid transform.</dd></dl>
<dl class="section author"><dt>Authors</dt><dd>Paul Mitiguy (2018) Original author. </dd>
<dd>
Drake team (see <a href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The underlying scalar type. Must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaac6934d2979499ff35457a8583ce60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac6934d2979499ff35457a8583ce60a">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada1d92575e2e4beb3bfa036983c33923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1d92575e2e4beb3bfa036983c33923">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa71b78707a3d79cbcb1a8f3cc854bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa71b78707a3d79cbcb1a8f3cc854bee">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the RigidTransform that corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo. </p>
<p>Hence, the constructed RigidTransform contains an identity <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a zero position vector. </p>

</div>
</div>
<a id="a079ca01bad5c04328237cfc47c73f7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079ca01bad5c04328237cfc47c73f7c6">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a rotation matrix and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>rotation matrix relating frames A and B (e.g., <code>R_AB</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <code>p_AoBo_A</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadac43ad1559a232d321b36e501605fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadac43ad1559a232d321b36e501605fe">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rpy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html" title="This class represents the orientation between two arbitrary frames A and D associated with a Space-fi...">RollPitchYaw</a> and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rpy</td><td>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation with "roll-pitch-yaw" angles <code>[r, p, y]</code> or equivalently a Body- fixed (intrinsic) Z-Y-X rotation with "yaw-pitch-roll" angles <code>[y, p, r]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a05183386f55111df27e380877a9f11b2" title="Constructs a RotationMatrix from an RollPitchYaw. ">RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;)</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <code>p_AoBo_A</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a391249f5a5f48f189c7ff6572d6e3a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391249f5a5f48f189c7ff6572d6e3a19">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a Quaternion and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quaternion</td><td>a non-zero, finite quaternion which may or may not have unit length [i.e., <code>quaternion.norm()</code> does not have to be 1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <code>p_AoBo_A</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>in debug builds if the rotation matrix that is built from <code>quaternion</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7f6eb5993bd83412f92e82aa49873ae6" title="Constructs a RotationMatrix from an Eigen::Quaternion. ">RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;)</a> </dd></dl>

</div>
</div>
<a id="a0780a9ce724867fa65c009f0fbf82dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0780a9ce724867fa65c009f0fbf82dc5">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::AngleAxis&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a AngleAxis and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_lambda</td><td>an Eigen::AngleAxis whose associated axis (vector direction herein called <code>lambda</code>) is non-zero and finite, but which may or may not have unit length [i.e., <code>lambda.norm()</code> does not have to be 1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted `p_AoBo_A </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>in debug builds if the rotation matrix that is built from <code>theta_lambda</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#aeb8205e6418bc644739b23879344135b" title="Constructs a RotationMatrix from an Eigen::AngleAxis. ">RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;)</a> </dd></dl>

</div>
</div>
<a id="ab8d99e85efd9f05d378ea0ecb922fcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d99e85efd9f05d378ea0ecb922fcfa">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform with a given <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a zero position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>rotation matrix relating frames A and B (e.g., <code>R_AB</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbab39c825ec784b6162682de5e4cdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbab39c825ec784b6162682de5e4cdf1">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform with an identity <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a given position vector 'p'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <code>p_AoBo_A</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa36e94d338e3be24e9fde24f1d58a4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36e94d338e3be24e9fde24f1d58a4fb">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from an <a class="el" href="namespace_eigen.html">Eigen</a> Isometry3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Isometry3 that contains an allegedly valid rotation matrix <code>R_AB</code> and also contains a position vector <code>p_AoBo_A</code> from frame A's origin to frame B's origin. <code>p_AoBo_A</code> must be expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>in debug builds if R_AB is not a proper orthonormal 3x3 rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>no attempt is made to orthogonalize the 3x3 rotation matrix part of <code>pose</code>. As needed, use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7d51dc7c0ba0f0cf4747d47e9203255f" title="Given an approximate rotation matrix M, finds the RotationMatrix R closest to M. ">RotationMatrix::ProjectToRotationMatrix()</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1bc2d96e26802c52ea92f21a40540681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc2d96e26802c52ea92f21a40540681">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;U&gt; cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a RigidTransform templatized on a scalar type U from a RigidTransform templatized on scalar type T. </p>
<p>For example, </p><div class="fragment"><div class="line">RigidTransform&lt;double&gt; source = <a class="code" href="classdrake_1_1math_1_1_rigid_transform.html#a9af123d3a901431db4b446e542b55b98">RigidTransform&lt;double&gt;::Identity</a>();</div><div class="line">RigidTransform&lt;AutoDiffXd&gt; foo = source.cast&lt;<a class="code" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>&gt;();</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Scalar type on which the returned RigidTransform is templated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways...">RigidTransform</a>&lt;From&gt;::cast&lt;To&gt;()</code> creates a new <code><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways...">RigidTransform</a>&lt;To&gt;</code> from a <code><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways...">RigidTransform</a>&lt;From&gt;</code> but only if type <code>To</code> is constructible from type <code>From</code>. This cast method works in accordance with <a class="el" href="namespace_eigen.html">Eigen</a>'s cast method for <a class="el" href="namespace_eigen.html">Eigen</a>'s objects that underlie this RigidTransform. For example, <a class="el" href="namespace_eigen.html">Eigen</a> currently allows cast from type double to AutoDiffXd, but not vice-versa. </dd></dl>

</div>
</div>
<a id="a58717dcdc71536116684f6dc53bab9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58717dcdc71536116684f6dc53bab9b9">&#9670;&nbsp;</a></span>GetAsIsometry3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt;T&gt; GetAsIsometry3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the isometry in ℜ³ that is equivalent to a RigidTransform. </p>

</div>
</div>
<a id="a89d3b170a7e3621ad02fe72ee7218a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d3b170a7e3621ad02fe72ee7218a10">&#9670;&nbsp;</a></span>GetAsMatrix34()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 3, 4&gt; GetAsMatrix34 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 3x4 matrix associated with this RigidTransform, i.e., X_AB. </p>
<pre>
 ┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre> 
</div>
</div>
<a id="a605ec47e36e257f4661d7c86a7f2ac8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605ec47e36e257f4661d7c86a7f2ac8c">&#9670;&nbsp;</a></span>GetAsMatrix4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a>&lt;T&gt; GetAsMatrix4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 4x4 matrix associated with this RigidTransform, i.e., X_AB. </p>
<pre>
 ┌                ┐
 │ R_AB  p_AoBo_A │
 │                │
 │   0      1     │
 └                ┘
</pre> 
</div>
</div>
<a id="aa6d583e730b5dd2193c7ff9f1293fcde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d583e730b5dd2193c7ff9f1293fcde">&#9670;&nbsp;</a></span>GetMaximumAbsoluteDifference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T GetMaximumAbsoluteDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the infinity norm of <code>this</code> - <code>other</code> (i.e., the maximum absolute value of the difference between the elements of <code>this</code> and <code>other</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform to subtract from <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>‖<code>this</code> - <code>other</code>‖∞ </dd></dl>

</div>
</div>
<a id="aa8b1205e300a07901a70079bbbd1e566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b1205e300a07901a70079bbbd1e566">&#9670;&nbsp;</a></span>GetMaximumAbsoluteTranslationDifference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T GetMaximumAbsoluteTranslationDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum absolute value of the difference in the position vectors (translation) in <code>this</code> and <code>other</code>. </p>
<p>In other words, returns the infinity norm of the difference in the position vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform whose position vector is subtracted from the position vector in <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9af123d3a901431db4b446e542b55b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af123d3a901431db4b446e542b55b98">&#9670;&nbsp;</a></span>Identity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;T&gt;&amp; Identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the identity RigidTransform (corresponds to coincident frames). </p>
<dl class="section return"><dt>Returns</dt><dd>the RigidTransform that corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo. Hence, the returned RigidTransform contains a 3x3 identity matrix and a zero position vector. </dd></dl>

</div>
</div>
<a id="a5adbc50055d9a59126602077013cf04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adbc50055d9a59126602077013cf04e">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;T&gt; inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns X_BA = X_AB⁻¹, the inverse of <code>this</code> RigidTransform. </p>
<dl class="section note"><dt>Note</dt><dd>The inverse of RigidTransform X_AB is X_BA, which contains the rotation matrix R_BA = R_AB⁻¹ = R_ABᵀ and the position vector <code>p_BoAo_B_</code> (position from B's origin Bo to A's origin Ao, expressed in frame B). </dd>
<dd>
: The square-root of a RigidTransform's condition number is roughly the magnitude of the position vector. The accuracy of the calculation for the inverse of a RigidTransform drops off with the sqrt condition number. </dd></dl>

</div>
</div>
<a id="a2ff306c43d124f530d5dfbf6793a3741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff306c43d124f530d5dfbf6793a3741">&#9670;&nbsp;</a></span>IsExactlyEqualTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsExactlyEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>this</code> is exactly equal to <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform to compare to <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if each element of <code>this</code> is exactly equal to the corresponding element of <code>other</code>. </dd></dl>

</div>
</div>
<a id="ac804feef1db1925cdb41771475381a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac804feef1db1925cdb41771475381a17">&#9670;&nbsp;</a></span>IsExactlyIdentity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsExactlyIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>this</code> is exactly the identity RigidTransform. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ae4c29dcfbeeb594af24ae82cff87f35f" title="Return true if this is within tolerance of the identity RigidTransform. ">IsIdentityToEpsilon()</a>. </dd></dl>

</div>
</div>
<a id="ae4c29dcfbeeb594af24ae82cff87f35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c29dcfbeeb594af24ae82cff87f35f">&#9670;&nbsp;</a></span>IsIdentityToEpsilon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsIdentityToEpsilon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>translation_tolerance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <code>this</code> is within tolerance of the identity RigidTransform. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> portion of <code>this</code> satisfies <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a143570ba23e5a444790c7070a7447f09" title="Returns true if this is equal to the identity matrix to within the threshold of get_internal_toleranc...">RotationMatrix::IsIdentityToInternalTolerance()</a> and if the position vector portion of <code>this</code> is equal to zero vector within <code>translation_tolerance</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">translation_tolerance</td><td>a non-negative number. One way to choose <code>translation_tolerance</code> is to multiply a characteristic length (e.g., the magnitude of a characteristic position vector) by an epsilon (e.g., <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a20d41963e2c1b3fe99e04abd23d88f36" title="Returns an internal tolerance that checks rotation matrix orthonormality. ">RotationMatrix::get_internal_tolerance_for_orthonormality()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ac804feef1db1925cdb41771475381a17" title="Returns true if this is exactly the identity RigidTransform. ">IsExactlyIdentity()</a>. </dd></dl>

</div>
</div>
<a id="a5015553d30ad4312a6b0cbb56c4d1d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5015553d30ad4312a6b0cbb56c4d1d4c">&#9670;&nbsp;</a></span>IsNearlyEqualTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsNearlyEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares each element of <code>this</code> to the corresponding element of <code>other</code> to check if they are the same to within a specified <code>tolerance</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform to compare to <code>this</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>maximum allowable absolute difference between the elements in <code>this</code> and <code>other</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>‖this.matrix() - other.matrix()‖∞ &lt;= tolerance</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Consider scaling tolerance with the largest of magA and magB, where magA and magB denoted the magnitudes of <code>this</code> position vector and <code>other</code> position vectors, respectively. </dd></dl>

</div>
</div>
<a id="ad499a35e296e980d5018b462352284ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad499a35e296e980d5018b462352284ab">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;T&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates <code>this</code> RigidTransform <code>X_AB</code> multiplied by <code>other</code> RigidTransform <code>X_BC</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform that post-multiplies <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_AC</td><td>= X_AB * X_BC </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade664b3208dbb3d22c045207104cac5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade664b3208dbb3d22c045207104cac5b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BoQ_B</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates <code>this</code> RigidTransform <code>X_AB</code> multiplied by the position vector 'p_BoQ_B` which is from Bo (B's origin) to an arbitrary point Q. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoQ_B</td><td>position vector from Bo to Q, expressed in frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">p_AoQ_A</td><td>position vector from Ao to Q, expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e707a792e7418486a4c286cc517f528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e707a792e7418486a4c286cc517f528">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;T&gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place multiply of <code>this</code> RigidTransform <code>X_AB</code> by <code>other</code> RigidTransform <code>X_BC</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform that post-multiplies <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> RigidTransform which has been multiplied by <code>other</code>. On return, <code>this = X_AC</code>, where <code>X_AC = X_AB * X_BC</code>. </dd></dl>

</div>
</div>
<a id="a814b6772b29ffd1c2bbc34befae3667d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814b6772b29ffd1c2bbc34befae3667d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a257f755b0f58f8958f8827b0651e205c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257f755b0f58f8958f8827b0651e205c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acbb70b2d5e20b8e9a4ffe2e21c7bf8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb70b2d5e20b8e9a4ffe2e21c7bf8fd">&#9670;&nbsp;</a></span>rotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp; rotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns R_AB, the rotation matrix portion of <code>this</code> RigidTransform. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">R_AB</td><td>the rotation matrix portion of <code>this</code> RigidTransform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae31756c2694bacdfdf6b0c75602d498b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31756c2694bacdfdf6b0c75602d498b">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>this</code> RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>rotation matrix relating frames A and B (e.g., <code>R_AB</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <code>p_AoBo_A</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e953a8287f40248d4d2c1030ef72cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e953a8287f40248d4d2c1030ef72cef">&#9670;&nbsp;</a></span>set_rotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_rotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the RotationMatrix portion of <code>this</code> RigidTransform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>rotation matrix relating frames A and B (e.g., <code>R_AB</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fe4dc36c56c493ac1e956ec185bdfea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe4dc36c56c493ac1e956ec185bdfea">&#9670;&nbsp;</a></span>set_translation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_translation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the position vector portion of <code>this</code> RigidTransform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from Ao (frame A's origin) to Bo (frame B's origin) expressed in frame A. In monogram notation p is denoted p_AoBo_A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e77b1e5fde8184fd5d18a62d00297bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e77b1e5fde8184fd5d18a62d00297bf">&#9670;&nbsp;</a></span>SetFromIsometry3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetFromIsometry3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>this</code> RigidTransform from an <a class="el" href="namespace_eigen.html">Eigen</a> Isometry3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Isometry3 that contains an allegedly valid rotation matrix <code>R_AB</code> and also contains a position vector <code>p_AoBo_A</code> from frame A's origin to frame B's origin. <code>p_AoBo_A</code> must be expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>in debug builds if R_AB is not a proper orthonormal 3x3 rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>no attempt is made to orthogonalize the 3x3 rotation matrix part of <code>pose</code>. As needed, use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7d51dc7c0ba0f0cf4747d47e9203255f" title="Given an approximate rotation matrix M, finds the RotationMatrix R closest to M. ">RotationMatrix::ProjectToRotationMatrix()</a>. </dd></dl>

</div>
</div>
<a id="abd964513cdca714478e29210f7e9cf31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd964513cdca714478e29210f7e9cf31">&#9670;&nbsp;</a></span>SetIdentity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;T&gt;&amp; SetIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>this</code> RigidTransform so it corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo. </p>
<p>Hence, <code>this</code> RigidTransform contains a 3x3 identity matrix and a zero position vector. </p>

</div>
</div>
<a id="a3ee702d4bdc143681fe2b84270e609f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee702d4bdc143681fe2b84270e609f2">&#9670;&nbsp;</a></span>translation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;&amp; translation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>p_AoBo_A</code>, the position vector portion of <code>this</code> RigidTransform, i.e., position vector from Ao (frame A's origin) to Bo (frame B's origin). </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a8bedd8c483aaf5bc48587d10d7a3d485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bedd8c483aaf5bc48587d10d7a3d485">&#9670;&nbsp;</a></span>RigidTransform</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdc48b2f77bba9b5873dc56ec1b7248d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc48b2f77bba9b5873dc56ec1b7248d">&#9670;&nbsp;</a></span>RigidTransformd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#afdc48b2f77bba9b5873dc56ec1b7248d">RigidTransformd</a> =  <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abbreviation (alias/typedef) for a <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways...">RigidTransform</a> double scalar type. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/math/<a class="el" href="rigid__transform_8h.html">rigid_transform.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1math.html">math</a></li><li class="navelem"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
