<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: SpatialAcceleration&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_spatial_acceleration.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1_spatial_acceleration-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SpatialAcceleration&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is used to represent a <em>spatial acceleration</em> that combines rotational (angular acceleration) and translational (linear acceleration) components.  
 <a href="classdrake_1_1multibody_1_1_spatial_acceleration.html#details">More...</a></p>

<p><code>#include &lt;drake/multibody/multibody_tree/math/spatial_acceleration.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad7f507917333adceb2c6542f4d2df38c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#ad7f507917333adceb2c6542f4d2df38c">SpatialAcceleration</a> ()</td></tr>
<tr class="memdesc:ad7f507917333adceb2c6542f4d2df38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ad7f507917333adceb2c6542f4d2df38c">More...</a><br /></td></tr>
<tr class="separator:ad7f507917333adceb2c6542f4d2df38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bf6b4ed657ad8f3bacd8d7cf2e8338"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#aa6bf6b4ed657ad8f3bacd8d7cf2e8338">SpatialAcceleration</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;alpha, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;a)</td></tr>
<tr class="memdesc:aa6bf6b4ed657ad8f3bacd8d7cf2e8338"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html" title="This class is used to represent a spatial acceleration that combines rotational (angular acceleration...">SpatialAcceleration</a> constructor from an angular acceleration <code>alpha</code> and a linear acceleration <code>a</code>.  <a href="#aa6bf6b4ed657ad8f3bacd8d7cf2e8338">More...</a><br /></td></tr>
<tr class="separator:aa6bf6b4ed657ad8f3bacd8d7cf2e8338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b917a147d41074fa7d6b8108d3d19c1"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7b917a147d41074fa7d6b8108d3d19c1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#a7b917a147d41074fa7d6b8108d3d19c1">SpatialAcceleration</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>)</td></tr>
<tr class="memdesc:a7b917a147d41074fa7d6b8108d3d19c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html" title="This class is used to represent a spatial acceleration that combines rotational (angular acceleration...">SpatialAcceleration</a> constructor from an <a class="el" href="namespace_eigen.html">Eigen</a> expression that represents a six-dimensional vector.  <a href="#a7b917a147d41074fa7d6b8108d3d19c1">More...</a><br /></td></tr>
<tr class="separator:a7b917a147d41074fa7d6b8108d3d19c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707251979c42429c0e6ee7dfb6542b98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#a707251979c42429c0e6ee7dfb6542b98">ShiftInPlace</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PoBo_E, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;w_WP_E)</td></tr>
<tr class="memdesc:a707251979c42429c0e6ee7dfb6542b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place shift of <code>this</code> spatial acceleration <code>A_WP</code> of a frame P into the spatial acceleration <code>A_WPb</code> of a frame <code>Pb</code> which is an offset frame rigidly aligned with P, but with its origin shifted to a point <code>Bo</code> by an offset p_PoBo.  <a href="#a707251979c42429c0e6ee7dfb6542b98">More...</a><br /></td></tr>
<tr class="separator:a707251979c42429c0e6ee7dfb6542b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396ad36ac4f0aedd9dc30d2847c3fb5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#a396ad36ac4f0aedd9dc30d2847c3fb5d">Shift</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PoBo_E, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;w_WP_E) const</td></tr>
<tr class="memdesc:a396ad36ac4f0aedd9dc30d2847c3fb5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts <code>this</code> spatial acceleration <code>A_WP</code> of a frame P into the spatial acceleration <code>A_WPb</code> of a frame <code>Pb</code> which is an offset frame rigidly aligned with P, but with its origin shifted to a point <code>Bo</code> by an offset p_PoBo.  <a href="#a396ad36ac4f0aedd9dc30d2847c3fb5d">More...</a><br /></td></tr>
<tr class="separator:a396ad36ac4f0aedd9dc30d2847c3fb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefc4f231d1c1b976b8a99004921b164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#adefc4f231d1c1b976b8a99004921b164">ComposeWithMovingFrameAcceleration</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PoBo_E, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;w_WP_E, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;V_PB_E, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;A_PB_E) const</td></tr>
<tr class="memdesc:adefc4f231d1c1b976b8a99004921b164"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method composes <code>this</code> spatial acceleration <code>A_WP</code> of a frame P measured in a frame W, with that of a third frame B moving in P with spatial acceleration <code>A_PB</code>.  <a href="#adefc4f231d1c1b976b8a99004921b164">More...</a><br /></td></tr>
<tr class="separator:adefc4f231d1c1b976b8a99004921b164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a8bf37dab7236092d343a3550f3c0a97d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#a8bf37dab7236092d343a3550f3c0a97d">SpatialAcceleration</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a> &amp;)=default</td></tr>
<tr class="separator:a8bf37dab7236092d343a3550f3c0a97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2c52c1ca5f71c7d19ae3e462f28ea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#a0e2c52c1ca5f71c7d19ae3e462f28ea4">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a> &amp;)=default</td></tr>
<tr class="separator:a0e2c52c1ca5f71c7d19ae3e462f28ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779e53116ddd6e0dbded2c52f141c580"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#a779e53116ddd6e0dbded2c52f141c580">SpatialAcceleration</a> (<a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a779e53116ddd6e0dbded2c52f141c580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1304fa4eec81102161931379fe4b55c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#af1304fa4eec81102161931379fe4b55c">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a> &amp;&amp;)=default</td></tr>
<tr class="separator:af1304fa4eec81102161931379fe4b55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdrake_1_1multibody_1_1_spatial_vector')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html">SpatialVector&lt; SpatialAcceleration, T &gt;</a></td></tr>
<tr class="memitem:a7ef3ca98bf83a4e8ee30147de1ce201d inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a7ef3ca98bf83a4e8ee30147de1ce201d">SpatialVector</a> ()</td></tr>
<tr class="memdesc:a7ef3ca98bf83a4e8ee30147de1ce201d inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a7ef3ca98bf83a4e8ee30147de1ce201d">More...</a><br /></td></tr>
<tr class="separator:a7ef3ca98bf83a4e8ee30147de1ce201d inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadedf5dde48c214001423e185449e233 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#aadedf5dde48c214001423e185449e233">SpatialVector</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;w, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:aadedf5dde48c214001423e185449e233 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">SpatialVector constructor from an rotational component <code>w</code> and a linear component <code>v</code>.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#aadedf5dde48c214001423e185449e233">More...</a><br /></td></tr>
<tr class="separator:aadedf5dde48c214001423e185449e233 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa831e731779635166d20d016b8ba686b inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#aa831e731779635166d20d016b8ba686b">SpatialVector</a> (const Eigen::MatrixBase&lt; OtherDerived &gt; &amp;V)</td></tr>
<tr class="memdesc:aa831e731779635166d20d016b8ba686b inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">SpatialVector constructor from an <a class="el" href="namespace_eigen.html">Eigen</a> expression that represents a six-dimensional vector.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#aa831e731779635166d20d016b8ba686b">More...</a><br /></td></tr>
<tr class="separator:aa831e731779635166d20d016b8ba686b inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9593d4a5ff4274efaf429cb4f9e57cc inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#af9593d4a5ff4274efaf429cb4f9e57cc">size</a> () const</td></tr>
<tr class="memdesc:af9593d4a5ff4274efaf429cb4f9e57cc inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total size of the concatenation of the angular and linear components.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#af9593d4a5ff4274efaf429cb4f9e57cc">More...</a><br /></td></tr>
<tr class="separator:af9593d4a5ff4274efaf429cb4f9e57cc inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb40ed6a35143cdd6f683075a1dac18 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a0cb40ed6a35143cdd6f683075a1dac18">operator[]</a> (<a class="el" href="classint.html">int</a> <a class="el" href="geometry__properties__test_8cc.html#acb559820d9ca11295b4500f179ef6392">i</a>) const</td></tr>
<tr class="memdesc:a0cb40ed6a35143cdd6f683075a1dac18 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const access to the i-th component of this spatial vector.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a0cb40ed6a35143cdd6f683075a1dac18">More...</a><br /></td></tr>
<tr class="separator:a0cb40ed6a35143cdd6f683075a1dac18 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0534e977fc9fee424b3ef94f27a9ed61 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a0534e977fc9fee424b3ef94f27a9ed61">operator[]</a> (<a class="el" href="classint.html">int</a> <a class="el" href="geometry__properties__test_8cc.html#acb559820d9ca11295b4500f179ef6392">i</a>)</td></tr>
<tr class="memdesc:a0534e977fc9fee424b3ef94f27a9ed61 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable access to the i-th component of this spatial vector.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a0534e977fc9fee424b3ef94f27a9ed61">More...</a><br /></td></tr>
<tr class="separator:a0534e977fc9fee424b3ef94f27a9ed61 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d09ceb2acbdee33c80ac3a32751c43 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#ab8d09ceb2acbdee33c80ac3a32751c43">rotational</a> () const</td></tr>
<tr class="memdesc:ab8d09ceb2acbdee33c80ac3a32751c43 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const access to the rotational component of this spatial vector.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#ab8d09ceb2acbdee33c80ac3a32751c43">More...</a><br /></td></tr>
<tr class="separator:ab8d09ceb2acbdee33c80ac3a32751c43 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08720d2d7b744464ca0a01a7ac4a84df inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a08720d2d7b744464ca0a01a7ac4a84df">rotational</a> ()</td></tr>
<tr class="memdesc:a08720d2d7b744464ca0a01a7ac4a84df inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable access to the rotational component of this spatial vector.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a08720d2d7b744464ca0a01a7ac4a84df">More...</a><br /></td></tr>
<tr class="separator:a08720d2d7b744464ca0a01a7ac4a84df inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d56e1315fbb0f8a59a83c948fcded20 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a9d56e1315fbb0f8a59a83c948fcded20">translational</a> () const</td></tr>
<tr class="memdesc:a9d56e1315fbb0f8a59a83c948fcded20 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const access to the translational component of this spatial vector.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a9d56e1315fbb0f8a59a83c948fcded20">More...</a><br /></td></tr>
<tr class="separator:a9d56e1315fbb0f8a59a83c948fcded20 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520e7186918c44e7d3f5971ee87ceee6 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a520e7186918c44e7d3f5971ee87ceee6">translational</a> ()</td></tr>
<tr class="memdesc:a520e7186918c44e7d3f5971ee87ceee6 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable access to the translational component of this spatial vector.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a520e7186918c44e7d3f5971ee87ceee6">More...</a><br /></td></tr>
<tr class="separator:a520e7186918c44e7d3f5971ee87ceee6 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce7ecceadabf1ae43d7fe0a016bb84b inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a6ce7ecceadabf1ae43d7fe0a016bb84b">data</a> () const</td></tr>
<tr class="memdesc:a6ce7ecceadabf1ae43d7fe0a016bb84b inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a (const) bare pointer to the underlying data.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a6ce7ecceadabf1ae43d7fe0a016bb84b">More...</a><br /></td></tr>
<tr class="separator:a6ce7ecceadabf1ae43d7fe0a016bb84b inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0956f52a2d65962e383a87b3e6c3a30b inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a0956f52a2d65962e383a87b3e6c3a30b">mutable_data</a> ()</td></tr>
<tr class="memdesc:a0956f52a2d65962e383a87b3e6c3a30b inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a (mutable) bare pointer to the underlying data.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a0956f52a2d65962e383a87b3e6c3a30b">More...</a><br /></td></tr>
<tr class="separator:a0956f52a2d65962e383a87b3e6c3a30b inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec0b46e26e4295575e966033fb79f4c inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; const T, const T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a3ec0b46e26e4295575e966033fb79f4c">GetMaximumAbsoluteDifferences</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a9e320858f0854b7842fbd11edeeca62c">SpatialQuantity</a> &amp;other) const</td></tr>
<tr class="memdesc:a3ec0b46e26e4295575e966033fb79f4c inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum absolute values of the differences in the rotational and translational components of <code>this</code> and <code>other</code> (i.e., the infinity norms of the difference in rotational and translational components).  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a3ec0b46e26e4295575e966033fb79f4c">More...</a><br /></td></tr>
<tr class="separator:a3ec0b46e26e4295575e966033fb79f4c inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1aab695295b4f88e6f0bfd5271357c inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">decltype(T()&lt; T())&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a1e1aab695295b4f88e6f0bfd5271357c">IsNearlyEqualWithinAbsoluteTolerance</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a9e320858f0854b7842fbd11edeeca62c">SpatialQuantity</a> &amp;other, <a class="el" href="classdouble.html">double</a> rotational_tolerance, <a class="el" href="classdouble.html">double</a> translational_tolerance) const</td></tr>
<tr class="memdesc:a1e1aab695295b4f88e6f0bfd5271357c inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the rotational and translational parts of <code>this</code> and <code>other</code> to check if they are the same to within specified absolute differences.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a1e1aab695295b4f88e6f0bfd5271357c">More...</a><br /></td></tr>
<tr class="separator:a1e1aab695295b4f88e6f0bfd5271357c inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecee900de2aa10bca5a4e9e36121b25 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">decltype(T()&lt; T())&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#adecee900de2aa10bca5a4e9e36121b25">IsApprox</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a9e320858f0854b7842fbd11edeeca62c">SpatialQuantity</a> &amp;other, <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>=std::numeric_limits&lt; <a class="el" href="classdouble.html">double</a> &gt;::epsilon()) const</td></tr>
<tr class="memdesc:adecee900de2aa10bca5a4e9e36121b25 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <code>this</code> spatial vector to the provided spatial vector <code>other</code> within a specified tolerance.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#adecee900de2aa10bca5a4e9e36121b25">More...</a><br /></td></tr>
<tr class="separator:adecee900de2aa10bca5a4e9e36121b25 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b2415a4b0787515507518d9c0dd4e5 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a09b2415a4b0787515507518d9c0dd4e5">SetNaN</a> ()</td></tr>
<tr class="memdesc:a09b2415a4b0787515507518d9c0dd4e5 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all entries in <code>this</code> SpatialVector to NaN.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a09b2415a4b0787515507518d9c0dd4e5">More...</a><br /></td></tr>
<tr class="separator:a09b2415a4b0787515507518d9c0dd4e5 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d910cbcc53e1f9e2c4bcf24f0f61fc inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a9e320858f0854b7842fbd11edeeca62c">SpatialQuantity</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#aa4d910cbcc53e1f9e2c4bcf24f0f61fc">SetZero</a> ()</td></tr>
<tr class="memdesc:aa4d910cbcc53e1f9e2c4bcf24f0f61fc inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets both rotational and translational components of <code>this</code> SpatialVector to zero.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#aa4d910cbcc53e1f9e2c4bcf24f0f61fc">More...</a><br /></td></tr>
<tr class="separator:aa4d910cbcc53e1f9e2c4bcf24f0f61fc inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09bd8d0cfc7e7ae4853c5f57973254a inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a5f0089be5091a13d6af90b05e40d2648">CoeffsEigenType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#ab09bd8d0cfc7e7ae4853c5f57973254a">get_coeffs</a> ()</td></tr>
<tr class="memdesc:ab09bd8d0cfc7e7ae4853c5f57973254a inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the underlying storage.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#ab09bd8d0cfc7e7ae4853c5f57973254a">More...</a><br /></td></tr>
<tr class="separator:ab09bd8d0cfc7e7ae4853c5f57973254a inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929ee35f2e827f504f3557b18b3c40c8 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a5f0089be5091a13d6af90b05e40d2648">CoeffsEigenType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a929ee35f2e827f504f3557b18b3c40c8">get_coeffs</a> () const</td></tr>
<tr class="memdesc:a929ee35f2e827f504f3557b18b3c40c8 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the underlying storage.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a929ee35f2e827f504f3557b18b3c40c8">More...</a><br /></td></tr>
<tr class="separator:a929ee35f2e827f504f3557b18b3c40c8 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0c32d939e868db06857e7c940083bb inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a9e320858f0854b7842fbd11edeeca62c">SpatialQuantity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#afb0c32d939e868db06857e7c940083bb">operator-</a> () const</td></tr>
<tr class="memdesc:afb0c32d939e868db06857e7c940083bb inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operator.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#afb0c32d939e868db06857e7c940083bb">More...</a><br /></td></tr>
<tr class="separator:afb0c32d939e868db06857e7c940083bb inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7519ac8ffeab83f9f99992265b5f5db7 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a7519ac8ffeab83f9f99992265b5f5db7">SpatialVector</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html">SpatialVector</a> &amp;)=default</td></tr>
<tr class="separator:a7519ac8ffeab83f9f99992265b5f5db7 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ef3f82fae301899d9bb544a7ea2de0 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a55ef3f82fae301899d9bb544a7ea2de0">SpatialVector</a> (<a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html">SpatialVector</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a55ef3f82fae301899d9bb544a7ea2de0 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdcb096285e383be3e6a8c2380b616c inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html">SpatialVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#aefdcb096285e383be3e6a8c2380b616c">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html">SpatialVector</a> &amp;)=default</td></tr>
<tr class="separator:aefdcb096285e383be3e6a8c2380b616c inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce284c584f78b3f4cfd64b9d7632aa3 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html">SpatialVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a9ce284c584f78b3f4cfd64b9d7632aa3">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html">SpatialVector</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a9ce284c584f78b3f4cfd64b9d7632aa3 inherit pub_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classdrake_1_1multibody_1_1_spatial_vector"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classdrake_1_1multibody_1_1_spatial_vector')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html">SpatialVector&lt; SpatialAcceleration, T &gt;</a></td></tr>
<tr class="memitem:adc29c2ff13d900c2f185ee95427fb06c inherit pub_types_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><tr class="memdesc:adc29c2ff13d900c2f185ee95427fb06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sizes for spatial quantities and its components in three dimensions.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#adc29c2ff13d900c2f185ee95427fb06c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adc29c2ff13d900c2f185ee95427fb06c inherit pub_types_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e320858f0854b7842fbd11edeeca62c inherit pub_types_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a9e320858f0854b7842fbd11edeeca62c">SpatialQuantity</a> = <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a9e320858f0854b7842fbd11edeeca62c inherit pub_types_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">The more specialized spatial vector class templated on the scalar type T.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a9e320858f0854b7842fbd11edeeca62c">More...</a><br /></td></tr>
<tr class="separator:a9e320858f0854b7842fbd11edeeca62c inherit pub_types_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0089be5091a13d6af90b05e40d2648 inherit pub_types_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a5f0089be5091a13d6af90b05e40d2648">CoeffsEigenType</a></td></tr>
<tr class="memdesc:a5f0089be5091a13d6af90b05e40d2648 inherit pub_types_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the underlying in-memory representation using an <a class="el" href="namespace_eigen.html">Eigen</a> vector.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a5f0089be5091a13d6af90b05e40d2648">More...</a><br /></td></tr>
<tr class="separator:a5f0089be5091a13d6af90b05e40d2648 inherit pub_types_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10f2f6c99c6db0e698fdb1221e1b983 inherit pub_types_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#ad10f2f6c99c6db0e698fdb1221e1b983">ScalarType</a></td></tr>
<tr class="separator:ad10f2f6c99c6db0e698fdb1221e1b983 inherit pub_types_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classdrake_1_1multibody_1_1_spatial_vector"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classdrake_1_1multibody_1_1_spatial_vector')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html">SpatialVector&lt; SpatialAcceleration, T &gt;</a></td></tr>
<tr class="memitem:a73f248b5cef3cf345c59fe794472fc4c inherit pub_static_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a9e320858f0854b7842fbd11edeeca62c">SpatialQuantity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a73f248b5cef3cf345c59fe794472fc4c">Zero</a> ()</td></tr>
<tr class="memdesc:a73f248b5cef3cf345c59fe794472fc4c inherit pub_static_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a <em>zero</em> SpatialVector, i.e.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a73f248b5cef3cf345c59fe794472fc4c">More...</a><br /></td></tr>
<tr class="separator:a73f248b5cef3cf345c59fe794472fc4c inherit pub_static_methods_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classdrake_1_1multibody_1_1_spatial_vector"><td colspan="2" onclick="javascript:toggleInherit('related_classdrake_1_1multibody_1_1_spatial_vector')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html">SpatialVector&lt; SpatialAcceleration, T &gt;</a></td></tr>
<tr class="memitem:a5348c349330782440dbdd2e600cd31c0 inherit related_classdrake_1_1multibody_1_1_spatial_vector"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a5348c349330782440dbdd2e600cd31c0">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html">SpatialVector</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html#a9e320858f0854b7842fbd11edeeca62c">SpatialQuantity</a>, T &gt; &amp;V)</td></tr>
<tr class="memdesc:a5348c349330782440dbdd2e600cd31c0 inherit related_classdrake_1_1multibody_1_1_spatial_vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream insertion operator to write SpatialVector objects into a <code>std::ostream</code>.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#a5348c349330782440dbdd2e600cd31c0">More...</a><br /></td></tr>
<tr class="separator:a5348c349330782440dbdd2e600cd31c0 inherit related_classdrake_1_1multibody_1_1_spatial_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::SpatialAcceleration&lt; T &gt;</h3>

<p>This class is used to represent a <em>spatial acceleration</em> that combines rotational (angular acceleration) and translational (linear acceleration) components. </p>
<p>While a <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html" title="This class is used to represent a spatial velocity (also called a twist) that combines rotational (an...">SpatialVelocity</a> <code>V_XY</code> represents the motion of a "moving frame" Y measured with respect to a "measured-in" frame X, the SpatialAcceleration <code>A_XY</code> represents the rate of change of this spatial velocity <code>V_XY</code> in frame X. That is \(^XA^Y = \frac{^Xd}{dt}\,{^XV^Y} \) where \(\frac{^Xd}{dt} \) denotes the time derivative taken in frame X. That is, to compute an acceleration we need to specify in what frame the time derivative is taken, see [Mitiguy 2016, §6.1] for a more in depth discussion on this. Time derivatives can be taken in different frames, and they transform according to the "Transport Theorem", which is in Drake is implemented in <a class="el" href="namespacedrake_1_1math.html#a7ad7ab2561d0c05591eb9720adccc7d5" title="Given ᴮd/dt(v) (the time derivative in frame B of an arbitrary 3D vector v) and given ᴬωᴮ (frame B...">drake::math::ConvertTimeDerivativeToOtherFrame()</a>. In source code comments we write <code>A_XY = DtX(V_XY)</code>, where <code>DtX()</code> is the operator that takes the time derivative in the X frame. By convention, and unless otherwise stated, we assume that the frame in which the time derivative is taken is the "measured-in" frame, i.e. the time derivative used in <code>A_XY</code> is in frame X by default (i.e. DtX()). To perform numerical computations, we need to specify an "expressed-in" frame E (which may be distinct from either X or Y), so that components can be expressed as real numbers. Only the vector values are stored in a SpatialAcceleration object; the frames must be understood from context and it is the responsibility of the user to keep track of them. That is best accomplished through disciplined notation. In source code we use monogram notation where capital A is used to designate a spatial acceleration quantity. The same monogram notation rules for <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html" title="This class is used to represent a spatial velocity (also called a twist) that combines rotational (an...">SpatialVelocity</a> are also used for SpatialAcceleration. That is, the spatial acceleration of a frame Y measured in X and expressed in E is denoted with <code>A_XY_E</code>. For a more detailed introduction on spatial vectors and the monogram notation please refer to section <a class="el" href="group__multibody__spatial__vectors.html">Spatial Vectors</a>.</p>
<p>[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics &amp; Motion Simulation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The underlying scalar type. Must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8bf37dab7236092d343a3550f3c0a97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf37dab7236092d343a3550f3c0a97d">&#9670;&nbsp;</a></span>SpatialAcceleration() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a779e53116ddd6e0dbded2c52f141c580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779e53116ddd6e0dbded2c52f141c580">&#9670;&nbsp;</a></span>SpatialAcceleration() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7f507917333adceb2c6542f4d2df38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f507917333adceb2c6542f4d2df38c">&#9670;&nbsp;</a></span>SpatialAcceleration() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>In Release builds the elements of the newly constructed spatial acceleration are left uninitialized resulting in a zero cost operation. However in Debug builds those entries are set to NaN so that operations using this uninitialized spatial acceleration fail fast, allowing fast bug detection. </p>

</div>
</div>
<a id="aa6bf6b4ed657ad8f3bacd8d7cf2e8338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bf6b4ed657ad8f3bacd8d7cf2e8338">&#9670;&nbsp;</a></span>SpatialAcceleration() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html" title="This class is used to represent a spatial acceleration that combines rotational (angular acceleration...">SpatialAcceleration</a> constructor from an angular acceleration <code>alpha</code> and a linear acceleration <code>a</code>. </p>

</div>
</div>
<a id="a7b917a147d41074fa7d6b8108d3d19c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b917a147d41074fa7d6b8108d3d19c1">&#9670;&nbsp;</a></span>SpatialAcceleration() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html" title="This class is used to represent a spatial acceleration that combines rotational (angular acceleration...">SpatialAcceleration</a> constructor from an <a class="el" href="namespace_eigen.html">Eigen</a> expression that represents a six-dimensional vector. </p>
<p>Under the hood, spatial accelerations are 6-element quantities that are pairs of ordinary 3-vectors. Elements 0-2 constitute the angular acceleration component while elements 3-5 constitute the translational acceleration. The argument <code>A</code> in this constructor is the concatenation of the rotational 3D component followed by the translational 3D component. This constructor will assert the size of <code>A</code> is six (6) at compile-time for fixed sized <a class="el" href="namespace_eigen.html">Eigen</a> expressions and at run-time for dynamic sized <a class="el" href="namespace_eigen.html">Eigen</a> expressions. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adefc4f231d1c1b976b8a99004921b164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefc4f231d1c1b976b8a99004921b164">&#9670;&nbsp;</a></span>ComposeWithMovingFrameAcceleration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt;T&gt; ComposeWithMovingFrameAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PoBo_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_WP_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_PB_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_PB_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method composes <code>this</code> spatial acceleration <code>A_WP</code> of a frame P measured in a frame W, with that of a third frame B moving in P with spatial acceleration <code>A_PB</code>. </p>
<p>The result is the spatial acceleration <code>A_WB</code> of frame B measured in W. At the instant in which the accelerations are composed, frame B is located with its origin <code>Bo</code> at <code>p_PoBo</code> from P's origin Po.</p>
<p>This operation can be written in a more compact fom in terms of the rigid shift operator <code>Φᵀ(p_PoBo)</code> (see <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html#a6f3d914695e66945fc14bb098058b1f3" title="Shift of a SpatialVelocity from one point on a rigid body or frame to another point on the same body ...">SpatialVelocity::Shift()</a>) as: </p><pre>
  A_WB = Φᵀ(p_PoBo)A_WP + Ac_WB(w_WP, V_PB) + A_PB_W
</pre><p> where <code>Φᵀ(p_PoBo)A_WP</code> denotes the application of the rigid shift operation as in <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html#a6f3d914695e66945fc14bb098058b1f3" title="Shift of a SpatialVelocity from one point on a rigid body or frame to another point on the same body ...">SpatialVelocity::Shift()</a> and <code>Ac_WB(w_WP, V_PB)</code> contains the centrifugal and Coriolis terms: </p><pre>
  Ac_WB(w_WP, V_PB) = | w_WP x w_PB_W                            |
                      | w_WP x w_WP x p_PoBo_W + 2 w_WP x v_PB_W |
                                  ^^^                ^^^
                              centrifugal         Coriolis
</pre><p> The equation above shows that composing spatial accelerations cannot be simply accomplished by adding <code>A_WP</code> with <code>A_PB</code> (this is the reason why this class does not overload the <code><a class="el" href="namespacedrake_1_1multibody.html#a43f558d75654fa0468cecbead1324ca9" title="Computes the resultant spatial force as the addition of two spatial forces F1_Sp_E and F2_Sp_E on a s...">operator+()</a></code> and provides this method instead). Moreover, we see that, unlike with angular velocities, angular accelerations cannot be added in order to compose them. That is <code>w_AC = w_AB + w_BC</code> but <code>alpha_AC ≠ alpha_AB + alpha_BC</code> due to the cross term <code>w_AC x w_BC</code>. See the derivation below for more details.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html#a7d173a00c859d5a2e3cfe3ce6939edd9" title="This method composes this spatial velocity V_WP of a frame P measured in a frame W, with that of a third frame B moving in P with spatial velocity V_PB. ">SpatialVelocity::ComposeWithMovingFrameVelocity()</a> for the composition of <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html" title="This class is used to represent a spatial velocity (also called a twist) that combines rotational (an...">SpatialVelocity</a> quantities.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is the extension to the <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#a396ad36ac4f0aedd9dc30d2847c3fb5d" title="Shifts this spatial acceleration A_WP of a frame P into the spatial acceleration A_WPb of a frame Pb ...">Shift()</a> operator, which computes the spatial acceleration frame P shifted to <code>Bo</code> as if frame B moved rigidly with P, that is, for when <code>V_PB</code> and <code>A_PB</code> are both zero. In other words the results from <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#a396ad36ac4f0aedd9dc30d2847c3fb5d" title="Shifts this spatial acceleration A_WP of a frame P into the spatial acceleration A_WPb of a frame Pb ...">Shift()</a> equal the results from this method when <code>V_PB</code> and <code>A_PB</code> are both zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_PoBo_E</td><td>Shift vector from P's origin to B's origin, expressed in frame E. The "from" point <code>Po</code> must be the point whose acceleration is currently represented in <code>this</code> spatial acceleration, and E must be the same expressed-in frame as for <code>this</code> spatial acceleration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w_WP_E</td><td>Angular velocity of frame P measured in frame A and expressed in frame E. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_PB_E</td><td>The spatial velocity of a third frame B in motion with respect to P, expressed in the same frame E as <code>this</code> spatial acceleration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_PB_E</td><td>The spatial acceleration of a third frame B in motion with respect to P, expressed in the same frame E as <code>this</code> spatial acceleration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">A_WB_E</td><td>The spatial acceleration of frame B in W, expressed in frame E.</td></tr>
  </table>
  </dd>
</dl>
<h3>Derivation </h3>
<p>The spatial velocity of frame B in W can be obtained by composing <code>V_WP</code> with <code>V_PB</code>: </p><pre>
  V_WB = V_WPb + V_PB = V_WP.Shift(p_PoBo) + V_PB                     (1)
</pre><p> This operation can be performed with the <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html" title="This class is used to represent a spatial velocity (also called a twist) that combines rotational (an...">SpatialVelocity</a> method ComposeWithMovingFrameVelocity().</p>
<h4>Translational acceleration component </h4>
<p>The translational velocity <code>v_WBo</code> of point Bo in W corresponds to the translational component in Eq. (1): </p><pre>
  v_WBo = v_WPo + w_WP x p_PoBo + v_PBo                               (2)
</pre><p> Therefore, for the translational acceleration we have: </p><pre>
  a_WBo = DtW(v_WBo)
        = DtW(v_WPo + w_WP x p_PoBo + v_PBo)
        = DtW(v_WPo) + DtW(w_WP x p_PoBo) + DtW(v_PBo)
        = a_WPo + DtW(w_WP) x p_PoBo + w_WP x DtW(p_PoBo) + DtW(v_PBo)
        = a_WPo + alpha_WP x p_PoBo + w_WP x DtW(p_PoBo) + DtW(v_PBo) (3)
</pre><p> with <code>a_WPo = DtW(v_WPo)</code> and <code>alpha_WP = DtW(w_WP)</code> by definition. The term DtW(p_PoBo) in Eq. (3) is obtained by converting the vector time derivative from <code>DtW()</code> to <code>DtP()</code>, see <a class="el" href="namespacedrake_1_1math.html#a7ad7ab2561d0c05591eb9720adccc7d5" title="Given ᴮd/dt(v) (the time derivative in frame B of an arbitrary 3D vector v) and given ᴬωᴮ (frame B...">drake::math::ConvertTimeDerivativeToOtherFrame()</a>: </p><pre>
  DtW(p_PoBo) = DtP(p_PoBo) + w_WP x p_PoBo
              = v_PBo + w_WP x p_PoBo                                 (4)
</pre><p> since <code>v_PBo = DtP(p_PoBo)</code> by definition. Similarly, the term <code>DtW(v_PBo)</code> in Eq. (3) is also obtained by converting the time derivative from <code>DtW()</code> to <code>DtP()</code>: </p><pre>
  DtW(v_PBo) = DtP(v_PBo) + w_WP x v_PBo
             = a_PBo + w_WP x v_PBo                                   (5)
</pre><p> with <code>a_PBo = DtP(v_PBo)</code> by definition. Using Eqs. (4) and (5) in Eq. (3) yields for the translational acceleration: </p><pre>
  a_WBo = a_WPo + alpha_WP x p_PoBo
        + w_WP x (v_PBo + w_WP x p_PoBo) + a_PBo + w_WP x v_PBo
</pre><p> and finally, by grouping terms together: </p><pre>
  a_WBo = a_WPo + alpha_WP x p_PoBo
        + w_WP x w_WP x p_PoBo + 2 * w_WP x v_PBo + a_PBo             (6)
</pre><p> which includes the effect of angular acceleration of P in W <code>alpha_WP x p_PoBo</code>, the centrifugual acceleration <code>w_WP x w_WP x p_PoBo</code>, the Coriolis acceleration <code>2 * w_WP x v_PBo</code> due to the motion of <code>Bo</code> in P and, the additional acceleration of <code>Bo</code> in P <code>a_PBo</code>.</p>
<h4>Rotational acceleration component </h4>
<p>The rotational velocity <code>w_WB</code> of frame B in W corresponds to the rotational component in Eq. (1): </p><pre>
  w_WB = w_WP + w_PB                                                  (7)
</pre><p> Therefore, the rotational acceleration of B in W corresponds to: </p><pre>
  alpha_WB = DtW(w_WB) = DtW(w_WP) + DtW(w_PB)
           = alpha_WP + DtW(w_PB)                                     (8)
</pre><p> where the last term in Eq. (8) can be converted to a time derivative in P as: </p><pre>
  DtW(w_PB) = DtP(w_PB) + w_WP x w_PB = alpha_PB + w_WP x w_PB        (9)
</pre><p> where <code>alpha_PB = DtP(w_PB)</code> by definition. Thus, the final expression for <code>alpha_WB</code> is obtained by using Eq. (9) into Eq. (8): </p><pre>
  alpha_WB = alpha_WP + alpha_PB + w_WP x w_PB                       (10)
</pre><p> Equation (10) shows that angular accelerations cannot be simply added as angular velocities can but there exists an additional term <code>w_WP x w_PB</code>.</p>
<h4>The spatial acceleration </h4>
<p>The rotational and translational components of the spatial acceleration are given by Eqs. (10) and (6) respectively: </p><pre>
  A_WB.rotational() = alpha_WB = {alpha_WP} + alpha_PB + w_WP x w_PB (11)
  A_WB.translational() = a_WBo
                     = {a_WPo + alpha_WP x p_PoBo + w_WP x w_WP x p_PoBo}
                     + 2 * w_WP x v_PBo + a_PBo                      (12)
</pre><p> where we have placed within curly brackets <code>{}</code> all the terms that also appear in the <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#a396ad36ac4f0aedd9dc30d2847c3fb5d" title="Shifts this spatial acceleration A_WP of a frame P into the spatial acceleration A_WPb of a frame Pb ...">Shift()</a> operation, which is equivalent to this method when <code>V_PB</code> and <code>A_PB</code> are both zero. In the equations above <code>alpha_WP = A_WP.rotational()</code> and <code>a_WPo = A_WP.translational()</code>. The above expression can be written in a more compact fom in terms of the rigid shift operator <code>Φᵀ(p_PoBo)</code> (see <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html#a6f3d914695e66945fc14bb098058b1f3" title="Shift of a SpatialVelocity from one point on a rigid body or frame to another point on the same body ...">SpatialVelocity::Shift()</a>) as presented in the main body of this documentation: </p><pre>
  A_WB = Φᵀ(p_PoBo)A_WP + Ac_WB(w_WP, V_PB) + A_PB_W                 (13)
</pre><p> where <code>Ac_WB(w_WP, V_PB)</code> contains the centrifugal and Coriolis terms: </p><pre>
  Ac_WB(w_WP, V_PB) = | w_WP x w_PB_W                            |
                      | w_WP x w_WP x p_PoBo_W + 2 w_WP x v_PB_W |
                                  ^^^                ^^^
                              centrifugal         Coriolis
</pre><p> As usual, for computation, all quantities above must be expressed in a common frame E; we add an <code>_E</code> suffix to each symbol to indicate that. </p>

</div>
</div>
<a id="af1304fa4eec81102161931379fe4b55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1304fa4eec81102161931379fe4b55c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e2c52c1ca5f71c7d19ae3e462f28ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2c52c1ca5f71c7d19ae3e462f28ea4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a396ad36ac4f0aedd9dc30d2847c3fb5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396ad36ac4f0aedd9dc30d2847c3fb5d">&#9670;&nbsp;</a></span>Shift()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt;T&gt; Shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PoBo_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_WP_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts <code>this</code> spatial acceleration <code>A_WP</code> of a frame P into the spatial acceleration <code>A_WPb</code> of a frame <code>Pb</code> which is an offset frame rigidly aligned with P, but with its origin shifted to a point <code>Bo</code> by an offset p_PoBo. </p>
<p><a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> <code>Pb</code> is instantaneously moving together with frame P as if rigidly attached to it. As an example of application, this operation can be used to compute <code>A_WPb</code> where P is a frame on a rigid body and <code>Bo</code> is another point on that same body. Therefore P and <code>Pb</code> move together with the spatial velocity <code>V_PPb</code> being zero at all times. This is an alternate signature for shifting a spatial acceleration that does not change the original object. See <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#a707251979c42429c0e6ee7dfb6542b98" title="In-place shift of this spatial acceleration A_WP of a frame P into the spatial acceleration A_WPb of ...">ShiftInPlace()</a> for more information and a description of the arguments. </p>

</div>
</div>
<a id="a707251979c42429c0e6ee7dfb6542b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707251979c42429c0e6ee7dfb6542b98">&#9670;&nbsp;</a></span>ShiftInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt;T&gt;&amp; ShiftInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PoBo_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_WP_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place shift of <code>this</code> spatial acceleration <code>A_WP</code> of a frame P into the spatial acceleration <code>A_WPb</code> of a frame <code>Pb</code> which is an offset frame rigidly aligned with P, but with its origin shifted to a point <code>Bo</code> by an offset p_PoBo. </p>
<p><a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> <code>Pb</code> is instantaneously moving together with frame P as if rigidly attached to it. As an example of application, this operation can be used to compute <code>A_WPb</code> where P is a frame on a rigid body and <code>Bo</code> is another point on that same body. Therefore P and <code>Pb</code> move together with the spatial velocity <code>V_PPb</code> being zero at all times.</p>
<p>The shift operation modifies <code>this</code> spatial acceleration <code>A_WP_E</code> of a frame P measured in a frame W and expressed in a frame E, to become <code>A_WPb_E</code>, representing the acceleration of a frame <code>Pb</code> result of shifting frame P to point <code>Bo</code> which instantaneously moves together with frame P. This requires adjusting the linear acceleration component to account for:</p>
<ol type="1">
<li>the angular acceleration <code>alpha_WP</code> of frame P in W.</li>
<li>the centrifugal acceleration due to the angular velocity <code>w_WP</code> of frame P in W.</li>
</ol>
<p>We are given the vector from the origin <code>Po</code> of frame P to point <code>Bo</code>, which becomes the origin of the shifted frame <code>Pb</code>, as the position vector <code>p_PoBo_E</code> expressed in the same frame E as <code>this</code> spatial acceleration. The operation performed, in coordinate-free form, is: </p><pre>
  alpha_WPb  = alpha_WP,  i.e. the angular acceleration is unchanged.
  a_WBo = a_WPo + alpha_WP x p_PoBo + w_WP x w_WP x p_PoBo
</pre><p> where <code>alpha</code> and <code>a</code> represent the angular and linear acceleration components respectively. See notes at the end of this documentation for a detailed derivation.</p>
<p>For computation, all quantities above must be expressed in a common frame E; we add an <code>_E</code> suffix to each symbol to indicate that.</p>
<p>This operation is performed in-place modifying the original object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_PoBo_E</td><td>Shift vector from the origin <code>Po</code> of frame P to point <code>Bo</code>, expressed in frame E. The "from" frame P must be the frame whose acceleration is currently represented in <code>this</code> spatial acceleration, and E must be the same expressed-in frame as for this spatial acceleration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w_WP_E</td><td>Angular velocity of frame P measured in frame W and expressed in frame E.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> spatial acceleration which is now <code>A_WPb_E</code>, that is, the spatial acceleration of frame <code>Pb</code>, still measured in frame W and expressed in frame E.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html#a396ad36ac4f0aedd9dc30d2847c3fb5d" title="Shifts this spatial acceleration A_WP of a frame P into the spatial acceleration A_WPb of a frame Pb ...">Shift()</a> to compute the shifted spatial <a class="el" href="system__identification__test_8cc.html#a24df1cc087cfeb6f8b7cb95deada4f19">acceleration</a> without modifying this original object.</dd></dl>
<h3>Derivation </h3>
<h4>Translational acceleration component </h4>
<p>Recall that frame <code>Pb</code> is an offset frame rigidly aligned with P, but with its origin shifted to a point <code>Bo</code> by an offset <code>p_PoBo</code>. <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> <code>Pb</code> is instantaneously moving together with frame P as if rigidly attached to it. The translational velocity <code>v_WPb</code> of frame <code>Pb</code>'s origin, point <code>Bo</code>, in W can be obtained by the shift operation as: </p><pre>
  v_WPb = v_WPo + w_WP x p_PoBo                                       (1)
</pre><p> Therefore, for the translational acceleration we have: </p><pre>
  a_WBo = DtW(v_WPb)
        = DtW(v_WPo + w_WP x p_PoBo)
        = DtW(v_WPo) + DtW(w_WP x p_PoBo)
        = a_WPo + DtW(w_WP) x p_PoBo + w_WP x DtW(p_PoBo)
        = a_WPo + alpha_WP x p_PoBo + w_WP x DtW(p_PoBo)              (2)
</pre><p> with <code>a_WPo = DtW(v_WPo)</code> and <code>alpha_WP = DtW(w_WP)</code> by definition. The last term in Eq. (2) is obtained by converting the vector time derivative from <code>DtW()</code> to <code>DtP()</code>, see <a class="el" href="namespacedrake_1_1math.html#a7ad7ab2561d0c05591eb9720adccc7d5" title="Given ᴮd/dt(v) (the time derivative in frame B of an arbitrary 3D vector v) and given ᴬωᴮ (frame B...">drake::math::ConvertTimeDerivativeToOtherFrame()</a>: </p><pre>
  DtW(p_PoBo) = DtP(p_PoBo) + w_WP x p_PoBo
              = w_WP x p_PoBo                                         (3)
</pre><p> since <code>v_PBo = DtP(p_PoBo) = 0</code> because the position of point <code>Bo</code> is fixed in frame P. Using Eq. (3) in Eq. (2) finally yields for the translational acceleration: </p><pre>
  a_WBo = a_WPo + alpha_WP x p_PoBo + w_WP x w_WP x p_PoBo            (4)
</pre><h4>Rotational acceleration component </h4>
<p>The rotational velocity of frame <code>Pb</code> simply equals that of frame P since they are moving together in rigid motion, therefore <code>w_WPb = w_WP</code>. From this, the rotational acceleration of frame <code>Pb</code> in W is obtained as: </p><pre>
  alpha_WPb = DtW(w_WPb) = DtW(w_WP) = alpha_WP                       (5)
</pre><p> which should be immediately obvious considering that frame <code>Pb</code> rotates together with frame P.</p>
<p>With the rotational, Eq. (5), and translational, Eq. (4), components of acceleration derived above, we can write for <code>A_WPb</code>: </p><pre>
  A_WPb.rotational() = alpha_WPb = alpha_WP
  A_WPb.translational() = a_WBo
                        = a_WPo + alpha_WP x p_PoBo + w_WP x w_WP x p_PoBo
</pre><p> with <code>alpha_WP = A_WP.rotational()</code> and <code>a_WPo = A_WP.translational()</code>. As usual, for computation, all quantities above must be expressed in a common frame E; we add an <code>_E</code> suffix to each symbol to indicate that. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/multibody_tree/math/<a class="el" href="spatial__acceleration_8h.html">spatial_acceleration.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
