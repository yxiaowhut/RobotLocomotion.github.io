<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: System&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1systems_1_1_system.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdrake_1_1systems_1_1_system-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">System&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for all <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> functionality that is dependent on the templatized scalar type T for input, state, parameters, and outputs.  
 <a href="classdrake_1_1systems_1_1_system.html#details">More...</a></p>

<p><code>#include &lt;drake/systems/framework/witness_function.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3773fa71e3bc321a65cc8690b9291d14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a3773fa71e3bc321a65cc8690b9291d14">~System</a> () override=default</td></tr>
<tr class="separator:a3773fa71e3bc321a65cc8690b9291d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9811579b88aa9f5e5524c980f354fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a5c9811579b88aa9f5e5524c980f354fe">GetWitnessFunctions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; *&gt; *w) const</td></tr>
<tr class="memdesc:a5c9811579b88aa9f5e5524c980f354fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the witness functions active for the given state.  <a href="#a5c9811579b88aa9f5e5524c980f354fe">More...</a><br /></td></tr>
<tr class="separator:a5c9811579b88aa9f5e5524c980f354fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2949deb61db7903dae4c0b7cb9633fac"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a2949deb61db7903dae4c0b7cb9633fac">CalcWitnessValue</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &amp;witness_func) const</td></tr>
<tr class="memdesc:a2949deb61db7903dae4c0b7cb9633fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a witness function at the given context.  <a href="#a2949deb61db7903dae4c0b7cb9633fac">More...</a><br /></td></tr>
<tr class="separator:a2949deb61db7903dae4c0b7cb9633fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838b32b3b596aae6c11fa9c19e655407"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a838b32b3b596aae6c11fa9c19e655407">AddTriggeredWitnessFunctionToCompositeEventCollection</a> (<a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; *event, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const =0</td></tr>
<tr class="memdesc:a838b32b3b596aae6c11fa9c19e655407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <code>event</code> to <code>events</code> due to a witness function triggering.  <a href="#a838b32b3b596aae6c11fa9c19e655407">More...</a><br /></td></tr>
<tr class="separator:a838b32b3b596aae6c11fa9c19e655407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a718e74eb516f658aa9f80ab77706e4e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a718e74eb516f658aa9f80ab77706e4e5">System</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> &amp;)=delete</td></tr>
<tr class="separator:a718e74eb516f658aa9f80ab77706e4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a193dfa5e776f4c271dbb37a6bd03f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a0a193dfa5e776f4c271dbb37a6bd03f5">operator=</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> &amp;)=delete</td></tr>
<tr class="separator:a0a193dfa5e776f4c271dbb37a6bd03f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e42f15501f79c6a60375041a7e3729"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a51e42f15501f79c6a60375041a7e3729">System</a> (<a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a51e42f15501f79c6a60375041a7e3729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64a17bc4243a6ba605108281c6519de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ac64a17bc4243a6ba605108281c6519de">operator=</a> (<a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac64a17bc4243a6ba605108281c6519de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Resource allocation and initialization</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are used to allocate and initialize <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> resources.</p>
</div></td></tr>
<tr class="memitem:a07c386a39241bbd79236c7701d370d7e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a07c386a39241bbd79236c7701d370d7e">AllocateContext</a> () const</td></tr>
<tr class="memdesc:a07c386a39241bbd79236c7701d370d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Context&lt;T&gt; suitable for use with this System&lt;T&gt;.  <a href="#a07c386a39241bbd79236c7701d370d7e">More...</a><br /></td></tr>
<tr class="separator:a07c386a39241bbd79236c7701d370d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd4136260d1751f53abe9f9f3610df0"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#abbd4136260d1751f53abe9f9f3610df0">AllocateCompositeEventCollection</a> () const =0</td></tr>
<tr class="memdesc:abbd4136260d1751f53abe9f9f3610df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html" title="This class bundles an instance of each EventCollection&lt;EventType&gt; into one object that stores the het...">CompositeEventCollection</a> for this system.  <a href="#abbd4136260d1751f53abe9f9f3610df0">More...</a><br /></td></tr>
<tr class="separator:abbd4136260d1751f53abe9f9f3610df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7d64d658e5fb67234d9ffc918155bd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a6c7d64d658e5fb67234d9ffc918155bd">AllocateInputVector</a> (const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;input_port) const</td></tr>
<tr class="memdesc:a6c7d64d658e5fb67234d9ffc918155bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input port, allocates the vector storage.  <a href="#a6c7d64d658e5fb67234d9ffc918155bd">More...</a><br /></td></tr>
<tr class="separator:a6c7d64d658e5fb67234d9ffc918155bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a50463e995d1d3e414ade7051c3458a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">AbstractValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a3a50463e995d1d3e414ade7051c3458a">AllocateInputAbstract</a> (const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;input_port) const</td></tr>
<tr class="memdesc:a3a50463e995d1d3e414ade7051c3458a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input port, allocates the abstract storage.  <a href="#a3a50463e995d1d3e414ade7051c3458a">More...</a><br /></td></tr>
<tr class="separator:a3a50463e995d1d3e414ade7051c3458a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b7d1592da75535d37841d338ec39be"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a52b7d1592da75535d37841d338ec39be">AllocateOutput</a> () const</td></tr>
<tr class="memdesc:a52b7d1592da75535d37841d338ec39be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container that can hold the values of all of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>'s output ports.  <a href="#a52b7d1592da75535d37841d338ec39be">More...</a><br /></td></tr>
<tr class="separator:a52b7d1592da75535d37841d338ec39be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5935b95776173ff31b5923c5b6c9e1"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a8b5935b95776173ff31b5923c5b6c9e1">AllocateTimeDerivatives</a> () const</td></tr>
<tr class="memdesc:a8b5935b95776173ff31b5923c5b6c9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html" title="ContinuousState is a view of, and optionally a container for, all the continuous state variables xc o...">ContinuousState</a> of the same size as the continuous_state allocated in CreateDefaultContext.  <a href="#a8b5935b95776173ff31b5923c5b6c9e1">More...</a><br /></td></tr>
<tr class="separator:a8b5935b95776173ff31b5923c5b6c9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99efc8858c97bc99384ab81c2d5ac3a0"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a99efc8858c97bc99384ab81c2d5ac3a0">AllocateDiscreteVariables</a> () const</td></tr>
<tr class="memdesc:a99efc8858c97bc99384ab81c2d5ac3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a DiscreteState of the same dimensions as the discrete_state allocated in CreateDefaultContext.  <a href="#a99efc8858c97bc99384ab81c2d5ac3a0">More...</a><br /></td></tr>
<tr class="separator:a99efc8858c97bc99384ab81c2d5ac3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad047317ab91889c6743d5e47a64c7f08"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ad047317ab91889c6743d5e47a64c7f08">CreateDefaultContext</a> () const</td></tr>
<tr class="memdesc:ad047317ab91889c6743d5e47a64c7f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This convenience method allocates a context using <a class="el" href="classdrake_1_1systems_1_1_system.html#a07c386a39241bbd79236c7701d370d7e" title="Returns a Context&lt;T&gt; suitable for use with this System&lt;T&gt;. ">AllocateContext()</a> and sets its default values using <a class="el" href="classdrake_1_1systems_1_1_system.html#ab4e6ee413f4f47a20f6dcc2cbd831b88">SetDefaultContext()</a>.  <a href="#ad047317ab91889c6743d5e47a64c7f08">More...</a><br /></td></tr>
<tr class="separator:ad047317ab91889c6743d5e47a64c7f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909935648b14e55b07263264616ace3c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a909935648b14e55b07263264616ace3c">SetDefaultState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const =0</td></tr>
<tr class="memdesc:a909935648b14e55b07263264616ace3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns default values to all elements of the state.  <a href="#a909935648b14e55b07263264616ace3c">More...</a><br /></td></tr>
<tr class="separator:a909935648b14e55b07263264616ace3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9c4edaf95ef26f1ec419f32446e042"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#abb9c4edaf95ef26f1ec419f32446e042">SetDefaultParameters</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; *parameters) const =0</td></tr>
<tr class="memdesc:abb9c4edaf95ef26f1ec419f32446e042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns default values to all parameters.  <a href="#abb9c4edaf95ef26f1ec419f32446e042">More...</a><br /></td></tr>
<tr class="separator:abb9c4edaf95ef26f1ec419f32446e042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e6ee413f4f47a20f6dcc2cbd831b88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ab4e6ee413f4f47a20f6dcc2cbd831b88">SetDefaultContext</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="separator:ab4e6ee413f4f47a20f6dcc2cbd831b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a8dc372e0063851c9851ee15da74e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a47a8dc372e0063851c9851ee15da74e9">SetRandomState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state, <a class="el" href="namespacedrake_1_1systems.html#ad96f28f81be35c3eb7fa5e19b48db26e">RandomGenerator</a> *generator) const</td></tr>
<tr class="memdesc:a47a8dc372e0063851c9851ee15da74e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns random values to all elements of the state.  <a href="#a47a8dc372e0063851c9851ee15da74e9">More...</a><br /></td></tr>
<tr class="separator:a47a8dc372e0063851c9851ee15da74e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a8969fd7784256a68402b391f8902b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#af7a8969fd7784256a68402b391f8902b">SetRandomParameters</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; *parameters, <a class="el" href="namespacedrake_1_1systems.html#ad96f28f81be35c3eb7fa5e19b48db26e">RandomGenerator</a> *generator) const</td></tr>
<tr class="memdesc:af7a8969fd7784256a68402b391f8902b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns random values to all parameters.  <a href="#af7a8969fd7784256a68402b391f8902b">More...</a><br /></td></tr>
<tr class="separator:af7a8969fd7784256a68402b391f8902b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5a403983483dda39f8196a241225f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a6a5a403983483dda39f8196a241225f2">SetRandomContext</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context, <a class="el" href="namespacedrake_1_1systems.html#ad96f28f81be35c3eb7fa5e19b48db26e">RandomGenerator</a> *generator) const</td></tr>
<tr class="separator:a6a5a403983483dda39f8196a241225f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ec86445724fd77391af7874bfc4848"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a47ec86445724fd77391af7874bfc4848">AllocateFixedInputs</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a47ec86445724fd77391af7874bfc4848"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each input port, allocates a fixed input of the concrete type that this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> requires, and binds it to the port, disconnecting any prior input.  <a href="#a47ec86445724fd77391af7874bfc4848">More...</a><br /></td></tr>
<tr class="separator:a47ec86445724fd77391af7874bfc4848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34847cc9c420c8aa3186d8900197e0f"><td class="memItemLeft" align="right" valign="top">virtual std::multimap&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ab34847cc9c420c8aa3186d8900197e0f">GetDirectFeedthroughs</a> () const =0</td></tr>
<tr class="memdesc:ab34847cc9c420c8aa3186d8900197e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports all direct feedthroughs from input ports to output ports.  <a href="#ab34847cc9c420c8aa3186d8900197e0f">More...</a><br /></td></tr>
<tr class="separator:ab34847cc9c420c8aa3186d8900197e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037dd9c0afe6e059e67edb4c9c01eeb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a037dd9c0afe6e059e67edb4c9c01eeb3">HasAnyDirectFeedthrough</a> () const</td></tr>
<tr class="memdesc:a037dd9c0afe6e059e67edb4c9c01eeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any of the inputs to the system might be directly fed through to any of its outputs and <code>false</code> otherwise.  <a href="#a037dd9c0afe6e059e67edb4c9c01eeb3">More...</a><br /></td></tr>
<tr class="separator:a037dd9c0afe6e059e67edb4c9c01eeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51acfa17df1bc87ce8eaa0e1556f6d46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a51acfa17df1bc87ce8eaa0e1556f6d46">HasDirectFeedthrough</a> (<a class="el" href="classint.html">int</a> output_port) const</td></tr>
<tr class="memdesc:a51acfa17df1bc87ce8eaa0e1556f6d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there might be direct-feedthrough from any input port to the given <code>output_port</code>, and false otherwise.  <a href="#a51acfa17df1bc87ce8eaa0e1556f6d46">More...</a><br /></td></tr>
<tr class="separator:a51acfa17df1bc87ce8eaa0e1556f6d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd5092dc2aa2c8f38e0d6336437012d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a8dd5092dc2aa2c8f38e0d6336437012d">HasDirectFeedthrough</a> (<a class="el" href="classint.html">int</a> input_port, <a class="el" href="classint.html">int</a> output_port) const</td></tr>
<tr class="memdesc:a8dd5092dc2aa2c8f38e0d6336437012d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there might be direct-feedthrough from the given <code>input_port</code> to the given <code>output_port</code>, and false otherwise.  <a href="#a8dd5092dc2aa2c8f38e0d6336437012d">More...</a><br /></td></tr>
<tr class="separator:a8dd5092dc2aa2c8f38e0d6336437012d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Publishing</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Publishing is the primary mechanism for a System to communicate with the world outside the System abstraction during a simulation.</p>
<p>Publishing occurs at user-specified times or events and can generate side-effect results such as terminal output, visualization, logging, plotting, and network messages. Other than computational cost, publishing has no effect on the progress of a simulation. </p>
</div></td></tr>
<tr class="memitem:a31898e0276f6bbc4edf7111f809afb01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a31898e0276f6bbc4edf7111f809afb01">Publish</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt;&gt; &amp;events) const</td></tr>
<tr class="memdesc:a31898e0276f6bbc4edf7111f809afb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the public entry point for dispatching all publish event handlers.  <a href="#a31898e0276f6bbc4edf7111f809afb01">More...</a><br /></td></tr>
<tr class="separator:a31898e0276f6bbc4edf7111f809afb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa5fa6fa51aaa8f987abb101e341739"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aafa5fa6fa51aaa8f987abb101e341739">Publish</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aafa5fa6fa51aaa8f987abb101e341739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces a publish on the system, given a <code>context</code>.  <a href="#aafa5fa6fa51aaa8f987abb101e341739">More...</a><br /></td></tr>
<tr class="separator:aafa5fa6fa51aaa8f987abb101e341739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cached evaluations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Given the values in a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, a Drake System must be able to provide the results of particular computations needed for analysis and simulation of the System.</p>
<p>These results are maintained in a mutable cache within the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> so that a result need be computed only once, the first time it is requested after a change to one of its prerequisite values.</p>
<p>The <code>Eval</code> methods in this group return a reference to the already-computed result in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>'s cache. If the current value is out of date, they first update the cache entry using the corresponding <code>Calc</code> method from the "Calculations" group. Evaluations of input ports instead delegate to the containing <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a>, which arranges to have the appropriate subsystem evaluate the source output port.</p>
<p>Methods in this group that specify preconditions operate as follows: The preconditions will be checked in Debug builds but some or all might not be checked in Release builds for performance reasons. If we do check and a precondition is violated, an std::logic_error will be thrown with a helpful message. </p>
</div></td></tr>
<tr class="memitem:ae38625e953699a0433249142972eef52"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ae38625e953699a0433249142972eef52">EvalTimeDerivatives</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:ae38625e953699a0433249142972eef52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the continuous state variable time derivatives, evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#af2677f8773e90a538483eedd80a81a9f" title="Calculates the time derivatives xcdot of the continuous state xc into a given output argument...">CalcTimeDerivatives()</a>.  <a href="#ae38625e953699a0433249142972eef52">More...</a><br /></td></tr>
<tr class="separator:ae38625e953699a0433249142972eef52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432bd44170a669c140bc483e18f9e6df"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a432bd44170a669c140bc483e18f9e6df">EvalPotentialEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a432bd44170a669c140bc483e18f9e6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#a3d5eb1d2630aab1938230257554d1f43" title="Calculates and returns the potential energy represented by the current configuration provided in cont...">CalcPotentialEnergy()</a>.  <a href="#a432bd44170a669c140bc483e18f9e6df">More...</a><br /></td></tr>
<tr class="separator:a432bd44170a669c140bc483e18f9e6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60880d6e51fedbf2ad61b6f0cae8f96"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa60880d6e51fedbf2ad61b6f0cae8f96">EvalKineticEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aa60880d6e51fedbf2ad61b6f0cae8f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#aad01402fef0de79310989d7d22dfde92" title="Calculates and returns the kinetic energy represented by the current configuration and velocity provi...">CalcKineticEnergy()</a>.  <a href="#aa60880d6e51fedbf2ad61b6f0cae8f96">More...</a><br /></td></tr>
<tr class="separator:aa60880d6e51fedbf2ad61b6f0cae8f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d982876c8955c50988ae9f03ce6f75"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa0d982876c8955c50988ae9f03ce6f75">EvalConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aa0d982876c8955c50988ae9f03ce6f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#a5674ae416c2808c939dffc117b209f23" title="Calculates and returns the conservative power represented by the current contents of the given contex...">CalcConservativePower()</a>.  <a href="#aa0d982876c8955c50988ae9f03ce6f75">More...</a><br /></td></tr>
<tr class="separator:aa0d982876c8955c50988ae9f03ce6f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace530af4be075614218eb4bc725c1aba"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ace530af4be075614218eb4bc725c1aba">EvalNonConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:ace530af4be075614218eb4bc725c1aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#a23fe133b70153e382d7f50c38b96bf1f" title="Calculates and returns the non-conservative power represented by the current contents of the given co...">CalcNonConservativePower()</a>.  <a href="#ace530af4be075614218eb4bc725c1aba">More...</a><br /></td></tr>
<tr class="separator:ace530af4be075614218eb4bc725c1aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa184508e6a0494c1b8214dab77e34ce3"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class Vec = BasicVector&gt; </td></tr>
<tr class="memitem:aa184508e6a0494c1b8214dab77e34ce3"><td class="memTemplItemLeft" align="right" valign="top">const Vec&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa184508e6a0494c1b8214dab77e34ce3">EvalVectorInput</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:aa184508e6a0494c1b8214dab77e34ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the vector-valued input port with the given <code>port_index</code> as a <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase. ">BasicVector</a> or a specific subclass <code>Vec</code> derived from <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase. ">BasicVector</a>.  <a href="#aa184508e6a0494c1b8214dab77e34ce3">More...</a><br /></td></tr>
<tr class="separator:aa184508e6a0494c1b8214dab77e34ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02557f96761f5c65d36e55bb2084c8c5"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a02557f96761f5c65d36e55bb2084c8c5">EvalEigenVectorInput</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:a02557f96761f5c65d36e55bb2084c8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the vector-valued input port with the given <code>port_index</code> as an Eigen vector.  <a href="#a02557f96761f5c65d36e55bb2084c8c5">More...</a><br /></td></tr>
<tr class="separator:a02557f96761f5c65d36e55bb2084c8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constraint-related functions</div></td></tr>
<tr class="memitem:aa21289a0f31d15c21a17ae321a75ac47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa21289a0f31d15c21a17ae321a75ac47">get_num_constraint_equations</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aa21289a0f31d15c21a17ae321a75ac47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of constraint equations for this system using the given context (useful in case the number of constraints is dependent upon the current state (as might be the case with a system modeled using piecewise differential algebraic equations).  <a href="#aa21289a0f31d15c21a17ae321a75ac47">More...</a><br /></td></tr>
<tr class="separator:aa21289a0f31d15c21a17ae321a75ac47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a271e43d57f6eeb3bbdb3bbd1105a8d"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a0a271e43d57f6eeb3bbdb3bbd1105a8d">EvalConstraintEquations</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a0a271e43d57f6eeb3bbdb3bbd1105a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the constraint equations for the system at the generalized coordinates and generalized velocity specified by the context.  <a href="#a0a271e43d57f6eeb3bbdb3bbd1105a8d">More...</a><br /></td></tr>
<tr class="separator:a0a271e43d57f6eeb3bbdb3bbd1105a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c0399e6d530a28b40ddde9b2135f6e"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a29c0399e6d530a28b40ddde9b2135f6e">EvalConstraintEquationsDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a29c0399e6d530a28b40ddde9b2135f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the time derivative of each constraint equation, evaluated at the generalized coordinates and generalized velocity specified by the context.  <a href="#a29c0399e6d530a28b40ddde9b2135f6e">More...</a><br /></td></tr>
<tr class="separator:a29c0399e6d530a28b40ddde9b2135f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcd68e4f53dbb75927e2d4f9d709440"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#adbcd68e4f53dbb75927e2d4f9d709440">CalcVelocityChangeFromConstraintImpulses</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::MatrixXd &amp;J, const Eigen::VectorXd &amp;lambda) const</td></tr>
<tr class="memdesc:adbcd68e4f53dbb75927e2d4f9d709440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the change in velocity from applying the given constraint forces to the system at the given context.  <a href="#adbcd68e4f53dbb75927e2d4f9d709440">More...</a><br /></td></tr>
<tr class="separator:adbcd68e4f53dbb75927e2d4f9d709440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71893bf8c20254b15b075c7c10935d12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a71893bf8c20254b15b075c7c10935d12">CalcConstraintErrorNorm</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::VectorXd &amp;error) const</td></tr>
<tr class="memdesc:a71893bf8c20254b15b075c7c10935d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the norm on constraint error (used as a metric for comparing errors between the outputs of algebraic equations applied to two different state variable instances).  <a href="#a71893bf8c20254b15b075c7c10935d12">More...</a><br /></td></tr>
<tr class="separator:a71893bf8c20254b15b075c7c10935d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Calculations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>A Drake System defines a set of common computations that are understood by the framework.</p>
<p>Most of these are embodied in a <code>Calc</code> method that unconditionally performs the calculation into an output argument of the appropriate type, using only values from the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. These are paired with an <code>Eval</code> method that returns a reference to an already-calculated result residing in the cache; if needed that result is first obtained using the <code>Calc</code> method. See the "Evaluations" group for more information.</p>
<p>This group also includes additional System-specific operations that depend on both <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> and additional input arguments. </p>
</div></td></tr>
<tr class="memitem:af2677f8773e90a538483eedd80a81a9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#af2677f8773e90a538483eedd80a81a9f">CalcTimeDerivatives</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *derivatives) const</td></tr>
<tr class="memdesc:af2677f8773e90a538483eedd80a81a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the time derivatives <code>xcdot</code> of the continuous state <code>xc</code> into a given output argument.  <a href="#af2677f8773e90a538483eedd80a81a9f">More...</a><br /></td></tr>
<tr class="separator:af2677f8773e90a538483eedd80a81a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4b5edfcccb98a87f958bc9b6b626bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a2b4b5edfcccb98a87f958bc9b6b626bd">CalcDiscreteVariableUpdates</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt;&gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state) const</td></tr>
<tr class="memdesc:a2b4b5edfcccb98a87f958bc9b6b626bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the public entry point for dispatching all discrete variable update event handlers.  <a href="#a2b4b5edfcccb98a87f958bc9b6b626bd">More...</a><br /></td></tr>
<tr class="separator:a2b4b5edfcccb98a87f958bc9b6b626bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054ef0e9e578c5abc57fd4dc8b12bd84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a054ef0e9e578c5abc57fd4dc8b12bd84">CalcDiscreteVariableUpdates</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state) const</td></tr>
<tr class="memdesc:a054ef0e9e578c5abc57fd4dc8b12bd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method forces a discrete update on the system given a <code>context</code>, and the updated discrete state is stored in <code>discrete_state</code>.  <a href="#a054ef0e9e578c5abc57fd4dc8b12bd84">More...</a><br /></td></tr>
<tr class="separator:a054ef0e9e578c5abc57fd4dc8b12bd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad195518c9c6d2c9421e6e2b222514d89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ad195518c9c6d2c9421e6e2b222514d89">CalcUnrestrictedUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt;&gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:ad195518c9c6d2c9421e6e2b222514d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the public entry point for dispatching all unrestricted update event handlers.  <a href="#ad195518c9c6d2c9421e6e2b222514d89">More...</a><br /></td></tr>
<tr class="separator:ad195518c9c6d2c9421e6e2b222514d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f04e429745ae7a16600c4dfda0f931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a25f04e429745ae7a16600c4dfda0f931">CalcUnrestrictedUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:a25f04e429745ae7a16600c4dfda0f931"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method forces an unrestricted update on the system given a <code>context</code>, and the updated state is stored in <code>state</code>.  <a href="#a25f04e429745ae7a16600c4dfda0f931">More...</a><br /></td></tr>
<tr class="separator:a25f04e429745ae7a16600c4dfda0f931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164afe3c1db737b93696b8808bb2c942"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a164afe3c1db737b93696b8808bb2c942">CalcNextUpdateTime</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:a164afe3c1db737b93696b8808bb2c942"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by a <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> during its calculation of the size of the next continuous step to attempt.  <a href="#a164afe3c1db737b93696b8808bb2c942">More...</a><br /></td></tr>
<tr class="separator:a164afe3c1db737b93696b8808bb2c942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a24b8f910f9d990db8e59bf2bae6d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ad8a24b8f910f9d990db8e59bf2bae6d0">GetPerStepEvents</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:ad8a24b8f910f9d990db8e59bf2bae6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by <a class="el" href="classdrake_1_1systems_1_1_simulator.html#a98b1050f09da390896f964fb7a892391" title="Prepares the Simulator for a simulation. ">Simulator::Initialize()</a> to gather all update and publish events that are to be handled in StepTo() at the point before <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> integrates continuous state.  <a href="#ad8a24b8f910f9d990db8e59bf2bae6d0">More...</a><br /></td></tr>
<tr class="separator:ad8a24b8f910f9d990db8e59bf2bae6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f84e649d76754f38ea7420a21a1a04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ae6f84e649d76754f38ea7420a21a1a04">GetInitializationEvents</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:ae6f84e649d76754f38ea7420a21a1a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by <a class="el" href="classdrake_1_1systems_1_1_simulator.html#a98b1050f09da390896f964fb7a892391" title="Prepares the Simulator for a simulation. ">Simulator::Initialize()</a> to gather all update and publish events that need to be handled at initialization before the simulator starts integration.  <a href="#ae6f84e649d76754f38ea7420a21a1a04">More...</a><br /></td></tr>
<tr class="separator:ae6f84e649d76754f38ea7420a21a1a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f7d226abe6847e09248db0def0c746"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ae0f7d226abe6847e09248db0def0c746">GetUniquePeriodicDiscreteUpdateAttribute</a> () const</td></tr>
<tr class="memdesc:ae0f7d226abe6847e09248db0def0c746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether there exists a unique periodic attribute that triggers one or more discrete update events (and, if so, returns that unique periodic attribute).  <a href="#ae0f7d226abe6847e09248db0def0c746">More...</a><br /></td></tr>
<tr class="separator:ae0f7d226abe6847e09248db0def0c746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd73a23410d860ee73dc021663ec99f"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a>, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; * &gt;, <a class="el" href="structdrake_1_1systems_1_1_periodic_event_data_comparator.html">PeriodicEventDataComparator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#acdd73a23410d860ee73dc021663ec99f">GetPeriodicEvents</a> () const</td></tr>
<tr class="memdesc:acdd73a23410d860ee73dc021663ec99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all periodic triggered events for a system.  <a href="#acdd73a23410d860ee73dc021663ec99f">More...</a><br /></td></tr>
<tr class="separator:acdd73a23410d860ee73dc021663ec99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574467e50cf5c242f665557daca33111"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a574467e50cf5c242f665557daca33111">CalcOutput</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *outputs) const</td></tr>
<tr class="memdesc:a574467e50cf5c242f665557daca33111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method that computes for <em>every</em> output port i the value y(i) that should result from the current contents of the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="#a574467e50cf5c242f665557daca33111">More...</a><br /></td></tr>
<tr class="separator:a574467e50cf5c242f665557daca33111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5eb1d2630aab1938230257554d1f43"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a3d5eb1d2630aab1938230257554d1f43">CalcPotentialEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a3d5eb1d2630aab1938230257554d1f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the potential energy represented by the current configuration provided in <code>context</code>.  <a href="#a3d5eb1d2630aab1938230257554d1f43">More...</a><br /></td></tr>
<tr class="separator:a3d5eb1d2630aab1938230257554d1f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad01402fef0de79310989d7d22dfde92"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aad01402fef0de79310989d7d22dfde92">CalcKineticEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aad01402fef0de79310989d7d22dfde92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the kinetic energy represented by the current configuration and velocity provided in <code>context</code>.  <a href="#aad01402fef0de79310989d7d22dfde92">More...</a><br /></td></tr>
<tr class="separator:aad01402fef0de79310989d7d22dfde92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5674ae416c2808c939dffc117b209f23"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a5674ae416c2808c939dffc117b209f23">CalcConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a5674ae416c2808c939dffc117b209f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the conservative power represented by the current contents of the given <code>context</code>.  <a href="#a5674ae416c2808c939dffc117b209f23">More...</a><br /></td></tr>
<tr class="separator:a5674ae416c2808c939dffc117b209f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fe133b70153e382d7f50c38b96bf1f"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a23fe133b70153e382d7f50c38b96bf1f">CalcNonConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a23fe133b70153e382d7f50c38b96bf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the non-conservative power represented by the current contents of the given <code>context</code>.  <a href="#a23fe133b70153e382d7f50c38b96bf1f">More...</a><br /></td></tr>
<tr class="separator:a23fe133b70153e382d7f50c38b96bf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cc5df6d0d0fe4ea54b522ae776ca39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a05cc5df6d0d0fe4ea54b522ae776ca39">MapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;generalized_velocity, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *qdot) const</td></tr>
<tr class="memdesc:a05cc5df6d0d0fe4ea54b522ae776ca39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a given generalized velocity <code>v</code> to the time derivative <code>qdot</code> of the generalized configuration <code>q</code> taken from the supplied <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="#a05cc5df6d0d0fe4ea54b522ae776ca39">More...</a><br /></td></tr>
<tr class="separator:a05cc5df6d0d0fe4ea54b522ae776ca39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d05cfdce7f2dbae7c9f18babfc827e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a3d05cfdce7f2dbae7c9f18babfc827e8">MapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;generalized_velocity, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *qdot) const</td></tr>
<tr class="memdesc:a3d05cfdce7f2dbae7c9f18babfc827e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given generalized velocity to the time derivative of generalized configuration.  <a href="#a3d05cfdce7f2dbae7c9f18babfc827e8">More...</a><br /></td></tr>
<tr class="separator:a3d05cfdce7f2dbae7c9f18babfc827e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10eba167739bfe8e7e419b5c8ae41537"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a10eba167739bfe8e7e419b5c8ae41537">MapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;qdot, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *generalized_velocity) const</td></tr>
<tr class="memdesc:a10eba167739bfe8e7e419b5c8ae41537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the time derivative <code>qdot</code> of the generalized configuration <code>q</code> to generalized velocities <code>v</code>.  <a href="#a10eba167739bfe8e7e419b5c8ae41537">More...</a><br /></td></tr>
<tr class="separator:a10eba167739bfe8e7e419b5c8ae41537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9914457357091af1a9932863f2b396a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a9914457357091af1a9932863f2b396a4">MapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;qdot, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *generalized_velocity) const</td></tr>
<tr class="memdesc:a9914457357091af1a9932863f2b396a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given time derivative <code>qdot</code> of generalized configuration <code>q</code> to generalized velocity <code>v</code>.  <a href="#a9914457357091af1a9932863f2b396a4">More...</a><br /></td></tr>
<tr class="separator:a9914457357091af1a9932863f2b396a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility methods</div></td></tr>
<tr class="memitem:a9714aaf76aca9169da6de7fbcb8339fb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a9714aaf76aca9169da6de7fbcb8339fb">GetMemoryObjectName</a> () const</td></tr>
<tr class="memdesc:a9714aaf76aca9169da6de7fbcb8339fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a name for this System based on a stringification of its type name and memory address.  <a href="#a9714aaf76aca9169da6de7fbcb8339fb">More...</a><br /></td></tr>
<tr class="separator:a9714aaf76aca9169da6de7fbcb8339fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b7b9f7723ad69fca8766e6590ef681"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a39b7b9f7723ad69fca8766e6590ef681">get_input_port</a> (<a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:a39b7b9f7723ad69fca8766e6590ef681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed input port at index <code>port_index</code>.  <a href="#a39b7b9f7723ad69fca8766e6590ef681">More...</a><br /></td></tr>
<tr class="separator:a39b7b9f7723ad69fca8766e6590ef681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd5af969c0fcb5fe0923aeac56c6124"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a4bd5af969c0fcb5fe0923aeac56c6124">GetInputPort</a> (const std::string &amp;port_name) const</td></tr>
<tr class="memdesc:a4bd5af969c0fcb5fe0923aeac56c6124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed input port with the unique name <code>port_name</code>.  <a href="#a4bd5af969c0fcb5fe0923aeac56c6124">More...</a><br /></td></tr>
<tr class="separator:a4bd5af969c0fcb5fe0923aeac56c6124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d32474ac975155d1289d564016a8a13"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a9d32474ac975155d1289d564016a8a13">get_output_port</a> (<a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:a9d32474ac975155d1289d564016a8a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed output port at index <code>port_index</code>.  <a href="#a9d32474ac975155d1289d564016a8a13">More...</a><br /></td></tr>
<tr class="separator:a9d32474ac975155d1289d564016a8a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8d63cb84ca11a136b9034d7e06a0bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a6d8d63cb84ca11a136b9034d7e06a0bf">GetOutputPort</a> (const std::string &amp;port_name) const</td></tr>
<tr class="memdesc:a6d8d63cb84ca11a136b9034d7e06a0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed output port with the unique name <code>port_name</code>.  <a href="#a6d8d63cb84ca11a136b9034d7e06a0bf">More...</a><br /></td></tr>
<tr class="separator:a6d8d63cb84ca11a136b9034d7e06a0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6ef02eb739a38c128ac65eff3394f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a8a6ef02eb739a38c128ac65eff3394f2">get_num_constraints</a> () const</td></tr>
<tr class="memdesc:a8a6ef02eb739a38c128ac65eff3394f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraints specified for the system.  <a href="#a8a6ef02eb739a38c128ac65eff3394f2">More...</a><br /></td></tr>
<tr class="separator:a8a6ef02eb739a38c128ac65eff3394f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853c4c7c3ab38e861225aa04f91644e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a853c4c7c3ab38e861225aa04f91644e1">get_num_continuous_states</a> () const =0</td></tr>
<tr class="memdesc:a853c4c7c3ab38e861225aa04f91644e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the continuous state vector that has been declared until now.  <a href="#a853c4c7c3ab38e861225aa04f91644e1">More...</a><br /></td></tr>
<tr class="separator:a853c4c7c3ab38e861225aa04f91644e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99fae784f8ff0d30444e35d13601177"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#af99fae784f8ff0d30444e35d13601177">get_constraint</a> (<a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a> constraint_index) const</td></tr>
<tr class="memdesc:af99fae784f8ff0d30444e35d13601177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint at index <code>constraint_index</code>.  <a href="#af99fae784f8ff0d30444e35d13601177">More...</a><br /></td></tr>
<tr class="separator:af99fae784f8ff0d30444e35d13601177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adf20a88ef081c27ea071d880292209"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a4adf20a88ef081c27ea071d880292209">CheckSystemConstraintsSatisfied</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdouble.html">double</a> tol) const</td></tr>
<tr class="memdesc:a4adf20a88ef081c27ea071d880292209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>context</code> satisfies all of the registered SystemConstraints with tolerance <code>tol</code>.  <a href="#a4adf20a88ef081c27ea071d880292209">More...</a><br /></td></tr>
<tr class="separator:a4adf20a88ef081c27ea071d880292209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852a4bc3895e11faf46f4e32b47d338d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a852a4bc3895e11faf46f4e32b47d338d">CheckValidOutput</a> (const <a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *output) const</td></tr>
<tr class="memdesc:a852a4bc3895e11faf46f4e32b47d338d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that <code>output</code> is consistent with the number and size of output ports declared by the system.  <a href="#a852a4bc3895e11faf46f4e32b47d338d">More...</a><br /></td></tr>
<tr class="separator:a852a4bc3895e11faf46f4e32b47d338d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde7091d9f2709229fcb446f3d5ff001"><td class="memTemplParams" colspan="2">template&lt;typename T1  = T&gt; </td></tr>
<tr class="memitem:abde7091d9f2709229fcb446f3d5ff001"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#abde7091d9f2709229fcb446f3d5ff001">CheckValidContextT</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T1 &gt; &amp;context) const</td></tr>
<tr class="memdesc:abde7091d9f2709229fcb446f3d5ff001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that <code>context</code> is consistent for this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> template.  <a href="#abde7091d9f2709229fcb446f3d5ff001">More...</a><br /></td></tr>
<tr class="separator:abde7091d9f2709229fcb446f3d5ff001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c711d92735642b2fa7fc975e9b5bf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a24c711d92735642b2fa7fc975e9b5bf8">CopyContinuousStateVector</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a24c711d92735642b2fa7fc975e9b5bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the continuous state vector <code>xc</code> into an <a class="el" href="namespace_eigen.html">Eigen</a> vector.  <a href="#a24c711d92735642b2fa7fc975e9b5bf8">More...</a><br /></td></tr>
<tr class="separator:a24c711d92735642b2fa7fc975e9b5bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Graphviz methods</div></td></tr>
<tr class="memitem:a588e4f7454694f04b4b654d154f170f3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a588e4f7454694f04b4b654d154f170f3">GetGraphvizString</a> (<a class="el" href="classint.html">int</a> max_depth=std::numeric_limits&lt; <a class="el" href="classint.html">int</a> &gt;::max()) const</td></tr>
<tr class="memdesc:a588e4f7454694f04b4b654d154f170f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Graphviz string describing this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="#a588e4f7454694f04b4b654d154f170f3">More...</a><br /></td></tr>
<tr class="separator:a588e4f7454694f04b4b654d154f170f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8946ae289e8ce80d9d03114e6f60bd86"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a8946ae289e8ce80d9d03114e6f60bd86">GetGraphvizFragment</a> (<a class="el" href="classint.html">int</a> max_depth, std::stringstream *dot) const</td></tr>
<tr class="memdesc:a8946ae289e8ce80d9d03114e6f60bd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a Graphviz fragment to the <code>dot</code> stream.  <a href="#a8946ae289e8ce80d9d03114e6f60bd86">More...</a><br /></td></tr>
<tr class="separator:a8946ae289e8ce80d9d03114e6f60bd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8056b92562217c25ff76fac7ad67961"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ab8056b92562217c25ff76fac7ad67961">GetGraphvizInputPortToken</a> (const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;port, <a class="el" href="classint.html">int</a> max_depth, std::stringstream *dot) const</td></tr>
<tr class="memdesc:ab8056b92562217c25ff76fac7ad67961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a fragment to the <code>dot</code> stream identifying the graphviz node representing <code>port</code>.  <a href="#ab8056b92562217c25ff76fac7ad67961">More...</a><br /></td></tr>
<tr class="separator:ab8056b92562217c25ff76fac7ad67961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75de0b661eaa9b9a45959a9de4eaae0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa75de0b661eaa9b9a45959a9de4eaae0">GetGraphvizOutputPortToken</a> (const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;port, <a class="el" href="classint.html">int</a> max_depth, std::stringstream *dot) const</td></tr>
<tr class="memdesc:aa75de0b661eaa9b9a45959a9de4eaae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a fragment to the <code>dot</code> stream identifying the graphviz node representing <code>port</code>.  <a href="#aa75de0b661eaa9b9a45959a9de4eaae0">More...</a><br /></td></tr>
<tr class="separator:aa75de0b661eaa9b9a45959a9de4eaae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fac664a1c120c425bc522d7ecb435c"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa1fac664a1c120c425bc522d7ecb435c">GetGraphvizId</a> () const</td></tr>
<tr class="memdesc:aa1fac664a1c120c425bc522d7ecb435c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an opaque integer that uniquely identifies this system in the Graphviz output.  <a href="#aa1fac664a1c120c425bc522d7ecb435c">More...</a><br /></td></tr>
<tr class="separator:aa1fac664a1c120c425bc522d7ecb435c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scalar type conversion utilities</div></td></tr>
<tr class="memitem:a601fb2c6cf565d954253d25725ae9d6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a601fb2c6cf565d954253d25725ae9d6b">FixInputPortsFrom</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;other_system, const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;other_context, <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *target_context) const</td></tr>
<tr class="memdesc:a601fb2c6cf565d954253d25725ae9d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixes all of the input ports in <code>target_context</code> to their current values in <code>other_context</code>, as evaluated by <code>other_system</code>.  <a href="#a601fb2c6cf565d954253d25725ae9d6b">More...</a><br /></td></tr>
<tr class="separator:a601fb2c6cf565d954253d25725ae9d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686f497f27885d9f632df0c43d29a0d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a686f497f27885d9f632df0c43d29a0d6">get_system_scalar_converter</a> () const</td></tr>
<tr class="memdesc:a686f497f27885d9f632df0c43d29a0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns the <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html" title="Helper class to convert a System&lt;U&gt; into a System&lt;T&gt;, intended for internal use by the System framewo...">SystemScalarConverter</a> for this object.  <a href="#a686f497f27885d9f632df0c43d29a0d6">More...</a><br /></td></tr>
<tr class="separator:a686f497f27885d9f632df0c43d29a0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1systems_1_1_system_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdrake_1_1systems_1_1_system_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a></td></tr>
<tr class="memitem:ae7271d3848e9754bee3e07c53614100c inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ae7271d3848e9754bee3e07c53614100c">~SystemBase</a> () override</td></tr>
<tr class="separator:ae7271d3848e9754bee3e07c53614100c inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5260b9627048b854b45d05ed34adc22 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad5260b9627048b854b45d05ed34adc22">set_name</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:ad5260b9627048b854b45d05ed34adc22 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the system.  <a href="classdrake_1_1systems_1_1_system_base.html#ad5260b9627048b854b45d05ed34adc22">More...</a><br /></td></tr>
<tr class="separator:ad5260b9627048b854b45d05ed34adc22 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1591b1773209f55ccc85356efb639a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aea1591b1773209f55ccc85356efb639a">get_name</a> () const</td></tr>
<tr class="memdesc:aea1591b1773209f55ccc85356efb639a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name last supplied to <a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad5260b9627048b854b45d05ed34adc22" title="Sets the name of the system. ">set_name()</a>, if any.  <a href="classdrake_1_1systems_1_1_system_base.html#aea1591b1773209f55ccc85356efb639a">More...</a><br /></td></tr>
<tr class="separator:aea1591b1773209f55ccc85356efb639a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2143907221997b4bfd7cf5fc40b422 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#acf2143907221997b4bfd7cf5fc40b422">GetSystemName</a> () const final</td></tr>
<tr class="memdesc:acf2143907221997b4bfd7cf5fc40b422 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a human-readable name for this system, for use in messages and logging.  <a href="classdrake_1_1systems_1_1_system_base.html#acf2143907221997b4bfd7cf5fc40b422">More...</a><br /></td></tr>
<tr class="separator:acf2143907221997b4bfd7cf5fc40b422 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f54385db97ee385847ad7577dbe34e inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ac8f54385db97ee385847ad7577dbe34e">GetSystemPathname</a> () const final</td></tr>
<tr class="memdesc:ac8f54385db97ee385847ad7577dbe34e inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a human-readable full path name of this subsystem, for use in messages and logging.  <a href="classdrake_1_1systems_1_1_system_base.html#ac8f54385db97ee385847ad7577dbe34e">More...</a><br /></td></tr>
<tr class="separator:ac8f54385db97ee385847ad7577dbe34e inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283b89b5f6b6d1745bc590e6050177a9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a283b89b5f6b6d1745bc590e6050177a9">GetSystemType</a> () const final</td></tr>
<tr class="memdesc:a283b89b5f6b6d1745bc590e6050177a9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the most-derived type of this concrete <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> object as a human-readable string suitable for use in error messages.  <a href="classdrake_1_1systems_1_1_system_base.html#a283b89b5f6b6d1745bc590e6050177a9">More...</a><br /></td></tr>
<tr class="separator:a283b89b5f6b6d1745bc590e6050177a9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4efb09df0463ac35602f194f053348 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1f4efb09df0463ac35602f194f053348">ThrowIfContextNotCompatible</a> (const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context) const final</td></tr>
<tr class="memdesc:a1f4efb09df0463ac35602f194f053348 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception with an appropriate message if the given <code>context</code> is not compatible with this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#a1f4efb09df0463ac35602f194f053348">More...</a><br /></td></tr>
<tr class="separator:a1f4efb09df0463ac35602f194f053348 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e75aaff1fa28d033136d4073c59e097 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0e75aaff1fa28d033136d4073c59e097">AllocateContext</a> () const</td></tr>
<tr class="memdesc:a0e75aaff1fa28d033136d4073c59e097 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> suitable for use with this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#a0e75aaff1fa28d033136d4073c59e097">More...</a><br /></td></tr>
<tr class="separator:a0e75aaff1fa28d033136d4073c59e097 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cdbe6795af06e2bb415d5ab860e4e7 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af4cdbe6795af06e2bb415d5ab860e4e7">get_num_input_ports</a> () const</td></tr>
<tr class="memdesc:af4cdbe6795af06e2bb415d5ab860e4e7 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of input ports currently allocated in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#af4cdbe6795af06e2bb415d5ab860e4e7">More...</a><br /></td></tr>
<tr class="separator:af4cdbe6795af06e2bb415d5ab860e4e7 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e45f7b611946054bad75bf53685747 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a39e45f7b611946054bad75bf53685747">get_num_output_ports</a> () const</td></tr>
<tr class="memdesc:a39e45f7b611946054bad75bf53685747 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of output ports currently allocated in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#a39e45f7b611946054bad75bf53685747">More...</a><br /></td></tr>
<tr class="separator:a39e45f7b611946054bad75bf53685747 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209c59864026db2a428f593601ee7ffc inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port_base.html">InputPortBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a209c59864026db2a428f593601ee7ffc">get_input_port_base</a> (<a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a209c59864026db2a428f593601ee7ffc inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an <a class="el" href="classdrake_1_1systems_1_1_input_port.html" title="This extends InputPortBase with some scalar type-dependent methods. ">InputPort</a> given its <code>port_index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a209c59864026db2a428f593601ee7ffc">More...</a><br /></td></tr>
<tr class="separator:a209c59864026db2a428f593601ee7ffc inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa50d5f614683c52737a0694e245963 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port_base.html">OutputPortBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a2fa50d5f614683c52737a0694e245963">get_output_port_base</a> (<a class="el" href="namespacedrake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa">OutputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a2fa50d5f614683c52737a0694e245963 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an <a class="el" href="classdrake_1_1systems_1_1_output_port.html" title="An OutputPort belongs to a System and represents the properties of one of that System&#39;s output ports...">OutputPort</a> given its <code>port_index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a2fa50d5f614683c52737a0694e245963">More...</a><br /></td></tr>
<tr class="separator:a2fa50d5f614683c52737a0694e245963 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd5e53bbc12fdb8d9691fe9abcd951b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aedd5e53bbc12fdb8d9691fe9abcd951b">get_num_total_inputs</a> () const</td></tr>
<tr class="memdesc:aedd5e53bbc12fdb8d9691fe9abcd951b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total dimension of all of the vector-valued input ports (as if they were muxed).  <a href="classdrake_1_1systems_1_1_system_base.html#aedd5e53bbc12fdb8d9691fe9abcd951b">More...</a><br /></td></tr>
<tr class="separator:aedd5e53bbc12fdb8d9691fe9abcd951b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97dedd5343d8eb91b450ee15db973d90 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a97dedd5343d8eb91b450ee15db973d90">get_num_total_outputs</a> () const</td></tr>
<tr class="memdesc:a97dedd5343d8eb91b450ee15db973d90 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total dimension of all of the vector-valued output ports (as if they were muxed).  <a href="classdrake_1_1systems_1_1_system_base.html#a97dedd5343d8eb91b450ee15db973d90">More...</a><br /></td></tr>
<tr class="separator:a97dedd5343d8eb91b450ee15db973d90 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a98a257dc03eb749975de05778dbc8 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a87a98a257dc03eb749975de05778dbc8">num_cache_entries</a> () const</td></tr>
<tr class="memdesc:a87a98a257dc03eb749975de05778dbc8 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number nc of cache entries currently allocated in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#a87a98a257dc03eb749975de05778dbc8">More...</a><br /></td></tr>
<tr class="separator:a87a98a257dc03eb749975de05778dbc8 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517ae28d98adfc4e8381382d0a4c7be9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a517ae28d98adfc4e8381382d0a4c7be9">get_cache_entry</a> (<a class="el" href="namespacedrake_1_1systems.html#a06ac9ad764b14ccff79b6feb393be498">CacheIndex</a> index) const</td></tr>
<tr class="memdesc:a517ae28d98adfc4e8381382d0a4c7be9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to a <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> given its <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a517ae28d98adfc4e8381382d0a4c7be9">More...</a><br /></td></tr>
<tr class="separator:a517ae28d98adfc4e8381382d0a4c7be9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1480f0eb8db57c2ef6c67e47396ab9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aaa1480f0eb8db57c2ef6c67e47396ab9">CheckValidContext</a> (const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context) const</td></tr>
<tr class="memdesc:aaa1480f0eb8db57c2ef6c67e47396ab9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given context is valid for this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> and throws an exception with a helpful message if not.  <a href="classdrake_1_1systems_1_1_system_base.html#aaa1480f0eb8db57c2ef6c67e47396ab9">More...</a><br /></td></tr>
<tr class="separator:aaa1480f0eb8db57c2ef6c67e47396ab9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7f7189714d79a830e909e281324533 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0b7f7189714d79a830e909e281324533">SystemBase</a> (const <a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> &amp;)=delete</td></tr>
<tr class="separator:a0b7f7189714d79a830e909e281324533 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d56d3b45890e61f36e24199dd1e2aa inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af4d56d3b45890e61f36e24199dd1e2aa">operator=</a> (const <a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> &amp;)=delete</td></tr>
<tr class="separator:af4d56d3b45890e61f36e24199dd1e2aa inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e502b9bccb8c93c30f872d3eb00e9b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a14e502b9bccb8c93c30f872d3eb00e9b">SystemBase</a> (<a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a14e502b9bccb8c93c30f872d3eb00e9b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4f8b3ccb41a8d6ce26373c7ae3c477 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aee4f8b3ccb41a8d6ce26373c7ae3c477">operator=</a> (<a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aee4f8b3ccb41a8d6ce26373c7ae3c477 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb18001bedce2dfaf75b0ae8a14375e inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">AbstractValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a2cb18001bedce2dfaf75b0ae8a14375e">EvalAbstractInput</a> (const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:a2cb18001bedce2dfaf75b0ae8a14375e inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the input port with the given <code>port_index</code> as an <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html" title="A fully type-erased container class. ">AbstractValue</a>, which is permitted for ports of any type.  <a href="classdrake_1_1systems_1_1_system_base.html#a2cb18001bedce2dfaf75b0ae8a14375e">More...</a><br /></td></tr>
<tr class="separator:a2cb18001bedce2dfaf75b0ae8a14375e inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0d520318199bf36a45ec450612fdce inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:afc0d520318199bf36a45ec450612fdce inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplItemLeft" align="right" valign="top">const V *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#afc0d520318199bf36a45ec450612fdce">EvalInputValue</a> (const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:afc0d520318199bf36a45ec450612fdce inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of an abstract-valued input port with the given <code>port_index</code> as a value of known type <code>V</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#afc0d520318199bf36a45ec450612fdce">More...</a><br /></td></tr>
<tr class="separator:afc0d520318199bf36a45ec450612fdce inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb9927349d2ab8f1274429c6f132149 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a5eb9927349d2ab8f1274429c6f132149">DeclareCacheEntry</a> (std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html#a451b30ae2de34d5852363135f73861e1">CacheEntry::AllocCallback</a> alloc_function, <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html#a3947b9d8e95098739aaaea55af1d1ead">CacheEntry::CalcCallback</a> calc_function, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a5eb9927349d2ab8f1274429c6f132149 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a new CacheEntry in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> using the least-restrictive definitions for the associated functions.  <a href="classdrake_1_1systems_1_1_system_base.html#a5eb9927349d2ab8f1274429c6f132149">More...</a><br /></td></tr>
<tr class="separator:a5eb9927349d2ab8f1274429c6f132149 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde2cd0793189949f8200e961fd7f690 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:acde2cd0793189949f8200e961fd7f690 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#acde2cd0793189949f8200e961fd7f690">DeclareCacheEntry</a> (std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, ValueType(MySystem::*make)() const, void(MySystem::*calc)(const MyContext &amp;, ValueType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:acde2cd0793189949f8200e961fd7f690 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a cache entry by specifying member functions to use both for the allocator and calculator.  <a href="classdrake_1_1systems_1_1_system_base.html#acde2cd0793189949f8200e961fd7f690">More...</a><br /></td></tr>
<tr class="separator:acde2cd0793189949f8200e961fd7f690 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c71a0967652b31f86cad89742d9379 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:a16c71a0967652b31f86cad89742d9379 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a16c71a0967652b31f86cad89742d9379">DeclareCacheEntry</a> (std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, const ValueType &amp;model_value, void(MySystem::*calc)(const MyContext &amp;, ValueType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a16c71a0967652b31f86cad89742d9379 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a cache entry by specifying a model value of concrete type <code>ValueType</code> and a calculator function that is a class member function (method) with signature:  <a href="classdrake_1_1systems_1_1_system_base.html#a16c71a0967652b31f86cad89742d9379">More...</a><br /></td></tr>
<tr class="separator:a16c71a0967652b31f86cad89742d9379 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dd680b52b1d39a443a58ebf64708eb inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:ac0dd680b52b1d39a443a58ebf64708eb inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ac0dd680b52b1d39a443a58ebf64708eb">DeclareCacheEntry</a> (std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, const ValueType &amp;model_value, ValueType(MySystem::*calc)(const MyContext &amp;) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:ac0dd680b52b1d39a443a58ebf64708eb inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a cache entry by specifying a model value of concrete type <code>ValueType</code> and a calculator function that is a class member function (method) with signature:  <a href="classdrake_1_1systems_1_1_system_base.html#ac0dd680b52b1d39a443a58ebf64708eb">More...</a><br /></td></tr>
<tr class="separator:ac0dd680b52b1d39a443a58ebf64708eb inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb0a0db30a4e352fa2b59b63b22e513 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:afdb0a0db30a4e352fa2b59b63b22e513 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#afdb0a0db30a4e352fa2b59b63b22e513">DeclareCacheEntry</a> (std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, void(MySystem::*calc)(const MyContext &amp;, ValueType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:afdb0a0db30a4e352fa2b59b63b22e513 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a cache entry by specifying only a calculator function that is a class member function (method) with signature:  <a href="classdrake_1_1systems_1_1_system_base.html#afdb0a0db30a4e352fa2b59b63b22e513">More...</a><br /></td></tr>
<tr class="separator:afdb0a0db30a4e352fa2b59b63b22e513 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b9a14022a774ceaf5459aa30df8d6d inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:a80b9a14022a774ceaf5459aa30df8d6d inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a80b9a14022a774ceaf5459aa30df8d6d">DeclareCacheEntry</a> (std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, ValueType(MySystem::*calc)(const MyContext &amp;) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a80b9a14022a774ceaf5459aa30df8d6d inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a cache entry by specifying only a calculator function that is a class member function (method) with signature:  <a href="classdrake_1_1systems_1_1_system_base.html#a80b9a14022a774ceaf5459aa30df8d6d">More...</a><br /></td></tr>
<tr class="separator:a80b9a14022a774ceaf5459aa30df8d6d inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf86073429b07d388b0157956bfdbac6 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#adf86073429b07d388b0157956bfdbac6">discrete_state_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a> index) const</td></tr>
<tr class="memdesc:adf86073429b07d388b0157956bfdbac6 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular discrete state variable xdᵢ (may be a vector).  <a href="classdrake_1_1systems_1_1_system_base.html#adf86073429b07d388b0157956bfdbac6">More...</a><br /></td></tr>
<tr class="separator:adf86073429b07d388b0157956bfdbac6 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8d4f32034a610ea30a283699040708 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a4a8d4f32034a610ea30a283699040708">abstract_state_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a> index) const</td></tr>
<tr class="memdesc:a4a8d4f32034a610ea30a283699040708 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular abstract state variable xaᵢ.  <a href="classdrake_1_1systems_1_1_system_base.html#a4a8d4f32034a610ea30a283699040708">More...</a><br /></td></tr>
<tr class="separator:a4a8d4f32034a610ea30a283699040708 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e0bf1fd3096bff3df2587ec4f02285 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a45e0bf1fd3096bff3df2587ec4f02285">numeric_parameter_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#af11369a06c5bfd3fa18acb79f85777df">NumericParameterIndex</a> index) const</td></tr>
<tr class="memdesc:a45e0bf1fd3096bff3df2587ec4f02285 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular numeric parameter pnᵢ (may be a vector).  <a href="classdrake_1_1systems_1_1_system_base.html#a45e0bf1fd3096bff3df2587ec4f02285">More...</a><br /></td></tr>
<tr class="separator:a45e0bf1fd3096bff3df2587ec4f02285 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4ef0e0e633c6f722ee518308d7cb5a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1a4ef0e0e633c6f722ee518308d7cb5a">abstract_parameter_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#a86b350169906f6d5e07e9db46e36d57a">AbstractParameterIndex</a> index) const</td></tr>
<tr class="memdesc:a1a4ef0e0e633c6f722ee518308d7cb5a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular abstract parameter paᵢ.  <a href="classdrake_1_1systems_1_1_system_base.html#a1a4ef0e0e633c6f722ee518308d7cb5a">More...</a><br /></td></tr>
<tr class="separator:a1a4ef0e0e633c6f722ee518308d7cb5a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085e66b9f3f0c01647815b7e1ec07980 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a085e66b9f3f0c01647815b7e1ec07980">input_port_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> index)</td></tr>
<tr class="memdesc:a085e66b9f3f0c01647815b7e1ec07980 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on input port uᵢ indicated by <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a085e66b9f3f0c01647815b7e1ec07980">More...</a><br /></td></tr>
<tr class="separator:a085e66b9f3f0c01647815b7e1ec07980 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4404427da5dce64982087871448dc4e2 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a4404427da5dce64982087871448dc4e2">cache_entry_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#a06ac9ad764b14ccff79b6feb393be498">CacheIndex</a> index)</td></tr>
<tr class="memdesc:a4404427da5dce64982087871448dc4e2 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on the cache entry indicated by <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a4404427da5dce64982087871448dc4e2">More...</a><br /></td></tr>
<tr class="separator:a4404427da5dce64982087871448dc4e2 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71881f1aaa6e2372678419100e59d1c1 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a71881f1aaa6e2372678419100e59d1c1">output_port_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa">OutputPortIndex</a> index)</td></tr>
<tr class="memdesc:a71881f1aaa6e2372678419100e59d1c1 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a ticket indicating dependence on the output port indicated by <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a71881f1aaa6e2372678419100e59d1c1">More...</a><br /></td></tr>
<tr class="separator:a71881f1aaa6e2372678419100e59d1c1 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a03d2d5e70020145bd659eba780f967 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1a03d2d5e70020145bd659eba780f967">num_discrete_state_groups</a> () const</td></tr>
<tr class="memdesc:a1a03d2d5e70020145bd659eba780f967 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of declared discrete state groups (each group is a vector-valued discrete state variable).  <a href="classdrake_1_1systems_1_1_system_base.html#a1a03d2d5e70020145bd659eba780f967">More...</a><br /></td></tr>
<tr class="separator:a1a03d2d5e70020145bd659eba780f967 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c71c7988b370b4e93ea1c33a2a0e9b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad2c71c7988b370b4e93ea1c33a2a0e9b">num_abstract_states</a> () const</td></tr>
<tr class="memdesc:ad2c71c7988b370b4e93ea1c33a2a0e9b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of declared abstract state variables.  <a href="classdrake_1_1systems_1_1_system_base.html#ad2c71c7988b370b4e93ea1c33a2a0e9b">More...</a><br /></td></tr>
<tr class="separator:ad2c71c7988b370b4e93ea1c33a2a0e9b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6508ca0ff8f5e886e63fb9c830e36a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aff6508ca0ff8f5e886e63fb9c830e36a">num_numeric_parameter_groups</a> () const</td></tr>
<tr class="memdesc:aff6508ca0ff8f5e886e63fb9c830e36a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of declared numeric parameters (each of these is a vector-valued parameter).  <a href="classdrake_1_1systems_1_1_system_base.html#aff6508ca0ff8f5e886e63fb9c830e36a">More...</a><br /></td></tr>
<tr class="separator:aff6508ca0ff8f5e886e63fb9c830e36a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cd7f024c61032c807af46f19f6daef inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a91cd7f024c61032c807af46f19f6daef">DRAKE_DEPRECATED</a> (&quot;Use <a class="el" href="classdrake_1_1systems_1_1_system_base.html#aff6508ca0ff8f5e886e63fb9c830e36a">num_numeric_parameter_groups</a>().  This method will be&quot; &quot; removed after 2/15/19.&quot;) int num_numeric_parameters() const</td></tr>
<tr class="separator:a91cd7f024c61032c807af46f19f6daef inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0232523ac7f8337a392b321ffd282187 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0232523ac7f8337a392b321ffd282187">num_abstract_parameters</a> () const</td></tr>
<tr class="memdesc:a0232523ac7f8337a392b321ffd282187 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of declared abstract parameters.  <a href="classdrake_1_1systems_1_1_system_base.html#a0232523ac7f8337a392b321ffd282187">More...</a><br /></td></tr>
<tr class="separator:a0232523ac7f8337a392b321ffd282187 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9440f6840ccb22a989d50ff8a7e65760"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a9440f6840ccb22a989d50ff8a7e65760">DoCalcWitnessValue</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &amp;witness_func) const =0</td></tr>
<tr class="memdesc:a9440f6840ccb22a989d50ff8a7e65760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes will implement this method to evaluate a witness function at the given context.  <a href="#a9440f6840ccb22a989d50ff8a7e65760">More...</a><br /></td></tr>
<tr class="separator:a9440f6840ccb22a989d50ff8a7e65760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad67111baf766af9690537477790a6c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aad67111baf766af9690537477790a6c4">DoGetWitnessFunctions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; *&gt; *) const</td></tr>
<tr class="memdesc:aad67111baf766af9690537477790a6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes can override this method to provide witness functions active for the given state.  <a href="#aad67111baf766af9690537477790a6c4">More...</a><br /></td></tr>
<tr class="separator:aad67111baf766af9690537477790a6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fbf92ac77db4d805a5a5cf980de130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ac9fbf92ac77db4d805a5a5cf980de130">AddConstraint</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt; T &gt;&gt; <a class="el" href="nlopt__solver_8cc.html#a3c57db1007715ab636108b253c041c17">constraint</a>)</td></tr>
<tr class="memdesc:ac9fbf92ac77db4d805a5a5cf980de130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an already-created constraint to the list of constraints for this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="#ac9fbf92ac77db4d805a5a5cf980de130">More...</a><br /></td></tr>
<tr class="separator:ac9fbf92ac77db4d805a5a5cf980de130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa532bcdc29e8be25c20b40968bb95b66"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa532bcdc29e8be25c20b40968bb95b66">get_forced_publish_events</a> () const</td></tr>
<tr class="separator:aa532bcdc29e8be25c20b40968bb95b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3137d050d040e4beb9ef60cd004ac112"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a3137d050d040e4beb9ef60cd004ac112">get_forced_discrete_update_events</a> () const</td></tr>
<tr class="separator:a3137d050d040e4beb9ef60cd004ac112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac53f82a39ea0c5e3240a9bab52b1415"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aac53f82a39ea0c5e3240a9bab52b1415">get_forced_unrestricted_update_events</a> () const</td></tr>
<tr class="separator:aac53f82a39ea0c5e3240a9bab52b1415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7240490688324a9f15132fee98e52ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ac7240490688324a9f15132fee98e52ce">set_forced_publish_events</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt;&gt;&gt; forced)</td></tr>
<tr class="separator:ac7240490688324a9f15132fee98e52ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0aacb96a01eb38099ac6cd4d12037b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#afd0aacb96a01eb38099ac6cd4d12037b">set_forced_discrete_update_events</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt;&gt;&gt; forced)</td></tr>
<tr class="separator:afd0aacb96a01eb38099ac6cd4d12037b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c5ab861b2f08ff5a29066458747b9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a75c5ab861b2f08ff5a29066458747b9a">set_forced_unrestricted_update_events</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt;&gt;&gt; forced)</td></tr>
<tr class="separator:a75c5ab861b2f08ff5a29066458747b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Event handler dispatch mechanism</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>For a <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> (or user implemented equivalent classes), these functions need to call the appropriate LeafSystem::DoX event handler.</p>
<p>E.g. LeafSystem::DispatchPublishHandler() calls <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#af6671aa860bee3579fd7573d5c86a7c8" title="Derived-class event handler for all simultaneous publish events in events. ">LeafSystem::DoPublish()</a>. User supplied custom event callbacks embedded in each individual event need to be further dispatched in the LeafSystem::DoX handlers if desired. For a <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>, the pseudo code of the complete default publish event handler dispatching is roughly: </p><pre>
  leaf_sys.Publish(context, event_collection)
  -&gt; leaf_sys.DispatchPublishHandler(context, event_collection)
     -&gt; leaf_sys.DoPublish(context, event_collection.get_events())
        -&gt; for (event : event_collection_events):
             if (event.has_handler)
               event.handler(context)
</pre><p> Discrete update events and unrestricted update events are dispatched similarly for a <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>.</p>
<p>For a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> (or user implemented equivalent classes), these functions must iterate through all subsystems, extract their corresponding subcontext and subevent collections from <code>context</code> and <code>events</code>, and pass those to the subsystems' public non-virtual event handlers if the subevent collection is nonempty (e.g. <a class="el" href="classdrake_1_1systems_1_1_system.html#a31898e0276f6bbc4edf7111f809afb01" title="This method is the public entry point for dispatching all publish event handlers. ...">System::Publish()</a> for publish events).</p>
<p>All of these functions are only called from their corresponding public non-virtual event dispatchers, where <code>context</code> is error checked. The derived implementations can assume that <code>context</code> is valid. See, e.g., LeafSystem::DispatchPublishHandler() and Diagram::DispatchPublishHandler() for more details. </p>
</div></td></tr>
<tr class="memitem:a84fe4f2e8e6d8a61dfae06f64fb6d5ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a84fe4f2e8e6d8a61dfae06f64fb6d5ce">DispatchPublishHandler</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt;&gt; &amp;events) const =0</td></tr>
<tr class="memdesc:a84fe4f2e8e6d8a61dfae06f64fb6d5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function dispatches all publish events to the appropriate handlers.  <a href="#a84fe4f2e8e6d8a61dfae06f64fb6d5ce">More...</a><br /></td></tr>
<tr class="separator:a84fe4f2e8e6d8a61dfae06f64fb6d5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921d9a050e25d0f2c55de265477c26f5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a921d9a050e25d0f2c55de265477c26f5">DispatchDiscreteVariableUpdateHandler</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt;&gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state) const =0</td></tr>
<tr class="memdesc:a921d9a050e25d0f2c55de265477c26f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function dispatches all discrete update events to the appropriate handlers.  <a href="#a921d9a050e25d0f2c55de265477c26f5">More...</a><br /></td></tr>
<tr class="separator:a921d9a050e25d0f2c55de265477c26f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb56df9a1e83ab8cef21c9b122d6346"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#affb56df9a1e83ab8cef21c9b122d6346">DispatchUnrestrictedUpdateHandler</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt;&gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const =0</td></tr>
<tr class="memdesc:affb56df9a1e83ab8cef21c9b122d6346"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function dispatches all unrestricted update events to the appropriate handlers.  <a href="#affb56df9a1e83ab8cef21c9b122d6346">More...</a><br /></td></tr>
<tr class="separator:affb56df9a1e83ab8cef21c9b122d6346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">System construction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Authors of derived Systems can use these methods in the constructor for those Systems.</p>
</div></td></tr>
<tr class="memitem:aa1b849c60d9ec6bbfeac42dc3c075a02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa1b849c60d9ec6bbfeac42dc3c075a02">System</a> (<a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> converter)</td></tr>
<tr class="memdesc:aa1b849c60d9ec6bbfeac42dc3c075a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty System base class object and allocates base class resources, possibly supporting scalar-type conversion support (AutoDiff, etc.) using <code>converter</code>.  <a href="#aa1b849c60d9ec6bbfeac42dc3c075a02">More...</a><br /></td></tr>
<tr class="separator:aa1b849c60d9ec6bbfeac42dc3c075a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011a04791ece0fa2ae1efa90d9bf35cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a011a04791ece0fa2ae1efa90d9bf35cf">DeclareInputPort</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1systems.html#ae516fceb67f15f61c7a232b9cc483fbe">PortDataType</a> <a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>, <a class="el" href="classint.html">int</a> <a class="el" href="lcm__image__array__to__images_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>, <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt; random_type=<a class="el" href="namespacedrake.html#acd293644b847dc4549de80a090d66625">nullopt</a>)</td></tr>
<tr class="memdesc:a011a04791ece0fa2ae1efa90d9bf35cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a port with the specified <code>type</code> and <code>size</code> to the input topology.  <a href="#a011a04791ece0fa2ae1efa90d9bf35cf">More...</a><br /></td></tr>
<tr class="separator:a011a04791ece0fa2ae1efa90d9bf35cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">To-be-deprecated declarations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods in this section leave out the port name parameter and are the same as invoking the corresponding method with <code>kUseDefaultName</code> as the name.</p>
<p>We intend to make specifying the name required and will deprecate these soon. Don't use them. </p>
</div></td></tr>
<tr class="memitem:afc5f2153443d34fc439945fc34e64c5e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#afc5f2153443d34fc439945fc34e64c5e">DeclareInputPort</a> (<a class="el" href="namespacedrake_1_1systems.html#ae516fceb67f15f61c7a232b9cc483fbe">PortDataType</a> <a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>, <a class="el" href="classint.html">int</a> <a class="el" href="lcm__image__array__to__images_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>, <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt; random_type=<a class="el" href="namespacedrake.html#acd293644b847dc4549de80a090d66625">nullopt</a>)</td></tr>
<tr class="memdesc:afc5f2153443d34fc439945fc34e64c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the nearly identical signature with an additional (first) argument specifying the port name.  <a href="#afc5f2153443d34fc439945fc34e64c5e">More...</a><br /></td></tr>
<tr class="separator:afc5f2153443d34fc439945fc34e64c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Virtual methods for calculations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These virtuals allow concrete systems to implement the calculations defined by the <code>Calc</code> methods in the public interface.</p>
<p>Most have default implementations that are usable for simple systems, but you are likely to need to override some or all of these in your concrete system to produce meaningful calculations.</p>
<p>These methods are invoked by the corresponding method in the public interface that has the same name with <code>Do</code> removed. The public method performs error checking on the arguments so you do not need to do so in your implementation. Users cannot invoke these directly since they are protected. You should place your overrides in the protected or private sections of your concrete class. </p>
</div></td></tr>
<tr class="memitem:a2d2b6bbca36ba86a269c9fd42ddfb6d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a2d2b6bbca36ba86a269c9fd42ddfb6d0">DoCalcTimeDerivatives</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *derivatives) const</td></tr>
<tr class="memdesc:a2d2b6bbca36ba86a269c9fd42ddfb6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this if you have any continuous state variables <code>xc</code> in your concrete System to calculate their time derivatives.  <a href="#a2d2b6bbca36ba86a269c9fd42ddfb6d0">More...</a><br /></td></tr>
<tr class="separator:a2d2b6bbca36ba86a269c9fd42ddfb6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc9aebb6327099391cd0f621b4b8d44"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#afdc9aebb6327099391cd0f621b4b8d44">DoCalcNextUpdateTime</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events, T *<a class="el" href="robot__plan__interpolator__test_8cc.html#a97f443479343d27ae6800e77d16ae3f1">time</a>) const</td></tr>
<tr class="memdesc:afdc9aebb6327099391cd0f621b4b8d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the next time at which this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> must perform a discrete action.  <a href="#afdc9aebb6327099391cd0f621b4b8d44">More...</a><br /></td></tr>
<tr class="separator:afdc9aebb6327099391cd0f621b4b8d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb36a8c15587e340c460d261f3786a03"><td class="memItemLeft" align="right" valign="top">virtual std::map&lt; <a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a>, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; * &gt;, <a class="el" href="structdrake_1_1systems_1_1_periodic_event_data_comparator.html">PeriodicEventDataComparator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#abb36a8c15587e340c460d261f3786a03">DoGetPeriodicEvents</a> () const =0</td></tr>
<tr class="memdesc:abb36a8c15587e340c460d261f3786a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method to return all periodic triggered events.  <a href="#abb36a8c15587e340c460d261f3786a03">More...</a><br /></td></tr>
<tr class="separator:abb36a8c15587e340c460d261f3786a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8100d7c746acc72a3a86fe8cad9d7c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aaa8100d7c746acc72a3a86fe8cad9d7c">DoGetPerStepEvents</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:aaa8100d7c746acc72a3a86fe8cad9d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method to return any events to be handled before the simulator integrates the system's continuous state at each time step.  <a href="#aaa8100d7c746acc72a3a86fe8cad9d7c">More...</a><br /></td></tr>
<tr class="separator:aaa8100d7c746acc72a3a86fe8cad9d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a38740aa5d71df2a0bab769c29fff7c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a0a38740aa5d71df2a0bab769c29fff7c">DoGetInitializationEvents</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:a0a38740aa5d71df2a0bab769c29fff7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method to return any events to be handled at the simulator's initialization step.  <a href="#a0a38740aa5d71df2a0bab769c29fff7c">More...</a><br /></td></tr>
<tr class="separator:a0a38740aa5d71df2a0bab769c29fff7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f055c2fb422eefe50faf9a0979c1e0"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a40f055c2fb422eefe50faf9a0979c1e0">DoCalcPotentialEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a40f055c2fb422eefe50faf9a0979c1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method for physical systems to calculate the potential energy PE currently stored in the configuration provided in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="#a40f055c2fb422eefe50faf9a0979c1e0">More...</a><br /></td></tr>
<tr class="separator:a40f055c2fb422eefe50faf9a0979c1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de30438c7fbda84a0cc9a35ca543c8e"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a8de30438c7fbda84a0cc9a35ca543c8e">DoCalcKineticEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a8de30438c7fbda84a0cc9a35ca543c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method for physical systems to calculate the kinetic energy KE currently present in the motion provided in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="#a8de30438c7fbda84a0cc9a35ca543c8e">More...</a><br /></td></tr>
<tr class="separator:a8de30438c7fbda84a0cc9a35ca543c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa6ce88c0e7ba9f6592713d36bc4047"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aafa6ce88c0e7ba9f6592713d36bc4047">DoCalcConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aafa6ce88c0e7ba9f6592713d36bc4047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method to return the rate Pc at which mechanical energy is being converted <em>from</em> potential energy <em>to</em> kinetic energy by this system in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="#aafa6ce88c0e7ba9f6592713d36bc4047">More...</a><br /></td></tr>
<tr class="separator:aafa6ce88c0e7ba9f6592713d36bc4047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc39e42fbb88d08592d2f7e7c12637d"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a3bc39e42fbb88d08592d2f7e7c12637d">DoCalcNonConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a3bc39e42fbb88d08592d2f7e7c12637d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method to return the rate Pnc at which work W is done on the system by non-conservative forces.  <a href="#a3bc39e42fbb88d08592d2f7e7c12637d">More...</a><br /></td></tr>
<tr class="separator:a3bc39e42fbb88d08592d2f7e7c12637d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8545168ea9a0a202bd82b3aeb08f5530"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a8545168ea9a0a202bd82b3aeb08f5530">DoMapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;qdot, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *generalized_velocity) const</td></tr>
<tr class="memdesc:a8545168ea9a0a202bd82b3aeb08f5530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the substantive implementation of <a class="el" href="classdrake_1_1systems_1_1_system.html#a10eba167739bfe8e7e419b5c8ae41537" title="Transforms the time derivative qdot of the generalized configuration q to generalized velocities v...">MapQDotToVelocity()</a>.  <a href="#a8545168ea9a0a202bd82b3aeb08f5530">More...</a><br /></td></tr>
<tr class="separator:a8545168ea9a0a202bd82b3aeb08f5530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2922fc55384af89c4a3734a476af08f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa2922fc55384af89c4a3734a476af08f">DoMapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;generalized_velocity, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *qdot) const</td></tr>
<tr class="memdesc:aa2922fc55384af89c4a3734a476af08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the substantive implementation of <a class="el" href="classdrake_1_1systems_1_1_system.html#a05cc5df6d0d0fe4ea54b522ae776ca39" title="Transforms a given generalized velocity v to the time derivative qdot of the generalized configuratio...">MapVelocityToQDot()</a>.  <a href="#aa2922fc55384af89c4a3734a476af08f">More...</a><br /></td></tr>
<tr class="separator:aa2922fc55384af89c4a3734a476af08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constraint-related functions (protected).</div></td></tr>
<tr class="memitem:af92f74ba8239aeca3a325e3a77c53478"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#af92f74ba8239aeca3a325e3a77c53478">do_get_num_constraint_equations</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:af92f74ba8239aeca3a325e3a77c53478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of constraint equations for this system from the given context.  <a href="#af92f74ba8239aeca3a325e3a77c53478">More...</a><br /></td></tr>
<tr class="separator:af92f74ba8239aeca3a325e3a77c53478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73640bb8a630f97962b71df8035a7fc2"><td class="memItemLeft" align="right" valign="top">virtual Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a73640bb8a630f97962b71df8035a7fc2">DoEvalConstraintEquations</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a73640bb8a630f97962b71df8035a7fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the constraint equations for the system at the generalized coordinates and generalized velocity specified by the context.  <a href="#a73640bb8a630f97962b71df8035a7fc2">More...</a><br /></td></tr>
<tr class="separator:a73640bb8a630f97962b71df8035a7fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11da6dcf33e2196ef99444666969d7dd"><td class="memItemLeft" align="right" valign="top">virtual Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a11da6dcf33e2196ef99444666969d7dd">DoEvalConstraintEquationsDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a11da6dcf33e2196ef99444666969d7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the time derivative of each constraint equation, evaluated at the generalized coordinates and generalized velocity specified by the context.  <a href="#a11da6dcf33e2196ef99444666969d7dd">More...</a><br /></td></tr>
<tr class="separator:a11da6dcf33e2196ef99444666969d7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae033a9554c35fda06c022cb890621583"><td class="memItemLeft" align="right" valign="top">virtual Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ae033a9554c35fda06c022cb890621583">DoCalcVelocityChangeFromConstraintImpulses</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::MatrixXd &amp;J, const Eigen::VectorXd &amp;lambda) const</td></tr>
<tr class="memdesc:ae033a9554c35fda06c022cb890621583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the change in velocity from applying the given constraint forces to the system at the given context.  <a href="#ae033a9554c35fda06c022cb890621583">More...</a><br /></td></tr>
<tr class="separator:ae033a9554c35fda06c022cb890621583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d42c7934ea48286f9eaa1c57e65e0b5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a7d42c7934ea48286f9eaa1c57e65e0b5">DoCalcConstraintErrorNorm</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::VectorXd &amp;error) const</td></tr>
<tr class="memdesc:a7d42c7934ea48286f9eaa1c57e65e0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the norm of the constraint error.  <a href="#a7d42c7934ea48286f9eaa1c57e65e0b5">More...</a><br /></td></tr>
<tr class="separator:a7d42c7934ea48286f9eaa1c57e65e0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility methods (protected)</div></td></tr>
<tr class="memitem:a224803a17e7cb76634565ce6def996d8"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a224803a17e7cb76634565ce6def996d8">GetMutableOutputVector</a> (<a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *output, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:a224803a17e7cb76634565ce6def996d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable <a class="el" href="namespace_eigen.html">Eigen</a> expression for a vector valued output port with index <code>port_index</code> in this system.  <a href="#a224803a17e7cb76634565ce6def996d8">More...</a><br /></td></tr>
<tr class="separator:a224803a17e7cb76634565ce6def996d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1systems_1_1_system_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdrake_1_1systems_1_1_system_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a></td></tr>
<tr class="memitem:a1cd0ce5bd76208e8110ad85a956e3127 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1cd0ce5bd76208e8110ad85a956e3127">SystemBase</a> ()=default</td></tr>
<tr class="memdesc:a1cd0ce5bd76208e8110ad85a956e3127 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Default constructor.  <a href="classdrake_1_1systems_1_1_system_base.html#a1cd0ce5bd76208e8110ad85a956e3127">More...</a><br /></td></tr>
<tr class="separator:a1cd0ce5bd76208e8110ad85a956e3127 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83ce091f3aba8ecb71e72262fc1fd6b inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab83ce091f3aba8ecb71e72262fc1fd6b">AddInputPort</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_input_port_base.html">InputPortBase</a> &gt; port)</td></tr>
<tr class="memdesc:ab83ce091f3aba8ecb71e72262fc1fd6b inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Adds an already-constructed input port to this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#ab83ce091f3aba8ecb71e72262fc1fd6b">More...</a><br /></td></tr>
<tr class="separator:ab83ce091f3aba8ecb71e72262fc1fd6b inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89be3ba9e76827e83fb1e139e5b750cc inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a89be3ba9e76827e83fb1e139e5b750cc">AddOutputPort</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_output_port_base.html">OutputPortBase</a> &gt; port)</td></tr>
<tr class="memdesc:a89be3ba9e76827e83fb1e139e5b750cc inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Adds an already-constructed output port to this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#a89be3ba9e76827e83fb1e139e5b750cc">More...</a><br /></td></tr>
<tr class="separator:a89be3ba9e76827e83fb1e139e5b750cc inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af663ea589da3acdb084bdc608b1a4255 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af663ea589da3acdb084bdc608b1a4255">NextInputPortName</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; given_name) const</td></tr>
<tr class="memdesc:af663ea589da3acdb084bdc608b1a4255 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a name for the next input port, using the given name if it isn't kUseDefaultName, otherwise making up a name like "u3" from the next available input port index.  <a href="classdrake_1_1systems_1_1_system_base.html#af663ea589da3acdb084bdc608b1a4255">More...</a><br /></td></tr>
<tr class="separator:af663ea589da3acdb084bdc608b1a4255 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3697edc2cfdba03b33e7f39474531d3 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab3697edc2cfdba03b33e7f39474531d3">NextOutputPortName</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; given_name) const</td></tr>
<tr class="memdesc:ab3697edc2cfdba03b33e7f39474531d3 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a name for the next output port, using the given name if it isn't kUseDefaultName, otherwise making up a name like "y3" from the next available output port index.  <a href="classdrake_1_1systems_1_1_system_base.html#ab3697edc2cfdba03b33e7f39474531d3">More...</a><br /></td></tr>
<tr class="separator:ab3697edc2cfdba03b33e7f39474531d3 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e83668b3fecff021600eff4390cc2a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab4e83668b3fecff021600eff4390cc2a">AddDiscreteStateGroup</a> (<a class="el" href="namespacedrake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a> index)</td></tr>
<tr class="memdesc:ab4e83668b3fecff021600eff4390cc2a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns a ticket to a new discrete variable group with the given <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#ab4e83668b3fecff021600eff4390cc2a">More...</a><br /></td></tr>
<tr class="separator:ab4e83668b3fecff021600eff4390cc2a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af329e5c00e271bc61a65b0227d34c76e inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af329e5c00e271bc61a65b0227d34c76e">AddAbstractState</a> (<a class="el" href="namespacedrake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a> index)</td></tr>
<tr class="memdesc:af329e5c00e271bc61a65b0227d34c76e inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns a ticket to a new abstract state variable with the given <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#af329e5c00e271bc61a65b0227d34c76e">More...</a><br /></td></tr>
<tr class="separator:af329e5c00e271bc61a65b0227d34c76e inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794ca537e26044e254cda9ccba0a6385 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a794ca537e26044e254cda9ccba0a6385">AddNumericParameter</a> (<a class="el" href="namespacedrake_1_1systems.html#af11369a06c5bfd3fa18acb79f85777df">NumericParameterIndex</a> index)</td></tr>
<tr class="memdesc:a794ca537e26044e254cda9ccba0a6385 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns a ticket to a new numeric parameter with the given <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a794ca537e26044e254cda9ccba0a6385">More...</a><br /></td></tr>
<tr class="separator:a794ca537e26044e254cda9ccba0a6385 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accca12932eb38b764d93ab6bed8f02fc inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#accca12932eb38b764d93ab6bed8f02fc">AddAbstractParameter</a> (<a class="el" href="namespacedrake_1_1systems.html#a86b350169906f6d5e07e9db46e36d57a">AbstractParameterIndex</a> index)</td></tr>
<tr class="memdesc:accca12932eb38b764d93ab6bed8f02fc inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns a ticket to a new abstract parameter with the given <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#accca12932eb38b764d93ab6bed8f02fc">More...</a><br /></td></tr>
<tr class="separator:accca12932eb38b764d93ab6bed8f02fc inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97150e242d9cc6d62d4dc592fd321b0d inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a97150e242d9cc6d62d4dc592fd321b0d">DeclareCacheEntryWithKnownTicket</a> (<a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> known_ticket, std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html#a451b30ae2de34d5852363135f73861e1">CacheEntry::AllocCallback</a> alloc_function, <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html#a3947b9d8e95098739aaaea55af1d1ead">CacheEntry::CalcCallback</a> calc_function, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a97150e242d9cc6d62d4dc592fd321b0d inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) This is for cache entries associated with pre-defined tickets, for example the cache entry for time derivatives.  <a href="classdrake_1_1systems_1_1_system_base.html#a97150e242d9cc6d62d4dc592fd321b0d">More...</a><br /></td></tr>
<tr class="separator:a97150e242d9cc6d62d4dc592fd321b0d inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bcdc5ff465681009f4a32470ebfb26 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const internal::SystemParentServiceInterface *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab8bcdc5ff465681009f4a32470ebfb26">get_parent_service</a> () const</td></tr>
<tr class="memdesc:ab8bcdc5ff465681009f4a32470ebfb26 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the service interface of the immediately enclosing <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> if one has been set, otherwise nullptr.  <a href="classdrake_1_1systems_1_1_system_base.html#ab8bcdc5ff465681009f4a32470ebfb26">More...</a><br /></td></tr>
<tr class="separator:ab8bcdc5ff465681009f4a32470ebfb26 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161f7073ea98c0a25ca55f5dd4186dca inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a161f7073ea98c0a25ca55f5dd4186dca">assign_next_dependency_ticket</a> ()</td></tr>
<tr class="memdesc:a161f7073ea98c0a25ca55f5dd4186dca inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns the next unused dependency ticket number, unique only within a particular system.  <a href="classdrake_1_1systems_1_1_system_base.html#a161f7073ea98c0a25ca55f5dd4186dca">More...</a><br /></td></tr>
<tr class="separator:a161f7073ea98c0a25ca55f5dd4186dca inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f89d878ae72c67da5af5acb06f48a22 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">AbstractValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a4f89d878ae72c67da5af5acb06f48a22">EvalAbstractInputImpl</a> (const char *func, const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a4f89d878ae72c67da5af5acb06f48a22 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Shared code for updating an input port and returning a pointer to its abstract value, or nullptr if the port is not connected.  <a href="classdrake_1_1systems_1_1_system_base.html#a4f89d878ae72c67da5af5acb06f48a22">More...</a><br /></td></tr>
<tr class="separator:a4f89d878ae72c67da5af5acb06f48a22 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa640b3592c2af42c76fac2d8a048d25c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aa640b3592c2af42c76fac2d8a048d25c">ThrowNegativePortIndex</a> (const char *func, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:aa640b3592c2af42c76fac2d8a048d25c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::out_of_range to report a negative <code>port_index</code> that was passed to API method <code>func</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#aa640b3592c2af42c76fac2d8a048d25c">More...</a><br /></td></tr>
<tr class="separator:aa640b3592c2af42c76fac2d8a048d25c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9295e809fe1cff333430e1b00a84520c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a9295e809fe1cff333430e1b00a84520c">ThrowInputPortIndexOutOfRange</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a9295e809fe1cff333430e1b00a84520c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::out_of_range to report bad input <code>port_index</code> that was passed to API method <code>func</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a9295e809fe1cff333430e1b00a84520c">More...</a><br /></td></tr>
<tr class="separator:a9295e809fe1cff333430e1b00a84520c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58594b987a3e5b1684d4e38bf00767e inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af58594b987a3e5b1684d4e38bf00767e">ThrowOutputPortIndexOutOfRange</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa">OutputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:af58594b987a3e5b1684d4e38bf00767e inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::out_of_range to report bad output <code>port_index</code> that was passed to API method <code>func</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#af58594b987a3e5b1684d4e38bf00767e">More...</a><br /></td></tr>
<tr class="separator:af58594b987a3e5b1684d4e38bf00767e inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2dfff6a2db34da2c791a7971e2af0c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aee2dfff6a2db34da2c791a7971e2af0c">ThrowNotAVectorInputPort</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:aee2dfff6a2db34da2c791a7971e2af0c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::logic_error because someone misused API method <code>func</code>, that is only allowed for declared-vector input ports, on an abstract port whose index is given here.  <a href="classdrake_1_1systems_1_1_system_base.html#aee2dfff6a2db34da2c791a7971e2af0c">More...</a><br /></td></tr>
<tr class="separator:aee2dfff6a2db34da2c791a7971e2af0c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2200e7d8b6b39e758e5df64ee81c356a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a2200e7d8b6b39e758e5df64ee81c356a">ThrowInputPortHasWrongType</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index, const std::string &amp;expected_type, const std::string &amp;actual_type) const</td></tr>
<tr class="memdesc:a2200e7d8b6b39e758e5df64ee81c356a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::logic_error because someone called API method <code>func</code> claiming the input port had some value type that was wrong.  <a href="classdrake_1_1systems_1_1_system_base.html#a2200e7d8b6b39e758e5df64ee81c356a">More...</a><br /></td></tr>
<tr class="separator:a2200e7d8b6b39e758e5df64ee81c356a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bc2d35e014b293b9564cb9e85e5390 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a49bc2d35e014b293b9564cb9e85e5390">ThrowCantEvaluateInputPort</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a49bc2d35e014b293b9564cb9e85e5390 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::logic_error because someone called API method <code>func</code>, that requires this input port to be evaluatable, but the port was neither fixed nor connected.  <a href="classdrake_1_1systems_1_1_system_base.html#a49bc2d35e014b293b9564cb9e85e5390">More...</a><br /></td></tr>
<tr class="separator:a49bc2d35e014b293b9564cb9e85e5390 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace57c456b11046f56381f7b4ab7e2343 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port_base.html">InputPortBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ace57c456b11046f56381f7b4ab7e2343">GetInputPortBaseOrThrow</a> (const char *func, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:ace57c456b11046f56381f7b4ab7e2343 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns the <a class="el" href="classdrake_1_1systems_1_1_input_port_base.html" title="An InputPort is a System resource that describes the kind of input a System accepts, on a given port. ">InputPortBase</a> at index <code>port_index</code>, throwing std::out_of_range we don't like the port index.  <a href="classdrake_1_1systems_1_1_system_base.html#ace57c456b11046f56381f7b4ab7e2343">More...</a><br /></td></tr>
<tr class="separator:ace57c456b11046f56381f7b4ab7e2343 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18146b3800f5a63bbe4d08eae828883 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port_base.html">OutputPortBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab18146b3800f5a63bbe4d08eae828883">GetOutputPortBaseOrThrow</a> (const char *func, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:ab18146b3800f5a63bbe4d08eae828883 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns the <a class="el" href="classdrake_1_1systems_1_1_output_port_base.html" title="OutputPortBase handles the scalar type-independent aspects of an OutputPort. ">OutputPortBase</a> at index <code>port_index</code>, throwing std::out_of_range we don't like the port index.  <a href="classdrake_1_1systems_1_1_system_base.html#ab18146b3800f5a63bbe4d08eae828883">More...</a><br /></td></tr>
<tr class="separator:ab18146b3800f5a63bbe4d08eae828883 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb74936487f1ae4658b54979195fa1b inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0eb74936487f1ae4658b54979195fa1b">InitializeContextBase</a> (<a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> *context) const</td></tr>
<tr class="memdesc:a0eb74936487f1ae4658b54979195fa1b inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be invoked from within derived class <a class="el" href="classdrake_1_1systems_1_1_system_base.html#acfa7f79f981ab30a3919aa36e829b62a" title="Derived class implementations should allocate a suitable concrete Context type, then invoke the above...">DoAllocateContext()</a> implementations right after the concrete <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> object has been allocated.  <a href="classdrake_1_1systems_1_1_system_base.html#a0eb74936487f1ae4658b54979195fa1b">More...</a><br /></td></tr>
<tr class="separator:a0eb74936487f1ae4658b54979195fa1b inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa7f79f981ab30a3919aa36e829b62a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#acfa7f79f981ab30a3919aa36e829b62a">DoAllocateContext</a> () const =0</td></tr>
<tr class="memdesc:acfa7f79f981ab30a3919aa36e829b62a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class implementations should allocate a suitable concrete <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> type, then invoke the above <a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0eb74936487f1ae4658b54979195fa1b" title="This method must be invoked from within derived class DoAllocateContext() implementations right after...">InitializeContextBase()</a> method.  <a href="classdrake_1_1systems_1_1_system_base.html#acfa7f79f981ab30a3919aa36e829b62a">More...</a><br /></td></tr>
<tr class="separator:acfa7f79f981ab30a3919aa36e829b62a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a711f9256206b0eb48db02088a645e6a9"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a711f9256206b0eb48db02088a645e6a9">SystemImpl</a></td></tr>
<tr class="separator:a711f9256206b0eb48db02088a645e6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Automatic differentiation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp499e97cf84f0109413f68a1ca6c407df"></a>From a System templatized by <code>double</code>, you can obtain an identical system templatized by an automatic differentation scalar providing machine-precision computation of partial derivatives of any numerical result of the System with respect to any of the numerical values that can be contained in a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> (time, inputs, parameters, and state).</p>
</td></tr>
<tr class="memitem:aaa81bdf4638506d1ba5ee11e05821651"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aaa81bdf4638506d1ba5ee11e05821651">ToAutoDiffXd</a> () const</td></tr>
<tr class="memdesc:aaa81bdf4638506d1ba5ee11e05821651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives.  <a href="#aaa81bdf4638506d1ba5ee11e05821651">More...</a><br /></td></tr>
<tr class="separator:aaa81bdf4638506d1ba5ee11e05821651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8661a664b857b7bec879b6f84ca763c7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a8661a664b857b7bec879b6f84ca763c7">ToAutoDiffXdMaybe</a> () const</td></tr>
<tr class="memdesc:a8661a664b857b7bec879b6f84ca763c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this system exactly like <a class="el" href="classdrake_1_1systems_1_1_system.html#aaa81bdf4638506d1ba5ee11e05821651" title="Creates a deep copy of this System, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives. ">ToAutoDiffXd()</a>, but returns nullptr if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> does not support autodiff, instead of throwing an exception.  <a href="#a8661a664b857b7bec879b6f84ca763c7">More...</a><br /></td></tr>
<tr class="separator:a8661a664b857b7bec879b6f84ca763c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dccd7061415e910fff3a252ece2a88"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class S = ::drake::systems::System&gt; </td></tr>
<tr class="memitem:a12dccd7061415e910fff3a252ece2a88"><td class="memTemplItemLeft" align="right" valign="top">static std::unique_ptr&lt; S&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a12dccd7061415e910fff3a252ece2a88">ToAutoDiffXd</a> (const S&lt; T &gt; &amp;from)</td></tr>
<tr class="memdesc:a12dccd7061415e910fff3a252ece2a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of <code>from</code>, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives.  <a href="#a12dccd7061415e910fff3a252ece2a88">More...</a><br /></td></tr>
<tr class="separator:a12dccd7061415e910fff3a252ece2a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Symbolics</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp9a6fa9fa7346333952544f89309217a2"></a>From a System templatized by <code>double</code>, you can obtain an identical system templatized by a symbolic expression scalar.</p>
</td></tr>
<tr class="memitem:a1c259e82a4e51da3c7ace27af64e0d3a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a1c259e82a4e51da3c7ace27af64e0d3a">ToSymbolic</a> () const</td></tr>
<tr class="memdesc:a1c259e82a4e51da3c7ace27af64e0d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>, transmogrified to use the symbolic scalar type.  <a href="#a1c259e82a4e51da3c7ace27af64e0d3a">More...</a><br /></td></tr>
<tr class="separator:a1c259e82a4e51da3c7ace27af64e0d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49431db031c1d14de328a7231290e95"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ae49431db031c1d14de328a7231290e95">ToSymbolicMaybe</a> () const</td></tr>
<tr class="memdesc:ae49431db031c1d14de328a7231290e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this system exactly like <a class="el" href="classdrake_1_1systems_1_1_system.html#a1c259e82a4e51da3c7ace27af64e0d3a" title="Creates a deep copy of this System, transmogrified to use the symbolic scalar type. ">ToSymbolic()</a>, but returns nullptr if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> does not support symbolic, instead of throwing an exception.  <a href="#ae49431db031c1d14de328a7231290e95">More...</a><br /></td></tr>
<tr class="separator:ae49431db031c1d14de328a7231290e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eddb9f14f9b26636316c045a2f5ea58"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class S = ::drake::systems::System&gt; </td></tr>
<tr class="memitem:a7eddb9f14f9b26636316c045a2f5ea58"><td class="memTemplItemLeft" align="right" valign="top">static std::unique_ptr&lt; S&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a7eddb9f14f9b26636316c045a2f5ea58">ToSymbolic</a> (const S&lt; T &gt; &amp;from)</td></tr>
<tr class="memdesc:a7eddb9f14f9b26636316c045a2f5ea58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of <code>from</code>, transmogrified to use the symbolic scalar type.  <a href="#a7eddb9f14f9b26636316c045a2f5ea58">More...</a><br /></td></tr>
<tr class="separator:a7eddb9f14f9b26636316c045a2f5ea58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classdrake_1_1systems_1_1_system_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classdrake_1_1systems_1_1_system_base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a></td></tr>
<tr class="memitem:a6fe75ddbd79ab1d862df9a50b3c8a624 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a6fe75ddbd79ab1d862df9a50b3c8a624">nothing_ticket</a> ()</td></tr>
<tr class="memdesc:a6fe75ddbd79ab1d862df9a50b3c8a624 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating that a computation does not depend on <em>any</em> source value; that is, it is a constant.  <a href="classdrake_1_1systems_1_1_system_base.html#a6fe75ddbd79ab1d862df9a50b3c8a624">More...</a><br /></td></tr>
<tr class="separator:a6fe75ddbd79ab1d862df9a50b3c8a624 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68516072b2dc51a601f2de699691f1c3 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a68516072b2dc51a601f2de699691f1c3">time_ticket</a> ()</td></tr>
<tr class="memdesc:a68516072b2dc51a601f2de699691f1c3 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on time.  <a href="classdrake_1_1systems_1_1_system_base.html#a68516072b2dc51a601f2de699691f1c3">More...</a><br /></td></tr>
<tr class="separator:a68516072b2dc51a601f2de699691f1c3 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad649083fc3bcb645671be3fad577d2ab inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad649083fc3bcb645671be3fad577d2ab">accuracy_ticket</a> ()</td></tr>
<tr class="memdesc:ad649083fc3bcb645671be3fad577d2ab inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on the accuracy setting in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#ad649083fc3bcb645671be3fad577d2ab">More...</a><br /></td></tr>
<tr class="separator:ad649083fc3bcb645671be3fad577d2ab inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d3cdadf7d6b62b055993148b82df19 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a41d3cdadf7d6b62b055993148b82df19">q_ticket</a> ()</td></tr>
<tr class="memdesc:a41d3cdadf7d6b62b055993148b82df19 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating that a computation depends on configuration state variables q.  <a href="classdrake_1_1systems_1_1_system_base.html#a41d3cdadf7d6b62b055993148b82df19">More...</a><br /></td></tr>
<tr class="separator:a41d3cdadf7d6b62b055993148b82df19 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab858ddb6f259d65f760c2032b3bd5164 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab858ddb6f259d65f760c2032b3bd5164">v_ticket</a> ()</td></tr>
<tr class="memdesc:ab858ddb6f259d65f760c2032b3bd5164 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on velocity state variables v.  <a href="classdrake_1_1systems_1_1_system_base.html#ab858ddb6f259d65f760c2032b3bd5164">More...</a><br /></td></tr>
<tr class="separator:ab858ddb6f259d65f760c2032b3bd5164 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340a9b088fc407f703a9e21ed9dee32e inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a340a9b088fc407f703a9e21ed9dee32e">z_ticket</a> ()</td></tr>
<tr class="memdesc:a340a9b088fc407f703a9e21ed9dee32e inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on any or all of the miscellaneous continuous state variables z.  <a href="classdrake_1_1systems_1_1_system_base.html#a340a9b088fc407f703a9e21ed9dee32e">More...</a><br /></td></tr>
<tr class="separator:a340a9b088fc407f703a9e21ed9dee32e inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385e0d5605b81db0fbfc6bdd57affb5e inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a385e0d5605b81db0fbfc6bdd57affb5e">xc_ticket</a> ()</td></tr>
<tr class="memdesc:a385e0d5605b81db0fbfc6bdd57affb5e inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> of the continuous state variables q, v, or z.  <a href="classdrake_1_1systems_1_1_system_base.html#a385e0d5605b81db0fbfc6bdd57affb5e">More...</a><br /></td></tr>
<tr class="separator:a385e0d5605b81db0fbfc6bdd57affb5e inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64938d044107c8eedc97f89aaf0e4a32 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a64938d044107c8eedc97f89aaf0e4a32">xd_ticket</a> ()</td></tr>
<tr class="memdesc:a64938d044107c8eedc97f89aaf0e4a32 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the numerical discrete state variables, in any discrete variable group.  <a href="classdrake_1_1systems_1_1_system_base.html#a64938d044107c8eedc97f89aaf0e4a32">More...</a><br /></td></tr>
<tr class="separator:a64938d044107c8eedc97f89aaf0e4a32 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19842775d11b50e5ae56abcc6d38ccc4 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a19842775d11b50e5ae56abcc6d38ccc4">xa_ticket</a> ()</td></tr>
<tr class="memdesc:a19842775d11b50e5ae56abcc6d38ccc4 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the abstract state variables in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#a19842775d11b50e5ae56abcc6d38ccc4">More...</a><br /></td></tr>
<tr class="separator:a19842775d11b50e5ae56abcc6d38ccc4 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2789768c5d75378c081683a8016f0784 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a2789768c5d75378c081683a8016f0784">all_state_ticket</a> ()</td></tr>
<tr class="memdesc:a2789768c5d75378c081683a8016f0784 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> state variables x in this system, including continuous variables xc, discrete (numeric) variables xd, and abstract state variables xa.  <a href="classdrake_1_1systems_1_1_system_base.html#a2789768c5d75378c081683a8016f0784">More...</a><br /></td></tr>
<tr class="separator:a2789768c5d75378c081683a8016f0784 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeae092662e78f50416eb6dc01ad3ddb inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aaeae092662e78f50416eb6dc01ad3ddb">pn_ticket</a> ()</td></tr>
<tr class="memdesc:aaeae092662e78f50416eb6dc01ad3ddb inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the numerical parameters in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#aaeae092662e78f50416eb6dc01ad3ddb">More...</a><br /></td></tr>
<tr class="separator:aaeae092662e78f50416eb6dc01ad3ddb inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c65473a41f73091c600eaead714fe2 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af3c65473a41f73091c600eaead714fe2">pa_ticket</a> ()</td></tr>
<tr class="memdesc:af3c65473a41f73091c600eaead714fe2 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the abstract parameters pa in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#af3c65473a41f73091c600eaead714fe2">More...</a><br /></td></tr>
<tr class="separator:af3c65473a41f73091c600eaead714fe2 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b63a1cb8922051fb1a7fe4b56092bf inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad6b63a1cb8922051fb1a7fe4b56092bf">all_parameters_ticket</a> ()</td></tr>
<tr class="memdesc:ad6b63a1cb8922051fb1a7fe4b56092bf inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> parameters p in this system, including numeric parameters pn, and abstract parameters pa.  <a href="classdrake_1_1systems_1_1_system_base.html#ad6b63a1cb8922051fb1a7fe4b56092bf">More...</a><br /></td></tr>
<tr class="separator:ad6b63a1cb8922051fb1a7fe4b56092bf inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7c526102c09a75195c57ebf5f54a11 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a6d7c526102c09a75195c57ebf5f54a11">all_input_ports_ticket</a> ()</td></tr>
<tr class="memdesc:a6d7c526102c09a75195c57ebf5f54a11 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> input ports u of this system.  <a href="classdrake_1_1systems_1_1_system_base.html#a6d7c526102c09a75195c57ebf5f54a11">More...</a><br /></td></tr>
<tr class="separator:a6d7c526102c09a75195c57ebf5f54a11 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b9bc9f93181e042bdb2c36f4dbea10 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a> ()</td></tr>
<tr class="memdesc:af0b9bc9f93181e042bdb2c36f4dbea10 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on every possible independent source value, including time, accuracy, state, input ports, and parameters (but not cache entries).  <a href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">More...</a><br /></td></tr>
<tr class="separator:af0b9bc9f93181e042bdb2c36f4dbea10 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28830dced98dcdc1f498d8d250db0ae4 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a28830dced98dcdc1f498d8d250db0ae4">configuration_ticket</a> ()</td></tr>
<tr class="memdesc:a28830dced98dcdc1f498d8d250db0ae4 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all source values that may affect configuration-dependent computations.  <a href="classdrake_1_1systems_1_1_system_base.html#a28830dced98dcdc1f498d8d250db0ae4">More...</a><br /></td></tr>
<tr class="separator:a28830dced98dcdc1f498d8d250db0ae4 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1291b5091aa55dbd03c9b5944dbced09 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1291b5091aa55dbd03c9b5944dbced09">kinematics_ticket</a> ()</td></tr>
<tr class="memdesc:a1291b5091aa55dbd03c9b5944dbced09 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all source values that may affect configuration- or velocity-dependent computations.  <a href="classdrake_1_1systems_1_1_system_base.html#a1291b5091aa55dbd03c9b5944dbced09">More...</a><br /></td></tr>
<tr class="separator:a1291b5091aa55dbd03c9b5944dbced09 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42cd3bff14253894eb0a29edf843b3f inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab42cd3bff14253894eb0a29edf843b3f">xcdot_ticket</a> ()</td></tr>
<tr class="memdesc:ab42cd3bff14253894eb0a29edf843b3f inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds time derivatives of the continuous variables.  <a href="classdrake_1_1systems_1_1_system_base.html#ab42cd3bff14253894eb0a29edf843b3f">More...</a><br /></td></tr>
<tr class="separator:ab42cd3bff14253894eb0a29edf843b3f inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f1689b1ae9f05b6e2f194db873927b inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a49f1689b1ae9f05b6e2f194db873927b">pe_ticket</a> ()</td></tr>
<tr class="memdesc:a49f1689b1ae9f05b6e2f194db873927b inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the potential energy calculation.  <a href="classdrake_1_1systems_1_1_system_base.html#a49f1689b1ae9f05b6e2f194db873927b">More...</a><br /></td></tr>
<tr class="separator:a49f1689b1ae9f05b6e2f194db873927b inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e1d9af27119011a497b78df6907b1a inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a66e1d9af27119011a497b78df6907b1a">ke_ticket</a> ()</td></tr>
<tr class="memdesc:a66e1d9af27119011a497b78df6907b1a inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the kinetic energy calculation.  <a href="classdrake_1_1systems_1_1_system_base.html#a66e1d9af27119011a497b78df6907b1a">More...</a><br /></td></tr>
<tr class="separator:a66e1d9af27119011a497b78df6907b1a inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc60bc4c201f17bd35bf40c13a183b3 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#afdc60bc4c201f17bd35bf40c13a183b3">pc_ticket</a> ()</td></tr>
<tr class="memdesc:afdc60bc4c201f17bd35bf40c13a183b3 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the conservative power calculation.  <a href="classdrake_1_1systems_1_1_system_base.html#afdc60bc4c201f17bd35bf40c13a183b3">More...</a><br /></td></tr>
<tr class="separator:afdc60bc4c201f17bd35bf40c13a183b3 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afc9712c887706c12039e871476f30c inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0afc9712c887706c12039e871476f30c">pnc_ticket</a> ()</td></tr>
<tr class="memdesc:a0afc9712c887706c12039e871476f30c inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the non-conservative power calculation.  <a href="classdrake_1_1systems_1_1_system_base.html#a0afc9712c887706c12039e871476f30c">More...</a><br /></td></tr>
<tr class="separator:a0afc9712c887706c12039e871476f30c inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classdrake_1_1systems_1_1_system_base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classdrake_1_1systems_1_1_system_base')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a></td></tr>
<tr class="memitem:abbed6ab1f586a7b4d4a6131c6fa415ab inherit pro_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#abbed6ab1f586a7b4d4a6131c6fa415ab">set_parent_service</a> (<a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> *child, const internal::SystemParentServiceInterface *parent_service)</td></tr>
<tr class="memdesc:abbed6ab1f586a7b4d4a6131c6fa415ab inherit pro_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Declares that <code>parent_service</code> is the service interface of the <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> that owns this subsystem.  <a href="classdrake_1_1systems_1_1_system_base.html#abbed6ab1f586a7b4d4a6131c6fa415ab">More...</a><br /></td></tr>
<tr class="separator:abbed6ab1f586a7b4d4a6131c6fa415ab inherit pro_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414a090dc2d413d6d83bb2143e931dba inherit pro_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a414a090dc2d413d6d83bb2143e931dba">ThrowInputPortHasWrongType</a> (const char *func, const std::string &amp;system_pathname, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a>, const std::string &amp;expected_type, const std::string &amp;actual_type)</td></tr>
<tr class="memdesc:a414a090dc2d413d6d83bb2143e931dba inherit pro_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::logic_error because someone called API method <code>func</code> claiming the input port had some value type that was wrong.  <a href="classdrake_1_1systems_1_1_system_base.html#a414a090dc2d413d6d83bb2143e931dba">More...</a><br /></td></tr>
<tr class="separator:a414a090dc2d413d6d83bb2143e931dba inherit pro_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::systems::System&lt; T &gt;</h3>

<p>Base class for all <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> functionality that is dependent on the templatized scalar type T for input, state, parameters, and outputs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The vector element type, which must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a718e74eb516f658aa9f80ab77706e4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718e74eb516f658aa9f80ab77706e4e5">&#9670;&nbsp;</a></span>System() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51e42f15501f79c6a60375041a7e3729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e42f15501f79c6a60375041a7e3729">&#9670;&nbsp;</a></span>System() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3773fa71e3bc321a65cc8690b9291d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3773fa71e3bc321a65cc8690b9291d14">&#9670;&nbsp;</a></span>~System()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1b849c60d9ec6bbfeac42dc3c075a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b849c60d9ec6bbfeac42dc3c075a02">&#9670;&nbsp;</a></span>System() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a>&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty System base class object and allocates base class resources, possibly supporting scalar-type conversion support (AutoDiff, etc.) using <code>converter</code>. </p>
<p>See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a> for detailed background and examples related to scalar-type conversion support. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac9fbf92ac77db4d805a5a5cf980de130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9fbf92ac77db4d805a5a5cf980de130">&#9670;&nbsp;</a></span>AddConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a> AddConstraint </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>constraint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an already-created constraint to the list of constraints for this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>. </p>
<p>Ownership of the <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html" title="A SystemConstraint is a generic base-class for constraints on Systems. ">SystemConstraint</a> is transferred to this system. </p>

</div>
</div>
<a id="a838b32b3b596aae6c11fa9c19e655407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838b32b3b596aae6c11fa9c19e655407">&#9670;&nbsp;</a></span>AddTriggeredWitnessFunctionToCompositeEventCollection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AddTriggeredWitnessFunctionToCompositeEventCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add <code>event</code> to <code>events</code> due to a witness function triggering. </p>
<p><code>events</code> should be allocated with this system's AllocateCompositeEventCollection. Neither <code>event</code> nor <code>events</code> can be nullptr. Additionally, <code>event</code> must contain event data (event-&gt;get_event_data() must not be nullptr) and the type of that data must be <a class="el" href="classdrake_1_1systems_1_1_witness_triggered_event_data.html" title="Class for storing data from a witness function triggering to be passed to event handlers. ">WitnessTriggeredEventData</a>. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#af3167bd30bfa014aa61d55fb50ed36f9">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#af3167bd30bfa014aa61d55fb50ed36f9">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#af3167bd30bfa014aa61d55fb50ed36f9">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#af3167bd30bfa014aa61d55fb50ed36f9">LeafSystem&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#af3167bd30bfa014aa61d55fb50ed36f9">LeafSystem&lt; AutoDiffXd &gt;</a>.</p>

</div>
</div>
<a id="abbd4136260d1751f53abe9f9f3610df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd4136260d1751f53abe9f9f3610df0">&#9670;&nbsp;</a></span>AllocateCompositeEventCollection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt;T&gt; &gt; AllocateCompositeEventCollection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html" title="This class bundles an instance of each EventCollection&lt;EventType&gt; into one object that stores the het...">CompositeEventCollection</a> for this system. </p>
<p>The allocated instance is used for registering events; for example, <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> passes this object to <a class="el" href="classdrake_1_1systems_1_1_system.html#a164afe3c1db737b93696b8808bb2c942" title="This method is called by a Simulator during its calculation of the size of the next continuous step t...">System::CalcNextUpdateTime()</a> to allow the system to register upcoming events. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5dc6a1bfa8837ee9da5b26173e1bffe1">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5dc6a1bfa8837ee9da5b26173e1bffe1">LeafSystem&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5dc6a1bfa8837ee9da5b26173e1bffe1">LeafSystem&lt; AutoDiffXd &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a5dc6a1bfa8837ee9da5b26173e1bffe1">Diagram&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a5dc6a1bfa8837ee9da5b26173e1bffe1">Diagram&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a07c386a39241bbd79236c7701d370d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c386a39241bbd79236c7701d370d7e">&#9670;&nbsp;</a></span>AllocateContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt;T&gt; &gt; AllocateContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a Context&lt;T&gt; suitable for use with this System&lt;T&gt;. </p>

</div>
</div>
<a id="a99efc8858c97bc99384ab81c2d5ac3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99efc8858c97bc99384ab81c2d5ac3a0">&#9670;&nbsp;</a></span>AllocateDiscreteVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt;T&gt; &gt; AllocateDiscreteVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a DiscreteState of the same dimensions as the discrete_state allocated in CreateDefaultContext. </p>
<p>The simulator will provide this state as the output argument to Update. By default, allocates nothing. Systems with discrete state variables should override. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a81279e22a18e2e563b7343c23ca80bb5">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a81279e22a18e2e563b7343c23ca80bb5">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a81279e22a18e2e563b7343c23ca80bb5">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a81279e22a18e2e563b7343c23ca80bb5">LeafSystem&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a81279e22a18e2e563b7343c23ca80bb5">LeafSystem&lt; AutoDiffXd &gt;</a>.</p>

</div>
</div>
<a id="a47ec86445724fd77391af7874bfc4848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ec86445724fd77391af7874bfc4848">&#9670;&nbsp;</a></span>AllocateFixedInputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AllocateFixedInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each input port, allocates a fixed input of the concrete type that this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> requires, and binds it to the port, disconnecting any prior input. </p>
<p>Does not assign any values to the fixed inputs. </p>

</div>
</div>
<a id="a3a50463e995d1d3e414ade7051c3458a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a50463e995d1d3e414ade7051c3458a">&#9670;&nbsp;</a></span>AllocateInputAbstract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">AbstractValue</a>&gt; AllocateInputAbstract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_port</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input port, allocates the abstract storage. </p>
<p>The <code>input_port</code> must match a port declared via DeclareInputPort. </p>

</div>
</div>
<a id="a6c7d64d658e5fb67234d9ffc918155bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7d64d658e5fb67234d9ffc918155bd">&#9670;&nbsp;</a></span>AllocateInputVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt;T&gt; &gt; AllocateInputVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_port</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an input port, allocates the vector storage. </p>
<p>The <code>input_port</code> must match a port declared via DeclareInputPort. </p>

</div>
</div>
<a id="a52b7d1592da75535d37841d338ec39be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b7d1592da75535d37841d338ec39be">&#9670;&nbsp;</a></span>AllocateOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt;T&gt; &gt; AllocateOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a container that can hold the values of all of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>'s output ports. </p>
<p>It is sized with the number of output ports and uses each output port's allocation method to provide an object of the right type for that port. </p>

</div>
</div>
<a id="a8b5935b95776173ff31b5923c5b6c9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5935b95776173ff31b5923c5b6c9e1">&#9670;&nbsp;</a></span>AllocateTimeDerivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt;T&gt; &gt; AllocateTimeDerivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html" title="ContinuousState is a view of, and optionally a container for, all the continuous state variables xc o...">ContinuousState</a> of the same size as the continuous_state allocated in CreateDefaultContext. </p>
<p>The simulator will provide this state as the output argument to EvalTimeDerivatives.</p>
<p>By default, allocates no derivatives. Systems with continuous state variables should override. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#aa396d162f35ef250bf092d1340c01231">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#aa396d162f35ef250bf092d1340c01231">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#aa396d162f35ef250bf092d1340c01231">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#aa396d162f35ef250bf092d1340c01231">LeafSystem&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#aa396d162f35ef250bf092d1340c01231">LeafSystem&lt; AutoDiffXd &gt;</a>.</p>

</div>
</div>
<a id="a5674ae416c2808c939dffc117b209f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5674ae416c2808c939dffc117b209f23">&#9670;&nbsp;</a></span>CalcConservativePower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CalcConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the conservative power represented by the current contents of the given <code>context</code>. </p>
<p>Prefer <a class="el" href="classdrake_1_1systems_1_1_system.html#aa0d982876c8955c50988ae9f03ce6f75" title="Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary...">EvalConservativePower()</a> to avoid unnecessary recalculation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#aa0d982876c8955c50988ae9f03ce6f75" title="Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary...">EvalConservativePower()</a> for more information. </dd></dl>

</div>
</div>
<a id="a71893bf8c20254b15b075c7c10935d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71893bf8c20254b15b075c7c10935d12">&#9670;&nbsp;</a></span>CalcConstraintErrorNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> CalcConstraintErrorNorm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the norm on constraint error (used as a metric for comparing errors between the outputs of algebraic equations applied to two different state variable instances). </p>
<p>This norm need be neither continuous nor differentiable. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the dimension of <code>err</code> is not equivalent to the output of <a class="el" href="classdrake_1_1systems_1_1_system.html#aa21289a0f31d15c21a17ae321a75ac47" title="Gets the number of constraint equations for this system using the given context (useful in case the n...">get_num_constraint_equations()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b4b5edfcccb98a87f958bc9b6b626bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4b5edfcccb98a87f958bc9b6b626bd">&#9670;&nbsp;</a></span>CalcDiscreteVariableUpdates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcDiscreteVariableUpdates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>discrete_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is the public entry point for dispatching all discrete variable update event handlers. </p>
<p>Using all the discrete update handlers in <code>events</code>, the method calculates the update <code>xd(n+1)</code> to discrete variables <code>xd(n)</code> in <code>context</code> and outputs the results to <code>discrete_state</code>. See documentation for <a class="el" href="classdrake_1_1systems_1_1_system.html#a921d9a050e25d0f2c55de265477c26f5" title="This function dispatches all discrete update events to the appropriate handlers. ">DispatchDiscreteVariableUpdateHandler()</a> for more details. </p>

</div>
</div>
<a id="a054ef0e9e578c5abc57fd4dc8b12bd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054ef0e9e578c5abc57fd4dc8b12bd84">&#9670;&nbsp;</a></span>CalcDiscreteVariableUpdates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcDiscreteVariableUpdates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>discrete_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method forces a discrete update on the system given a <code>context</code>, and the updated discrete state is stored in <code>discrete_state</code>. </p>
<p>The discrete update event will have a trigger type of kForced, with no attribute or custom callback. </p>

</div>
</div>
<a id="aad01402fef0de79310989d7d22dfde92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad01402fef0de79310989d7d22dfde92">&#9670;&nbsp;</a></span>CalcKineticEnergy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CalcKineticEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the kinetic energy represented by the current configuration and velocity provided in <code>context</code>. </p>
<p>Prefer <a class="el" href="classdrake_1_1systems_1_1_system.html#aa60880d6e51fedbf2ad61b6f0cae8f96" title="Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary usi...">EvalKineticEnergy()</a> to avoid unnecessary recalculation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#aa60880d6e51fedbf2ad61b6f0cae8f96" title="Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary usi...">EvalKineticEnergy()</a> for more information. </dd></dl>

</div>
</div>
<a id="a164afe3c1db737b93696b8808bb2c942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164afe3c1db737b93696b8808bb2c942">&#9670;&nbsp;</a></span>CalcNextUpdateTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CalcNextUpdateTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called by a <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> during its calculation of the size of the next continuous step to attempt. </p>
<p>The <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> returns the next time at which some discrete action must be taken, and records what those actions ought to be in <code>events</code>. Upon reaching that time, the simulator will merge <code>events</code> with the other <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html" title="This class bundles an instance of each EventCollection&lt;EventType&gt; into one object that stores the het...">CompositeEventCollection</a> instances scheduled through mechanisms (e.g. <a class="el" href="classdrake_1_1systems_1_1_system.html#ad8a24b8f910f9d990db8e59bf2bae6d0" title="This method is called by Simulator::Initialize() to gather all update and publish events that are to ...">GetPerStepEvents()</a>), and the merged <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html" title="This class bundles an instance of each EventCollection&lt;EventType&gt; into one object that stores the het...">CompositeEventCollection</a> will be passed to all event handling mechanisms.</p>
<p><code>events</code> cannot be null. <code>events</code> will be cleared on entry. </p>

</div>
</div>
<a id="a23fe133b70153e382d7f50c38b96bf1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fe133b70153e382d7f50c38b96bf1f">&#9670;&nbsp;</a></span>CalcNonConservativePower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CalcNonConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the non-conservative power represented by the current contents of the given <code>context</code>. </p>
<p>Prefer <a class="el" href="classdrake_1_1systems_1_1_system.html#ace530af4be075614218eb4bc725c1aba" title="Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if nece...">EvalNonConservativePower()</a> to avoid unnecessary recalculation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#ace530af4be075614218eb4bc725c1aba" title="Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if nece...">EvalNonConservativePower()</a> for more information. </dd></dl>

</div>
</div>
<a id="a574467e50cf5c242f665557daca33111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574467e50cf5c242f665557daca33111">&#9670;&nbsp;</a></span>CalcOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility method that computes for <em>every</em> output port i the value y(i) that should result from the current contents of the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<p>Note that individual output port values can be calculated using <code>get_output_port(i).Calc()</code>; this method invokes that for each output port in index order. The result may depend on time and the current values of input ports, parameters, and state variables. The result is written to <code>outputs</code> which must already have been allocated to have the right number of entries of the right types. </p>

</div>
</div>
<a id="a3d5eb1d2630aab1938230257554d1f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5eb1d2630aab1938230257554d1f43">&#9670;&nbsp;</a></span>CalcPotentialEnergy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CalcPotentialEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the potential energy represented by the current configuration provided in <code>context</code>. </p>
<p>Prefer <a class="el" href="classdrake_1_1systems_1_1_system.html#a432bd44170a669c140bc483e18f9e6df" title="Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary u...">EvalPotentialEnergy()</a> to avoid unnecessary recalculation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#a432bd44170a669c140bc483e18f9e6df" title="Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary u...">EvalPotentialEnergy()</a> for more information. </dd></dl>

</div>
</div>
<a id="af2677f8773e90a538483eedd80a81a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2677f8773e90a538483eedd80a81a9f">&#9670;&nbsp;</a></span>CalcTimeDerivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcTimeDerivatives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>derivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the time derivatives <code>xcdot</code> of the continuous state <code>xc</code> into a given output argument. </p>
<p>Prefer <a class="el" href="classdrake_1_1systems_1_1_system.html#ae38625e953699a0433249142972eef52" title="Returns a reference to the cached value of the continuous state variable time derivatives, evaluating first if necessary using CalcTimeDerivatives(). ">EvalTimeDerivatives()</a> instead to avoid unnecessary recomputation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#ae38625e953699a0433249142972eef52" title="Returns a reference to the cached value of the continuous state variable time derivatives, evaluating first if necessary using CalcTimeDerivatives(). ">EvalTimeDerivatives()</a> for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose contents will be used to evaluate the derivatives. </td></tr>
    <tr><td class="paramname">derivatives</td><td>The time derivatives <code>xcdot</code>. Must be the same size as the continuous state vector in <code>context</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad195518c9c6d2c9421e6e2b222514d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad195518c9c6d2c9421e6e2b222514d89">&#9670;&nbsp;</a></span>CalcUnrestrictedUpdate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcUnrestrictedUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is the public entry point for dispatching all unrestricted update event handlers. </p>
<p>Using all the unrestricted update handers in <code>events</code>, it updates <em>any</em> state variables in the <code>context</code>, and outputs the results to <code>state</code>. It does not allow the dimensionality of the state variables to change. See the documentation for <a class="el" href="classdrake_1_1systems_1_1_system.html#affb56df9a1e83ab8cef21c9b122d6346" title="This function dispatches all unrestricted update events to the appropriate handlers. ">DispatchUnrestrictedUpdateHandler()</a> for more details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the dimensionality of the state variables changes in the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25f04e429745ae7a16600c4dfda0f931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f04e429745ae7a16600c4dfda0f931">&#9670;&nbsp;</a></span>CalcUnrestrictedUpdate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcUnrestrictedUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method forces an unrestricted update on the system given a <code>context</code>, and the updated state is stored in <code>state</code>. </p>
<p>The unrestricted update event will have a trigger type of kForced, with no additional data, attribute or custom callback.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#ad195518c9c6d2c9421e6e2b222514d89" title="This method is the public entry point for dispatching all unrestricted update event handlers...">CalcUnrestrictedUpdate</a>(const Context&lt;T&gt;&amp;, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html" title="There are three concrete event types for any System: publish, discrete state update, and unrestricted state update, listed in order of increasing ability to change the state (i.e., zero to all). ">EventCollection</a>&lt;UnrestrictedUpdateEvent&lt;T&gt;&gt;*, State&lt;T&gt;* state) for more information. </dd></dl>

</div>
</div>
<a id="adbcd68e4f53dbb75927e2d4f9d709440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcd68e4f53dbb75927e2d4f9d709440">&#9670;&nbsp;</a></span>CalcVelocityChangeFromConstraintImpulses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd CalcVelocityChangeFromConstraintImpulses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the change in velocity from applying the given constraint forces to the system at the given context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the current system state, provision of which also yields the ability of the constraints to be dependent upon the current system state (as might be the case with a piecewise differential algebraic equation). </td></tr>
    <tr><td class="paramname">J</td><td>a m × n constraint Jacobian matrix of the <code>m</code> constraint equations <code>g()</code> differentiated with respect to the <code>n</code> configuration variables <code>q</code> (i.e., <code>J</code> should be <code>∂g/∂q</code>). If the time derivatives of the generalized coordinates of the system are not identical to the generalized velocity (in general they need not be, e.g., if generalized coordinates use unit unit quaternions to represent 3D orientation), <code>J</code> should instead be defined as <code>∂g/∂q⋅N</code>, where <code>N ≡ ∂q/∂ꝗ</code> is the Jacobian matrix (dependent on <code>q</code>) of the generalized coordinates with respect to the quasi-coordinates (ꝗ, pronounced "qbar", where dꝗ/dt are the generalized velocities). </td></tr>
    <tr><td class="paramname">lambda</td><td>the vector of constraint forces (of same dimension as the number of rows in the Jacobian matrix, <code>J</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code>n</code> dimensional vector, where <code>n</code> is the dimension of the quasi-coordinates. </dd></dl>

</div>
</div>
<a id="a2949deb61db7903dae4c0b7cb9633fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2949deb61db7903dae4c0b7cb9633fac">&#9670;&nbsp;</a></span>CalcWitnessValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CalcWitnessValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>witness_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates a witness function at the given context. </p>

</div>
</div>
<a id="a4adf20a88ef081c27ea071d880292209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4adf20a88ef081c27ea071d880292209">&#9670;&nbsp;</a></span>CheckSystemConstraintsSatisfied()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; CheckSystemConstraintsSatisfied </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <code>context</code> satisfies all of the registered SystemConstraints with tolerance <code>tol</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system_constraint.html#a3899e4ce18e02c4370c47d0feebbc9e3" title="Evaluates the function pointer, and check if all of the outputs are within the desired bounds...">SystemConstraint::CheckSatisfied</a>. </dd></dl>

</div>
</div>
<a id="abde7091d9f2709229fcb446f3d5ff001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde7091d9f2709229fcb446f3d5ff001">&#9670;&nbsp;</a></span>CheckValidContextT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CheckValidContextT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that <code>context</code> is consistent for this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> template. </p>
<p>Supports any scalar type, but expects T by default.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>unless <code>context</code> is valid for this system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>the scalar type of the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a852a4bc3895e11faf46f4e32b47d338d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852a4bc3895e11faf46f4e32b47d338d">&#9670;&nbsp;</a></span>CheckValidOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CheckValidOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that <code>output</code> is consistent with the number and size of output ports declared by the system. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>unless <code>output</code> is non-null and valid for this system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24c711d92735642b2fa7fc975e9b5bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c711d92735642b2fa7fc975e9b5bf8">&#9670;&nbsp;</a></span>CopyContinuousStateVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; CopyContinuousStateVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the continuous state vector <code>xc</code> into an <a class="el" href="namespace_eigen.html">Eigen</a> vector. </p>

</div>
</div>
<a id="ad047317ab91889c6743d5e47a64c7f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad047317ab91889c6743d5e47a64c7f08">&#9670;&nbsp;</a></span>CreateDefaultContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt;T&gt; &gt; CreateDefaultContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This convenience method allocates a context using <a class="el" href="classdrake_1_1systems_1_1_system.html#a07c386a39241bbd79236c7701d370d7e" title="Returns a Context&lt;T&gt; suitable for use with this System&lt;T&gt;. ">AllocateContext()</a> and sets its default values using <a class="el" href="classdrake_1_1systems_1_1_system.html#ab4e6ee413f4f47a20f6dcc2cbd831b88">SetDefaultContext()</a>. </p>

</div>
</div>
<a id="a011a04791ece0fa2ae1efa90d9bf35cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011a04791ece0fa2ae1efa90d9bf35cf">&#9670;&nbsp;</a></span>DeclareInputPort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt;T&gt;&amp; DeclareInputPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#ae516fceb67f15f61c7a232b9cc483fbe">PortDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt;&#160;</td>
          <td class="paramname"><em>random_type</em> = <code><a class="el" href="namespacedrake.html#acd293644b847dc4549de80a090d66625">nullopt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a port with the specified <code>type</code> and <code>size</code> to the input topology. </p>
<p>Input port names must be unique for this system (passing in a duplicate <code>name</code> will throw std::logic_error). If <code>name</code> is given as kUseDefaultName, then a default value of e.g. "u2", where 2 is the input number will be provided. An empty <code>name</code> is not permitted.</p>
<p>If the port is intended to model a random noise or disturbance input, <code>random_type</code> can (optionally) be used to label it as such; doing so enables algorithms for design and analysis (e.g. state estimation) to reason explicitly about randomness at the system level. All random input ports are assumed to be statistically independent. </p><dl class="section pre"><dt>Precondition</dt><dd><code>name</code> must not be empty. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for a duplicate port name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the declared port. </dd></dl>

</div>
</div>
<a id="afc5f2153443d34fc439945fc34e64c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5f2153443d34fc439945fc34e64c5e">&#9670;&nbsp;</a></span>DeclareInputPort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt;T&gt;&amp; DeclareInputPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#ae516fceb67f15f61c7a232b9cc483fbe">PortDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt;&#160;</td>
          <td class="paramname"><em>random_type</em> = <code><a class="el" href="namespacedrake.html#acd293644b847dc4549de80a090d66625">nullopt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See the nearly identical signature with an additional (first) argument specifying the port name. </p>
<p>This version will be deprecated as discussed in #9447. </p>

</div>
</div>
<a id="a921d9a050e25d0f2c55de265477c26f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921d9a050e25d0f2c55de265477c26f5">&#9670;&nbsp;</a></span>DispatchDiscreteVariableUpdateHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DispatchDiscreteVariableUpdateHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>discrete_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function dispatches all discrete update events to the appropriate handlers. </p>
<p><code>discrete_state</code> cannot be null. </p>

</div>
</div>
<a id="a84fe4f2e8e6d8a61dfae06f64fb6d5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fe4f2e8e6d8a61dfae06f64fb6d5ce">&#9670;&nbsp;</a></span>DispatchPublishHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DispatchPublishHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function dispatches all publish events to the appropriate handlers. </p>

</div>
</div>
<a id="affb56df9a1e83ab8cef21c9b122d6346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb56df9a1e83ab8cef21c9b122d6346">&#9670;&nbsp;</a></span>DispatchUnrestrictedUpdateHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DispatchUnrestrictedUpdateHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function dispatches all unrestricted update events to the appropriate handlers. </p>
<p><code>state</code> cannot be null. </p>

</div>
</div>
<a id="af92f74ba8239aeca3a325e3a77c53478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92f74ba8239aeca3a325e3a77c53478">&#9670;&nbsp;</a></span>do_get_num_constraint_equations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classint.html">int</a> do_get_num_constraint_equations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of constraint equations for this system from the given context. </p>
<p>The context is supplied in case the number of constraints is dependent upon the current state (as might be the case with a piecewise differential algebraic equation). Derived classes can override this function, which is called by <a class="el" href="classdrake_1_1systems_1_1_system.html#aa21289a0f31d15c21a17ae321a75ac47" title="Gets the number of constraint equations for this system using the given context (useful in case the n...">get_num_constraint_equations()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#aa21289a0f31d15c21a17ae321a75ac47" title="Gets the number of constraint equations for this system using the given context (useful in case the n...">get_num_constraint_equations()</a> for parameter documentation. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>zero by default </dd></dl>

</div>
</div>
<a id="aafa6ce88c0e7ba9f6592713d36bc4047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa6ce88c0e7ba9f6592713d36bc4047">&#9670;&nbsp;</a></span>DoCalcConservativePower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T DoCalcConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this method to return the rate Pc at which mechanical energy is being converted <em>from</em> potential energy <em>to</em> kinetic energy by this system in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<p>By default, returns zero. Physical systems should override. You may assume that <code>context</code> has already been validated before it is passed to you here.</p>
<p>See <a class="el" href="classdrake_1_1systems_1_1_system.html#aa0d982876c8955c50988ae9f03ce6f75" title="Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary...">EvalConservativePower()</a> for details on what you must compute here. In particular, this quantity must be <em>positive</em> when potential energy is <em>decreasing</em>, and your conservative power method must <em>not</em> depend explicitly on time or any input port values. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#adf21bb1c65c43e8948d3c4eeb9da1a49">RigidBodyPlant&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#adf21bb1c65c43e8948d3c4eeb9da1a49">RigidBodyPlant&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_spring_mass_system.html#a464f9783933838f554ca2a5ca6277076">SpringMassSystem&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_spring_mass_system.html#a464f9783933838f554ca2a5ca6277076">SpringMassSystem&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a7d42c7934ea48286f9eaa1c57e65e0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d42c7934ea48286f9eaa1c57e65e0b5">&#9670;&nbsp;</a></span>DoCalcConstraintErrorNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> DoCalcConstraintErrorNorm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the norm of the constraint error. </p>
<p>This default implementation computes a Euclidean norm of the error. Derived classes can override this function, which is called by <a class="el" href="classdrake_1_1systems_1_1_system.html#a71893bf8c20254b15b075c7c10935d12" title="Computes the norm on constraint error (used as a metric for comparing errors between the outputs of a...">CalcConstraintErrorNorm()</a>. This norm need be neither continuous nor differentiable. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#a71893bf8c20254b15b075c7c10935d12" title="Computes the norm on constraint error (used as a metric for comparing errors between the outputs of a...">CalcConstraintErrorNorm()</a> for parameter documentation. </dd></dl>

</div>
</div>
<a id="a8de30438c7fbda84a0cc9a35ca543c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de30438c7fbda84a0cc9a35ca543c8e">&#9670;&nbsp;</a></span>DoCalcKineticEnergy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T DoCalcKineticEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this method for physical systems to calculate the kinetic energy KE currently present in the motion provided in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<p>The default implementation returns 0 which is correct for non-physical systems. You may assume that <code>context</code> has already been validated before it is passed to you here.</p>
<p>See <a class="el" href="classdrake_1_1systems_1_1_system.html#aa60880d6e51fedbf2ad61b6f0cae8f96" title="Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary usi...">EvalKineticEnergy()</a> for details on what you must compute here. In particular, your kinetic energy method must <em>not</em> depend explicitly on time or any input port values. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#a201226e0db2f9911c859bf9ea03edd43">RigidBodyPlant&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#a201226e0db2f9911c859bf9ea03edd43">RigidBodyPlant&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_spring_mass_system.html#a7aa27e1a665fc57e4708d02169f3658c">SpringMassSystem&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_spring_mass_system.html#a7aa27e1a665fc57e4708d02169f3658c">SpringMassSystem&lt; double &gt;</a>.</p>

</div>
</div>
<a id="afdc9aebb6327099391cd0f621b4b8d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc9aebb6327099391cd0f621b4b8d44">&#9670;&nbsp;</a></span>DoCalcNextUpdateTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoCalcNextUpdateTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the next time at which this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> must perform a discrete action. </p>
<p>Override this method if your <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> has any discrete actions which must interrupt the continuous simulation. This method is called only from the public non-virtual <a class="el" href="classdrake_1_1systems_1_1_system.html#a164afe3c1db737b93696b8808bb2c942" title="This method is called by a Simulator during its calculation of the size of the next continuous step t...">CalcNextUpdateTime()</a> which will already have error-checked the parameters so you don't have to. You may assume that <code>context</code> has already been validated and <code>events</code> pointer is not null.</p>
<p>The default implementation returns with the next sample time being Infinity and no events added to <code>events</code>. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a44e600fb330237f0e76dfc4f6f1b6faf">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a44e600fb330237f0e76dfc4f6f1b6faf">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5c883b4b0aa7a507e29dee582d9ed0fb">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5c883b4b0aa7a507e29dee582d9ed0fb">LeafSystem&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5c883b4b0aa7a507e29dee582d9ed0fb">LeafSystem&lt; AutoDiffXd &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1lcm_1_1_lcm_subscriber_system.html#ad04c37d6ce3d9764d1d4992b6d8ff7e7">LcmSubscriberSystem</a>, and <a class="el" href="classdrake_1_1systems_1_1lcm_1_1_lcm_log_playback_system.html#aef25b6bf7f703116ca7188bffdee593c">LcmLogPlaybackSystem</a>.</p>

</div>
</div>
<a id="a3bc39e42fbb88d08592d2f7e7c12637d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc39e42fbb88d08592d2f7e7c12637d">&#9670;&nbsp;</a></span>DoCalcNonConservativePower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T DoCalcNonConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this method to return the rate Pnc at which work W is done on the system by non-conservative forces. </p>
<p>By default, returns zero. Physical systems should override. You may assume that <code>context</code> has already been validated before it is passed to you here.</p>
<p>See <a class="el" href="classdrake_1_1systems_1_1_system.html#ace530af4be075614218eb4bc725c1aba" title="Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if nece...">EvalNonConservativePower()</a> for details on what you must compute here. In particular, this quantity must be <em>negative</em> if the non-conservative forces are <em>dissipative</em>, positive otherwise. Your non-conservative power method can depend on anything you find in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, including time and input ports. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#a60deaca664422c0df983f4d53acb3eed">RigidBodyPlant&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#a60deaca664422c0df983f4d53acb3eed">RigidBodyPlant&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_spring_mass_system.html#a3bde0864b0c6638c1a028ec7ec6a39c8">SpringMassSystem&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_spring_mass_system.html#a3bde0864b0c6638c1a028ec7ec6a39c8">SpringMassSystem&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a40f055c2fb422eefe50faf9a0979c1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f055c2fb422eefe50faf9a0979c1e0">&#9670;&nbsp;</a></span>DoCalcPotentialEnergy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T DoCalcPotentialEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this method for physical systems to calculate the potential energy PE currently stored in the configuration provided in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<p>The default implementation returns 0 which is correct for non-physical systems. You may assume that <code>context</code> has already been validated before it is passed to you here.</p>
<p>See <a class="el" href="classdrake_1_1systems_1_1_system.html#a432bd44170a669c140bc483e18f9e6df" title="Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary u...">EvalPotentialEnergy()</a> for details on what you must compute here. In particular, your potential energy method must <em>not</em> depend explicitly on time, velocities, or any input port values. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#a4abf19dfe8da71cacec3bdb381efae35">RigidBodyPlant&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#a4abf19dfe8da71cacec3bdb381efae35">RigidBodyPlant&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_spring_mass_system.html#abe19d25907e50ffe5c78566765e52489">SpringMassSystem&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_spring_mass_system.html#abe19d25907e50ffe5c78566765e52489">SpringMassSystem&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a2d2b6bbca36ba86a269c9fd42ddfb6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2b6bbca36ba86a269c9fd42ddfb6d0">&#9670;&nbsp;</a></span>DoCalcTimeDerivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoCalcTimeDerivatives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>derivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this if you have any continuous state variables <code>xc</code> in your concrete System to calculate their time derivatives. </p>
<p>The <code>derivatives</code> vector will correspond elementwise with the state vector <code>Context.state.continuous_state.get_state()</code>. Thus, if the state in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> has second-order structure <code>xc=[q,v,z]</code>, that same structure applies to the derivatives.</p>
<p>This method is called only from the public non-virtual <a class="el" href="classdrake_1_1systems_1_1_system.html#af2677f8773e90a538483eedd80a81a9f" title="Calculates the time derivatives xcdot of the continuous state xc into a given output argument...">CalcTimeDerivatives()</a> which will already have error-checked the parameters so you don't have to. In particular, implementations may assume that the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> is valid for this System; that the <code>derivatives</code> pointer is non-null, and that the referenced object has the same constituent structure as was produced by <a class="el" href="classdrake_1_1systems_1_1_system.html#a8b5935b95776173ff31b5923c5b6c9e1" title="Returns a ContinuousState of the same size as the continuous_state allocated in CreateDefaultContext...">AllocateTimeDerivatives()</a>.</p>
<p>The default implementation does nothing if the <code>derivatives</code> vector is size zero and aborts otherwise. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#a18737529bba0537a9fa06a649378b1a8">RigidBodyPlant&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#a18737529bba0537a9fa06a649378b1a8">RigidBodyPlant&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a18737529bba0537a9fa06a649378b1a8">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a18737529bba0537a9fa06a649378b1a8">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_spring_mass_system.html#a18737529bba0537a9fa06a649378b1a8">SpringMassSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_spring_mass_system.html#a18737529bba0537a9fa06a649378b1a8">SpringMassSystem&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1controllers_1_1_pid_controller.html#a18737529bba0537a9fa06a649378b1a8">PidController&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_vector_system.html#a021b8135deba8c945c9deea3cb4ce7a0">VectorSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_vector_system.html#a021b8135deba8c945c9deea3cb4ce7a0">VectorSystem&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1implicit__integrator__test_1_1_spring_mass_damper_system.html#a18737529bba0537a9fa06a649378b1a8">SpringMassDamperSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_time_varying_affine_system.html#a18737529bba0537a9fa06a649378b1a8">TimeVaryingAffineSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_time_varying_affine_system.html#a18737529bba0537a9fa06a649378b1a8">TimeVaryingAffineSystem&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1analysis_1_1test_1_1_stiff_double_mass_spring_system.html#a6871d1ec516e871e07ee4fa7a114a43d">StiffDoubleMassSpringSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1implicit__integrator__test_1_1_discontinuous_spring_mass_damper_system.html#a18737529bba0537a9fa06a649378b1a8">DiscontinuousSpringMassDamperSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1detail_1_1_o_d_e_system.html#a18737529bba0537a9fa06a649378b1a8">ODESystem&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1analysis_1_1test_1_1_robertson_system.html#a6871d1ec516e871e07ee4fa7a114a43d">RobertsonSystem&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ae033a9554c35fda06c022cb890621583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae033a9554c35fda06c022cb890621583">&#9670;&nbsp;</a></span>DoCalcVelocityChangeFromConstraintImpulses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Eigen::VectorXd DoCalcVelocityChangeFromConstraintImpulses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the change in velocity from applying the given constraint forces to the system at the given context. </p>
<p>Derived classes can override this function, which is called by <a class="el" href="classdrake_1_1systems_1_1_system.html#adbcd68e4f53dbb75927e2d4f9d709440" title="Computes the change in velocity from applying the given constraint forces to the system at the given ...">CalcVelocityChangeFromConstraintImpulses()</a>. </p><dl class="section return"><dt>Returns</dt><dd>the zero vector of dimension of the dimension of the quasi-coordinates, by default. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#adbcd68e4f53dbb75927e2d4f9d709440" title="Computes the change in velocity from applying the given constraint forces to the system at the given ...">CalcVelocityChangeFromConstraintImpulses()</a> for parameter documentation. </dd></dl>

</div>
</div>
<a id="a9440f6840ccb22a989d50ff8a7e65760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9440f6840ccb22a989d50ff8a7e65760">&#9670;&nbsp;</a></span>DoCalcWitnessValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T DoCalcWitnessValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>witness_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes will implement this method to evaluate a witness function at the given context. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">LeafSystem&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">LeafSystem&lt; AutoDiffXd &gt;</a>.</p>

</div>
</div>
<a id="a73640bb8a630f97962b71df8035a7fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73640bb8a630f97962b71df8035a7fc2">&#9670;&nbsp;</a></span>DoEvalConstraintEquations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Eigen::VectorXd DoEvalConstraintEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the constraint equations for the system at the generalized coordinates and generalized velocity specified by the context. </p>
<p>The context allows the set of constraints to be dependent upon the current system state (as might be the case with a piecewise differential algebraic equation). The default implementation of this function returns a zero-dimensional vector. Derived classes can override this function, which is called by <a class="el" href="classdrake_1_1systems_1_1_system.html#a0a271e43d57f6eeb3bbdb3bbd1105a8d" title="Evaluates the constraint equations for the system at the generalized coordinates and generalized velo...">EvalConstraintEquations()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#a0a271e43d57f6eeb3bbdb3bbd1105a8d" title="Evaluates the constraint equations for the system at the generalized coordinates and generalized velo...">EvalConstraintEquations()</a> for parameter documentation. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of dimension <a class="el" href="classdrake_1_1systems_1_1_system.html#aa21289a0f31d15c21a17ae321a75ac47" title="Gets the number of constraint equations for this system using the given context (useful in case the n...">get_num_constraint_equations()</a>; the zero vector indicates that the algebraic constraints are all satisfied. </dd></dl>

</div>
</div>
<a id="a11da6dcf33e2196ef99444666969d7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11da6dcf33e2196ef99444666969d7dd">&#9670;&nbsp;</a></span>DoEvalConstraintEquationsDot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Eigen::VectorXd DoEvalConstraintEquationsDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the time derivative of each constraint equation, evaluated at the generalized coordinates and generalized velocity specified by the context. </p>
<p>The context allows the set of constraints to be dependent upon the current system state (as might be the case with a piecewise differential algebraic equation). The default implementation of this function returns a zero-dimensional vector. Derived classes can override this function, which is called by <a class="el" href="classdrake_1_1systems_1_1_system.html#a29c0399e6d530a28b40ddde9b2135f6e" title="Computes the time derivative of each constraint equation, evaluated at the generalized coordinates an...">EvalConstraintEquationsDot()</a>. </p><dl class="section return"><dt>Returns</dt><dd>a vector of dimension <a class="el" href="classdrake_1_1systems_1_1_system.html#aa21289a0f31d15c21a17ae321a75ac47" title="Gets the number of constraint equations for this system using the given context (useful in case the n...">get_num_constraint_equations()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#a29c0399e6d530a28b40ddde9b2135f6e" title="Computes the time derivative of each constraint equation, evaluated at the generalized coordinates an...">EvalConstraintEquationsDot()</a> for parameter documentation. </dd></dl>

</div>
</div>
<a id="a0a38740aa5d71df2a0bab769c29fff7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a38740aa5d71df2a0bab769c29fff7c">&#9670;&nbsp;</a></span>DoGetInitializationEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoGetInitializationEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method to return any events to be handled at the simulator's initialization step. </p>
<p><code>events</code> is cleared in the public non-virtual <a class="el" href="classdrake_1_1systems_1_1_system.html#ae6f84e649d76754f38ea7420a21a1a04" title="This method is called by Simulator::Initialize() to gather all update and publish events that need to...">GetInitializationEvents()</a>. You may assume that <code>context</code> has already been validated and that <code>events</code> is not null. <code>events</code> can be changed freely by the overriding implementation.</p>
<p>The default implementation returns without changing <code>events</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#ae6f84e649d76754f38ea7420a21a1a04" title="This method is called by Simulator::Initialize() to gather all update and publish events that need to...">GetInitializationEvents()</a> </dd></dl>

</div>
</div>
<a id="abb36a8c15587e340c460d261f3786a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb36a8c15587e340c460d261f3786a03">&#9670;&nbsp;</a></span>DoGetPeriodicEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::map&lt;<a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a>, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;const <a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt;T&gt;*&gt;, <a class="el" href="structdrake_1_1systems_1_1_periodic_event_data_comparator.html">PeriodicEventDataComparator</a>&gt; DoGetPeriodicEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method to return all periodic triggered events. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#acdd73a23410d860ee73dc021663ec99f" title="Gets all periodic triggered events for a system. ">GetPeriodicEvents()</a> for a detailed <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a> of the returned variable. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The default implementation returns an empty map. </dd></dl>

</div>
</div>
<a id="aaa8100d7c746acc72a3a86fe8cad9d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8100d7c746acc72a3a86fe8cad9d7c">&#9670;&nbsp;</a></span>DoGetPerStepEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoGetPerStepEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method to return any events to be handled before the simulator integrates the system's continuous state at each time step. </p>
<p><code>events</code> is cleared in the public non-virtual <a class="el" href="classdrake_1_1systems_1_1_system.html#ad8a24b8f910f9d990db8e59bf2bae6d0" title="This method is called by Simulator::Initialize() to gather all update and publish events that are to ...">GetPerStepEvents()</a> before that method calls this function. You may assume that <code>context</code> has already been validated and that <code>events</code> is not null. <code>events</code> can be changed freely by the overriding implementation.</p>
<p>The default implementation returns without changing <code>events</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#ad8a24b8f910f9d990db8e59bf2bae6d0" title="This method is called by Simulator::Initialize() to gather all update and publish events that are to ...">GetPerStepEvents()</a> </dd></dl>

</div>
</div>
<a id="aad67111baf766af9690537477790a6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad67111baf766af9690537477790a6c4">&#9670;&nbsp;</a></span>DoGetWitnessFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoGetWitnessFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; *&gt; *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes can override this method to provide witness functions active for the given state. </p>
<p>The default implementation does nothing. On entry to this function, the context will have already been validated and the vector of witness functions will have been validated to be both empty and non-null. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a314a88f9ff6b480ccc6f60ebd7c883f4">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a314a88f9ff6b480ccc6f60ebd7c883f4">Diagram&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1analysis__test_1_1_stateless_system.html#ad7ef727c4b8a2e3b3dc1eac1db927a22">StatelessSystem&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a8545168ea9a0a202bd82b3aeb08f5530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8545168ea9a0a202bd82b3aeb08f5530">&#9670;&nbsp;</a></span>DoMapQDotToVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoMapQDotToVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>generalized_velocity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the substantive implementation of <a class="el" href="classdrake_1_1systems_1_1_system.html#a10eba167739bfe8e7e419b5c8ae41537" title="Transforms the time derivative qdot of the generalized configuration q to generalized velocities v...">MapQDotToVelocity()</a>. </p>
<p>The default implementation uses the identity mapping, and correctly does nothing if the System does not have second-order state variables. It throws std::runtime_error if the <code>generalized_velocity</code> and <code>qdot</code> are not the same size, but that is not enough to guarantee that the default implementation is adequate. Child classes must override this function if qdot != v (even if they are the same size). This occurs, for example, if a joint uses roll-pitch-yaw rotation angles for orientation but angular velocity for rotational rate rather than rotation angle derivatives.</p>
<p>If you implement this method you are required to use no more than <code>O(nq)</code> time where <code>nq</code> is the size of <code>qdot</code>, so that the System can meet the performance guarantee made for the public interface, and you must also implement <a class="el" href="classdrake_1_1systems_1_1_system.html#aa2922fc55384af89c4a3734a476af08f" title="Provides the substantive implementation of MapVelocityToQDot(). ">DoMapVelocityToQDot()</a>. Implementations may assume that <code>qdot</code> has already been validated to be the same size as <code>q</code> in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, and that <code>generalized_velocity</code> is non-null. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ae4b5728e12f4dc6ee7baab4510b044b8">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ae4b5728e12f4dc6ee7baab4510b044b8">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#a2b8e3a497724d104c40c09604e606386">RigidBodyPlant&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#a2b8e3a497724d104c40c09604e606386">RigidBodyPlant&lt; double &gt;</a>.</p>

</div>
</div>
<a id="aa2922fc55384af89c4a3734a476af08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2922fc55384af89c4a3734a476af08f">&#9670;&nbsp;</a></span>DoMapVelocityToQDot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoMapVelocityToQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>generalized_velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the substantive implementation of <a class="el" href="classdrake_1_1systems_1_1_system.html#a05cc5df6d0d0fe4ea54b522ae776ca39" title="Transforms a given generalized velocity v to the time derivative qdot of the generalized configuratio...">MapVelocityToQDot()</a>. </p>
<p>The default implementation uses the identity mapping, and correctly does nothing if the System does not have second-order state variables. It throws std::runtime_error if the <code>generalized_velocity</code> (<code>v</code>) and <code>qdot</code> are not the same size, but that is not enough to guarantee that the default implementation is adequate. Child classes must override this function if <code>qdot != v</code> (even if they are the same size). This occurs, for example, if a joint uses roll-pitch-yaw rotation angles for orientation but angular velocity for rotational rate rather than rotation angle derivatives.</p>
<p>If you implement this method you are required to use no more than <code>O(nq)</code> time where <code>nq</code> is the size of <code>qdot</code>, so that the System can meet the performance guarantee made for the public interface, and you must also implement <a class="el" href="classdrake_1_1systems_1_1_system.html#a8545168ea9a0a202bd82b3aeb08f5530" title="Provides the substantive implementation of MapQDotToVelocity(). ">DoMapQDotToVelocity()</a>. Implementations may assume that <code>generalized_velocity</code> has already been validated to be the same size as <code>v</code> in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, and that <code>qdot</code> is non-null. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a1f2c50542b5dbf9cd42adafb19fbf2e5">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a1f2c50542b5dbf9cd42adafb19fbf2e5">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#adcc244e26729080ff909c3c4a412a089">RigidBodyPlant&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#adcc244e26729080ff909c3c4a412a089">RigidBodyPlant&lt; double &gt;</a>.</p>

</div>
</div>
<a id="aa0d982876c8955c50988ae9f03ce6f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d982876c8955c50988ae9f03ce6f75">&#9670;&nbsp;</a></span>EvalConservativePower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; EvalConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#a5674ae416c2808c939dffc117b209f23" title="Calculates and returns the conservative power represented by the current contents of the given contex...">CalcConservativePower()</a>. </p>
<p>The returned Pc represents the rate at which mechanical energy is being converted <em>from</em> potential energy (PE) <em>to</em> kinetic energy (KE) by this system in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. This quantity will be <em>positive</em> when PE is <em>decreasing</em>. By definition here, conservative power may depend only on quantities that explicitly contribute to PE and KE. See <a class="el" href="classdrake_1_1systems_1_1_system.html#a432bd44170a669c140bc483e18f9e6df" title="Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary u...">EvalPotentialEnergy()</a> and <a class="el" href="classdrake_1_1systems_1_1_system.html#aa60880d6e51fedbf2ad61b6f0cae8f96" title="Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary usi...">EvalKineticEnergy()</a> for details.</p>
<p>Power due to non-conservative forces (e.g. dampers) can contribute to the rate of change of KE. Therefore this method alone cannot be used to determine whether KE is increasing or decreasing, only whether the conservative power is adding or removing kinetic energy. <a class="el" href="classdrake_1_1systems_1_1_system.html#ace530af4be075614218eb4bc725c1aba" title="Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if nece...">EvalNonConservativePower()</a> can be used in conjunction with this method to find the total rate of change of KE.</p>
<p>Non-physical systems where Pc is not meaningful will return Pc = 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose contents may be used to evaluate conservative power. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Pc</td><td>The conservative power in watts (W or J/s) represented by the contents of the given <code>context</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#a5674ae416c2808c939dffc117b209f23" title="Calculates and returns the conservative power represented by the current contents of the given contex...">CalcConservativePower()</a>, <a class="el" href="classdrake_1_1systems_1_1_system.html#ace530af4be075614218eb4bc725c1aba" title="Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if nece...">EvalNonConservativePower()</a>, <a class="el" href="classdrake_1_1systems_1_1_system.html#a432bd44170a669c140bc483e18f9e6df" title="Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary u...">EvalPotentialEnergy()</a>, <a class="el" href="classdrake_1_1systems_1_1_system.html#aa60880d6e51fedbf2ad61b6f0cae8f96" title="Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary usi...">EvalKineticEnergy()</a> </dd></dl>

</div>
</div>
<a id="a0a271e43d57f6eeb3bbdb3bbd1105a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a271e43d57f6eeb3bbdb3bbd1105a8d">&#9670;&nbsp;</a></span>EvalConstraintEquations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd EvalConstraintEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the constraint equations for the system at the generalized coordinates and generalized velocity specified by the context. </p>
<p>The context allows the set of constraints to be dependent upon the current system state (as might be the case with a system modeled using piecewise differential algebraic equations). </p><dl class="section return"><dt>Returns</dt><dd>a vector of dimension <a class="el" href="classdrake_1_1systems_1_1_system.html#aa21289a0f31d15c21a17ae321a75ac47" title="Gets the number of constraint equations for this system using the given context (useful in case the n...">get_num_constraint_equations()</a>; the zero vector indicates that the algebraic constraints are all satisfied. </dd></dl>

</div>
</div>
<a id="a29c0399e6d530a28b40ddde9b2135f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c0399e6d530a28b40ddde9b2135f6e">&#9670;&nbsp;</a></span>EvalConstraintEquationsDot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd EvalConstraintEquationsDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the time derivative of each constraint equation, evaluated at the generalized coordinates and generalized velocity specified by the context. </p>
<p>The context allows the set of constraints to be dependent upon the current system state (as might be the case with a system modeled using piecewise differential algebraic equations). </p><dl class="section return"><dt>Returns</dt><dd>a vector of dimension <a class="el" href="classdrake_1_1systems_1_1_system.html#aa21289a0f31d15c21a17ae321a75ac47" title="Gets the number of constraint equations for this system using the given context (useful in case the n...">get_num_constraint_equations()</a>. </dd></dl>

</div>
</div>
<a id="a02557f96761f5c65d36e55bb2084c8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02557f96761f5c65d36e55bb2084c8c5">&#9670;&nbsp;</a></span>EvalEigenVectorInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; EvalEigenVectorInput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>port_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the vector-valued input port with the given <code>port_index</code> as an Eigen vector. </p>
<p>Causes the value to become up to date first if necessary. See <a class="el" href="classdrake_1_1systems_1_1_system_base.html#a2cb18001bedce2dfaf75b0ae8a14375e" title="Returns the value of the input port with the given port_index as an AbstractValue, which is permitted for ports of any type. ">EvalAbstractInput()</a> for more information.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>port_index</code> selects an existing input port of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>. </dd>
<dd>
the port must have been declared to be vector-valued. </dd>
<dd>
the port must be evaluable (connected or fixed).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#aa184508e6a0494c1b8214dab77e34ce3" title="Returns the value of the vector-valued input port with the given port_index as a BasicVector or a spe...">EvalVectorInput()</a> </dd></dl>

</div>
</div>
<a id="aa60880d6e51fedbf2ad61b6f0cae8f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60880d6e51fedbf2ad61b6f0cae8f96">&#9670;&nbsp;</a></span>EvalKineticEnergy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; EvalKineticEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#aad01402fef0de79310989d7d22dfde92" title="Calculates and returns the kinetic energy represented by the current configuration and velocity provi...">CalcKineticEnergy()</a>. </p>
<p>By definition here, kinetic energy depends only on "configuration" and "velocity" (e.g. angular and translational velocity) of moving masses which includes a subset of the state variables, and parameters that affect configuration, velocities, or mass properties. The calculated value may also be affected by the accuracy value supplied in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. KE cannot depend explicitly on time (∂KE/∂t = 0) or input port values (∂KE/∂u = 0).</p>
<p>Non-physical systems where KE is not meaningful will return KE = 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose configuration and velocity variables may be used to evaluate kinetic energy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">KE</td><td>The kinetic energy in joules (J) represented by the configuration and velocity given in <code>context</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#aad01402fef0de79310989d7d22dfde92" title="Calculates and returns the kinetic energy represented by the current configuration and velocity provi...">CalcKineticEnergy()</a> </dd></dl>

</div>
</div>
<a id="ace530af4be075614218eb4bc725c1aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace530af4be075614218eb4bc725c1aba">&#9670;&nbsp;</a></span>EvalNonConservativePower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; EvalNonConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#a23fe133b70153e382d7f50c38b96bf1f" title="Calculates and returns the non-conservative power represented by the current contents of the given co...">CalcNonConservativePower()</a>. </p>
<p>The returned Pnc represents the rate at which work W is done on the system by non-conservative forces. Pnc is <em>negative</em> if the non-conservative forces are <em>dissipative</em>, positive otherwise. Time integration of Pnc yields work W, and the total mechanical energy <code>E = PE + KE − W</code> should be conserved by any physically-correct model, to within integration accuracy of W. Power is in watts (J/s). (Watts are abbreviated W but not to be confused with work!) Any values in the supplied <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> (including time and input ports) may contribute to the computation of non-conservative power.</p>
<p>Non-physical systems where Pnc is not meaningful will return Pnc = 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose contents may be used to evaluate non-conservative power. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Pnc</td><td>The non-conservative power in watts (W or J/s) represented by the contents of the given <code>context</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#a23fe133b70153e382d7f50c38b96bf1f" title="Calculates and returns the non-conservative power represented by the current contents of the given co...">CalcNonConservativePower()</a>, <a class="el" href="classdrake_1_1systems_1_1_system.html#aa0d982876c8955c50988ae9f03ce6f75" title="Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary...">EvalConservativePower()</a> </dd></dl>

</div>
</div>
<a id="a432bd44170a669c140bc483e18f9e6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432bd44170a669c140bc483e18f9e6df">&#9670;&nbsp;</a></span>EvalPotentialEnergy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; EvalPotentialEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#a3d5eb1d2630aab1938230257554d1f43" title="Calculates and returns the potential energy represented by the current configuration provided in cont...">CalcPotentialEnergy()</a>. </p>
<p>By definition here, potential energy depends only on "configuration" (e.g. orientation and position), which includes a subset of the state variables, and parameters that affect configuration or conservative forces (such as lengths and masses). The calculated value may also be affected by the accuracy value supplied in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. PE cannot depend explicitly on time (∂PE/∂t = 0), velocities (∂PE/∂v = 0), or input port values (∂PE/∂u = 0).</p>
<p>Non-physical systems where PE is not meaningful will return PE = 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose configuration variables may be used to evaluate potential energy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">PE</td><td>The potential energy in joules (J) represented by the configuration given in <code>context</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#a3d5eb1d2630aab1938230257554d1f43" title="Calculates and returns the potential energy represented by the current configuration provided in cont...">CalcPotentialEnergy()</a> </dd></dl>

</div>
</div>
<a id="ae38625e953699a0433249142972eef52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38625e953699a0433249142972eef52">&#9670;&nbsp;</a></span>EvalTimeDerivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt;T&gt;&amp; EvalTimeDerivatives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the cached value of the continuous state variable time derivatives, evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#af2677f8773e90a538483eedd80a81a9f" title="Calculates the time derivatives xcdot of the continuous state xc into a given output argument...">CalcTimeDerivatives()</a>. </p>
<p>This method returns the time derivatives <code>xcdot</code> of the continuous state <code>xc</code>. The referenced return object will correspond elementwise with the continuous state in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. Thus, if the state in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> has second-order structure <code>xc=[q v z]</code>, that same structure applies to the derivatives so we will have <code>xcdot=[qdot vdot zdot]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose time, input port, parameter, state, and accuracy values may be used to evaluate the derivatives.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">xcdot</td><td>The time derivatives of <code>xc</code> returned as a reference to an object of the same type and size as this Context's continuous state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#af2677f8773e90a538483eedd80a81a9f" title="Calculates the time derivatives xcdot of the continuous state xc into a given output argument...">CalcTimeDerivatives()</a> </dd></dl>

</div>
</div>
<a id="aa184508e6a0494c1b8214dab77e34ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa184508e6a0494c1b8214dab77e34ce3">&#9670;&nbsp;</a></span>EvalVectorInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Vec&lt;T&gt;* EvalVectorInput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>port_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the vector-valued input port with the given <code>port_index</code> as a <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase. ">BasicVector</a> or a specific subclass <code>Vec</code> derived from <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase. ">BasicVector</a>. </p>
<p>Causes the value to become up to date first if necessary. See <a class="el" href="classdrake_1_1systems_1_1_system_base.html#a2cb18001bedce2dfaf75b0ae8a14375e" title="Returns the value of the input port with the given port_index as an AbstractValue, which is permitted for ports of any type. ">EvalAbstractInput()</a> for more information.</p>
<p>The result is returned as a pointer to the input port's value of type <code>Vec&lt;T&gt;</code> or nullptr if the port is not connected.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>port_index</code> selects an existing input port of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>. </dd>
<dd>
the port must have been declared to be vector-valued. </dd>
<dd>
the port's value must be of type Vec&lt;T&gt;.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vec</td><td>The template type of the input vector, which must be a subclass of <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase. ">BasicVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a601fb2c6cf565d954253d25725ae9d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601fb2c6cf565d954253d25725ae9d6b">&#9670;&nbsp;</a></span>FixInputPortsFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FixInputPortsFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other_system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>target_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fixes all of the input ports in <code>target_context</code> to their current values in <code>other_context</code>, as evaluated by <code>other_system</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>unless <code>other_context</code> and <code>target_context</code> both have the same shape as this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>, and the <code>other_system</code>. Ignores disconnected inputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af99fae784f8ff0d30444e35d13601177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99fae784f8ff0d30444e35d13601177">&#9670;&nbsp;</a></span>get_constraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt;T&gt;&amp; get_constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td>
          <td class="paramname"><em>constraint_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the constraint at index <code>constraint_index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>for an invalid constraint_index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3137d050d040e4beb9ef60cd004ac112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3137d050d040e4beb9ef60cd004ac112">&#9670;&nbsp;</a></span>get_forced_discrete_update_events()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt;<a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt;T&gt; &gt;&amp; get_forced_discrete_update_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa532bcdc29e8be25c20b40968bb95b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa532bcdc29e8be25c20b40968bb95b66">&#9670;&nbsp;</a></span>get_forced_publish_events()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt;<a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt;T&gt; &gt;&amp; get_forced_publish_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac53f82a39ea0c5e3240a9bab52b1415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac53f82a39ea0c5e3240a9bab52b1415">&#9670;&nbsp;</a></span>get_forced_unrestricted_update_events()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt;<a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt;T&gt; &gt;&amp; get_forced_unrestricted_update_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39b7b9f7723ad69fca8766e6590ef681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b7b9f7723ad69fca8766e6590ef681">&#9670;&nbsp;</a></span>get_input_port()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt;T&gt;&amp; get_input_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>port_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the typed input port at index <code>port_index</code>. </p>

</div>
</div>
<a id="aa21289a0f31d15c21a17ae321a75ac47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21289a0f31d15c21a17ae321a75ac47">&#9670;&nbsp;</a></span>get_num_constraint_equations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> get_num_constraint_equations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of constraint equations for this system using the given context (useful in case the number of constraints is dependent upon the current state (as might be the case with a system modeled using piecewise differential algebraic equations). </p>

</div>
</div>
<a id="a8a6ef02eb739a38c128ac65eff3394f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6ef02eb739a38c128ac65eff3394f2">&#9670;&nbsp;</a></span>get_num_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> get_num_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of constraints specified for the system. </p>

</div>
</div>
<a id="a853c4c7c3ab38e861225aa04f91644e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853c4c7c3ab38e861225aa04f91644e1">&#9670;&nbsp;</a></span>get_num_continuous_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classint.html">int</a> get_num_continuous_states </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the dimension of the continuous state vector that has been declared until now. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a1080d4d1447a12437ab9287351ec2a70">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a1080d4d1447a12437ab9287351ec2a70">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a1080d4d1447a12437ab9287351ec2a70">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a1080d4d1447a12437ab9287351ec2a70">LeafSystem&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a1080d4d1447a12437ab9287351ec2a70">LeafSystem&lt; AutoDiffXd &gt;</a>.</p>

</div>
</div>
<a id="a9d32474ac975155d1289d564016a8a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d32474ac975155d1289d564016a8a13">&#9670;&nbsp;</a></span>get_output_port()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt;T&gt;&amp; get_output_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>port_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the typed output port at index <code>port_index</code>. </p>

</div>
</div>
<a id="a686f497f27885d9f632df0c43d29a0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686f497f27885d9f632df0c43d29a0d6">&#9670;&nbsp;</a></span>get_system_scalar_converter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a>&amp; get_system_scalar_converter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Returns the <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html" title="Helper class to convert a System&lt;U&gt; into a System&lt;T&gt;, intended for internal use by the System framewo...">SystemScalarConverter</a> for this object. </p>
<p>This is an expert-level API intended for framework authors. Most users should prefer the convenience helpers such as <a class="el" href="classdrake_1_1systems_1_1_system.html#aaa81bdf4638506d1ba5ee11e05821651" title="Creates a deep copy of this System, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives. ">System::ToAutoDiffXd</a>. </p>

</div>
</div>
<a id="ab34847cc9c420c8aa3186d8900197e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34847cc9c420c8aa3186d8900197e0f">&#9670;&nbsp;</a></span>GetDirectFeedthroughs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::multimap&lt;<a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>&gt; GetDirectFeedthroughs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports all direct feedthroughs from input ports to output ports. </p>
<p>For a system with m input ports: <code>I = i₀, i₁, ..., iₘ₋₁</code>, and n output ports, <code>O = o₀, o₁, ..., oₙ₋₁</code>, the return map will contain pairs (u, v) such that</p>
<ul>
<li>0 ≤ u &lt; m,</li>
<li>0 ≤ v &lt; n,</li>
<li>and there <em>might</em> be a direct feedthrough from input iᵤ to each output oᵥ. </li>
</ul>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a83479e1867e83638b90266c1aed0b6a3">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a83479e1867e83638b90266c1aed0b6a3">LeafSystem&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a83479e1867e83638b90266c1aed0b6a3">LeafSystem&lt; AutoDiffXd &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a83479e1867e83638b90266c1aed0b6a3">Diagram&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a83479e1867e83638b90266c1aed0b6a3">Diagram&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a8946ae289e8ce80d9d03114e6f60bd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8946ae289e8ce80d9d03114e6f60bd86">&#9670;&nbsp;</a></span>GetGraphvizFragment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetGraphvizFragment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stringstream *&#160;</td>
          <td class="paramname"><em>dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a Graphviz fragment to the <code>dot</code> stream. </p>
<p>The fragment must be valid Graphviz when wrapped in a <code>digraph</code> or <code>subgraph</code> stanza. Does nothing by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_depth</td><td>Sets a limit to the depth of nested diagrams to </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ac370e74eb508e94b3eee667977d7185a">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ac370e74eb508e94b3eee667977d7185a">LeafSystem&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ac370e74eb508e94b3eee667977d7185a">LeafSystem&lt; AutoDiffXd &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ac370e74eb508e94b3eee667977d7185a">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ac370e74eb508e94b3eee667977d7185a">Diagram&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1controllers_1_1_pid_controller.html#ac370e74eb508e94b3eee667977d7185a">PidController&lt; T &gt;</a>.</p>

</div>
</div>
<a id="aa1fac664a1c120c425bc522d7ecb435c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fac664a1c120c425bc522d7ecb435c">&#9670;&nbsp;</a></span>GetGraphvizId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t GetGraphvizId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an opaque integer that uniquely identifies this system in the Graphviz output. </p>

</div>
</div>
<a id="ab8056b92562217c25ff76fac7ad67961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8056b92562217c25ff76fac7ad67961">&#9670;&nbsp;</a></span>GetGraphvizInputPortToken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetGraphvizInputPortToken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stringstream *&#160;</td>
          <td class="paramname"><em>dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a fragment to the <code>dot</code> stream identifying the graphviz node representing <code>port</code>. </p>
<p>Does nothing by default. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#acfd6d412aafdf2814ced8e8fe460fc23">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#acfd6d412aafdf2814ced8e8fe460fc23">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#acfd6d412aafdf2814ced8e8fe460fc23">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#acfd6d412aafdf2814ced8e8fe460fc23">LeafSystem&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#acfd6d412aafdf2814ced8e8fe460fc23">LeafSystem&lt; AutoDiffXd &gt;</a>.</p>

</div>
</div>
<a id="aa75de0b661eaa9b9a45959a9de4eaae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75de0b661eaa9b9a45959a9de4eaae0">&#9670;&nbsp;</a></span>GetGraphvizOutputPortToken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetGraphvizOutputPortToken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stringstream *&#160;</td>
          <td class="paramname"><em>dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a fragment to the <code>dot</code> stream identifying the graphviz node representing <code>port</code>. </p>
<p>Does nothing by default. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a37060c889e34319f11652b5ad21cfbb9">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a37060c889e34319f11652b5ad21cfbb9">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a37060c889e34319f11652b5ad21cfbb9">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a37060c889e34319f11652b5ad21cfbb9">LeafSystem&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a37060c889e34319f11652b5ad21cfbb9">LeafSystem&lt; AutoDiffXd &gt;</a>.</p>

</div>
</div>
<a id="a588e4f7454694f04b4b654d154f170f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588e4f7454694f04b4b654d154f170f3">&#9670;&nbsp;</a></span>GetGraphvizString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetGraphvizString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_depth</em> = <code>std::numeric_limits&lt;<a class="el" href="classint.html">int</a>&gt;::max()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a Graphviz string describing this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>. </p>
<p>To render the string, use the Graphviz tool, <code>dot</code>. <a href="http://www.graphviz.org/Documentation/dotguide.pdf">http://www.graphviz.org/Documentation/dotguide.pdf</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_depth</td><td>Sets a limit to the depth of nested diagrams to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6f84e649d76754f38ea7420a21a1a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f84e649d76754f38ea7420a21a1a04">&#9670;&nbsp;</a></span>GetInitializationEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetInitializationEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called by <a class="el" href="classdrake_1_1systems_1_1_simulator.html#a98b1050f09da390896f964fb7a892391" title="Prepares the Simulator for a simulation. ">Simulator::Initialize()</a> to gather all update and publish events that need to be handled at initialization before the simulator starts integration. </p>
<p><code>events</code> cannot be null. <code>events</code> will be cleared on entry. </p>

</div>
</div>
<a id="a4bd5af969c0fcb5fe0923aeac56c6124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd5af969c0fcb5fe0923aeac56c6124">&#9670;&nbsp;</a></span>GetInputPort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt;T&gt;&amp; GetInputPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>port_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the typed input port with the unique name <code>port_name</code>. </p>
<p>The current implementation performs a linear search over strings; prefer <a class="el" href="classdrake_1_1systems_1_1_system.html#a39b7b9f7723ad69fca8766e6590ef681" title="Returns the typed input port at index port_index. ">get_input_port()</a> when performance is a concern. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if port_name is not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9714aaf76aca9169da6de7fbcb8339fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9714aaf76aca9169da6de7fbcb8339fb">&#9670;&nbsp;</a></span>GetMemoryObjectName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetMemoryObjectName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a name for this System based on a stringification of its type name and memory address. </p>
<p>This is intended for use in diagnostic output and should not be used for behavioral logic, because the stringification of the type name may produce differing results across platforms and because the address can vary from run to run. </p>

</div>
</div>
<a id="a224803a17e7cb76634565ce6def996d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224803a17e7cb76634565ce6def996d8">&#9670;&nbsp;</a></span>GetMutableOutputVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetMutableOutputVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>port_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable <a class="el" href="namespace_eigen.html">Eigen</a> expression for a vector valued output port with index <code>port_index</code> in this system. </p>
<p>All input ports that directly depend on this output port will be notified that upstream data has changed, and may invalidate cache entries as a result. </p>

</div>
</div>
<a id="a6d8d63cb84ca11a136b9034d7e06a0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8d63cb84ca11a136b9034d7e06a0bf">&#9670;&nbsp;</a></span>GetOutputPort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt;T&gt;&amp; GetOutputPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>port_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the typed output port with the unique name <code>port_name</code>. </p>
<p>The current implementation performs a linear search over strings; prefer <a class="el" href="classdrake_1_1systems_1_1_system.html#a9d32474ac975155d1289d564016a8a13" title="Returns the typed output port at index port_index. ">get_output_port()</a> when performance is a concern. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if port_name is not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdd73a23410d860ee73dc021663ec99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd73a23410d860ee73dc021663ec99f">&#9670;&nbsp;</a></span>GetPeriodicEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a>, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;const <a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt;T&gt;*&gt;, <a class="el" href="structdrake_1_1systems_1_1_periodic_event_data_comparator.html">PeriodicEventDataComparator</a>&gt; GetPeriodicEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all periodic triggered events for a system. </p>
<p>Each periodic attribute (offset and period, in seconds) is mapped to one or more update events that are to be triggered at the proper times. </p>

</div>
</div>
<a id="ad8a24b8f910f9d990db8e59bf2bae6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a24b8f910f9d990db8e59bf2bae6d0">&#9670;&nbsp;</a></span>GetPerStepEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetPerStepEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called by <a class="el" href="classdrake_1_1systems_1_1_simulator.html#a98b1050f09da390896f964fb7a892391" title="Prepares the Simulator for a simulation. ">Simulator::Initialize()</a> to gather all update and publish events that are to be handled in StepTo() at the point before <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> integrates continuous state. </p>
<p>It is assumed that these events remain constant throughout the simulation. The "step" here refers to the major time step taken by the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a>. During every simulation step, the simulator will merge <code>events</code> with the other <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html" title="This class bundles an instance of each EventCollection&lt;EventType&gt; into one object that stores the het...">CompositeEventCollection</a> instances generated by other types of event triggering mechanism (e.g., <a class="el" href="classdrake_1_1systems_1_1_system.html#a164afe3c1db737b93696b8808bb2c942" title="This method is called by a Simulator during its calculation of the size of the next continuous step t...">CalcNextUpdateTime()</a>), and the merged <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html" title="This class bundles an instance of each EventCollection&lt;EventType&gt; into one object that stores the het...">CompositeEventCollection</a> objects will be passed to the appropriate handlers before <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> integrates the continuous state.</p>
<p><code>events</code> cannot be null. <code>events</code> will be cleared on entry. </p>

</div>
</div>
<a id="ae0f7d226abe6847e09248db0def0c746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f7d226abe6847e09248db0def0c746">&#9670;&nbsp;</a></span>GetUniquePeriodicDiscreteUpdateAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt;<a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a>&gt; GetUniquePeriodicDiscreteUpdateAttribute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether there exists a unique periodic attribute that triggers one or more discrete update events (and, if so, returns that unique periodic attribute). </p>
<p>Thus, this method can be used (1) as a test to determine whether a system's dynamics are at least partially governed by difference equations and (2) to obtain the difference equation update times. </p><dl class="section return"><dt>Returns</dt><dd>optional&lt;PeriodicEventData&gt; Contains the periodic trigger attributes if the unique periodic attribute exists, otherwise <code>nullopt</code>. </dd></dl>

</div>
</div>
<a id="a5c9811579b88aa9f5e5524c980f354fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9811579b88aa9f5e5524c980f354fe">&#9670;&nbsp;</a></span>GetWitnessFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GetWitnessFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; *&gt; *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the witness functions active for the given state. </p>
<p><a class="el" href="classdrake_1_1systems_1_1_system.html#aad67111baf766af9690537477790a6c4" title="Derived classes can override this method to provide witness functions active for the given state...">DoGetWitnessFunctions()</a> does the actual work. The vector of active witness functions are expected to change only upon an unrestricted update. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>a valid context for the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> (aborts if not true). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>a valid pointer to an empty vector that will store pointers to the witness functions active for the current state. The method aborts if witnesses is null or non-empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a037dd9c0afe6e059e67edb4c9c01eeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037dd9c0afe6e059e67edb4c9c01eeb3">&#9670;&nbsp;</a></span>HasAnyDirectFeedthrough()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasAnyDirectFeedthrough </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if any of the inputs to the system might be directly fed through to any of its outputs and <code>false</code> otherwise. </p>

</div>
</div>
<a id="a51acfa17df1bc87ce8eaa0e1556f6d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51acfa17df1bc87ce8eaa0e1556f6d46">&#9670;&nbsp;</a></span>HasDirectFeedthrough() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasDirectFeedthrough </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>output_port</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there might be direct-feedthrough from any input port to the given <code>output_port</code>, and false otherwise. </p>

</div>
</div>
<a id="a8dd5092dc2aa2c8f38e0d6336437012d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd5092dc2aa2c8f38e0d6336437012d">&#9670;&nbsp;</a></span>HasDirectFeedthrough() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasDirectFeedthrough </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>input_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>output_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there might be direct-feedthrough from the given <code>input_port</code> to the given <code>output_port</code>, and false otherwise. </p>

</div>
</div>
<a id="a10eba167739bfe8e7e419b5c8ae41537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10eba167739bfe8e7e419b5c8ae41537">&#9670;&nbsp;</a></span>MapQDotToVelocity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MapQDotToVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>generalized_velocity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the time derivative <code>qdot</code> of the generalized configuration <code>q</code> to generalized velocities <code>v</code>. </p>
<p><code>v</code> and <code>qdot</code> are related linearly by <code>qdot = N(q) * v</code>, where <code>N</code> is a block diagonal matrix. For example, in a multibody system there will be one block of <code>N</code> per tree joint. Although <code>N</code> is not necessarily square, its left pseudo-inverse <code>N+</code> can be used to invert that relationship without residual error, provided that <code>qdot</code> is in the range space of <code>N</code> (that is, if it <em>could</em> have been produced as <code>qdot=N*v</code> for some <code>v</code>). Using the configuration <code>q</code> from the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> this method calculates <code>v = N+ * qdot</code> (where <code>N+=N+(q)</code>) for a given <code>qdot</code>. This computation requires only <code>O(nq)</code> time where <code>nq</code> is the size of <code>qdot</code>. Note that this method does not take <code>qdot</code> from the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.</p>
<p>See the alternate signature if you already have <code>qdot</code> in an Eigen VectorX object; this signature will copy the <a class="el" href="classdrake_1_1systems_1_1_vector_base.html" title="VectorBase is an abstract base class that real-valued signals between Systems and real-valued System ...">VectorBase</a> into an Eigen object before performing the computation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#a05cc5df6d0d0fe4ea54b522ae776ca39" title="Transforms a given generalized velocity v to the time derivative qdot of the generalized configuratio...">MapVelocityToQDot()</a> </dd></dl>

</div>
</div>
<a id="a9914457357091af1a9932863f2b396a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9914457357091af1a9932863f2b396a4">&#9670;&nbsp;</a></span>MapQDotToVelocity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MapQDotToVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>generalized_velocity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the given time derivative <code>qdot</code> of generalized configuration <code>q</code> to generalized velocity <code>v</code>. </p>
<p>This signature takes <code>qdot</code> as an Eigen VectorX object for faster speed. See the other signature of <a class="el" href="classdrake_1_1systems_1_1_system.html#a10eba167739bfe8e7e419b5c8ae41537" title="Transforms the time derivative qdot of the generalized configuration q to generalized velocities v...">MapQDotToVelocity()</a> for additional information. </p>

</div>
</div>
<a id="a05cc5df6d0d0fe4ea54b522ae776ca39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cc5df6d0d0fe4ea54b522ae776ca39">&#9670;&nbsp;</a></span>MapVelocityToQDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MapVelocityToQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>generalized_velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a given generalized velocity <code>v</code> to the time derivative <code>qdot</code> of the generalized configuration <code>q</code> taken from the supplied <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<p><code>v</code> and <code>qdot</code> are related linearly by <code>qdot = N(q) * v</code>, where <code>N</code> is a block diagonal matrix. For example, in a multibody system there will be one block of <code>N</code> per tree joint. This computation requires only <code>O(nq)</code> time where <code>nq</code> is the size of <code>qdot</code>. Note that <code>v</code> is <em>not</em> taken from the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>; it is given as an argument here.</p>
<p>See the alternate signature if you already have the generalized velocity in an <a class="el" href="namespace_eigen.html">Eigen</a> VectorX object; this signature will copy the <a class="el" href="classdrake_1_1systems_1_1_vector_base.html" title="VectorBase is an abstract base class that real-valued signals between Systems and real-valued System ...">VectorBase</a> into an <a class="el" href="namespace_eigen.html">Eigen</a> object before performing the computation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#a10eba167739bfe8e7e419b5c8ae41537" title="Transforms the time derivative qdot of the generalized configuration q to generalized velocities v...">MapQDotToVelocity()</a> </dd></dl>

</div>
</div>
<a id="a3d05cfdce7f2dbae7c9f18babfc827e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d05cfdce7f2dbae7c9f18babfc827e8">&#9670;&nbsp;</a></span>MapVelocityToQDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MapVelocityToQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>generalized_velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the given generalized velocity to the time derivative of generalized configuration. </p>
<p>See the other signature of <a class="el" href="classdrake_1_1systems_1_1_system.html#a05cc5df6d0d0fe4ea54b522ae776ca39" title="Transforms a given generalized velocity v to the time derivative qdot of the generalized configuratio...">MapVelocityToQDot()</a> for more information. </p>

</div>
</div>
<a id="a0a193dfa5e776f4c271dbb37a6bd03f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a193dfa5e776f4c271dbb37a6bd03f5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac64a17bc4243a6ba605108281c6519de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64a17bc4243a6ba605108281c6519de">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31898e0276f6bbc4edf7111f809afb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31898e0276f6bbc4edf7111f809afb01">&#9670;&nbsp;</a></span>Publish() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Publish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is the public entry point for dispatching all publish event handlers. </p>
<p>It checks the validity of <code>context</code>, and directly calls DispatchPublishHandler. <code>events</code> is a homogeneous collection of publish events, which is typically the publish portion of the heterogeneous event collection generated by CalcNextUpdateTime or GetPerStepEvents.</p>
<dl class="section note"><dt>Note</dt><dd>When publishing is scheduled at particular times, those times likely will not coincide with integrator step times. A <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> may interpolate to generate a suitable <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, or it may adjust the integrator step size so that a step begins exactly at the next publication time. In the latter case the change in step size may affect the numerical result somewhat since a smaller integrator step produces a more accurate solution. </dd></dl>

</div>
</div>
<a id="aafa5fa6fa51aaa8f987abb101e341739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa5fa6fa51aaa8f987abb101e341739">&#9670;&nbsp;</a></span>Publish() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Publish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces a publish on the system, given a <code>context</code>. </p>
<p>The publish event will have a trigger type of kForced, with no additional data, attribute or custom callback. The <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> can be configured to call this in <a class="el" href="classdrake_1_1systems_1_1_simulator.html#a98b1050f09da390896f964fb7a892391" title="Prepares the Simulator for a simulation. ">Simulator::Initialize()</a> and at the start of each continuous integration step. See the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> API for more details. </p>

</div>
</div>
<a id="afd0aacb96a01eb38099ac6cd4d12037b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0aacb96a01eb38099ac6cd4d12037b">&#9670;&nbsp;</a></span>set_forced_discrete_update_events()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_forced_discrete_update_events </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>forced</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7240490688324a9f15132fee98e52ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7240490688324a9f15132fee98e52ce">&#9670;&nbsp;</a></span>set_forced_publish_events()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_forced_publish_events </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>forced</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75c5ab861b2f08ff5a29066458747b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c5ab861b2f08ff5a29066458747b9a">&#9670;&nbsp;</a></span>set_forced_unrestricted_update_events()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_forced_unrestricted_update_events </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>forced</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4e6ee413f4f47a20f6dcc2cbd831b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e6ee413f4f47a20f6dcc2cbd831b88">&#9670;&nbsp;</a></span>SetDefaultContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb9c4edaf95ef26f1ec419f32446e042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9c4edaf95ef26f1ec419f32446e042">&#9670;&nbsp;</a></span>SetDefaultParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetDefaultParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns default values to all parameters. </p>
<p>Overrides must not change the number of parameters. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a48a5a76172d2c18e3ac495b44c866c1b">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a48a5a76172d2c18e3ac495b44c866c1b">LeafSystem&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a48a5a76172d2c18e3ac495b44c866c1b">LeafSystem&lt; AutoDiffXd &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a032a4baedb53bf9cf8579913217fe335">Diagram&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a032a4baedb53bf9cf8579913217fe335">Diagram&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a909935648b14e55b07263264616ace3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909935648b14e55b07263264616ace3c">&#9670;&nbsp;</a></span>SetDefaultState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetDefaultState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns default values to all elements of the state. </p>
<p>Overrides must not change the number of state variables. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1multibody__plant_1_1_multibody_plant.html#ae73edc00d493b3f15ba7679cc14830a0">MultibodyPlant&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#adf649a06493386bc4cad194332aec62f">RigidBodyPlant&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_rigid_body_plant.html#adf649a06493386bc4cad194332aec62f">RigidBodyPlant&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1lcm_1_1_lcm_subscriber_system.html#ae89331a37e538b4513a857ac02b64366">LcmSubscriberSystem</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ac920e22e905b83dbc0abaaa57d2c0251">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ac920e22e905b83dbc0abaaa57d2c0251">LeafSystem&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ac920e22e905b83dbc0abaaa57d2c0251">LeafSystem&lt; AutoDiffXd &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#ae73edc00d493b3f15ba7679cc14830a0">MultibodyTreeSystem&lt; double &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#ae73edc00d493b3f15ba7679cc14830a0">MultibodyTreeSystem&lt; AutoDiffXd &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1analysis_1_1test_1_1_stiff_double_mass_spring_system.html#adf649a06493386bc4cad194332aec62f">StiffDoubleMassSpringSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ac920e22e905b83dbc0abaaa57d2c0251">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ac920e22e905b83dbc0abaaa57d2c0251">Diagram&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1manipulation_1_1planner_1_1_robot_plan_interpolator.html#a7789ceec4890d514053228892f2048d3">RobotPlanInterpolator</a>.</p>

</div>
</div>
<a id="a6a5a403983483dda39f8196a241225f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5a403983483dda39f8196a241225f2">&#9670;&nbsp;</a></span>SetRandomContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetRandomContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#ad96f28f81be35c3eb7fa5e19b48db26e">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7a8969fd7784256a68402b391f8902b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a8969fd7784256a68402b391f8902b">&#9670;&nbsp;</a></span>SetRandomParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetRandomParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#ad96f28f81be35c3eb7fa5e19b48db26e">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns random values to all parameters. </p>
<p>This default implementation calls SetDefaultParameters; override this method to provide random parameters using the stdc++ random library, e.g.: </p><div class="fragment"><div class="line">std::uniform_real_distribution&lt;T&gt; uniform();</div><div class="line">parameters-&gt;get_mutable_numeric_parameter(0)</div><div class="line">          -&gt;SetAtIndex(0, uniform(*generator));</div></div><!-- fragment --><p> Overrides must not change the number of state variables.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__stochastic__systems.html">Stochastic Systems</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a90905f3227a56e00876f9954f0f044f5">Diagram&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a90905f3227a56e00876f9954f0f044f5">Diagram&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a47a8dc372e0063851c9851ee15da74e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a8dc372e0063851c9851ee15da74e9">&#9670;&nbsp;</a></span>SetRandomState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetRandomState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#ad96f28f81be35c3eb7fa5e19b48db26e">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns random values to all elements of the state. </p>
<p>This default implementation calls SetDefaultState; override this method to provide random initial conditions using the stdc++ random library, e.g.: </p><div class="fragment"><div class="line">std::normal_distribution&lt;T&gt; gaussian();</div><div class="line">state-&gt;get_mutable_continuous_state()-&gt;get_mutable_vector()</div><div class="line">     -&gt;SetAtIndex(0, gaussian(*generator));</div></div><!-- fragment --><p> Overrides must not change the number of state variables.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__stochastic__systems.html">Stochastic Systems</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#aa6c1de9b14d8feed0e50ac1e49c9a661">Diagram&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_diagram.html#aa6c1de9b14d8feed0e50ac1e49c9a661">Diagram&lt; double &gt;</a>.</p>

</div>
</div>
<a id="aaa81bdf4638506d1ba5ee11e05821651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa81bdf4638506d1ba5ee11e05821651">&#9670;&nbsp;</a></span>ToAutoDiffXd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt;<a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>&gt; &gt; ToAutoDiffXd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives. </p>
<p>The result is never nullptr. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> does not support autodiff</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a> for detailed background and examples related to scalar-type conversion support. </p>

</div>
</div>
<a id="a12dccd7061415e910fff3a252ece2a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12dccd7061415e910fff3a252ece2a88">&#9670;&nbsp;</a></span>ToAutoDiffXd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;S&lt;<a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>&gt; &gt; ToAutoDiffXd </td>
          <td>(</td>
          <td class="paramtype">const S&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of <code>from</code>, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives. </p>
<p>The result is never nullptr. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>from</code> does not support autodiff</td></tr>
  </table>
  </dd>
</dl>
<p>Usage:</p><div class="fragment"><div class="line">MySystem&lt;double&gt; plant;</div><div class="line">std::unique_ptr&lt;MySystem&lt;AutoDiffXd&gt;&gt; ad_plant =</div><div class="line">    <a class="code" href="classdrake_1_1systems_1_1_system.html#aaa81bdf4638506d1ba5ee11e05821651">systems::System&lt;double&gt;::ToAutoDiffXd</a>(plant);</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The specific <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> type to accept and return.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a> for detailed background and examples related to scalar-type conversion support. </p>

</div>
</div>
<a id="a8661a664b857b7bec879b6f84ca763c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8661a664b857b7bec879b6f84ca763c7">&#9670;&nbsp;</a></span>ToAutoDiffXdMaybe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt;<a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>&gt; &gt; ToAutoDiffXdMaybe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of this system exactly like <a class="el" href="classdrake_1_1systems_1_1_system.html#aaa81bdf4638506d1ba5ee11e05821651" title="Creates a deep copy of this System, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives. ">ToAutoDiffXd()</a>, but returns nullptr if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> does not support autodiff, instead of throwing an exception. </p>

</div>
</div>
<a id="a1c259e82a4e51da3c7ace27af64e0d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c259e82a4e51da3c7ace27af64e0d3a">&#9670;&nbsp;</a></span>ToSymbolic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt; &gt; ToSymbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>, transmogrified to use the symbolic scalar type. </p>
<p>The result is never nullptr. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> does not support symbolic</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a> for detailed background and examples related to scalar-type conversion support. </p>

</div>
</div>
<a id="a7eddb9f14f9b26636316c045a2f5ea58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eddb9f14f9b26636316c045a2f5ea58">&#9670;&nbsp;</a></span>ToSymbolic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;S&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt; &gt; ToSymbolic </td>
          <td>(</td>
          <td class="paramtype">const S&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of <code>from</code>, transmogrified to use the symbolic scalar type. </p>
<p>The result is never nullptr. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> does not support symbolic</td></tr>
  </table>
  </dd>
</dl>
<p>Usage:</p><div class="fragment"><div class="line">MySystem&lt;double&gt; plant;</div><div class="line">std::unique_ptr&lt;MySystem&lt;symbolic::Expression&gt;&gt; sym_plant =</div><div class="line">    <a class="code" href="classdrake_1_1systems_1_1_system.html#a1c259e82a4e51da3c7ace27af64e0d3a">systems::System&lt;double&gt;::ToSymbolic</a>(plant);</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The specific <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> pointer type to return.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a> for detailed background and examples related to scalar-type conversion support. </p>

</div>
</div>
<a id="ae49431db031c1d14de328a7231290e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49431db031c1d14de328a7231290e95">&#9670;&nbsp;</a></span>ToSymbolicMaybe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt; &gt; ToSymbolicMaybe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of this system exactly like <a class="el" href="classdrake_1_1systems_1_1_system.html#a1c259e82a4e51da3c7ace27af64e0d3a" title="Creates a deep copy of this System, transmogrified to use the symbolic scalar type. ">ToSymbolic()</a>, but returns nullptr if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> does not support symbolic, instead of throwing an exception. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a711f9256206b0eb48db02088a645e6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711f9256206b0eb48db02088a645e6a9">&#9670;&nbsp;</a></span>SystemImpl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class SystemImpl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/systems/framework/<a class="el" href="input__port_8h.html">input_port.h</a></li>
<li>drake/systems/framework/<a class="el" href="system_8h.html">system.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1systems.html">systems</a></li><li class="navelem"><a class="el" href="classdrake_1_1systems_1_1_system.html">System</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
