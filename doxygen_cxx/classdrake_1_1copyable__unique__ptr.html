<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: copyable_unique_ptr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1copyable__unique__ptr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a> &#124;
<a href="classdrake_1_1copyable__unique__ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">copyable_unique_ptr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A smart pointer with deep copy semantics.  
 <a href="classdrake_1_1copyable__unique__ptr.html#details">More...</a></p>

<p><code>#include &lt;drake/common/copyable_unique_ptr.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a38cdcb23181ad1c554ef0209a29cd768"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a38cdcb23181ad1c554ef0209a29cd768">copyable_unique_ptr</a> () noexcept</td></tr>
<tr class="memdesc:a38cdcb23181ad1c554ef0209a29cd768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor stores a <code>nullptr</code>.  <a href="#a38cdcb23181ad1c554ef0209a29cd768">More...</a><br /></td></tr>
<tr class="separator:a38cdcb23181ad1c554ef0209a29cd768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67cae08914b16290d64a748fb64d6dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#ac67cae08914b16290d64a748fb64d6dc">copyable_unique_ptr</a> (T *ptr) noexcept</td></tr>
<tr class="memdesc:ac67cae08914b16290d64a748fb64d6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer to a writable heap-allocated object, take over ownership of that object.  <a href="#ac67cae08914b16290d64a748fb64d6dc">More...</a><br /></td></tr>
<tr class="separator:ac67cae08914b16290d64a748fb64d6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efa09fdc8aad69db06b649c447d9806"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a9efa09fdc8aad69db06b649c447d9806">copyable_unique_ptr</a> (const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;cu_ptr)</td></tr>
<tr class="memdesc:a9efa09fdc8aad69db06b649c447d9806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is deep; the new copyable_unique_ptr object contains a new copy of the object in the source, created via the source object's copy constructor or <code>Clone()</code> method.  <a href="#a9efa09fdc8aad69db06b649c447d9806">More...</a><br /></td></tr>
<tr class="separator:a9efa09fdc8aad69db06b649c447d9806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1774b97188ce9c5a5cd47c5c4ff63fc0"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a1774b97188ce9c5a5cd47c5c4ff63fc0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a1774b97188ce9c5a5cd47c5c4ff63fc0">copyable_unique_ptr</a> (const std::unique_ptr&lt; U &gt; &amp;u_ptr)</td></tr>
<tr class="memdesc:a1774b97188ce9c5a5cd47c5c4ff63fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from a standard <code>unique_ptr</code> of <em>compatible</em> type.  <a href="#a1774b97188ce9c5a5cd47c5c4ff63fc0">More...</a><br /></td></tr>
<tr class="separator:a1774b97188ce9c5a5cd47c5c4ff63fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60d2d174b5ce39e94bf59719c997250"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#ac60d2d174b5ce39e94bf59719c997250">copyable_unique_ptr</a> (<a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&amp;cu_ptr) noexcept</td></tr>
<tr class="memdesc:ac60d2d174b5ce39e94bf59719c997250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor is very fast and leaves the source empty.  <a href="#ac60d2d174b5ce39e94bf59719c997250">More...</a><br /></td></tr>
<tr class="separator:ac60d2d174b5ce39e94bf59719c997250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a34341a71b340b3af3ee3d18e9d09bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a5a34341a71b340b3af3ee3d18e9d09bc">copyable_unique_ptr</a> (std::unique_ptr&lt; T &gt; &amp;&amp;u_ptr) noexcept</td></tr>
<tr class="memdesc:a5a34341a71b340b3af3ee3d18e9d09bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor from a standard <code>unique_ptr</code>.  <a href="#a5a34341a71b340b3af3ee3d18e9d09bc">More...</a><br /></td></tr>
<tr class="separator:a5a34341a71b340b3af3ee3d18e9d09bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b538a9c4ca822d4212226ba51dc0aa"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ad0b538a9c4ca822d4212226ba51dc0aa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#ad0b538a9c4ca822d4212226ba51dc0aa">copyable_unique_ptr</a> (std::unique_ptr&lt; U &gt; &amp;&amp;u_ptr) noexcept</td></tr>
<tr class="memdesc:ad0b538a9c4ca822d4212226ba51dc0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construction from a compatible standard <code>unique_ptr</code>.  <a href="#ad0b538a9c4ca822d4212226ba51dc0aa">More...</a><br /></td></tr>
<tr class="separator:ad0b538a9c4ca822d4212226ba51dc0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment</div></td></tr>
<tr class="memitem:aabb236eef6e850a09b441591f0812747"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#aabb236eef6e850a09b441591f0812747">operator=</a> (T *ptr) noexcept</td></tr>
<tr class="memdesc:aabb236eef6e850a09b441591f0812747"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the currently-held object by the given source object and takes over ownership of the source object.  <a href="#aabb236eef6e850a09b441591f0812747">More...</a><br /></td></tr>
<tr class="separator:aabb236eef6e850a09b441591f0812747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4078720893b915d022bd734f6eb5e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a4d4078720893b915d022bd734f6eb5e9">operator=</a> (const T &amp;ref)</td></tr>
<tr class="memdesc:a4d4078720893b915d022bd734f6eb5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the currently-held object by a heap-allocated copy of the source object, created using its copy constructor or <code>Clone()</code> method.  <a href="#a4d4078720893b915d022bd734f6eb5e9">More...</a><br /></td></tr>
<tr class="separator:a4d4078720893b915d022bd734f6eb5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35881f6551d81d4ba11f23bdc695dbf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a35881f6551d81d4ba11f23bdc695dbf5">operator=</a> (const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;cu_ptr)</td></tr>
<tr class="memdesc:a35881f6551d81d4ba11f23bdc695dbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from copyable_unique_ptr replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method.  <a href="#a35881f6551d81d4ba11f23bdc695dbf5">More...</a><br /></td></tr>
<tr class="separator:a35881f6551d81d4ba11f23bdc695dbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d014005bde7838a248d7129023b999c"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a5d014005bde7838a248d7129023b999c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a5d014005bde7838a248d7129023b999c">operator=</a> (const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; U &gt; &amp;cu_ptr)</td></tr>
<tr class="memdesc:a5d014005bde7838a248d7129023b999c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from a compatible copyable_unique_ptr replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method.  <a href="#a5d014005bde7838a248d7129023b999c">More...</a><br /></td></tr>
<tr class="separator:a5d014005bde7838a248d7129023b999c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241aa7fdb2e242c6965006831d9e62dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a241aa7fdb2e242c6965006831d9e62dd">operator=</a> (const std::unique_ptr&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:a241aa7fdb2e242c6965006831d9e62dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from a standard <code>unique_ptr</code> replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method.  <a href="#a241aa7fdb2e242c6965006831d9e62dd">More...</a><br /></td></tr>
<tr class="separator:a241aa7fdb2e242c6965006831d9e62dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bca368e89b4408972a3f54c09eaab3"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a67bca368e89b4408972a3f54c09eaab3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a67bca368e89b4408972a3f54c09eaab3">operator=</a> (const std::unique_ptr&lt; U &gt; &amp;u_ptr)</td></tr>
<tr class="memdesc:a67bca368e89b4408972a3f54c09eaab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from a compatible standard <code>unique_ptr</code> replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method.  <a href="#a67bca368e89b4408972a3f54c09eaab3">More...</a><br /></td></tr>
<tr class="separator:a67bca368e89b4408972a3f54c09eaab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2693139bff4ad445212aa4bb73284ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#af2693139bff4ad445212aa4bb73284ad">operator=</a> (<a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&amp;cu_ptr) noexcept</td></tr>
<tr class="memdesc:af2693139bff4ad445212aa4bb73284ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the source object, leaving the source empty.  <a href="#af2693139bff4ad445212aa4bb73284ad">More...</a><br /></td></tr>
<tr class="separator:af2693139bff4ad445212aa4bb73284ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fa4971dcefe82f931084653b196a55"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a60fa4971dcefe82f931084653b196a55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a60fa4971dcefe82f931084653b196a55">operator=</a> (<a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; U &gt; &amp;&amp;cu_ptr) noexcept</td></tr>
<tr class="memdesc:a60fa4971dcefe82f931084653b196a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the compatible source object, leaving the source empty.  <a href="#a60fa4971dcefe82f931084653b196a55">More...</a><br /></td></tr>
<tr class="separator:a60fa4971dcefe82f931084653b196a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f1739bcedb13183285a9995d3b9daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a53f1739bcedb13183285a9995d3b9daf">operator=</a> (std::unique_ptr&lt; T &gt; &amp;&amp;u_ptr) noexcept</td></tr>
<tr class="memdesc:a53f1739bcedb13183285a9995d3b9daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the source object, leaving the source empty.  <a href="#a53f1739bcedb13183285a9995d3b9daf">More...</a><br /></td></tr>
<tr class="separator:a53f1739bcedb13183285a9995d3b9daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf98f86aa60c05f0a546ca78c2a2e857"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:abf98f86aa60c05f0a546ca78c2a2e857"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#abf98f86aa60c05f0a546ca78c2a2e857">operator=</a> (std::unique_ptr&lt; U &gt; &amp;&amp;u_ptr) noexcept</td></tr>
<tr class="memdesc:abf98f86aa60c05f0a546ca78c2a2e857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the compatible source object, leaving the source empty.  <a href="#abf98f86aa60c05f0a546ca78c2a2e857">More...</a><br /></td></tr>
<tr class="separator:abf98f86aa60c05f0a546ca78c2a2e857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Observers</div></td></tr>
<tr class="memitem:a3f6fc5de06a318920d84f3c3742db07f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a3f6fc5de06a318920d84f3c3742db07f">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a3f6fc5de06a318920d84f3c3742db07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this container is empty, which is the state the container is in immediately after default construction and various other operations.  <a href="#a3f6fc5de06a318920d84f3c3742db07f">More...</a><br /></td></tr>
<tr class="separator:a3f6fc5de06a318920d84f3c3742db07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c791981969a90b67778f87036b032e"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#a76c791981969a90b67778f87036b032e">get</a> () const noexcept</td></tr>
<tr class="memdesc:a76c791981969a90b67778f87036b032e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the contained object if any, or <code>nullptr</code>.  <a href="#a76c791981969a90b67778f87036b032e">More...</a><br /></td></tr>
<tr class="separator:a76c791981969a90b67778f87036b032e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac684d04fadf2a6b636c98e38aabf7ccb"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#ac684d04fadf2a6b636c98e38aabf7ccb">get_mutable</a> () noexcept</td></tr>
<tr class="memdesc:ac684d04fadf2a6b636c98e38aabf7ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the contained object if any, or <code>nullptr</code>.  <a href="#ac684d04fadf2a6b636c98e38aabf7ccb">More...</a><br /></td></tr>
<tr class="separator:ac684d04fadf2a6b636c98e38aabf7ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ab5373c9f8caa95d0cdf8d4b7d1066cb3"><td class="memTemplParams" colspan="2">template&lt;class charT , class traits , class T &gt; </td></tr>
<tr class="memitem:ab5373c9f8caa95d0cdf8d4b7d1066cb3"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html#ab5373c9f8caa95d0cdf8d4b7d1066cb3">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;os, const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; &amp;cu_ptr)</td></tr>
<tr class="memdesc:ab5373c9f8caa95d0cdf8d4b7d1066cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the system-dependent representation of the pointer contained in a <a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics. ">copyable_unique_ptr</a> object.  <a href="#ab5373c9f8caa95d0cdf8d4b7d1066cb3">More...</a><br /></td></tr>
<tr class="separator:ab5373c9f8caa95d0cdf8d4b7d1066cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::copyable_unique_ptr&lt; T &gt;</h3>

<p>A smart pointer with deep copy semantics. </p>
<p>This is <em>similar</em> to <code>std::unique_ptr</code> in that it does not permit shared ownership of the contained object. However, unlike <code>std::unique_ptr</code>, copyable_unique_ptr supports copy and assignment operations, by insisting that the contained object be "copyable". To be copyable, the class must have either an accessible copy constructor, or it must have an accessible clone method with signature</p><div class="fragment"><div class="line">std::unique_ptr&lt;Foo&gt; Clone() <span class="keyword">const</span>;</div></div><!-- fragment --><p> where Foo is the type of the managed object. By "accessible" we mean either that the copy constructor or clone method is public, or <code>friend <a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics. ">copyable_unique_ptr</a>&lt;Foo&gt;;</code> appears in Foo's class declaration.</p>
<p>Generally, the API is modeled as closely as possible on the C++ standard <code>std::unique_ptr</code> API and copyable_unique_ptr&lt;T&gt; is interoperable with <code>unique_ptr&lt;T&gt;</code> wherever that makes sense. However, there are some differences:</p>
<ol type="1">
<li>It always uses a default deleter.</li>
<li>There is no array version.</li>
<li>To allow for future copy-on-write optimizations, there is a distinction between writable and const access, the <a class="el" href="classdrake_1_1copyable__unique__ptr.html#a76c791981969a90b67778f87036b032e" title="Return a const pointer to the contained object if any, or nullptr. ">get()</a> method is modified to return only a const pointer, with <a class="el" href="classdrake_1_1copyable__unique__ptr.html#ac684d04fadf2a6b636c98e38aabf7ccb" title="Return a writable pointer to the contained object if any, or nullptr. ">get_mutable()</a> added to return a writable pointer.</li>
</ol>
<p>This class is entirely inline and has no computational or space overhead except when copying is required; it contains just a single pointer and does no reference counting.</p>
<p><b>Usage</b></p>
<p>In the simplest use case, the instantiation type will match the type of object it references, e.g.: </p><div class="fragment"><div class="line">copyable_unique_ptr&lt;Foo&gt; ptr = make_unique&lt;Foo&gt;(...);</div></div><!-- fragment --><p> In this case, as long <code>Foo</code> is deemed compatible, the behavior will be as expected, i.e., when <code>ptr</code> copies, it will contain a reference to a new instance of <code>Foo</code>.</p>
<p>copyable_unique_ptr can also be used with polymorphic classes &ndash; a copyable_unique_ptr, instantiated on a <em>base</em> class, references an instance of a <em>derived</em> class. When copying the object, we would want the copy to likewise contain an instance of the derived class. For example:</p>
<div class="fragment"><div class="line">copyable_unique_ptr&lt;Base&gt; cu_ptr = make_unique&lt;Derived&gt;();</div><div class="line">copyable_unique_ptr&lt;Base&gt; other_cu_ptr = cu_ptr;           <span class="comment">// Triggers a copy.</span></div><div class="line">is_dynamic_castable&lt;Derived&gt;(cu_other_ptr.get());          <span class="comment">// Should be true.</span></div></div><!-- fragment --><p>This works for well-designed polymorphic classes.</p>
<dl class="section warning"><dt>Warning</dt><dd>Ill-formed polymorphic classes can lead to fatal type slicing of the referenced object, such that the new copy contains an instance of <code>Base</code> instead of <code>Derived</code>. Some mistakes that would lead to this degenerate behavior:</dd></dl>
<ul>
<li>The <code>Base</code> class has a public copy constructor.</li>
<li>The <code>Base</code> class's Clone() implementation does not invoke the <code>Derived</code> class's implementation of a suitable virtual method.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>One important difference between unique_ptr and copyable_unique_ptr is that a unique_ptr can be declared on a forward-declared class type. The copyable_unique_ptr <em>cannot</em>. The class must be fully defined so that the copyable_unique_ptr is able to determine if the type meets the requirements (i.e., public copy constructible or cloneable).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the contained object, which <em>must</em> be copyable as defined above. May be an abstract or concrete type. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a38cdcb23181ad1c554ef0209a29cd768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cdcb23181ad1c554ef0209a29cd768">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor stores a <code>nullptr</code>. </p>
<p>No heap allocation is performed. The <a class="el" href="classdrake_1_1copyable__unique__ptr.html#a3f6fc5de06a318920d84f3c3742db07f" title="Return true if this container is empty, which is the state the container is in immediately after defa...">empty()</a> method will return true when called on a default-constructed copyable_unique_ptr. </p>

</div>
</div>
<a id="ac67cae08914b16290d64a748fb64d6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67cae08914b16290d64a748fb64d6dc">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a pointer to a writable heap-allocated object, take over ownership of that object. </p>
<p>No copying occurs. </p>

</div>
</div>
<a id="a9efa09fdc8aad69db06b649c447d9806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efa09fdc8aad69db06b649c447d9806">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor is deep; the new copyable_unique_ptr object contains a new copy of the object in the source, created via the source object's copy constructor or <code>Clone()</code> method. </p>
<p>If the source container is empty this one will be empty also. </p>

</div>
</div>
<a id="a1774b97188ce9c5a5cd47c5c4ff63fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1774b97188ce9c5a5cd47c5c4ff63fc0">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from a standard <code>unique_ptr</code> of <em>compatible</em> type. </p>
<p>The copy is deep; the new copyable_unique_ptr object contains a new copy of the object in the source, created via the source object's copy constructor or <code>Clone()</code> method. If the source container is empty this one will be empty also. </p>

</div>
</div>
<a id="ac60d2d174b5ce39e94bf59719c997250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60d2d174b5ce39e94bf59719c997250">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor is very fast and leaves the source empty. </p>
<p>Ownership is transferred from the source to the new copyable_unique_ptr. If the source was empty this one will be empty also. No heap activity occurs. </p>

</div>
</div>
<a id="a5a34341a71b340b3af3ee3d18e9d09bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a34341a71b340b3af3ee3d18e9d09bc">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>u_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor from a standard <code>unique_ptr</code>. </p>
<p>The move is very fast and leaves the source empty. Ownership is transferred from the source to the new copyable_unique_ptr. If the source was empty this one will be empty also. No heap activity occurs. </p>

</div>
</div>
<a id="ad0b538a9c4ca822d4212226ba51dc0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b538a9c4ca822d4212226ba51dc0aa">&#9670;&nbsp;</a></span>copyable_unique_ptr() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>u_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move construction from a compatible standard <code>unique_ptr</code>. </p>
<p>Type <code>U*</code> must be implicitly convertible to type <code>T*</code>. Ownership is transferred from the source to the new copyable_unique_ptr. If the source was empty this one will be empty also. No heap activity occurs. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3f6fc5de06a318920d84f3c3742db07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6fc5de06a318920d84f3c3742db07f">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this container is empty, which is the state the container is in immediately after default construction and various other operations. </p>

</div>
</div>
<a id="a76c791981969a90b67778f87036b032e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c791981969a90b67778f87036b032e">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the contained object if any, or <code>nullptr</code>. </p>
<p>Note that this is different than <code>get()</code> for the standard smart pointers like <code>std::unique_ptr</code> which return a writable pointer. Use <a class="el" href="classdrake_1_1copyable__unique__ptr.html#ac684d04fadf2a6b636c98e38aabf7ccb" title="Return a writable pointer to the contained object if any, or nullptr. ">get_mutable()</a> here for that purpose. </p>

</div>
</div>
<a id="ac684d04fadf2a6b636c98e38aabf7ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac684d04fadf2a6b636c98e38aabf7ccb">&#9670;&nbsp;</a></span>get_mutable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* get_mutable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to the contained object if any, or <code>nullptr</code>. </p>
<p>Note that you need write access to this container in order to get write access to the object it contains.</p>
<dl class="section warning"><dt>Warning</dt><dd>If copyable_unique_ptr is instantiated on a const template parameter (e.g., <code><a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics. ">copyable_unique_ptr</a>&lt;const Foo&gt;</code>), then <a class="el" href="classdrake_1_1copyable__unique__ptr.html#ac684d04fadf2a6b636c98e38aabf7ccb" title="Return a writable pointer to the contained object if any, or nullptr. ">get_mutable()</a> returns a const pointer. </dd></dl>

</div>
</div>
<a id="aabb236eef6e850a09b441591f0812747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb236eef6e850a09b441591f0812747">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This form of assignment replaces the currently-held object by the given source object and takes over ownership of the source object. </p>
<p>The currently-held object (if any) is deleted. </p>

</div>
</div>
<a id="a4d4078720893b915d022bd734f6eb5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4078720893b915d022bd734f6eb5e9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This form of assignment replaces the currently-held object by a heap-allocated copy of the source object, created using its copy constructor or <code>Clone()</code> method. </p>
<p>The currently-held object (if any) is deleted. </p>

</div>
</div>
<a id="a35881f6551d81d4ba11f23bdc695dbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35881f6551d81d4ba11f23bdc695dbf5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment from copyable_unique_ptr replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method. </p>
<p>The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. Nothing happens if the source and destination are the same container. </p>

</div>
</div>
<a id="a5d014005bde7838a248d7129023b999c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d014005bde7838a248d7129023b999c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment from a compatible copyable_unique_ptr replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method. </p>
<p>The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. Nothing happens if the source and destination are the same container. </p>

</div>
</div>
<a id="a241aa7fdb2e242c6965006831d9e62dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241aa7fdb2e242c6965006831d9e62dd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment from a standard <code>unique_ptr</code> replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method. </p>
<p>The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. Nothing happens if the source and destination are the same container. </p>

</div>
</div>
<a id="a67bca368e89b4408972a3f54c09eaab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67bca368e89b4408972a3f54c09eaab3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment from a compatible standard <code>unique_ptr</code> replaces the currently-held object by a copy of the object held in the source container, created using the source object's copy constructor or <code>Clone()</code> method. </p>
<p>The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. Nothing happens if the source and destination are the same container. </p>

</div>
</div>
<a id="af2693139bff4ad445212aa4bb73284ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2693139bff4ad445212aa4bb73284ad">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the source object, leaving the source empty. </p>
<p>The currently-held object (if any) is deleted. The instance is <em>not</em> copied. Nothing happens if the source and destination are the same containers. </p>

</div>
</div>
<a id="a60fa4971dcefe82f931084653b196a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60fa4971dcefe82f931084653b196a55">&#9670;&nbsp;</a></span>operator=() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the compatible source object, leaving the source empty. </p>
<p>The currently-held object (if any) is deleted. The instance is <em>not</em> copied. Nothing happens if the source and destination are the same containers. </p>

</div>
</div>
<a id="a53f1739bcedb13183285a9995d3b9daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f1739bcedb13183285a9995d3b9daf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>u_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the source object, leaving the source empty. </p>
<p>The currently-held object (if any) is deleted. The instance is <em>not</em> copied. Nothing happens if the source and destination are the same containers. </p>

</div>
</div>
<a id="abf98f86aa60c05f0a546ca78c2a2e857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf98f86aa60c05f0a546ca78c2a2e857">&#9670;&nbsp;</a></span>operator=() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>u_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the compatible source object, leaving the source empty. </p>
<p>The currently-held object (if any) is deleted. The instance is <em>not</em> copied. Nothing happens if the source and destination are the same containers. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab5373c9f8caa95d0cdf8d4b7d1066cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5373c9f8caa95d0cdf8d4b7d1066cb3">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; charT, traits &gt; &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cu_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output the system-dependent representation of the pointer contained in a <a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics. ">copyable_unique_ptr</a> object. </p>
<p>This is equivalent to <code>os &lt;&lt; p.get();</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/common/<a class="el" href="copyable__unique__ptr_8h.html">copyable_unique_ptr.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
