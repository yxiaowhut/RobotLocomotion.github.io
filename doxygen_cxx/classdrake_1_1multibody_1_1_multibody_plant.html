<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: MultibodyPlant&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_multibody_plant.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdrake_1_1multibody_1_1_multibody_plant-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MultibodyPlant&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__systems.html">Modeling Dynamical Systems</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>MultibodyPlant is a Drake system framework representation (see <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">systems::System</a>) for the model of a physical system consisting of a collection of interconnected bodies.  
 <a href="classdrake_1_1multibody_1_1_multibody_plant.html#details">More...</a></p>

<p><code>#include &lt;drake/multibody/plant/multibody_plant.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a042f9f9407c26eceeec309377eadcfa2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a042f9f9407c26eceeec309377eadcfa2">MultibodyPlant</a> (<a class="el" href="classdouble.html">double</a> <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8daceb7a3c384d6ad9f305e42b5fc1c6">time_step</a>=0)</td></tr>
<tr class="memdesc:a042f9f9407c26eceeec309377eadcfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor creates a plant with a single "world" body.  <a href="#a042f9f9407c26eceeec309377eadcfa2">More...</a><br /></td></tr>
<tr class="separator:a042f9f9407c26eceeec309377eadcfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912adb84c4940893eb4634155e6e7e8b"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a912adb84c4940893eb4634155e6e7e8b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a912adb84c4940893eb4634155e6e7e8b">MultibodyPlant</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; U &gt; &amp;other)</td></tr>
<tr class="memdesc:a912adb84c4940893eb4634155e6e7e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar-converting copy constructor. See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a>.  <a href="#a912adb84c4940893eb4634155e6e7e8b">More...</a><br /></td></tr>
<tr class="separator:a912adb84c4940893eb4634155e6e7e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7f02e861a8f89fc0b575b2f30333d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ada7f02e861a8f89fc0b575b2f30333d3">num_frames</a> () const</td></tr>
<tr class="memdesc:ada7f02e861a8f89fc0b575b2f30333d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> objects in this model.  <a href="#ada7f02e861a8f89fc0b575b2f30333d3">More...</a><br /></td></tr>
<tr class="separator:ada7f02e861a8f89fc0b575b2f30333d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92b53211e54243aff4490a700168eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af92b53211e54243aff4490a700168eb4">num_bodies</a> () const</td></tr>
<tr class="memdesc:af92b53211e54243aff4490a700168eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bodies in the model, including the "world" body, which is always part of the model.  <a href="#af92b53211e54243aff4490a700168eb4">More...</a><br /></td></tr>
<tr class="separator:af92b53211e54243aff4490a700168eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636804b6c40e538d83d5c2dfefb7929e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a636804b6c40e538d83d5c2dfefb7929e">num_joints</a> () const</td></tr>
<tr class="memdesc:a636804b6c40e538d83d5c2dfefb7929e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of joints in the model.  <a href="#a636804b6c40e538d83d5c2dfefb7929e">More...</a><br /></td></tr>
<tr class="separator:a636804b6c40e538d83d5c2dfefb7929e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8601c026e9807127b4dd41e7585d2cfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8601c026e9807127b4dd41e7585d2cfc">num_actuators</a> () const</td></tr>
<tr class="memdesc:a8601c026e9807127b4dd41e7585d2cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of joint actuators in the model.  <a href="#a8601c026e9807127b4dd41e7585d2cfc">More...</a><br /></td></tr>
<tr class="separator:a8601c026e9807127b4dd41e7585d2cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7f0267d163693025fa04f78bb18333"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a6b7f0267d163693025fa04f78bb18333">num_force_elements</a> () const</td></tr>
<tr class="memdesc:a6b7f0267d163693025fa04f78bb18333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> objects.  <a href="#a6b7f0267d163693025fa04f78bb18333">More...</a><br /></td></tr>
<tr class="separator:a6b7f0267d163693025fa04f78bb18333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89140adb93cb9e507f71c30eb783198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac89140adb93cb9e507f71c30eb783198">num_model_instances</a> () const</td></tr>
<tr class="memdesc:ac89140adb93cb9e507f71c30eb783198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of model instances in the model.  <a href="#ac89140adb93cb9e507f71c30eb783198">More...</a><br /></td></tr>
<tr class="separator:ac89140adb93cb9e507f71c30eb783198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553">num_positions</a> () const</td></tr>
<tr class="memdesc:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the generalized position vector <code>q</code> for this model.  <a href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">More...</a><br /></td></tr>
<tr class="separator:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab669e070e6178c4aeeb067a1f4b6122e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab669e070e6178c4aeeb067a1f4b6122e">num_positions</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:ab669e070e6178c4aeeb067a1f4b6122e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the generalized position vector <code>q</code> for a specific model instance.  <a href="#ab669e070e6178c4aeeb067a1f4b6122e">More...</a><br /></td></tr>
<tr class="separator:ab669e070e6178c4aeeb067a1f4b6122e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0163ac0976659d811e3337647ff0313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313">num_velocities</a> () const</td></tr>
<tr class="memdesc:ae0163ac0976659d811e3337647ff0313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the generalized velocity vector <code>v</code> for this model.  <a href="#ae0163ac0976659d811e3337647ff0313">More...</a><br /></td></tr>
<tr class="separator:ae0163ac0976659d811e3337647ff0313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a686a8389beffdc5fb8a7690967e741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0a686a8389beffdc5fb8a7690967e741">num_velocities</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a0a686a8389beffdc5fb8a7690967e741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the generalized velocity vector <code>v</code> for a specific model instance.  <a href="#a0a686a8389beffdc5fb8a7690967e741">More...</a><br /></td></tr>
<tr class="separator:a0a686a8389beffdc5fb8a7690967e741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80c61762d32b97a34f02a0374fc6fe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac80c61762d32b97a34f02a0374fc6fe3">num_multibody_states</a> () const</td></tr>
<tr class="memdesc:ac80c61762d32b97a34f02a0374fc6fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the multibody system state vector <code>x = [q; v]</code>.  <a href="#ac80c61762d32b97a34f02a0374fc6fe3">More...</a><br /></td></tr>
<tr class="separator:ac80c61762d32b97a34f02a0374fc6fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae3fc8de8de8eaf2d37a24c79d6be8e97">num_actuated_dofs</a> () const</td></tr>
<tr class="memdesc:ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of actuated degrees of freedom.  <a href="#ae3fc8de8de8eaf2d37a24c79d6be8e97">More...</a><br /></td></tr>
<tr class="separator:ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279e31367e76849d4a45fd7db0f116f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a279e31367e76849d4a45fd7db0f116f1">num_actuated_dofs</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a279e31367e76849d4a45fd7db0f116f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of actuated degrees of freedom for a specific model instance.  <a href="#a279e31367e76849d4a45fd7db0f116f1">More...</a><br /></td></tr>
<tr class="separator:a279e31367e76849d4a45fd7db0f116f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6d28ce9c8119bee923e827eb6f02ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry.html#a32581e3a9c8879bcf23192e248df49c7">geometry::SourceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4a6d28ce9c8119bee923e827eb6f02ed">RegisterAsSourceForSceneGraph</a> (<a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *scene_graph)</td></tr>
<tr class="memdesc:a4a6d28ce9c8119bee923e827eb6f02ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers <code>this</code> plant to serve as a source for an instance of SceneGraph.  <a href="#a4a6d28ce9c8119bee923e827eb6f02ed">More...</a><br /></td></tr>
<tr class="separator:a4a6d28ce9c8119bee923e827eb6f02ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53549e4f65d1647147ff8b011712d96e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a53549e4f65d1647147ff8b011712d96e">RegisterVisualGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">geometry::IllustrationProperties</a> &amp;properties, <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *scene_graph=nullptr)</td></tr>
<tr class="memdesc:a53549e4f65d1647147ff8b011712d96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers geometry in a SceneGraph with a given <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications. ">geometry::Shape</a> to be used for visualization of a given <code>body</code>.  <a href="#a53549e4f65d1647147ff8b011712d96e">More...</a><br /></td></tr>
<tr class="separator:a53549e4f65d1647147ff8b011712d96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4b17e7296370d22fa3962a7e5b2f00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aee4b17e7296370d22fa3962a7e5b2f00">RegisterVisualGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;diffuse_color, <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *scene_graph=nullptr)</td></tr>
<tr class="memdesc:aee4b17e7296370d22fa3962a7e5b2f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for visual geometry registration; it converts the <code>diffuse_color</code> (RGBA with values in the range [0, 1]) into a <a class="el" href="namespacedrake_1_1geometry.html#a23299f33d6cf943a2b929b5f10d03c48" title="Implements ConnectDrakeVisualizer, but using pose_bundle_output_port to explicitly specify the output...">geometry::ConnectDrakeVisualizer()</a>-compatible set of <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role. ">geometry::IllustrationProperties</a>.  <a href="#aee4b17e7296370d22fa3962a7e5b2f00">More...</a><br /></td></tr>
<tr class="separator:aee4b17e7296370d22fa3962a7e5b2f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a41c96ae150a32a1c60eac72c97931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a85a41c96ae150a32a1c60eac72c97931">RegisterVisualGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *scene_graph=nullptr)</td></tr>
<tr class="memdesc:a85a41c96ae150a32a1c60eac72c97931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for visual geometry registration; it relies on the downstream <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role. ">geometry::IllustrationProperties</a> <em>consumer</em> to provide default parameter values (see <a class="el" href="group__geometry__roles.html">Geometry Roles</a> for details).  <a href="#a85a41c96ae150a32a1c60eac72c97931">More...</a><br /></td></tr>
<tr class="separator:a85a41c96ae150a32a1c60eac72c97931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac311fb9ac3a4450ba1a4b74a4c72a9f6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac311fb9ac3a4450ba1a4b74a4c72a9f6">GetVisualGeometriesForBody</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:ac311fb9ac3a4450ba1a4b74a4c72a9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of GeometryId's identifying the different visual geometries for <code>body</code> previously registered with a SceneGraph.  <a href="#ac311fb9ac3a4450ba1a4b74a4c72a9f6">More...</a><br /></td></tr>
<tr class="separator:ac311fb9ac3a4450ba1a4b74a4c72a9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c0b698e0102d42f085ca39f337b019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aa7c0b698e0102d42f085ca39f337b019">num_visual_geometries</a> () const</td></tr>
<tr class="memdesc:aa7c0b698e0102d42f085ca39f337b019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of geometries registered for visualization.  <a href="#aa7c0b698e0102d42f085ca39f337b019">More...</a><br /></td></tr>
<tr class="separator:aa7c0b698e0102d42f085ca39f337b019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff674ee03885b0b47b6eb6859cf6a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4ff674ee03885b0b47b6eb6859cf6a4a">RegisterCollisionGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;coulomb_friction, <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *scene_graph=nullptr)</td></tr>
<tr class="memdesc:a4ff674ee03885b0b47b6eb6859cf6a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers geometry in a SceneGraph with a given <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications. ">geometry::Shape</a> to be used for the contact modeling of a given <code>body</code>.  <a href="#a4ff674ee03885b0b47b6eb6859cf6a4a">More...</a><br /></td></tr>
<tr class="separator:a4ff674ee03885b0b47b6eb6859cf6a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eead1b1e0bac74e55fc0db28f8f2528"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0eead1b1e0bac74e55fc0db28f8f2528">GetCollisionGeometriesForBody</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:a0eead1b1e0bac74e55fc0db28f8f2528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of GeometryId's identifying the different contact geometries for <code>body</code> previously registered with a SceneGraph.  <a href="#a0eead1b1e0bac74e55fc0db28f8f2528">More...</a><br /></td></tr>
<tr class="separator:a0eead1b1e0bac74e55fc0db28f8f2528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b107ecf3446e56cb203461440200c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac1b107ecf3446e56cb203461440200c1">num_collision_geometries</a> () const</td></tr>
<tr class="memdesc:ac1b107ecf3446e56cb203461440200c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of geometries registered for contact modeling.  <a href="#ac1b107ecf3446e56cb203461440200c1">More...</a><br /></td></tr>
<tr class="separator:ac1b107ecf3446e56cb203461440200c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af854169fcb6b3080234c5f5ce78894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4af854169fcb6b3080234c5f5ce78894">CollectRegisteredGeometries</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; *&gt; &amp;bodies) const</td></tr>
<tr class="memdesc:a4af854169fcb6b3080234c5f5ce78894"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each of the provided <code>bodies</code>, collects up all geometries that have been registered to that body.  <a href="#a4af854169fcb6b3080234c5f5ce78894">More...</a><br /></td></tr>
<tr class="separator:a4af854169fcb6b3080234c5f5ce78894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f1718383aaaf709d076d844943dfa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a10f1718383aaaf709d076d844943dfa8">GetBodiesWeldedTo</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:a10f1718383aaaf709d076d844943dfa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all bodies that are transitively welded, or rigidly affixed, to <code>body</code>, per these two definitions:  <a href="#a10f1718383aaaf709d076d844943dfa8">More...</a><br /></td></tr>
<tr class="separator:a10f1718383aaaf709d076d844943dfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38608634b36afab217b71de1f31fbc85"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a38608634b36afab217b71de1f31fbc85">default_coulomb_friction</a> (<a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a> <a class="el" href="multilane_2loader_8cc.html#afd0d68c6d31ff249f3ae8662162663c3">id</a>) const</td></tr>
<tr class="memdesc:a38608634b36afab217b71de1f31fbc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the friction coefficients provided during geometry registration for the given geometry <code>id</code>.  <a href="#a38608634b36afab217b71de1f31fbc85">More...</a><br /></td></tr>
<tr class="separator:a38608634b36afab217b71de1f31fbc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad783d7e7e513feb7a73384c8080041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#afad783d7e7e513feb7a73384c8080041">geometry_source_is_registered</a> () const</td></tr>
<tr class="memdesc:afad783d7e7e513feb7a73384c8080041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>this</code> MultibodyPlant was registered with a SceneGraph.  <a href="#afad783d7e7e513feb7a73384c8080041">More...</a><br /></td></tr>
<tr class="separator:afad783d7e7e513feb7a73384c8080041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf36bc0dadc3f1e72bc17072c5f9e4f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#adf36bc0dadc3f1e72bc17072c5f9e4f2">GetBodyFromFrameId</a> (<a class="el" href="namespacedrake_1_1geometry.html#a13b34d2644a785d87ebaaade93f287d3">geometry::FrameId</a> frame_id) const</td></tr>
<tr class="memdesc:adf36bc0dadc3f1e72bc17072c5f9e4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a geometry frame identifier, returns a pointer to the body associated with that id (nullptr if there is no such body).  <a href="#adf36bc0dadc3f1e72bc17072c5f9e4f2">More...</a><br /></td></tr>
<tr class="separator:adf36bc0dadc3f1e72bc17072c5f9e4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ca6d32db3c06c6ef91ad42fc36052c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake_1_1geometry.html#a13b34d2644a785d87ebaaade93f287d3">geometry::FrameId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a52ca6d32db3c06c6ef91ad42fc36052c">GetBodyFrameIdIfExists</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:a52ca6d32db3c06c6ef91ad42fc36052c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the body with <code>body_index</code> has geometry registered with it, it returns the <a class="el" href="namespacedrake_1_1geometry.html#a13b34d2644a785d87ebaaade93f287d3" title="Type used to identify geometry frames in SceneGraph. ">geometry::FrameId</a> associated with it.  <a href="#a52ca6d32db3c06c6ef91ad42fc36052c">More...</a><br /></td></tr>
<tr class="separator:a52ca6d32db3c06c6ef91ad42fc36052c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcdcb4e7798a5aef9bc3111402dfa5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry.html#a13b34d2644a785d87ebaaade93f287d3">geometry::FrameId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#afdcdcb4e7798a5aef9bc3111402dfa5e">GetBodyFrameIdOrThrow</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:afdcdcb4e7798a5aef9bc3111402dfa5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the body with <code>body_index</code> has geometry registered with it, it returns the <a class="el" href="namespacedrake_1_1geometry.html#a13b34d2644a785d87ebaaade93f287d3" title="Type used to identify geometry frames in SceneGraph. ">geometry::FrameId</a> associated with it.  <a href="#afdcdcb4e7798a5aef9bc3111402dfa5e">More...</a><br /></td></tr>
<tr class="separator:afdcdcb4e7798a5aef9bc3111402dfa5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b671623de5eecd130ce235995ac320"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a64b671623de5eecd130ce235995ac320">get_generalized_contact_forces_output_port</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a64b671623de5eecd130ce235995ac320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port of generalized contact forces for a specific model instance.  <a href="#a64b671623de5eecd130ce235995ac320">More...</a><br /></td></tr>
<tr class="separator:a64b671623de5eecd130ce235995ac320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38514bf9e20aa4b85ad82a0a2009a65f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a38514bf9e20aa4b85ad82a0a2009a65f">get_contact_results_output_port</a> () const</td></tr>
<tr class="memdesc:a38514bf9e20aa4b85ad82a0a2009a65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the port that outputs <a class="el" href="classdrake_1_1multibody_1_1_contact_results.html" title="A container class storing the contact results information for each contact pair for a given state of ...">ContactResults</a>.  <a href="#a38514bf9e20aa4b85ad82a0a2009a65f">More...</a><br /></td></tr>
<tr class="separator:a38514bf9e20aa4b85ad82a0a2009a65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ef779ddfeea96c5d80c27d68a4f864"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a29ef779ddfeea96c5d80c27d68a4f864">world_body</a> () const</td></tr>
<tr class="memdesc:a29ef779ddfeea96c5d80c27d68a4f864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the <em>world</em> body.  <a href="#a29ef779ddfeea96c5d80c27d68a4f864">More...</a><br /></td></tr>
<tr class="separator:a29ef779ddfeea96c5d80c27d68a4f864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95da38020c32452f62a8cf973057c7a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html">BodyFrame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac95da38020c32452f62a8cf973057c7a">world_frame</a> () const</td></tr>
<tr class="memdesc:ac95da38020c32452f62a8cf973057c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the <em>world</em> frame.  <a href="#ac95da38020c32452f62a8cf973057c7a">More...</a><br /></td></tr>
<tr class="separator:ac95da38020c32452f62a8cf973057c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9547075b5a67b2354f3dabf0f2f787"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ada9547075b5a67b2354f3dabf0f2f787">get_body</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:ada9547075b5a67b2354f3dabf0f2f787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the body with unique index <code>body_index</code>.  <a href="#ada9547075b5a67b2354f3dabf0f2f787">More...</a><br /></td></tr>
<tr class="separator:ada9547075b5a67b2354f3dabf0f2f787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad293b63a81a28c455fdfb7e5f04c35b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad293b63a81a28c455fdfb7e5f04c35b0">get_joint</a> (<a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> joint_index) const</td></tr>
<tr class="memdesc:ad293b63a81a28c455fdfb7e5f04c35b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the joint with unique index <code>joint_index</code>.  <a href="#ad293b63a81a28c455fdfb7e5f04c35b0">More...</a><br /></td></tr>
<tr class="separator:ad293b63a81a28c455fdfb7e5f04c35b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb237ffaadc7323d817ba0e07e78a8f4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abb237ffaadc7323d817ba0e07e78a8f4">get_joint_actuator</a> (<a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> actuator_index) const</td></tr>
<tr class="memdesc:abb237ffaadc7323d817ba0e07e78a8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the joint actuator with unique index <code>actuator_index</code>.  <a href="#abb237ffaadc7323d817ba0e07e78a8f4">More...</a><br /></td></tr>
<tr class="separator:abb237ffaadc7323d817ba0e07e78a8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cafdc0efac53fe097f9380b955e396"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a95cafdc0efac53fe097f9380b955e396">get_frame</a> (<a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> frame_index) const</td></tr>
<tr class="memdesc:a95cafdc0efac53fe097f9380b955e396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the frame with unique index <code>frame_index</code>.  <a href="#a95cafdc0efac53fe097f9380b955e396">More...</a><br /></td></tr>
<tr class="separator:a95cafdc0efac53fe097f9380b955e396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99be499eb59f00037b05ec60b51e177"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab99be499eb59f00037b05ec60b51e177">GetModelInstanceName</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:ab99be499eb59f00037b05ec60b51e177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of a <code>model_instance</code>.  <a href="#ab99be499eb59f00037b05ec60b51e177">More...</a><br /></td></tr>
<tr class="separator:ab99be499eb59f00037b05ec60b51e177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1029d223ec3d0db0dc14d643fa7c88"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1c1029d223ec3d0db0dc14d643fa7c88">model</a> () const</td></tr>
<tr class="memdesc:a1c1029d223ec3d0db0dc14d643fa7c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the underlying MultibodyTree model for <code>this</code> plant.  <a href="#a1c1029d223ec3d0db0dc14d643fa7c88">More...</a><br /></td></tr>
<tr class="separator:a1c1029d223ec3d0db0dc14d643fa7c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7bb2a3531c09a97fb3623ac582d840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#acf7bb2a3531c09a97fb3623ac582d840">is_finalized</a> () const</td></tr>
<tr class="memdesc:acf7bb2a3531c09a97fb3623ac582d840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this MultibodyPlant was finalized with a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>.  <a href="#acf7bb2a3531c09a97fb3623ac582d840">More...</a><br /></td></tr>
<tr class="separator:acf7bb2a3531c09a97fb3623ac582d840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5987c219df6a53a55fde8a06d5c1f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0c5987c219df6a53a55fde8a06d5c1f1">Finalize</a> (<a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *scene_graph=nullptr)</td></tr>
<tr class="memdesc:a0c5987c219df6a53a55fde8a06d5c1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be called after all elements in the model (joints, bodies, force elements, constraints, etc.) are added and before any computations are performed.  <a href="#a0c5987c219df6a53a55fde8a06d5c1f1">More...</a><br /></td></tr>
<tr class="separator:a0c5987c219df6a53a55fde8a06d5c1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daceb7a3c384d6ad9f305e42b5fc1c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8daceb7a3c384d6ad9f305e42b5fc1c6">time_step</a> () const</td></tr>
<tr class="memdesc:a8daceb7a3c384d6ad9f305e42b5fc1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time step (or period) used to model <code>this</code> plant as a discrete system with periodic updates.  <a href="#a8daceb7a3c384d6ad9f305e42b5fc1c6">More...</a><br /></td></tr>
<tr class="separator:a8daceb7a3c384d6ad9f305e42b5fc1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098f3fd21ecb96e2769dbd4bb4c124f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a098f3fd21ecb96e2769dbd4bb4c124f2">SetDefaultContext</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a098f3fd21ecb96e2769dbd4bb4c124f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets default values in the context.  <a href="#a098f3fd21ecb96e2769dbd4bb4c124f2">More...</a><br /></td></tr>
<tr class="separator:a098f3fd21ecb96e2769dbd4bb4c124f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73edc00d493b3f15ba7679cc14830a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae73edc00d493b3f15ba7679cc14830a0">SetDefaultState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state) const override</td></tr>
<tr class="memdesc:ae73edc00d493b3f15ba7679cc14830a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state in <code>context</code> so that generalized positions and velocities are zero.  <a href="#ae73edc00d493b3f15ba7679cc14830a0">More...</a><br /></td></tr>
<tr class="separator:ae73edc00d493b3f15ba7679cc14830a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a3aeb03d90d213da4702f2dc5e484fc86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3aeb03d90d213da4702f2dc5e484fc86">MultibodyPlant</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> &amp;)=delete</td></tr>
<tr class="separator:a3aeb03d90d213da4702f2dc5e484fc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc2576d314d5baf56ad6ad593b26f9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aecc2576d314d5baf56ad6ad593b26f9f">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> &amp;)=delete</td></tr>
<tr class="separator:aecc2576d314d5baf56ad6ad593b26f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359ae04bf7eabd0461c5f12ab35fee1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a359ae04bf7eabd0461c5f12ab35fee1d">MultibodyPlant</a> (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a359ae04bf7eabd0461c5f12ab35fee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f43a6f72128af8e926d32c37ed7580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af4f43a6f72128af8e926d32c37ed7580">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:af4f43a6f72128af8e926d32c37ed7580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Position and velocity state component accessors and mutators.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Various methods for accessing and mutating <code>[q; v]</code>, where <code>q</code> is the vector of generalized positions and <code>v</code> is the vector of generalized velocities, or some portion thereof (e.g., only <code>v</code>). </p>
</div></td></tr>
<tr class="memitem:abda564c1168979bb8422343d46925b9a"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abda564c1168979bb8422343d46925b9a">GetPositionsAndVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:abda564c1168979bb8422343d46925b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const vector reference containing the vector <code>[q; v]</code> with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities.  <a href="#abda564c1168979bb8422343d46925b9a">More...</a><br /></td></tr>
<tr class="separator:abda564c1168979bb8422343d46925b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0be270734139ba7fd908effc13dd54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#afa0be270734139ba7fd908effc13dd54">GetPositionsAndVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:afa0be270734139ba7fd908effc13dd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector <code>[q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities for model instance <code>model_instance</code>.  <a href="#afa0be270734139ba7fd908effc13dd54">More...</a><br /></td></tr>
<tr class="separator:afa0be270734139ba7fd908effc13dd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1036e869271ac77a82f891a5f7187210"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1036e869271ac77a82f891a5f7187210">GetMutablePositionsAndVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a1036e869271ac77a82f891a5f7187210"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns a mutable vector containing the vector <code>[q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities (<b>see warning</b>).  <a href="#a1036e869271ac77a82f891a5f7187210">More...</a><br /></td></tr>
<tr class="separator:a1036e869271ac77a82f891a5f7187210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afeb2fce8493fe177dd3cd155819bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a2afeb2fce8493fe177dd3cd155819bb9">SetFreeBodyPose</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;X_WB) const</td></tr>
<tr class="memdesc:a2afeb2fce8493fe177dd3cd155819bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>context</code> to store the pose <code>X_WB</code> of a given <code>body</code> B in the world frame W.  <a href="#a2afeb2fce8493fe177dd3cd155819bb9">More...</a><br /></td></tr>
<tr class="separator:a2afeb2fce8493fe177dd3cd155819bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d819b895df9f2c35cc4c75269b0d2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a44d819b895df9f2c35cc4c75269b0d2a">SetFreeBodyPose</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;X_WB) const</td></tr>
<tr class="memdesc:a44d819b895df9f2c35cc4c75269b0d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>state</code> to store the pose <code>X_WB</code> of a given <code>body</code> B in the world frame W, for a given <code>context</code> of <code>this</code> model.  <a href="#a44d819b895df9f2c35cc4c75269b0d2a">More...</a><br /></td></tr>
<tr class="separator:a44d819b895df9f2c35cc4c75269b0d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c3b2ef66032df5f2a377c47e90ccb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae4c3b2ef66032df5f2a377c47e90ccb7">SetFreeBodySpatialVelocity</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;V_WB) const</td></tr>
<tr class="memdesc:ae4c3b2ef66032df5f2a377c47e90ccb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>context</code> to store the spatial velocity <code>V_WB</code> of a given <code>body</code> B in the world frame W.  <a href="#ae4c3b2ef66032df5f2a377c47e90ccb7">More...</a><br /></td></tr>
<tr class="separator:ae4c3b2ef66032df5f2a377c47e90ccb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecd07546b94fae6038ff66f389b7d23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a7ecd07546b94fae6038ff66f389b7d23">SetFreeBodySpatialVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;V_WB) const</td></tr>
<tr class="memdesc:a7ecd07546b94fae6038ff66f389b7d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>state</code> to store the spatial velocity <code>V_WB</code> of a given <code>body</code> B in the world frame W, for a given <code>context</code> of <code>this</code> model.  <a href="#a7ecd07546b94fae6038ff66f389b7d23">More...</a><br /></td></tr>
<tr class="separator:a7ecd07546b94fae6038ff66f389b7d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f77c6666edaa725dbd5dd060d2f5b00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5f77c6666edaa725dbd5dd060d2f5b00">SetPositionsAndVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;q_v) const</td></tr>
<tr class="memdesc:a5f77c6666edaa725dbd5dd060d2f5b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all generalized positions and velocities from the given vector [q; v].  <a href="#a5f77c6666edaa725dbd5dd060d2f5b00">More...</a><br /></td></tr>
<tr class="separator:a5f77c6666edaa725dbd5dd060d2f5b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16955a0cd87697a6806d99e9d6de0651"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a16955a0cd87697a6806d99e9d6de0651">SetPositionsAndVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;q_v) const</td></tr>
<tr class="memdesc:a16955a0cd87697a6806d99e9d6de0651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets generalized positions and velocities from the given vector [q; v] for the specified model instance.  <a href="#a16955a0cd87697a6806d99e9d6de0651">More...</a><br /></td></tr>
<tr class="separator:a16955a0cd87697a6806d99e9d6de0651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b48791a474f442ccb628dc9b76a24b9"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4b48791a474f442ccb628dc9b76a24b9">GetPositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a4b48791a474f442ccb628dc9b76a24b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const vector reference containing the vector of generalized positions.  <a href="#a4b48791a474f442ccb628dc9b76a24b9">More...</a><br /></td></tr>
<tr class="separator:a4b48791a474f442ccb628dc9b76a24b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2a085e96321a9d821551c479aed347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abe2a085e96321a9d821551c479aed347">GetPositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:abe2a085e96321a9d821551c479aed347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an vector containing the generalized positions (<code>q</code>) for the given model instance.  <a href="#abe2a085e96321a9d821551c479aed347">More...</a><br /></td></tr>
<tr class="separator:abe2a085e96321a9d821551c479aed347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2984079483027345739f5e1bc8a19c"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ace2984079483027345739f5e1bc8a19c">GetMutablePositions</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:ace2984079483027345739f5e1bc8a19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns a mutable vector reference containing the vector of generalized positions (<b>see warning</b>).  <a href="#ace2984079483027345739f5e1bc8a19c">More...</a><br /></td></tr>
<tr class="separator:ace2984079483027345739f5e1bc8a19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb9f945ca5577141351e60bd45156ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abfb9f945ca5577141351e60bd45156ef">SetPositions</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;q) const</td></tr>
<tr class="memdesc:abfb9f945ca5577141351e60bd45156ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all generalized positions from the given vector.  <a href="#abfb9f945ca5577141351e60bd45156ef">More...</a><br /></td></tr>
<tr class="separator:abfb9f945ca5577141351e60bd45156ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0258f954570e8d3df3b81e5e1f6e192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0258f954570e8d3df3b81e5e1f6e192">SetPositions</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;q_instance) const</td></tr>
<tr class="memdesc:ae0258f954570e8d3df3b81e5e1f6e192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the positions for a particular model instance from the given vector.  <a href="#ae0258f954570e8d3df3b81e5e1f6e192">More...</a><br /></td></tr>
<tr class="separator:ae0258f954570e8d3df3b81e5e1f6e192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800453060fc1f94455dff6c07dfde2d1"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a800453060fc1f94455dff6c07dfde2d1">GetVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a800453060fc1f94455dff6c07dfde2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const vector reference containing the generalized velocities.  <a href="#a800453060fc1f94455dff6c07dfde2d1">More...</a><br /></td></tr>
<tr class="separator:a800453060fc1f94455dff6c07dfde2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcd0c2630b23058791b7a3d6bac07a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#acbcd0c2630b23058791b7a3d6bac07a8">GetVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:acbcd0c2630b23058791b7a3d6bac07a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the generalized velocities (<code>v</code>) for the given model instance.  <a href="#acbcd0c2630b23058791b7a3d6bac07a8">More...</a><br /></td></tr>
<tr class="separator:acbcd0c2630b23058791b7a3d6bac07a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe7c6fe93604e71b9d277b76fab5932"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a7fe7c6fe93604e71b9d277b76fab5932">GetMutableVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a7fe7c6fe93604e71b9d277b76fab5932"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns a mutable vector reference containing the vector of generalized velocities (<b>see warning</b>).  <a href="#a7fe7c6fe93604e71b9d277b76fab5932">More...</a><br /></td></tr>
<tr class="separator:a7fe7c6fe93604e71b9d277b76fab5932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee483fa25d16a1ab99da1e0bface016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1ee483fa25d16a1ab99da1e0bface016">SetVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;v) const</td></tr>
<tr class="memdesc:a1ee483fa25d16a1ab99da1e0bface016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all generalized velocities from the given vector.  <a href="#a1ee483fa25d16a1ab99da1e0bface016">More...</a><br /></td></tr>
<tr class="separator:a1ee483fa25d16a1ab99da1e0bface016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac13b1f67afe352e62d292c1bd3a6e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#acac13b1f67afe352e62d292c1bd3a6e0">SetVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;v_instance) const</td></tr>
<tr class="memdesc:acac13b1f67afe352e62d292c1bd3a6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the generalized velocities for a particular model instance from the given vector.  <a href="#acac13b1f67afe352e62d292c1bd3a6e0">More...</a><br /></td></tr>
<tr class="separator:acac13b1f67afe352e62d292c1bd3a6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding new multibody elements</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>MultibodyPlant users will add modeling elements like bodies, joints, force elements, constraints, etc, using one of these methods.</p>
<p>Once a user is done adding <b>all</b> modeling elements, the <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> method <b>must</b> be called before invoking any MultibodyPlant service to perform computations. An attempt to call any of these methods <b>after</b> a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> on the plant, will result on an exception being thrown. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> for details. </p>
</div></td></tr>
<tr class="memitem:a9f6a68c31772eaa0c855ebb44eeaa0b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f6a68c31772eaa0c855ebb44eeaa0b7">AddRigidBody</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;M_BBo_B)</td></tr>
<tr class="memdesc:a9f6a68c31772eaa0c855ebb44eeaa0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid body with the provided name and spatial inertia.  <a href="#a9f6a68c31772eaa0c855ebb44eeaa0b7">More...</a><br /></td></tr>
<tr class="separator:a9f6a68c31772eaa0c855ebb44eeaa0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461a59b672f8c3f7c0dcc5caed56d245"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a461a59b672f8c3f7c0dcc5caed56d245">AddRigidBody</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;M_BBo_B)</td></tr>
<tr class="memdesc:a461a59b672f8c3f7c0dcc5caed56d245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid body with the provided name and spatial inertia.  <a href="#a461a59b672f8c3f7c0dcc5caed56d245">More...</a><br /></td></tr>
<tr class="separator:a461a59b672f8c3f7c0dcc5caed56d245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474c90a0b3e4f9349533207026413186"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class FrameType&gt; </td></tr>
<tr class="memitem:a474c90a0b3e4f9349533207026413186"><td class="memTemplItemLeft" align="right" valign="top">const FrameType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a474c90a0b3e4f9349533207026413186">AddFrame</a> (std::unique_ptr&lt; FrameType&lt; T &gt;&gt; frame)</td></tr>
<tr class="memdesc:a474c90a0b3e4f9349533207026413186"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds a <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> of type <code>FrameType&lt;T&gt;</code>.  <a href="#a474c90a0b3e4f9349533207026413186">More...</a><br /></td></tr>
<tr class="separator:a474c90a0b3e4f9349533207026413186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437f86026a2268c0fb06936b899ba8d7"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class JointType&gt; </td></tr>
<tr class="memitem:a437f86026a2268c0fb06936b899ba8d7"><td class="memTemplItemLeft" align="right" valign="top">const JointType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a437f86026a2268c0fb06936b899ba8d7">AddJoint</a> (std::unique_ptr&lt; JointType&lt; T &gt;&gt; joint)</td></tr>
<tr class="memdesc:a437f86026a2268c0fb06936b899ba8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <code>JointType</code> between two bodies.  <a href="#a437f86026a2268c0fb06936b899ba8d7">More...</a><br /></td></tr>
<tr class="separator:a437f86026a2268c0fb06936b899ba8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac828f1c818a0ed3f47ff5f342fa0ee0c"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class JointType, typename... Args&gt; </td></tr>
<tr class="memitem:ac828f1c818a0ed3f47ff5f342fa0ee0c"><td class="memTemplItemLeft" align="right" valign="top">const JointType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac828f1c818a0ed3f47ff5f342fa0ee0c">AddJoint</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;parent, const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;X_PF, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;child, const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;X_BM, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac828f1c818a0ed3f47ff5f342fa0ee0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <code>JointType</code> between two bodies.  <a href="#ac828f1c818a0ed3f47ff5f342fa0ee0c">More...</a><br /></td></tr>
<tr class="separator:ac828f1c818a0ed3f47ff5f342fa0ee0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48009c793b01c5a6dd079d33265435a3"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class ForceElementType, typename... Args&gt; </td></tr>
<tr class="memitem:a48009c793b01c5a6dd079d33265435a3"><td class="memTemplItemLeft" align="right" valign="top">const ForceElementType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a48009c793b01c5a6dd079d33265435a3">AddForceElement</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a48009c793b01c5a6dd079d33265435a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new force element model of type <code>ForceElementType</code> to <code>this</code> MultibodyPlant.  <a href="#a48009c793b01c5a6dd079d33265435a3">More...</a><br /></td></tr>
<tr class="separator:a48009c793b01c5a6dd079d33265435a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b73dad60ddee877aec7e1b5ea678b6"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class ForceElementType, typename... Args&gt; </td></tr>
<tr class="memitem:a63b73dad60ddee877aec7e1b5ea678b6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; ForceElementType&lt; T &gt;, <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html">UniformGravityFieldElement</a>&lt; T &gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const ForceElementType&lt; T &gt; &amp; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a63b73dad60ddee877aec7e1b5ea678b6">AddForceElement</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a63b73dad60ddee877aec7e1b5ea678b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5096160ffb18ddc72e2e29c0edfc5064"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5096160ffb18ddc72e2e29c0edfc5064">AddJointActuator</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;joint)</td></tr>
<tr class="memdesc:a5096160ffb18ddc72e2e29c0edfc5064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and adds a <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> model for an actuator acting on a given <code>joint</code>.  <a href="#a5096160ffb18ddc72e2e29c0edfc5064">More...</a><br /></td></tr>
<tr class="separator:a5096160ffb18ddc72e2e29c0edfc5064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edf1daa65069a26255c903b02bce4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4edf1daa65069a26255c903b02bce4c6">AddModelInstance</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:a4edf1daa65069a26255c903b02bce4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new model instance.  <a href="#a4edf1daa65069a26255c903b02bce4c6">More...</a><br /></td></tr>
<tr class="separator:a4edf1daa65069a26255c903b02bce4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eff4541522744b3ea5079c9ef1cbc3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html">WeldJoint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a63eff4541522744b3ea5079c9ef1cbc3">WeldFrames</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;B, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_AB=<a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::Identity())</td></tr>
<tr class="memdesc:a63eff4541522744b3ea5079c9ef1cbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Welds frames A and B with relative pose <code>X_AB</code>.  <a href="#a63eff4541522744b3ea5079c9ef1cbc3">More...</a><br /></td></tr>
<tr class="separator:a63eff4541522744b3ea5079c9ef1cbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Querying for multibody elements by name</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods allow a user to query whether a given multibody element is part of this plant's model.</p>
<p>These queries can be performed at any time during the lifetime of a MultibodyPlant model, i.e. there is no restriction on whether they must be called before or after <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. That is, these queries can be performed while new multibody elements are being added to the model. </p>
</div></td></tr>
<tr class="memitem:a89a198b6549e543018c7c9873d4e6dc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="separator:a89a198b6549e543018c7c9873d4e6dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5aa85a70a9f0f196091ed298266c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a2c5aa85a70a9f0f196091ed298266c57">HasBodyNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="separator:a2c5aa85a70a9f0f196091ed298266c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3530f8f6747cb603a24accba5901bd00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3530f8f6747cb603a24accba5901bd00">HasFrameNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="separator:a3530f8f6747cb603a24accba5901bd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab3a66ab482037c12c4d556800c550a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a7ab3a66ab482037c12c4d556800c550a">HasFrameNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="separator:a7ab3a66ab482037c12c4d556800c550a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c811258a0d93dd116d61648334a392"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a02c811258a0d93dd116d61648334a392">HasJointNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="separator:a02c811258a0d93dd116d61648334a392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ebee03109f4cb8990124949e97caa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac7ebee03109f4cb8990124949e97caa1">HasJointNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="separator:ac7ebee03109f4cb8990124949e97caa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dd7e61bafa3221193e7d68e4be7cbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a30dd7e61bafa3221193e7d68e4be7cbc">HasJointActuatorNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="separator:a30dd7e61bafa3221193e7d68e4be7cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6ad707643bf5220e76678e71291175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0f6ad707643bf5220e76678e71291175">HasJointActuatorNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="separator:a0f6ad707643bf5220e76678e71291175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b71664c8e2e91bc3fc92fef222a9bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a05b71664c8e2e91bc3fc92fef222a9bf">HasModelInstanceNamed</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="separator:a05b71664c8e2e91bc3fc92fef222a9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Retrieving multibody elements by name</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods allow a user to retrieve a reference to a multibody element by its name.</p>
<p>An exception is thrown if there is no element with the requested name. </p>
</div></td></tr>
<tr class="memitem:af3b40d661d83759731ad9a54553fc13f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af3b40d661d83759731ad9a54553fc13f">GetBodyByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:af3b40d661d83759731ad9a54553fc13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">These queries can be performed at any time during the lifetime of a MultibodyPlant, i.e.  <a href="#af3b40d661d83759731ad9a54553fc13f">More...</a><br /></td></tr>
<tr class="separator:af3b40d661d83759731ad9a54553fc13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d93818409f0144bb63248dc64a9130f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3d93818409f0144bb63248dc64a9130f">GetBodyByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a3d93818409f0144bb63248dc64a9130f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the body that is uniquely identified by the string <code>name</code> and <code>model_instance</code> in <code>this</code> MultibodyPlant.  <a href="#a3d93818409f0144bb63248dc64a9130f">More...</a><br /></td></tr>
<tr class="separator:a3d93818409f0144bb63248dc64a9130f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b557087f117859fd5246112f0d829cd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4b557087f117859fd5246112f0d829cd">GetFrameByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:a4b557087f117859fd5246112f0d829cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a frame that is identified by the string <code>name</code> in <code>this</code> model.  <a href="#a4b557087f117859fd5246112f0d829cd">More...</a><br /></td></tr>
<tr class="separator:a4b557087f117859fd5246112f0d829cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d552a24e1ad06c0b16004cec20fe94"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af4d552a24e1ad06c0b16004cec20fe94">GetFrameByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:af4d552a24e1ad06c0b16004cec20fe94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the frame that is uniquely identified by the string <code>name</code> in <code>model_instance</code>.  <a href="#af4d552a24e1ad06c0b16004cec20fe94">More...</a><br /></td></tr>
<tr class="separator:af4d552a24e1ad06c0b16004cec20fe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef21c2455a83e7a086df24f8411e26b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1ef21c2455a83e7a086df24f8411e26b">GetRigidBodyByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:a1ef21c2455a83e7a086df24f8411e26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a rigid body that is identified by the string <code>name</code> in <code>this</code> model.  <a href="#a1ef21c2455a83e7a086df24f8411e26b">More...</a><br /></td></tr>
<tr class="separator:a1ef21c2455a83e7a086df24f8411e26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1b9a39c20706b20221ea2c142d2cfd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0b1b9a39c20706b20221ea2c142d2cfd">GetRigidBodyByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a0b1b9a39c20706b20221ea2c142d2cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the rigid body that is uniquely identified by the string <code>name</code> in <code>model_instance</code>.  <a href="#a0b1b9a39c20706b20221ea2c142d2cfd">More...</a><br /></td></tr>
<tr class="separator:a0b1b9a39c20706b20221ea2c142d2cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72d95f825442702e3efb64787a80cb5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af72d95f825442702e3efb64787a80cb5">GetJointByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:af72d95f825442702e3efb64787a80cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a joint that is identified by the string <code>name</code> in <code>this</code> MultibodyPlant.  <a href="#af72d95f825442702e3efb64787a80cb5">More...</a><br /></td></tr>
<tr class="separator:af72d95f825442702e3efb64787a80cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049f388354fd2cd63faa9d0004f23c33"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a049f388354fd2cd63faa9d0004f23c33">GetJointByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a049f388354fd2cd63faa9d0004f23c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the joint that is uniquely identified by the string <code>name</code> and <code>model_instance</code> in <code>this</code> MultibodyPlant.  <a href="#a049f388354fd2cd63faa9d0004f23c33">More...</a><br /></td></tr>
<tr class="separator:a049f388354fd2cd63faa9d0004f23c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc8cfa422ad74560dd8a28fbf8296fa"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class JointType&gt; </td></tr>
<tr class="memitem:accc8cfa422ad74560dd8a28fbf8296fa"><td class="memTemplItemLeft" align="right" valign="top">const JointType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#accc8cfa422ad74560dd8a28fbf8296fa">GetJointByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:accc8cfa422ad74560dd8a28fbf8296fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A templated version of <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af72d95f825442702e3efb64787a80cb5" title="Returns a constant reference to a joint that is identified by the string name in this MultibodyPlant...">GetJointByName()</a> to return a constant reference of the specified type <code>JointType</code> in place of the base <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class.  <a href="#accc8cfa422ad74560dd8a28fbf8296fa">More...</a><br /></td></tr>
<tr class="separator:accc8cfa422ad74560dd8a28fbf8296fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222a13bd716a6b59b9393fcfef1c18ff"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class JointType&gt; </td></tr>
<tr class="memitem:a222a13bd716a6b59b9393fcfef1c18ff"><td class="memTemplItemLeft" align="right" valign="top">const JointType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a222a13bd716a6b59b9393fcfef1c18ff">GetJointByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a222a13bd716a6b59b9393fcfef1c18ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A templated version of <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af72d95f825442702e3efb64787a80cb5" title="Returns a constant reference to a joint that is identified by the string name in this MultibodyPlant...">GetJointByName()</a> to return a constant reference of the specified type <code>JointType</code> in place of the base <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class.  <a href="#a222a13bd716a6b59b9393fcfef1c18ff">More...</a><br /></td></tr>
<tr class="separator:a222a13bd716a6b59b9393fcfef1c18ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab835365a3c40185b23454f7e08cad083"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab835365a3c40185b23454f7e08cad083">GetJointActuatorByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:ab835365a3c40185b23454f7e08cad083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to an actuator that is identified by the string <code>name</code> in <code>this</code> MultibodyPlant.  <a href="#ab835365a3c40185b23454f7e08cad083">More...</a><br /></td></tr>
<tr class="separator:ab835365a3c40185b23454f7e08cad083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760fbe4384415d8cfd39c9e7e4f31422"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a760fbe4384415d8cfd39c9e7e4f31422">GetJointActuatorByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a760fbe4384415d8cfd39c9e7e4f31422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the actuator that is uniquely identified by the string <code>name</code> and <code>model_instance</code> in <code>this</code> MultibodyPlant.  <a href="#a760fbe4384415d8cfd39c9e7e4f31422">More...</a><br /></td></tr>
<tr class="separator:a760fbe4384415d8cfd39c9e7e4f31422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a177e855cc5efe12d15adc4c697930f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a2a177e855cc5efe12d15adc4c697930f">GetModelInstanceByName</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>) const</td></tr>
<tr class="memdesc:a2a177e855cc5efe12d15adc4c697930f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index to the model instance that is uniquely identified by the string <code>name</code> in <code>this</code> MultibodyPlant.  <a href="#a2a177e855cc5efe12d15adc4c697930f">More...</a><br /></td></tr>
<tr class="separator:a2a177e855cc5efe12d15adc4c697930f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Model instance accessors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Many of this class's methods expect vectors of tree state or joint actuator inputs which encompass the entire tree.</p>
<p>Methods in this section are convenience accessors for the portion of those vectors which apply to a single model instance only. </p>
</div></td></tr>
<tr class="memitem:aec851e17ae2c34da1b87a03ce85f460a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aec851e17ae2c34da1b87a03ce85f460a">SetActuationInArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;u_instance, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; u) const</td></tr>
<tr class="memdesc:aec851e17ae2c34da1b87a03ce85f460a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the actuation values <code>u_instance</code> for all actuators in <code>model_instance</code>, this method sets the actuation vector u for the entire model to which this actuator belongs to.  <a href="#aec851e17ae2c34da1b87a03ce85f460a">More...</a><br /></td></tr>
<tr class="separator:aec851e17ae2c34da1b87a03ce85f460a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8a17ef762452f820bdd351f8bb41b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9b8a17ef762452f820bdd351f8bb41b4">GetPositionsFromArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;q) const</td></tr>
<tr class="memdesc:a9b8a17ef762452f820bdd351f8bb41b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of generalized positions for <code>model_instance</code> from a vector <code>q_array</code> of generalized positions for the entire model model.  <a href="#a9b8a17ef762452f820bdd351f8bb41b4">More...</a><br /></td></tr>
<tr class="separator:a9b8a17ef762452f820bdd351f8bb41b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de72c319632f5a263fe6c9e96c70614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3de72c319632f5a263fe6c9e96c70614">SetPositionsInArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;q_instance, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; q) const</td></tr>
<tr class="memdesc:a3de72c319632f5a263fe6c9e96c70614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vector of generalized positions for <code>model_instance</code> in <code>q</code> using <code>q_instance</code>, leaving all other elements in the array untouched.  <a href="#a3de72c319632f5a263fe6c9e96c70614">More...</a><br /></td></tr>
<tr class="separator:a3de72c319632f5a263fe6c9e96c70614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7edf9b06b97e2f1b7045cc1d9f56f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aab7edf9b06b97e2f1b7045cc1d9f56f9">GetVelocitiesFromArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;v_array) const</td></tr>
<tr class="memdesc:aab7edf9b06b97e2f1b7045cc1d9f56f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of generalized velocities for <code>model_instance</code> from a vector <code>v</code> of generalized velocities for the entire <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> model.  <a href="#aab7edf9b06b97e2f1b7045cc1d9f56f9">More...</a><br /></td></tr>
<tr class="separator:aab7edf9b06b97e2f1b7045cc1d9f56f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e24d7263c7886bdf1adab111e34f33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aa3e24d7263c7886bdf1adab111e34f33">SetVelocitiesInArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;model_v, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; v_array) const</td></tr>
<tr class="memdesc:aa3e24d7263c7886bdf1adab111e34f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vector of generalized velocities for <code>model_instance</code> in <code>v</code> using <code>v_instance</code>, leaving all other elements in the array untouched.  <a href="#aa3e24d7263c7886bdf1adab111e34f33">More...</a><br /></td></tr>
<tr class="separator:aa3e24d7263c7886bdf1adab111e34f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing the state</div></td></tr>
<tr class="memitem:ac8acfdadb90c4901f9b66c41d2bfea0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac8acfdadb90c4901f9b66c41d2bfea0d">SetFreeBodyPoseInWorldFrame</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;X_WB) const</td></tr>
<tr class="memdesc:ac8acfdadb90c4901f9b66c41d2bfea0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>context</code> to store the pose <code>X_WB</code> of a given <code>body</code> B in the world frame W.  <a href="#ac8acfdadb90c4901f9b66c41d2bfea0d">More...</a><br /></td></tr>
<tr class="separator:ac8acfdadb90c4901f9b66c41d2bfea0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8eb477b56c4408f94ff5f3d4b4e47f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab8eb477b56c4408f94ff5f3d4b4e47f1">SetFreeBodyPoseInAnchoredFrame</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;X_FB) const</td></tr>
<tr class="memdesc:ab8eb477b56c4408f94ff5f3d4b4e47f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>context</code> to store the pose <code>X_FB</code> of a given <code>body</code> B in a frame F.  <a href="#ab8eb477b56c4408f94ff5f3d4b4e47f1">More...</a><br /></td></tr>
<tr class="separator:ab8eb477b56c4408f94ff5f3d4b4e47f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad807aa2b29b917462f14d0ca0dd7293f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad807aa2b29b917462f14d0ca0dd7293f">CalcRelativeTransform</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B) const</td></tr>
<tr class="memdesc:ad807aa2b29b917462f14d0ca0dd7293f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the relative transform <code>X_AB(q)</code> from a frame B to a frame A, as a function of the generalized positions q of the model.  <a href="#ad807aa2b29b917462f14d0ca0dd7293f">More...</a><br /></td></tr>
<tr class="separator:ad807aa2b29b917462f14d0ca0dd7293f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bce36db6170b2ed1ee53481f8017a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a27bce36db6170b2ed1ee53481f8017a5">CalcPointsPositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;p_BQi, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; p_AQi) const</td></tr>
<tr class="memdesc:a27bce36db6170b2ed1ee53481f8017a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the positions <code>p_BQi</code> for a set of points <code>Qi</code> measured and expressed in a frame B, this method computes the positions <code>p_AQi(q)</code> of each point <code>Qi</code> in the set as measured and expressed in another frame A, as a function of the generalized positions q of the model.  <a href="#a27bce36db6170b2ed1ee53481f8017a5">More...</a><br /></td></tr>
<tr class="separator:a27bce36db6170b2ed1ee53481f8017a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae776848d1a35d25966711e9df8ead6b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aae776848d1a35d25966711e9df8ead6b">EvalBodyPoseInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body_B) const</td></tr>
<tr class="memdesc:aae776848d1a35d25966711e9df8ead6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the pose <code>X_WB</code> of a body B in the world frame W.  <a href="#aae776848d1a35d25966711e9df8ead6b">More...</a><br /></td></tr>
<tr class="separator:aae776848d1a35d25966711e9df8ead6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8377774b012b4975b46941b3197f29c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8377774b012b4975b46941b3197f29c3">EvalBodySpatialVelocityInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body_B) const</td></tr>
<tr class="memdesc:a8377774b012b4975b46941b3197f29c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the spatial velocity <code>V_WB</code> of a body B in the world frame W.  <a href="#a8377774b012b4975b46941b3197f29c3">More...</a><br /></td></tr>
<tr class="separator:a8377774b012b4975b46941b3197f29c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28789d38fa6e3e0fc382fa3b0b0b882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae28789d38fa6e3e0fc382fa3b0b0b882">CalcPointsGeometricJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;p_FP_list, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; p_WP_list, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jv_WFp) const</td></tr>
<tr class="memdesc:ae28789d38fa6e3e0fc382fa3b0b0b882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of points with fixed position vectors <code>p_FP</code> in a frame F, (that is, their time derivative <code>DtF(p_FP)</code> in frame F is zero), this method computes the geometric Jacobian <code>Jv_WFp</code> defined by:  <a href="#ae28789d38fa6e3e0fc382fa3b0b0b882">More...</a><br /></td></tr>
<tr class="separator:ae28789d38fa6e3e0fc382fa3b0b0b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea824dec31f83e23d490b82be35b076a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aea824dec31f83e23d490b82be35b076a">CalcBiasForPointsGeometricJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;p_FP_list) const</td></tr>
<tr class="memdesc:aea824dec31f83e23d490b82be35b076a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bias term <code>b_WFp</code> associated with the translational acceleration <code>a_WFp</code> of a point <code>P</code> instantaneously moving with a frame F.  <a href="#aea824dec31f83e23d490b82be35b076a">More...</a><br /></td></tr>
<tr class="separator:aea824dec31f83e23d490b82be35b076a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4978894bc930fdb65827c03214ac9103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4978894bc930fdb65827c03214ac9103">CalcPointsGeometricJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;p_WP_list, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jv_WFp) const</td></tr>
<tr class="memdesc:a4978894bc930fdb65827c03214ac9103"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a variant to compute the geometric Jacobian <code>Jv_WFp</code> for a list of points <code>P</code> moving with <code>frame_F</code>, given that we know the position <code>p_WP</code> of each point in the list measured and expressed in the world frame W.  <a href="#a4978894bc930fdb65827c03214ac9103">More...</a><br /></td></tr>
<tr class="separator:a4978894bc930fdb65827c03214ac9103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08a137307614d55094430b858f0e8cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aa08a137307614d55094430b858f0e8cb">CalcPointsAnalyticalJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;p_FP_list, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; p_WP_list, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jq_WFp) const</td></tr>
<tr class="memdesc:aa08a137307614d55094430b858f0e8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of points with fixed position vectors <code>p_FP</code> in a frame F, (that is, their time derivative <code>DtF(p_FP)</code> in frame F is zero), this method computes the analytical Jacobian <code>Jq_WFp(q)</code>.  <a href="#aa08a137307614d55094430b858f0e8cb">More...</a><br /></td></tr>
<tr class="separator:aa08a137307614d55094430b858f0e8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45405f29fd8ad82a7459fd05642b329e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a45405f29fd8ad82a7459fd05642b329e">CalcFrameGeometricJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;p_FP, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jv_WFp) const</td></tr>
<tr class="memdesc:a45405f29fd8ad82a7459fd05642b329e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a frame <code>Fp</code> defined by shifting a frame F from its origin <code>Fo</code> to a new origin <code>P</code>, this method computes the geometric Jacobian <code>Jv_WFp</code> for frame <code>Fp</code>.  <a href="#a45405f29fd8ad82a7459fd05642b329e">More...</a><br /></td></tr>
<tr class="separator:a45405f29fd8ad82a7459fd05642b329e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9852a710b6fdd9e08d3bbc328485734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad9852a710b6fdd9e08d3bbc328485734">CalcRelativeFrameGeometricJacobian</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;p_BP, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jv_ABp_E) const</td></tr>
<tr class="memdesc:ad9852a710b6fdd9e08d3bbc328485734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the geometric Jacobian for a point moving with a given frame.  <a href="#ad9852a710b6fdd9e08d3bbc328485734">More...</a><br /></td></tr>
<tr class="separator:ad9852a710b6fdd9e08d3bbc328485734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfe3aca1ea2eba1caea19eb0bc0fb9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aecfe3aca1ea2eba1caea19eb0bc0fb9b">CalcBiasForFrameGeometricJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;p_FP) const</td></tr>
<tr class="memdesc:aecfe3aca1ea2eba1caea19eb0bc0fb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a frame <code>Fp</code> defined by shifting a frame F from its origin <code>Fo</code> to a new origin <code>P</code>, this method computes the bias term <code>Ab_WFp</code> associated with the spatial acceleration <code>A_WFp</code> a frame <code>Fp</code> instantaneously moving with a frame F at a fixed position <code>p_FP</code>.  <a href="#aecfe3aca1ea2eba1caea19eb0bc0fb9b">More...</a><br /></td></tr>
<tr class="separator:aecfe3aca1ea2eba1caea19eb0bc0fb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c0dbd7529fadcbf1fd550a9fd2e80b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a78c0dbd7529fadcbf1fd550a9fd2e80b">CalcJacobianSpatialVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;p_BP, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jw_ABp_E) const</td></tr>
<tr class="memdesc:a78c0dbd7529fadcbf1fd550a9fd2e80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian of spatial velocity for a frame instantaneously moving with a specified frame in the model.  <a href="#a78c0dbd7529fadcbf1fd550a9fd2e80b">More...</a><br /></td></tr>
<tr class="separator:a78c0dbd7529fadcbf1fd550a9fd2e80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa1c5393d7cab419a944009cc93aa6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aefa1c5393d7cab419a944009cc93aa6c">CalcSpatialAccelerationsFromVdot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;known_vdot, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&gt; *A_WB_array) const</td></tr>
<tr class="memdesc:aefa1c5393d7cab419a944009cc93aa6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the state of this model in <code>context</code> and a known vector of generalized accelerations <code>known_vdot</code>, this method computes the spatial acceleration <code>A_WB</code> for each body as measured and expressed in the world frame W.  <a href="#aefa1c5393d7cab419a944009cc93aa6c">More...</a><br /></td></tr>
<tr class="separator:aefa1c5393d7cab419a944009cc93aa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb4de9b58cb375d056da7e8ec30937a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#afcb4de9b58cb375d056da7e8ec30937a">CalcInverseDynamics</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;known_vdot, const <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; &amp;external_forces) const</td></tr>
<tr class="memdesc:afcb4de9b58cb375d056da7e8ec30937a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the state of this model in <code>context</code> and a known vector of generalized accelerations <code>vdot</code>, this method computes the set of generalized forces <code>tau</code> that would need to be applied in order to attain the specified generalized accelerations.  <a href="#afcb4de9b58cb375d056da7e8ec30937a">More...</a><br /></td></tr>
<tr class="separator:afcb4de9b58cb375d056da7e8ec30937a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b54c8562f107e4d6e11b4b0f8d53c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae1b54c8562f107e4d6e11b4b0f8d53c5">CalcForceElementsContribution</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; *forces) const</td></tr>
<tr class="memdesc:ae1b54c8562f107e4d6e11b4b0f8d53c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the combined force contribution of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> objects in the model.  <a href="#ae1b54c8562f107e4d6e11b4b0f8d53c5">More...</a><br /></td></tr>
<tr class="separator:ae1b54c8562f107e4d6e11b4b0f8d53c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35681a2d7d9d4026b6bc61f08da861f8"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a35681a2d7d9d4026b6bc61f08da861f8">CalcPotentialEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a35681a2d7d9d4026b6bc61f08da861f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the total potential energy stored in <code>this</code> multibody model for the configuration given by <code>context</code>.  <a href="#a35681a2d7d9d4026b6bc61f08da861f8">More...</a><br /></td></tr>
<tr class="separator:a35681a2d7d9d4026b6bc61f08da861f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d32c695cacd92615cb9b3773a17eb9"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af5d32c695cacd92615cb9b3773a17eb9">CalcConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:af5d32c695cacd92615cb9b3773a17eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the power generated by conservative forces in the multibody model.  <a href="#af5d32c695cacd92615cb9b3773a17eb9">More...</a><br /></td></tr>
<tr class="separator:af5d32c695cacd92615cb9b3773a17eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843e1ba389c017c706df10935784b4e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a843e1ba389c017c706df10935784b4e5">CalcBiasTerm</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; Cv) const</td></tr>
<tr class="memdesc:a843e1ba389c017c706df10935784b4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bias term <code>C(q, v)v</code> containing Coriolis and gyroscopic effects of the multibody equations of motion:  <a href="#a843e1ba389c017c706df10935784b4e5">More...</a><br /></td></tr>
<tr class="separator:a843e1ba389c017c706df10935784b4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad877d988ac4cd1942aa84e91e3c5d49a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad877d988ac4cd1942aa84e91e3c5d49a">CalcGravityGeneralizedForces</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:ad877d988ac4cd1942aa84e91e3c5d49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the generalized forces <code>tau_g(q)</code> due to gravity as a function of the generalized positions <code>q</code> stored in the input <code>context</code>.  <a href="#ad877d988ac4cd1942aa84e91e3c5d49a">More...</a><br /></td></tr>
<tr class="separator:ad877d988ac4cd1942aa84e91e3c5d49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb24fed19f16a76450eece1857b92dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a7bb24fed19f16a76450eece1857b92dc">MapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;v, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; qdot) const</td></tr>
<tr class="memdesc:a7bb24fed19f16a76450eece1857b92dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms generalized velocities v to time derivatives <code>qdot</code> of the generalized positions vector <code>q</code> (stored in <code>context</code>).  <a href="#a7bb24fed19f16a76450eece1857b92dc">More...</a><br /></td></tr>
<tr class="separator:a7bb24fed19f16a76450eece1857b92dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab128a8bba10523922358bc35df103753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab128a8bba10523922358bc35df103753">MapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;qdot, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; v) const</td></tr>
<tr class="memdesc:ab128a8bba10523922358bc35df103753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the time derivative <code>qdot</code> of the generalized positions vector <code>q</code> (stored in <code>context</code>) to generalized velocities <code>v</code>.  <a href="#ab128a8bba10523922358bc35df103753">More...</a><br /></td></tr>
<tr class="separator:ab128a8bba10523922358bc35df103753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7b2e7b0c09b6479d25250405ffd0c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5c7b2e7b0c09b6479d25250405ffd0c4">MakeStateSelectorMatrix</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;user_to_joint_index_map) const</td></tr>
<tr class="memdesc:a5c7b2e7b0c09b6479d25250405ffd0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows users to map the state of <code>this</code> model, x, into a vector of selected state xₛ with a given preferred ordering.  <a href="#a5c7b2e7b0c09b6479d25250405ffd0c4">More...</a><br /></td></tr>
<tr class="separator:a5c7b2e7b0c09b6479d25250405ffd0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7f5496735d233ea0b984c5a290671f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0d7f5496735d233ea0b984c5a290671f">MakeActuatorSelectorMatrix</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> &gt; &amp;user_to_actuator_index_map) const</td></tr>
<tr class="memdesc:a0d7f5496735d233ea0b984c5a290671f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows user to map a vector <code>uₛ</code> containing the actuation for a set of selected actuators into the vector u containing the actuation values for <code>this</code> full model.  <a href="#a0d7f5496735d233ea0b984c5a290671f">More...</a><br /></td></tr>
<tr class="separator:a0d7f5496735d233ea0b984c5a290671f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029244fdbe2f10a7bfaf5c21175d834c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a029244fdbe2f10a7bfaf5c21175d834c">MakeActuatorSelectorMatrix</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;user_to_joint_index_map) const</td></tr>
<tr class="memdesc:a029244fdbe2f10a7bfaf5c21175d834c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative signature to build an actuation selector matrix <code>Su</code> such that <code>u = Su⋅uₛ</code>, where u is the vector of actuation values for the full model (ordered by JointActuatorIndex) and uₛ is a vector of actuation values for the actuators acting on the joints listed by <code>user_to_joint_index_map</code>.  <a href="#a029244fdbe2f10a7bfaf5c21175d834c">More...</a><br /></td></tr>
<tr class="separator:a029244fdbe2f10a7bfaf5c21175d834c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3238273c2c927101e4515147bed17f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac3238273c2c927101e4515147bed17f6">CalcMassMatrixViaInverseDynamics</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; H) const</td></tr>
<tr class="memdesc:ac3238273c2c927101e4515147bed17f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the computation of the mass matrix <code>M(q)</code> of the model using inverse dynamics, where the generalized positions q are stored in <code>context</code>.  <a href="#ac3238273c2c927101e4515147bed17f6">More...</a><br /></td></tr>
<tr class="separator:ac3238273c2c927101e4515147bed17f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Retrieving ports for communication with a SceneGraph.</div></td></tr>
<tr class="memitem:aef692dc2241640a308801f7dfae902ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake_1_1geometry.html#a32581e3a9c8879bcf23192e248df49c7">geometry::SourceId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aef692dc2241640a308801f7dfae902ba">get_source_id</a> () const</td></tr>
<tr class="memdesc:aef692dc2241640a308801f7dfae902ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique id identifying <code>this</code> plant as a source for a SceneGraph.  <a href="#aef692dc2241640a308801f7dfae902ba">More...</a><br /></td></tr>
<tr class="separator:aef692dc2241640a308801f7dfae902ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d417c47f17405fb748b5bb02140bcd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a38d417c47f17405fb748b5bb02140bcd">get_geometry_query_input_port</a> () const</td></tr>
<tr class="memdesc:a38d417c47f17405fb748b5bb02140bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the input port used to perform geometric queries on a SceneGraph.  <a href="#a38d417c47f17405fb748b5bb02140bcd">More...</a><br /></td></tr>
<tr class="separator:a38d417c47f17405fb748b5bb02140bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89666082450a254fc4feda5aae4d01e0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89666082450a254fc4feda5aae4d01e0">get_geometry_poses_output_port</a> () const</td></tr>
<tr class="memdesc:a89666082450a254fc4feda5aae4d01e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output port of frames' poses to communicate with a SceneGraph.  <a href="#a89666082450a254fc4feda5aae4d01e0">More...</a><br /></td></tr>
<tr class="separator:a89666082450a254fc4feda5aae4d01e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Actuation input</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The input vector of actuation values can be provided either as a single input port which describes the entire plant (in the case where only a single model instance has actuated dofs), or through multiple input ports which each provide the actuation values for a specific model instance.</p>
<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5096160ffb18ddc72e2e29c0edfc5064" title="Creates and adds a JointActuator model for an actuator acting on a given joint. ">AddJointActuator()</a> and <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8601c026e9807127b4dd41e7585d2cfc" title="Returns the number of joint actuators in the model. ">num_actuators()</a>. </p>
</div></td></tr>
<tr class="memitem:a69ef9262ffab02b34bdf20449aab7551"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a69ef9262ffab02b34bdf20449aab7551">get_actuation_input_port</a> () const</td></tr>
<tr class="memdesc:a69ef9262ffab02b34bdf20449aab7551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the input port for external actuation for the case where only one model instance has actuated dofs.  <a href="#a69ef9262ffab02b34bdf20449aab7551">More...</a><br /></td></tr>
<tr class="separator:a69ef9262ffab02b34bdf20449aab7551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776f6189a7a33efee4aed2a9135f5150"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a776f6189a7a33efee4aed2a9135f5150">get_actuation_input_port</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a776f6189a7a33efee4aed2a9135f5150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the input port for external actuation for a specific model instance.  <a href="#a776f6189a7a33efee4aed2a9135f5150">More...</a><br /></td></tr>
<tr class="separator:a776f6189a7a33efee4aed2a9135f5150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Continuous state output</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Output ports are provided to access the continuous state of the whole plant and for individual model instances. </p>
</div></td></tr>
<tr class="memitem:aa51493ea8545a5f1b985076dd783bf23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aa51493ea8545a5f1b985076dd783bf23">get_continuous_state_output_port</a> () const</td></tr>
<tr class="memdesc:aa51493ea8545a5f1b985076dd783bf23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port for the full continuous state of the model.  <a href="#aa51493ea8545a5f1b985076dd783bf23">More...</a><br /></td></tr>
<tr class="separator:aa51493ea8545a5f1b985076dd783bf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c4a71ba69cecc95f478584e176775e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a44c4a71ba69cecc95f478584e176775e">get_continuous_state_output_port</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a44c4a71ba69cecc95f478584e176775e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port for the continuous state of a specific model instance.  <a href="#a44c4a71ba69cecc95f478584e176775e">More...</a><br /></td></tr>
<tr class="separator:a44c4a71ba69cecc95f478584e176775e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Contact by penalty method</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="mbp_penalty_method"></a></p>
<p>Currently MultibodyPlant uses a rigid contact model that is, bodies in the model are infinitely stiff or ideal rigid bodies. Therefore, the mathematical description of the rigid contact model needs to include non-penetration constraints among bodies in the formulation. There are several numerical methods to impose and solve these constraints. In a penalty method approach, we allow for a certain amount of interpenetration and we compute contact forces according to a simple law of the form: </p><pre>
  fₙ = k(1+dẋ)x
</pre><p> where the normal contact force <code>fₙ</code> is made a continuous function of the penetration distance x between the bodies (defined to be positive when the bodies are in contact) and the penetration distance rate ẋ (with ẋ &gt; 0 meaning the penetration distance is increasing and therefore the interpenetration between the bodies is also increasing). k and d are the penalty method coefficients for stiffness and damping. These are ad-hoc parameters which need to be tuned as a trade-off between:</p><ul>
<li>The accuracy of the numerical approximation to rigid contact, which requires a stiffness that approaches infinity, and</li>
<li>the computational cost of the numerical integration, which will require smaller time steps for stiffer systems.</li>
</ul>
<p>There is no exact procedure for choosing these coefficients, and estimating them manually can be cumbersome since in general they will depend on the scale of the problem including masses, speeds and even body sizes. However, MultibodyPlant aids the estimation of these coefficients using a heuristic function based on a user-supplied "penetration allowance", see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8cdb3408c412b2af94476886dc35cc71" title="Sets the penetration allowance used to estimate the coefficients in the penalty method used to impose...">set_penetration_allowance()</a>. The penetration allowance is a number in meters that specifies the order of magnitude of the average penetration between bodies in the system that the user is willing to accept as reasonable for the problem being solved. For instance, in the robotics manipulation of ordinary daily objects the user might set this number to 1 millimeter. However, the user might want to increase it for the simulation of heavy walking robots for which an allowance of 1 millimeter would result in a very stiff system.</p>
<p>As for the damping coefficient in the simple law above, MultibodyPlant chooses the damping coefficient d to model inelastic collisions and therefore sets it so that the penetration distance x behaves as a critically damped oscillator. That is, at the limit of ideal rigid contact (very stiff penalty coefficient k or equivalently the penetration allowance goes to zero), this method behaves as a unilateral constraint on the penetration distance, which models a perfect inelastic collision. For most applications, such as manipulation and walking, this is the desired behavior.</p>
<p>When <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8cdb3408c412b2af94476886dc35cc71" title="Sets the penetration allowance used to estimate the coefficients in the penalty method used to impose...">set_penetration_allowance()</a> is called, MultibodyPlant will estimate reasonable penalty method coefficients as a function of the input penetration allowance. Users will want to run their simulation a number of times and asses they are satisfied with the level of inter-penetration actually observed in the simulation; if the observed penetration is too large, the user will want to set a smaller penetration allowance. If the system is too stiff and the time integration requires very small time steps while at the same time the user can afford larger inter-penetrations, the user will want to increase the penetration allowance. Typically, the observed penetration will be proportional to the penetration allowance. Thus scaling the penetration allowance by say a factor of 0.5, would typically results in inter-penetrations being reduced by the same factor of 0.5. In summary, users should choose the largest penetration allowance that results in inter-penetration levels that are acceptable for the particular application (even when in theory this penetration should be zero for perfectly rigid bodies.)</p>
<p>For a given penetration allowance, the contact interaction that takes two bodies with a non-zero approaching velocity to zero approaching velocity, takes place in a finite amount of time (for ideal rigid contact this time is zero.) A good estimate of this time period is given by a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3338392f611d5d9f93d0ea90e172c68c" title="Returns a time-scale estimate tc based on the requested penetration allowance δ set with set_penetrat...">get_contact_penalty_method_time_scale()</a>. Users might want to query this value to either set the maximum time step in error-controlled time integration or to set the time step for fixed time step integration. As a guidance, typical fixed time step integrators will become unstable for time steps larger than about a tenth of this time scale. </p>
</div></td></tr>
<tr class="memitem:a8cdb3408c412b2af94476886dc35cc71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8cdb3408c412b2af94476886dc35cc71">set_penetration_allowance</a> (<a class="el" href="classdouble.html">double</a> penetration_allowance=0.001)</td></tr>
<tr class="memdesc:a8cdb3408c412b2af94476886dc35cc71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the penetration allowance used to estimate the coefficients in the penalty method used to impose non-penetration among bodies.  <a href="#a8cdb3408c412b2af94476886dc35cc71">More...</a><br /></td></tr>
<tr class="separator:a8cdb3408c412b2af94476886dc35cc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3338392f611d5d9f93d0ea90e172c68c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3338392f611d5d9f93d0ea90e172c68c">get_contact_penalty_method_time_scale</a> () const</td></tr>
<tr class="memdesc:a3338392f611d5d9f93d0ea90e172c68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a time-scale estimate <code>tc</code> based on the requested penetration allowance δ set with <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8cdb3408c412b2af94476886dc35cc71" title="Sets the penetration allowance used to estimate the coefficients in the penalty method used to impose...">set_penetration_allowance()</a>.  <a href="#a3338392f611d5d9f93d0ea90e172c68c">More...</a><br /></td></tr>
<tr class="separator:a3338392f611d5d9f93d0ea90e172c68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stribeck model of friction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="mbp_stribeck_model"></a></p>
<p>Currently MultibodyPlant uses the Stribeck approximation to model dry friction. The Stribeck model of friction is an approximation to Coulomb's law of friction that allows using continuous time integration without the need to specify complementarity constraints. While this results in a simpler model immediately tractable with standard numerical methods for integration of ODE's, it often leads to stiff dynamics that require an explicit integrator to take very small time steps. It is therefore recommended to use error controlled integrators when using this model. See <a class="el" href="group__contact__model__background.html#tangent_force">tangent_force</a> for a detailed discussion of the Stribeck model. </p>
</div></td></tr>
<tr class="memitem:a3ce165180ba1d40e2a120eea631e4cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3ce165180ba1d40e2a120eea631e4cb1">set_stiction_tolerance</a> (<a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#acf0ce0b0857d1863bf05a03ceca04164">v_stiction</a>=0.001)</td></tr>
<tr class="memdesc:a3ce165180ba1d40e2a120eea631e4cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stiction tolerance <code>v_stiction</code> for the Stribeck model, where <code>v_stiction</code> must be specified in m/s (meters per second.) <code>v_stiction</code> defaults to a value of 1 millimeter per second.  <a href="#a3ce165180ba1d40e2a120eea631e4cb1">More...</a><br /></td></tr>
<tr class="separator:a3ce165180ba1d40e2a120eea631e4cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html">MultibodyTreeSystem&lt; T &gt;</a></td></tr>
<tr class="memitem:a29ac82c4ca3b12b3935919a40fcdfc87 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a29ac82c4ca3b12b3935919a40fcdfc87">MultibodyTreeSystem</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; T &gt;&gt; <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a875f49ab037712aeeeddd091161bee45">tree</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#ac87e33717da832d66c6587cac66f56a9">is_discrete</a>=false)</td></tr>
<tr class="memdesc:a29ac82c4ca3b12b3935919a40fcdfc87 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of the given <code>tree</code>, finalizes it if it hasn't already been finalized, and then allocates the resources it needs.  <a href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a29ac82c4ca3b12b3935919a40fcdfc87">More...</a><br /></td></tr>
<tr class="separator:a29ac82c4ca3b12b3935919a40fcdfc87 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af312ef47f7435c49a29dbf2e2224836b inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:af312ef47f7435c49a29dbf2e2224836b inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#af312ef47f7435c49a29dbf2e2224836b">MultibodyTreeSystem</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html">MultibodyTreeSystem</a>&lt; U &gt; &amp;other)</td></tr>
<tr class="memdesc:af312ef47f7435c49a29dbf2e2224836b inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar-converting copy constructor.  <a href="classdrake_1_1multibody_1_1_multibody_tree_system.html#af312ef47f7435c49a29dbf2e2224836b">More...</a><br /></td></tr>
<tr class="separator:af312ef47f7435c49a29dbf2e2224836b inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac880a9afb311815456efc733e8840d18 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#ac880a9afb311815456efc733e8840d18">~MultibodyTreeSystem</a> () override</td></tr>
<tr class="separator:ac880a9afb311815456efc733e8840d18 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87e33717da832d66c6587cac66f56a9 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#ac87e33717da832d66c6587cac66f56a9">is_discrete</a> () const</td></tr>
<tr class="separator:ac87e33717da832d66c6587cac66f56a9 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875f49ab037712aeeeddd091161bee45 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a875f49ab037712aeeeddd091161bee45">tree</a> () const</td></tr>
<tr class="memdesc:a875f49ab037712aeeeddd091161bee45 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the MultibodyTree owned by this class.  <a href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a875f49ab037712aeeeddd091161bee45">More...</a><br /></td></tr>
<tr class="separator:a875f49ab037712aeeeddd091161bee45 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed59e6f62bfe30a418ba8d8c611580af inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_position_kinematics_cache.html">PositionKinematicsCache</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#aed59e6f62bfe30a418ba8d8c611580af">EvalPositionKinematics</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aed59e6f62bfe30a418ba8d8c611580af inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the up to date <a class="el" href="classdrake_1_1multibody_1_1_position_kinematics_cache.html" title="This class is one of the cache entries in MultibodyTreeContext. ">PositionKinematicsCache</a> in the given Context, recalculating it first if necessary.  <a href="classdrake_1_1multibody_1_1_multibody_tree_system.html#aed59e6f62bfe30a418ba8d8c611580af">More...</a><br /></td></tr>
<tr class="separator:aed59e6f62bfe30a418ba8d8c611580af inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0adc712bc2d51f9aa758e8d726276d inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_velocity_kinematics_cache.html">VelocityKinematicsCache</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a4d0adc712bc2d51f9aa758e8d726276d">EvalVelocityKinematics</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a4d0adc712bc2d51f9aa758e8d726276d inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the up to date <a class="el" href="classdrake_1_1multibody_1_1_velocity_kinematics_cache.html" title="This class is one of the cache entries in MultibodyTreeContext. ">VelocityKinematicsCache</a> in the given Context, recalculating it first if necessary.  <a href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a4d0adc712bc2d51f9aa758e8d726276d">More...</a><br /></td></tr>
<tr class="separator:a4d0adc712bc2d51f9aa758e8d726276d inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a296ea2a70b845483acb332f7c44d84 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a9a296ea2a70b845483acb332f7c44d84">EvalAcrossNodeGeometricJacobianExpressedInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a9a296ea2a70b845483acb332f7c44d84 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the up to date cached value for the across-mobilizer geometric Jacobian H_PB_W in the given Context, recalculating it first if necessary.  <a href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a9a296ea2a70b845483acb332f7c44d84">More...</a><br /></td></tr>
<tr class="separator:a9a296ea2a70b845483acb332f7c44d84 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa86dec781683d58a9af99f0cd06458f inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#afa86dec781683d58a9af99f0cd06458f">MultibodyTreeSystem</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html">MultibodyTreeSystem</a> &amp;)=delete</td></tr>
<tr class="separator:afa86dec781683d58a9af99f0cd06458f inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec1847132ec9aeb97f6166dfdebea8d inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html">MultibodyTreeSystem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8ec1847132ec9aeb97f6166dfdebea8d">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html">MultibodyTreeSystem</a> &amp;)=delete</td></tr>
<tr class="separator:a8ec1847132ec9aeb97f6166dfdebea8d inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dee8714f8225a8d3c8247c0298f4e1 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a64dee8714f8225a8d3c8247c0298f4e1">MultibodyTreeSystem</a> (<a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html">MultibodyTreeSystem</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a64dee8714f8225a8d3c8247c0298f4e1 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af851ed6b21a1bb20017e483838256af8 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html">MultibodyTreeSystem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#af851ed6b21a1bb20017e483838256af8">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html">MultibodyTreeSystem</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:af851ed6b21a1bb20017e483838256af8 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1systems_1_1_leaf_system"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdrake_1_1systems_1_1_leaf_system')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html">LeafSystem&lt; T &gt;</a></td></tr>
<tr class="memitem:a5341fd0b682386ac7623a65a898b48a0 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5341fd0b682386ac7623a65a898b48a0">~LeafSystem</a> () override</td></tr>
<tr class="separator:a5341fd0b682386ac7623a65a898b48a0 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc6a1bfa8837ee9da5b26173e1bffe1 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5dc6a1bfa8837ee9da5b26173e1bffe1">AllocateCompositeEventCollection</a> () const final</td></tr>
<tr class="memdesc:a5dc6a1bfa8837ee9da5b26173e1bffe1 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html" title="This class bundles an instance of each EventCollection&lt;EventType&gt; into one object that stores the het...">CompositeEventCollection</a> object for this system.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a5dc6a1bfa8837ee9da5b26173e1bffe1">More...</a><br /></td></tr>
<tr class="separator:a5dc6a1bfa8837ee9da5b26173e1bffe1 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73802c567b68a8eefc411e56493d6a93 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_leaf_context.html">LeafContext</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a73802c567b68a8eefc411e56493d6a93">AllocateContext</a> () const</td></tr>
<tr class="memdesc:a73802c567b68a8eefc411e56493d6a93 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadows <a class="el" href="classdrake_1_1systems_1_1_system.html#a07c386a39241bbd79236c7701d370d7e" title="Returns a Context&lt;T&gt; suitable for use with this System&lt;T&gt;. ">System&lt;T&gt;::AllocateContext</a> to provide a more concrete return type LeafContext&lt;T&gt;.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a73802c567b68a8eefc411e56493d6a93">More...</a><br /></td></tr>
<tr class="separator:a73802c567b68a8eefc411e56493d6a93 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd8db89a6261ad463d9184385bb7e22 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#adbd8db89a6261ad463d9184385bb7e22">DoAllocateContext</a> () const final</td></tr>
<tr class="memdesc:adbd8db89a6261ad463d9184385bb7e22 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class implementations should allocate a suitable concrete <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> type, then invoke the above <a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0eb74936487f1ae4658b54979195fa1b" title="This method must be invoked from within derived class DoAllocateContext() implementations right after...">InitializeContextBase()</a> method.  <a href="classdrake_1_1systems_1_1_leaf_system.html#adbd8db89a6261ad463d9184385bb7e22">More...</a><br /></td></tr>
<tr class="separator:adbd8db89a6261ad463d9184385bb7e22 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac920e22e905b83dbc0abaaa57d2c0251 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ac920e22e905b83dbc0abaaa57d2c0251">SetDefaultState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const override</td></tr>
<tr class="memdesc:ac920e22e905b83dbc0abaaa57d2c0251 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation: sets all continuous state to the model vector given in DeclareContinuousState (or zero if no model vector was given) and discrete states to zero.  <a href="classdrake_1_1systems_1_1_leaf_system.html#ac920e22e905b83dbc0abaaa57d2c0251">More...</a><br /></td></tr>
<tr class="separator:ac920e22e905b83dbc0abaaa57d2c0251 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a5a76172d2c18e3ac495b44c866c1b inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a48a5a76172d2c18e3ac495b44c866c1b">SetDefaultParameters</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; *parameters) const override</td></tr>
<tr class="memdesc:a48a5a76172d2c18e3ac495b44c866c1b inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation: sets all numeric parameters to the model vector given to DeclareNumericParameter, or else if no model was provided sets the numeric parameter to one.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a48a5a76172d2c18e3ac495b44c866c1b">More...</a><br /></td></tr>
<tr class="separator:a48a5a76172d2c18e3ac495b44c866c1b inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa396d162f35ef250bf092d1340c01231 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#aa396d162f35ef250bf092d1340c01231">AllocateTimeDerivatives</a> () const override</td></tr>
<tr class="memdesc:aa396d162f35ef250bf092d1340c01231 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the AllocateContinuousState value, which must not be nullptr.  <a href="classdrake_1_1systems_1_1_leaf_system.html#aa396d162f35ef250bf092d1340c01231">More...</a><br /></td></tr>
<tr class="separator:aa396d162f35ef250bf092d1340c01231 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81279e22a18e2e563b7343c23ca80bb5 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a81279e22a18e2e563b7343c23ca80bb5">AllocateDiscreteVariables</a> () const override</td></tr>
<tr class="memdesc:a81279e22a18e2e563b7343c23ca80bb5 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the AllocateDiscreteState value, which must not be nullptr.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a81279e22a18e2e563b7343c23ca80bb5">More...</a><br /></td></tr>
<tr class="separator:a81279e22a18e2e563b7343c23ca80bb5 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83479e1867e83638b90266c1aed0b6a3 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">std::multimap&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a83479e1867e83638b90266c1aed0b6a3">GetDirectFeedthroughs</a> () const final</td></tr>
<tr class="memdesc:a83479e1867e83638b90266c1aed0b6a3 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports all direct feedthroughs from input ports to output ports.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a83479e1867e83638b90266c1aed0b6a3">More...</a><br /></td></tr>
<tr class="separator:a83479e1867e83638b90266c1aed0b6a3 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1080d4d1447a12437ab9287351ec2a70 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a1080d4d1447a12437ab9287351ec2a70">get_num_continuous_states</a> () const final</td></tr>
<tr class="memdesc:a1080d4d1447a12437ab9287351ec2a70 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the continuous state vector that has been declared until now.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a1080d4d1447a12437ab9287351ec2a70">More...</a><br /></td></tr>
<tr class="separator:a1080d4d1447a12437ab9287351ec2a70 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f991cb29747da6cf7ec11421ac8a7f inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#af6f991cb29747da6cf7ec11421ac8a7f">LeafSystem</a> (const <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html">LeafSystem</a> &amp;)=delete</td></tr>
<tr class="separator:af6f991cb29747da6cf7ec11421ac8a7f inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5ff32e4a40707c73a10a0ea24029c0 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html">LeafSystem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a2a5ff32e4a40707c73a10a0ea24029c0">operator=</a> (const <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html">LeafSystem</a> &amp;)=delete</td></tr>
<tr class="separator:a2a5ff32e4a40707c73a10a0ea24029c0 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8c318bfb59f3894c0bbd0e0bdf8d22 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a9d8c318bfb59f3894c0bbd0e0bdf8d22">LeafSystem</a> (<a class="el" href="classdrake_1_1systems_1_1_leaf_system.html">LeafSystem</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a9d8c318bfb59f3894c0bbd0e0bdf8d22 inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e17a9a1a303fb56956cfe9e989ca2f inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html">LeafSystem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a28e17a9a1a303fb56956cfe9e989ca2f">operator=</a> (<a class="el" href="classdrake_1_1systems_1_1_leaf_system.html">LeafSystem</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a28e17a9a1a303fb56956cfe9e989ca2f inherit pub_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1systems_1_1_system"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdrake_1_1systems_1_1_system')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_system.html">System&lt; T &gt;</a></td></tr>
<tr class="memitem:a3773fa71e3bc321a65cc8690b9291d14 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a3773fa71e3bc321a65cc8690b9291d14">~System</a> () override=default</td></tr>
<tr class="separator:a3773fa71e3bc321a65cc8690b9291d14 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9811579b88aa9f5e5524c980f354fe inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a5c9811579b88aa9f5e5524c980f354fe">GetWitnessFunctions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; *&gt; *w) const</td></tr>
<tr class="memdesc:a5c9811579b88aa9f5e5524c980f354fe inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the witness functions active for the given state.  <a href="classdrake_1_1systems_1_1_system.html#a5c9811579b88aa9f5e5524c980f354fe">More...</a><br /></td></tr>
<tr class="separator:a5c9811579b88aa9f5e5524c980f354fe inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2949deb61db7903dae4c0b7cb9633fac inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a2949deb61db7903dae4c0b7cb9633fac">CalcWitnessValue</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &amp;witness_func) const</td></tr>
<tr class="memdesc:a2949deb61db7903dae4c0b7cb9633fac inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a witness function at the given context.  <a href="classdrake_1_1systems_1_1_system.html#a2949deb61db7903dae4c0b7cb9633fac">More...</a><br /></td></tr>
<tr class="separator:a2949deb61db7903dae4c0b7cb9633fac inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718e74eb516f658aa9f80ab77706e4e5 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a718e74eb516f658aa9f80ab77706e4e5">System</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> &amp;)=delete</td></tr>
<tr class="separator:a718e74eb516f658aa9f80ab77706e4e5 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a193dfa5e776f4c271dbb37a6bd03f5 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a0a193dfa5e776f4c271dbb37a6bd03f5">operator=</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> &amp;)=delete</td></tr>
<tr class="separator:a0a193dfa5e776f4c271dbb37a6bd03f5 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e42f15501f79c6a60375041a7e3729 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a51e42f15501f79c6a60375041a7e3729">System</a> (<a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a51e42f15501f79c6a60375041a7e3729 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64a17bc4243a6ba605108281c6519de inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ac64a17bc4243a6ba605108281c6519de">operator=</a> (<a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac64a17bc4243a6ba605108281c6519de inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c386a39241bbd79236c7701d370d7e inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a07c386a39241bbd79236c7701d370d7e">AllocateContext</a> () const</td></tr>
<tr class="memdesc:a07c386a39241bbd79236c7701d370d7e inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Context&lt;T&gt; suitable for use with this System&lt;T&gt;.  <a href="classdrake_1_1systems_1_1_system.html#a07c386a39241bbd79236c7701d370d7e">More...</a><br /></td></tr>
<tr class="separator:a07c386a39241bbd79236c7701d370d7e inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7d64d658e5fb67234d9ffc918155bd inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a6c7d64d658e5fb67234d9ffc918155bd">AllocateInputVector</a> (const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;input_port) const</td></tr>
<tr class="memdesc:a6c7d64d658e5fb67234d9ffc918155bd inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input port, allocates the vector storage.  <a href="classdrake_1_1systems_1_1_system.html#a6c7d64d658e5fb67234d9ffc918155bd">More...</a><br /></td></tr>
<tr class="separator:a6c7d64d658e5fb67234d9ffc918155bd inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a50463e995d1d3e414ade7051c3458a inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">AbstractValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a3a50463e995d1d3e414ade7051c3458a">AllocateInputAbstract</a> (const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;input_port) const</td></tr>
<tr class="memdesc:a3a50463e995d1d3e414ade7051c3458a inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input port, allocates the abstract storage.  <a href="classdrake_1_1systems_1_1_system.html#a3a50463e995d1d3e414ade7051c3458a">More...</a><br /></td></tr>
<tr class="separator:a3a50463e995d1d3e414ade7051c3458a inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b7d1592da75535d37841d338ec39be inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a52b7d1592da75535d37841d338ec39be">AllocateOutput</a> () const</td></tr>
<tr class="memdesc:a52b7d1592da75535d37841d338ec39be inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container that can hold the values of all of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>'s output ports.  <a href="classdrake_1_1systems_1_1_system.html#a52b7d1592da75535d37841d338ec39be">More...</a><br /></td></tr>
<tr class="separator:a52b7d1592da75535d37841d338ec39be inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad047317ab91889c6743d5e47a64c7f08 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ad047317ab91889c6743d5e47a64c7f08">CreateDefaultContext</a> () const</td></tr>
<tr class="memdesc:ad047317ab91889c6743d5e47a64c7f08 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This convenience method allocates a context using <a class="el" href="classdrake_1_1systems_1_1_system.html#a07c386a39241bbd79236c7701d370d7e" title="Returns a Context&lt;T&gt; suitable for use with this System&lt;T&gt;. ">AllocateContext()</a> and sets its default values using <a class="el" href="classdrake_1_1systems_1_1_system.html#ab4e6ee413f4f47a20f6dcc2cbd831b88">SetDefaultContext()</a>.  <a href="classdrake_1_1systems_1_1_system.html#ad047317ab91889c6743d5e47a64c7f08">More...</a><br /></td></tr>
<tr class="separator:ad047317ab91889c6743d5e47a64c7f08 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e6ee413f4f47a20f6dcc2cbd831b88 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ab4e6ee413f4f47a20f6dcc2cbd831b88">SetDefaultContext</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="separator:ab4e6ee413f4f47a20f6dcc2cbd831b88 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a8dc372e0063851c9851ee15da74e9 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a47a8dc372e0063851c9851ee15da74e9">SetRandomState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state, <a class="el" href="namespacedrake_1_1systems.html#ad96f28f81be35c3eb7fa5e19b48db26e">RandomGenerator</a> *generator) const</td></tr>
<tr class="memdesc:a47a8dc372e0063851c9851ee15da74e9 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns random values to all elements of the state.  <a href="classdrake_1_1systems_1_1_system.html#a47a8dc372e0063851c9851ee15da74e9">More...</a><br /></td></tr>
<tr class="separator:a47a8dc372e0063851c9851ee15da74e9 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a8969fd7784256a68402b391f8902b inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#af7a8969fd7784256a68402b391f8902b">SetRandomParameters</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; *parameters, <a class="el" href="namespacedrake_1_1systems.html#ad96f28f81be35c3eb7fa5e19b48db26e">RandomGenerator</a> *generator) const</td></tr>
<tr class="memdesc:af7a8969fd7784256a68402b391f8902b inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns random values to all parameters.  <a href="classdrake_1_1systems_1_1_system.html#af7a8969fd7784256a68402b391f8902b">More...</a><br /></td></tr>
<tr class="separator:af7a8969fd7784256a68402b391f8902b inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5a403983483dda39f8196a241225f2 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a6a5a403983483dda39f8196a241225f2">SetRandomContext</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context, <a class="el" href="namespacedrake_1_1systems.html#ad96f28f81be35c3eb7fa5e19b48db26e">RandomGenerator</a> *generator) const</td></tr>
<tr class="separator:a6a5a403983483dda39f8196a241225f2 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ec86445724fd77391af7874bfc4848 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a47ec86445724fd77391af7874bfc4848">AllocateFixedInputs</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a47ec86445724fd77391af7874bfc4848 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each input port, allocates a fixed input of the concrete type that this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> requires, and binds it to the port, disconnecting any prior input.  <a href="classdrake_1_1systems_1_1_system.html#a47ec86445724fd77391af7874bfc4848">More...</a><br /></td></tr>
<tr class="separator:a47ec86445724fd77391af7874bfc4848 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037dd9c0afe6e059e67edb4c9c01eeb3 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a037dd9c0afe6e059e67edb4c9c01eeb3">HasAnyDirectFeedthrough</a> () const</td></tr>
<tr class="memdesc:a037dd9c0afe6e059e67edb4c9c01eeb3 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any of the inputs to the system might be directly fed through to any of its outputs and <code>false</code> otherwise.  <a href="classdrake_1_1systems_1_1_system.html#a037dd9c0afe6e059e67edb4c9c01eeb3">More...</a><br /></td></tr>
<tr class="separator:a037dd9c0afe6e059e67edb4c9c01eeb3 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51acfa17df1bc87ce8eaa0e1556f6d46 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a51acfa17df1bc87ce8eaa0e1556f6d46">HasDirectFeedthrough</a> (<a class="el" href="classint.html">int</a> output_port) const</td></tr>
<tr class="memdesc:a51acfa17df1bc87ce8eaa0e1556f6d46 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there might be direct-feedthrough from any input port to the given <code>output_port</code>, and false otherwise.  <a href="classdrake_1_1systems_1_1_system.html#a51acfa17df1bc87ce8eaa0e1556f6d46">More...</a><br /></td></tr>
<tr class="separator:a51acfa17df1bc87ce8eaa0e1556f6d46 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd5092dc2aa2c8f38e0d6336437012d inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a8dd5092dc2aa2c8f38e0d6336437012d">HasDirectFeedthrough</a> (<a class="el" href="classint.html">int</a> input_port, <a class="el" href="classint.html">int</a> output_port) const</td></tr>
<tr class="memdesc:a8dd5092dc2aa2c8f38e0d6336437012d inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there might be direct-feedthrough from the given <code>input_port</code> to the given <code>output_port</code>, and false otherwise.  <a href="classdrake_1_1systems_1_1_system.html#a8dd5092dc2aa2c8f38e0d6336437012d">More...</a><br /></td></tr>
<tr class="separator:a8dd5092dc2aa2c8f38e0d6336437012d inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31898e0276f6bbc4edf7111f809afb01 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a31898e0276f6bbc4edf7111f809afb01">Publish</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt;&gt; &amp;events) const</td></tr>
<tr class="memdesc:a31898e0276f6bbc4edf7111f809afb01 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the public entry point for dispatching all publish event handlers.  <a href="classdrake_1_1systems_1_1_system.html#a31898e0276f6bbc4edf7111f809afb01">More...</a><br /></td></tr>
<tr class="separator:a31898e0276f6bbc4edf7111f809afb01 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa5fa6fa51aaa8f987abb101e341739 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aafa5fa6fa51aaa8f987abb101e341739">Publish</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aafa5fa6fa51aaa8f987abb101e341739 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces a publish on the system, given a <code>context</code>.  <a href="classdrake_1_1systems_1_1_system.html#aafa5fa6fa51aaa8f987abb101e341739">More...</a><br /></td></tr>
<tr class="separator:aafa5fa6fa51aaa8f987abb101e341739 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38625e953699a0433249142972eef52 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ae38625e953699a0433249142972eef52">EvalTimeDerivatives</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:ae38625e953699a0433249142972eef52 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the continuous state variable time derivatives, evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#af2677f8773e90a538483eedd80a81a9f" title="Calculates the time derivatives xcdot of the continuous state xc into a given output argument...">CalcTimeDerivatives()</a>.  <a href="classdrake_1_1systems_1_1_system.html#ae38625e953699a0433249142972eef52">More...</a><br /></td></tr>
<tr class="separator:ae38625e953699a0433249142972eef52 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432bd44170a669c140bc483e18f9e6df inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a432bd44170a669c140bc483e18f9e6df">EvalPotentialEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a432bd44170a669c140bc483e18f9e6df inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#a3d5eb1d2630aab1938230257554d1f43" title="Calculates and returns the potential energy represented by the current configuration provided in cont...">CalcPotentialEnergy()</a>.  <a href="classdrake_1_1systems_1_1_system.html#a432bd44170a669c140bc483e18f9e6df">More...</a><br /></td></tr>
<tr class="separator:a432bd44170a669c140bc483e18f9e6df inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60880d6e51fedbf2ad61b6f0cae8f96 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa60880d6e51fedbf2ad61b6f0cae8f96">EvalKineticEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aa60880d6e51fedbf2ad61b6f0cae8f96 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#aad01402fef0de79310989d7d22dfde92" title="Calculates and returns the kinetic energy represented by the current configuration and velocity provi...">CalcKineticEnergy()</a>.  <a href="classdrake_1_1systems_1_1_system.html#aa60880d6e51fedbf2ad61b6f0cae8f96">More...</a><br /></td></tr>
<tr class="separator:aa60880d6e51fedbf2ad61b6f0cae8f96 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d982876c8955c50988ae9f03ce6f75 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa0d982876c8955c50988ae9f03ce6f75">EvalConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aa0d982876c8955c50988ae9f03ce6f75 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#a5674ae416c2808c939dffc117b209f23" title="Calculates and returns the conservative power represented by the current contents of the given contex...">CalcConservativePower()</a>.  <a href="classdrake_1_1systems_1_1_system.html#aa0d982876c8955c50988ae9f03ce6f75">More...</a><br /></td></tr>
<tr class="separator:aa0d982876c8955c50988ae9f03ce6f75 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace530af4be075614218eb4bc725c1aba inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ace530af4be075614218eb4bc725c1aba">EvalNonConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:ace530af4be075614218eb4bc725c1aba inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if necessary using <a class="el" href="classdrake_1_1systems_1_1_system.html#a23fe133b70153e382d7f50c38b96bf1f" title="Calculates and returns the non-conservative power represented by the current contents of the given co...">CalcNonConservativePower()</a>.  <a href="classdrake_1_1systems_1_1_system.html#ace530af4be075614218eb4bc725c1aba">More...</a><br /></td></tr>
<tr class="separator:ace530af4be075614218eb4bc725c1aba inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa184508e6a0494c1b8214dab77e34ce3 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class Vec = BasicVector&gt; </td></tr>
<tr class="memitem:aa184508e6a0494c1b8214dab77e34ce3 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top">const Vec&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa184508e6a0494c1b8214dab77e34ce3">EvalVectorInput</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:aa184508e6a0494c1b8214dab77e34ce3 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the vector-valued input port with the given <code>port_index</code> as a <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase. ">BasicVector</a> or a specific subclass <code>Vec</code> derived from <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase. ">BasicVector</a>.  <a href="classdrake_1_1systems_1_1_system.html#aa184508e6a0494c1b8214dab77e34ce3">More...</a><br /></td></tr>
<tr class="separator:aa184508e6a0494c1b8214dab77e34ce3 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02557f96761f5c65d36e55bb2084c8c5 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a02557f96761f5c65d36e55bb2084c8c5">EvalEigenVectorInput</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:a02557f96761f5c65d36e55bb2084c8c5 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the vector-valued input port with the given <code>port_index</code> as an Eigen vector.  <a href="classdrake_1_1systems_1_1_system.html#a02557f96761f5c65d36e55bb2084c8c5">More...</a><br /></td></tr>
<tr class="separator:a02557f96761f5c65d36e55bb2084c8c5 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21289a0f31d15c21a17ae321a75ac47 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa21289a0f31d15c21a17ae321a75ac47">get_num_constraint_equations</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aa21289a0f31d15c21a17ae321a75ac47 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of constraint equations for this system using the given context (useful in case the number of constraints is dependent upon the current state (as might be the case with a system modeled using piecewise differential algebraic equations).  <a href="classdrake_1_1systems_1_1_system.html#aa21289a0f31d15c21a17ae321a75ac47">More...</a><br /></td></tr>
<tr class="separator:aa21289a0f31d15c21a17ae321a75ac47 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a271e43d57f6eeb3bbdb3bbd1105a8d inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a0a271e43d57f6eeb3bbdb3bbd1105a8d">EvalConstraintEquations</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a0a271e43d57f6eeb3bbdb3bbd1105a8d inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the constraint equations for the system at the generalized coordinates and generalized velocity specified by the context.  <a href="classdrake_1_1systems_1_1_system.html#a0a271e43d57f6eeb3bbdb3bbd1105a8d">More...</a><br /></td></tr>
<tr class="separator:a0a271e43d57f6eeb3bbdb3bbd1105a8d inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c0399e6d530a28b40ddde9b2135f6e inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a29c0399e6d530a28b40ddde9b2135f6e">EvalConstraintEquationsDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a29c0399e6d530a28b40ddde9b2135f6e inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the time derivative of each constraint equation, evaluated at the generalized coordinates and generalized velocity specified by the context.  <a href="classdrake_1_1systems_1_1_system.html#a29c0399e6d530a28b40ddde9b2135f6e">More...</a><br /></td></tr>
<tr class="separator:a29c0399e6d530a28b40ddde9b2135f6e inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcd68e4f53dbb75927e2d4f9d709440 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#adbcd68e4f53dbb75927e2d4f9d709440">CalcVelocityChangeFromConstraintImpulses</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::MatrixXd &amp;J, const Eigen::VectorXd &amp;lambda) const</td></tr>
<tr class="memdesc:adbcd68e4f53dbb75927e2d4f9d709440 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the change in velocity from applying the given constraint forces to the system at the given context.  <a href="classdrake_1_1systems_1_1_system.html#adbcd68e4f53dbb75927e2d4f9d709440">More...</a><br /></td></tr>
<tr class="separator:adbcd68e4f53dbb75927e2d4f9d709440 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71893bf8c20254b15b075c7c10935d12 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a71893bf8c20254b15b075c7c10935d12">CalcConstraintErrorNorm</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::VectorXd &amp;error) const</td></tr>
<tr class="memdesc:a71893bf8c20254b15b075c7c10935d12 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the norm on constraint error (used as a metric for comparing errors between the outputs of algebraic equations applied to two different state variable instances).  <a href="classdrake_1_1systems_1_1_system.html#a71893bf8c20254b15b075c7c10935d12">More...</a><br /></td></tr>
<tr class="separator:a71893bf8c20254b15b075c7c10935d12 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2677f8773e90a538483eedd80a81a9f inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#af2677f8773e90a538483eedd80a81a9f">CalcTimeDerivatives</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *derivatives) const</td></tr>
<tr class="memdesc:af2677f8773e90a538483eedd80a81a9f inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the time derivatives <code>xcdot</code> of the continuous state <code>xc</code> into a given output argument.  <a href="classdrake_1_1systems_1_1_system.html#af2677f8773e90a538483eedd80a81a9f">More...</a><br /></td></tr>
<tr class="separator:af2677f8773e90a538483eedd80a81a9f inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4b5edfcccb98a87f958bc9b6b626bd inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a2b4b5edfcccb98a87f958bc9b6b626bd">CalcDiscreteVariableUpdates</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt;&gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state) const</td></tr>
<tr class="memdesc:a2b4b5edfcccb98a87f958bc9b6b626bd inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the public entry point for dispatching all discrete variable update event handlers.  <a href="classdrake_1_1systems_1_1_system.html#a2b4b5edfcccb98a87f958bc9b6b626bd">More...</a><br /></td></tr>
<tr class="separator:a2b4b5edfcccb98a87f958bc9b6b626bd inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054ef0e9e578c5abc57fd4dc8b12bd84 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a054ef0e9e578c5abc57fd4dc8b12bd84">CalcDiscreteVariableUpdates</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state) const</td></tr>
<tr class="memdesc:a054ef0e9e578c5abc57fd4dc8b12bd84 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method forces a discrete update on the system given a <code>context</code>, and the updated discrete state is stored in <code>discrete_state</code>.  <a href="classdrake_1_1systems_1_1_system.html#a054ef0e9e578c5abc57fd4dc8b12bd84">More...</a><br /></td></tr>
<tr class="separator:a054ef0e9e578c5abc57fd4dc8b12bd84 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad195518c9c6d2c9421e6e2b222514d89 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ad195518c9c6d2c9421e6e2b222514d89">CalcUnrestrictedUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt;&gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:ad195518c9c6d2c9421e6e2b222514d89 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the public entry point for dispatching all unrestricted update event handlers.  <a href="classdrake_1_1systems_1_1_system.html#ad195518c9c6d2c9421e6e2b222514d89">More...</a><br /></td></tr>
<tr class="separator:ad195518c9c6d2c9421e6e2b222514d89 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f04e429745ae7a16600c4dfda0f931 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a25f04e429745ae7a16600c4dfda0f931">CalcUnrestrictedUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:a25f04e429745ae7a16600c4dfda0f931 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method forces an unrestricted update on the system given a <code>context</code>, and the updated state is stored in <code>state</code>.  <a href="classdrake_1_1systems_1_1_system.html#a25f04e429745ae7a16600c4dfda0f931">More...</a><br /></td></tr>
<tr class="separator:a25f04e429745ae7a16600c4dfda0f931 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164afe3c1db737b93696b8808bb2c942 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a164afe3c1db737b93696b8808bb2c942">CalcNextUpdateTime</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:a164afe3c1db737b93696b8808bb2c942 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by a <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> during its calculation of the size of the next continuous step to attempt.  <a href="classdrake_1_1systems_1_1_system.html#a164afe3c1db737b93696b8808bb2c942">More...</a><br /></td></tr>
<tr class="separator:a164afe3c1db737b93696b8808bb2c942 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a24b8f910f9d990db8e59bf2bae6d0 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ad8a24b8f910f9d990db8e59bf2bae6d0">GetPerStepEvents</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:ad8a24b8f910f9d990db8e59bf2bae6d0 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by <a class="el" href="classdrake_1_1systems_1_1_simulator.html#a98b1050f09da390896f964fb7a892391" title="Prepares the Simulator for a simulation. ">Simulator::Initialize()</a> to gather all update and publish events that are to be handled in StepTo() at the point before <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects...">Simulator</a> integrates continuous state.  <a href="classdrake_1_1systems_1_1_system.html#ad8a24b8f910f9d990db8e59bf2bae6d0">More...</a><br /></td></tr>
<tr class="separator:ad8a24b8f910f9d990db8e59bf2bae6d0 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f84e649d76754f38ea7420a21a1a04 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ae6f84e649d76754f38ea7420a21a1a04">GetInitializationEvents</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:ae6f84e649d76754f38ea7420a21a1a04 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by <a class="el" href="classdrake_1_1systems_1_1_simulator.html#a98b1050f09da390896f964fb7a892391" title="Prepares the Simulator for a simulation. ">Simulator::Initialize()</a> to gather all update and publish events that need to be handled at initialization before the simulator starts integration.  <a href="classdrake_1_1systems_1_1_system.html#ae6f84e649d76754f38ea7420a21a1a04">More...</a><br /></td></tr>
<tr class="separator:ae6f84e649d76754f38ea7420a21a1a04 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f7d226abe6847e09248db0def0c746 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ae0f7d226abe6847e09248db0def0c746">GetUniquePeriodicDiscreteUpdateAttribute</a> () const</td></tr>
<tr class="memdesc:ae0f7d226abe6847e09248db0def0c746 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether there exists a unique periodic attribute that triggers one or more discrete update events (and, if so, returns that unique periodic attribute).  <a href="classdrake_1_1systems_1_1_system.html#ae0f7d226abe6847e09248db0def0c746">More...</a><br /></td></tr>
<tr class="separator:ae0f7d226abe6847e09248db0def0c746 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd73a23410d860ee73dc021663ec99f inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a>, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; * &gt;, <a class="el" href="structdrake_1_1systems_1_1_periodic_event_data_comparator.html">PeriodicEventDataComparator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#acdd73a23410d860ee73dc021663ec99f">GetPeriodicEvents</a> () const</td></tr>
<tr class="memdesc:acdd73a23410d860ee73dc021663ec99f inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all periodic triggered events for a system.  <a href="classdrake_1_1systems_1_1_system.html#acdd73a23410d860ee73dc021663ec99f">More...</a><br /></td></tr>
<tr class="separator:acdd73a23410d860ee73dc021663ec99f inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574467e50cf5c242f665557daca33111 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a574467e50cf5c242f665557daca33111">CalcOutput</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *outputs) const</td></tr>
<tr class="memdesc:a574467e50cf5c242f665557daca33111 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method that computes for <em>every</em> output port i the value y(i) that should result from the current contents of the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classdrake_1_1systems_1_1_system.html#a574467e50cf5c242f665557daca33111">More...</a><br /></td></tr>
<tr class="separator:a574467e50cf5c242f665557daca33111 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5eb1d2630aab1938230257554d1f43 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a3d5eb1d2630aab1938230257554d1f43">CalcPotentialEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a3d5eb1d2630aab1938230257554d1f43 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the potential energy represented by the current configuration provided in <code>context</code>.  <a href="classdrake_1_1systems_1_1_system.html#a3d5eb1d2630aab1938230257554d1f43">More...</a><br /></td></tr>
<tr class="separator:a3d5eb1d2630aab1938230257554d1f43 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad01402fef0de79310989d7d22dfde92 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aad01402fef0de79310989d7d22dfde92">CalcKineticEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aad01402fef0de79310989d7d22dfde92 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the kinetic energy represented by the current configuration and velocity provided in <code>context</code>.  <a href="classdrake_1_1systems_1_1_system.html#aad01402fef0de79310989d7d22dfde92">More...</a><br /></td></tr>
<tr class="separator:aad01402fef0de79310989d7d22dfde92 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5674ae416c2808c939dffc117b209f23 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a5674ae416c2808c939dffc117b209f23">CalcConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a5674ae416c2808c939dffc117b209f23 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the conservative power represented by the current contents of the given <code>context</code>.  <a href="classdrake_1_1systems_1_1_system.html#a5674ae416c2808c939dffc117b209f23">More...</a><br /></td></tr>
<tr class="separator:a5674ae416c2808c939dffc117b209f23 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fe133b70153e382d7f50c38b96bf1f inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a23fe133b70153e382d7f50c38b96bf1f">CalcNonConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a23fe133b70153e382d7f50c38b96bf1f inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the non-conservative power represented by the current contents of the given <code>context</code>.  <a href="classdrake_1_1systems_1_1_system.html#a23fe133b70153e382d7f50c38b96bf1f">More...</a><br /></td></tr>
<tr class="separator:a23fe133b70153e382d7f50c38b96bf1f inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cc5df6d0d0fe4ea54b522ae776ca39 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a05cc5df6d0d0fe4ea54b522ae776ca39">MapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;generalized_velocity, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *qdot) const</td></tr>
<tr class="memdesc:a05cc5df6d0d0fe4ea54b522ae776ca39 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a given generalized velocity <code>v</code> to the time derivative <code>qdot</code> of the generalized configuration <code>q</code> taken from the supplied <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classdrake_1_1systems_1_1_system.html#a05cc5df6d0d0fe4ea54b522ae776ca39">More...</a><br /></td></tr>
<tr class="separator:a05cc5df6d0d0fe4ea54b522ae776ca39 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d05cfdce7f2dbae7c9f18babfc827e8 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a3d05cfdce7f2dbae7c9f18babfc827e8">MapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;generalized_velocity, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *qdot) const</td></tr>
<tr class="memdesc:a3d05cfdce7f2dbae7c9f18babfc827e8 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given generalized velocity to the time derivative of generalized configuration.  <a href="classdrake_1_1systems_1_1_system.html#a3d05cfdce7f2dbae7c9f18babfc827e8">More...</a><br /></td></tr>
<tr class="separator:a3d05cfdce7f2dbae7c9f18babfc827e8 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10eba167739bfe8e7e419b5c8ae41537 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a10eba167739bfe8e7e419b5c8ae41537">MapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;qdot, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *generalized_velocity) const</td></tr>
<tr class="memdesc:a10eba167739bfe8e7e419b5c8ae41537 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the time derivative <code>qdot</code> of the generalized configuration <code>q</code> to generalized velocities <code>v</code>.  <a href="classdrake_1_1systems_1_1_system.html#a10eba167739bfe8e7e419b5c8ae41537">More...</a><br /></td></tr>
<tr class="separator:a10eba167739bfe8e7e419b5c8ae41537 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9914457357091af1a9932863f2b396a4 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a9914457357091af1a9932863f2b396a4">MapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;qdot, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *generalized_velocity) const</td></tr>
<tr class="memdesc:a9914457357091af1a9932863f2b396a4 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given time derivative <code>qdot</code> of generalized configuration <code>q</code> to generalized velocity <code>v</code>.  <a href="classdrake_1_1systems_1_1_system.html#a9914457357091af1a9932863f2b396a4">More...</a><br /></td></tr>
<tr class="separator:a9914457357091af1a9932863f2b396a4 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9714aaf76aca9169da6de7fbcb8339fb inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a9714aaf76aca9169da6de7fbcb8339fb">GetMemoryObjectName</a> () const</td></tr>
<tr class="memdesc:a9714aaf76aca9169da6de7fbcb8339fb inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a name for this System based on a stringification of its type name and memory address.  <a href="classdrake_1_1systems_1_1_system.html#a9714aaf76aca9169da6de7fbcb8339fb">More...</a><br /></td></tr>
<tr class="separator:a9714aaf76aca9169da6de7fbcb8339fb inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b7b9f7723ad69fca8766e6590ef681 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a39b7b9f7723ad69fca8766e6590ef681">get_input_port</a> (<a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:a39b7b9f7723ad69fca8766e6590ef681 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed input port at index <code>port_index</code>.  <a href="classdrake_1_1systems_1_1_system.html#a39b7b9f7723ad69fca8766e6590ef681">More...</a><br /></td></tr>
<tr class="separator:a39b7b9f7723ad69fca8766e6590ef681 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd5af969c0fcb5fe0923aeac56c6124 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a4bd5af969c0fcb5fe0923aeac56c6124">GetInputPort</a> (const std::string &amp;port_name) const</td></tr>
<tr class="memdesc:a4bd5af969c0fcb5fe0923aeac56c6124 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed input port with the unique name <code>port_name</code>.  <a href="classdrake_1_1systems_1_1_system.html#a4bd5af969c0fcb5fe0923aeac56c6124">More...</a><br /></td></tr>
<tr class="separator:a4bd5af969c0fcb5fe0923aeac56c6124 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d32474ac975155d1289d564016a8a13 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a9d32474ac975155d1289d564016a8a13">get_output_port</a> (<a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:a9d32474ac975155d1289d564016a8a13 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed output port at index <code>port_index</code>.  <a href="classdrake_1_1systems_1_1_system.html#a9d32474ac975155d1289d564016a8a13">More...</a><br /></td></tr>
<tr class="separator:a9d32474ac975155d1289d564016a8a13 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8d63cb84ca11a136b9034d7e06a0bf inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a6d8d63cb84ca11a136b9034d7e06a0bf">GetOutputPort</a> (const std::string &amp;port_name) const</td></tr>
<tr class="memdesc:a6d8d63cb84ca11a136b9034d7e06a0bf inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed output port with the unique name <code>port_name</code>.  <a href="classdrake_1_1systems_1_1_system.html#a6d8d63cb84ca11a136b9034d7e06a0bf">More...</a><br /></td></tr>
<tr class="separator:a6d8d63cb84ca11a136b9034d7e06a0bf inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6ef02eb739a38c128ac65eff3394f2 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a8a6ef02eb739a38c128ac65eff3394f2">get_num_constraints</a> () const</td></tr>
<tr class="memdesc:a8a6ef02eb739a38c128ac65eff3394f2 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraints specified for the system.  <a href="classdrake_1_1systems_1_1_system.html#a8a6ef02eb739a38c128ac65eff3394f2">More...</a><br /></td></tr>
<tr class="separator:a8a6ef02eb739a38c128ac65eff3394f2 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99fae784f8ff0d30444e35d13601177 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#af99fae784f8ff0d30444e35d13601177">get_constraint</a> (<a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a> constraint_index) const</td></tr>
<tr class="memdesc:af99fae784f8ff0d30444e35d13601177 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint at index <code>constraint_index</code>.  <a href="classdrake_1_1systems_1_1_system.html#af99fae784f8ff0d30444e35d13601177">More...</a><br /></td></tr>
<tr class="separator:af99fae784f8ff0d30444e35d13601177 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adf20a88ef081c27ea071d880292209 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a4adf20a88ef081c27ea071d880292209">CheckSystemConstraintsSatisfied</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdouble.html">double</a> tol) const</td></tr>
<tr class="memdesc:a4adf20a88ef081c27ea071d880292209 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>context</code> satisfies all of the registered SystemConstraints with tolerance <code>tol</code>.  <a href="classdrake_1_1systems_1_1_system.html#a4adf20a88ef081c27ea071d880292209">More...</a><br /></td></tr>
<tr class="separator:a4adf20a88ef081c27ea071d880292209 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852a4bc3895e11faf46f4e32b47d338d inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a852a4bc3895e11faf46f4e32b47d338d">CheckValidOutput</a> (const <a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *output) const</td></tr>
<tr class="memdesc:a852a4bc3895e11faf46f4e32b47d338d inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that <code>output</code> is consistent with the number and size of output ports declared by the system.  <a href="classdrake_1_1systems_1_1_system.html#a852a4bc3895e11faf46f4e32b47d338d">More...</a><br /></td></tr>
<tr class="separator:a852a4bc3895e11faf46f4e32b47d338d inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde7091d9f2709229fcb446f3d5ff001 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;typename T1  = T&gt; </td></tr>
<tr class="memitem:abde7091d9f2709229fcb446f3d5ff001 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#abde7091d9f2709229fcb446f3d5ff001">CheckValidContextT</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T1 &gt; &amp;context) const</td></tr>
<tr class="memdesc:abde7091d9f2709229fcb446f3d5ff001 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that <code>context</code> is consistent for this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> template.  <a href="classdrake_1_1systems_1_1_system.html#abde7091d9f2709229fcb446f3d5ff001">More...</a><br /></td></tr>
<tr class="separator:abde7091d9f2709229fcb446f3d5ff001 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c711d92735642b2fa7fc975e9b5bf8 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a24c711d92735642b2fa7fc975e9b5bf8">CopyContinuousStateVector</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a24c711d92735642b2fa7fc975e9b5bf8 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the continuous state vector <code>xc</code> into an <a class="el" href="namespace_eigen.html">Eigen</a> vector.  <a href="classdrake_1_1systems_1_1_system.html#a24c711d92735642b2fa7fc975e9b5bf8">More...</a><br /></td></tr>
<tr class="separator:a24c711d92735642b2fa7fc975e9b5bf8 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588e4f7454694f04b4b654d154f170f3 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a588e4f7454694f04b4b654d154f170f3">GetGraphvizString</a> (<a class="el" href="classint.html">int</a> max_depth=std::numeric_limits&lt; <a class="el" href="classint.html">int</a> &gt;::max()) const</td></tr>
<tr class="memdesc:a588e4f7454694f04b4b654d154f170f3 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Graphviz string describing this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system.html#a588e4f7454694f04b4b654d154f170f3">More...</a><br /></td></tr>
<tr class="separator:a588e4f7454694f04b4b654d154f170f3 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fac664a1c120c425bc522d7ecb435c inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa1fac664a1c120c425bc522d7ecb435c">GetGraphvizId</a> () const</td></tr>
<tr class="memdesc:aa1fac664a1c120c425bc522d7ecb435c inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an opaque integer that uniquely identifies this system in the Graphviz output.  <a href="classdrake_1_1systems_1_1_system.html#aa1fac664a1c120c425bc522d7ecb435c">More...</a><br /></td></tr>
<tr class="separator:aa1fac664a1c120c425bc522d7ecb435c inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601fb2c6cf565d954253d25725ae9d6b inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a601fb2c6cf565d954253d25725ae9d6b">FixInputPortsFrom</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;other_system, const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;other_context, <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *target_context) const</td></tr>
<tr class="memdesc:a601fb2c6cf565d954253d25725ae9d6b inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixes all of the input ports in <code>target_context</code> to their current values in <code>other_context</code>, as evaluated by <code>other_system</code>.  <a href="classdrake_1_1systems_1_1_system.html#a601fb2c6cf565d954253d25725ae9d6b">More...</a><br /></td></tr>
<tr class="separator:a601fb2c6cf565d954253d25725ae9d6b inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686f497f27885d9f632df0c43d29a0d6 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a686f497f27885d9f632df0c43d29a0d6">get_system_scalar_converter</a> () const</td></tr>
<tr class="memdesc:a686f497f27885d9f632df0c43d29a0d6 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns the <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html" title="Helper class to convert a System&lt;U&gt; into a System&lt;T&gt;, intended for internal use by the System framewo...">SystemScalarConverter</a> for this object.  <a href="classdrake_1_1systems_1_1_system.html#a686f497f27885d9f632df0c43d29a0d6">More...</a><br /></td></tr>
<tr class="separator:a686f497f27885d9f632df0c43d29a0d6 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa81bdf4638506d1ba5ee11e05821651 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aaa81bdf4638506d1ba5ee11e05821651">ToAutoDiffXd</a> () const</td></tr>
<tr class="memdesc:aaa81bdf4638506d1ba5ee11e05821651 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives.  <a href="classdrake_1_1systems_1_1_system.html#aaa81bdf4638506d1ba5ee11e05821651">More...</a><br /></td></tr>
<tr class="separator:aaa81bdf4638506d1ba5ee11e05821651 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8661a664b857b7bec879b6f84ca763c7 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a8661a664b857b7bec879b6f84ca763c7">ToAutoDiffXdMaybe</a> () const</td></tr>
<tr class="memdesc:a8661a664b857b7bec879b6f84ca763c7 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this system exactly like <a class="el" href="classdrake_1_1systems_1_1_system.html#aaa81bdf4638506d1ba5ee11e05821651" title="Creates a deep copy of this System, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives. ">ToAutoDiffXd()</a>, but returns nullptr if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> does not support autodiff, instead of throwing an exception.  <a href="classdrake_1_1systems_1_1_system.html#a8661a664b857b7bec879b6f84ca763c7">More...</a><br /></td></tr>
<tr class="separator:a8661a664b857b7bec879b6f84ca763c7 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c259e82a4e51da3c7ace27af64e0d3a inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a1c259e82a4e51da3c7ace27af64e0d3a">ToSymbolic</a> () const</td></tr>
<tr class="memdesc:a1c259e82a4e51da3c7ace27af64e0d3a inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>, transmogrified to use the symbolic scalar type.  <a href="classdrake_1_1systems_1_1_system.html#a1c259e82a4e51da3c7ace27af64e0d3a">More...</a><br /></td></tr>
<tr class="separator:a1c259e82a4e51da3c7ace27af64e0d3a inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49431db031c1d14de328a7231290e95 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ae49431db031c1d14de328a7231290e95">ToSymbolicMaybe</a> () const</td></tr>
<tr class="memdesc:ae49431db031c1d14de328a7231290e95 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this system exactly like <a class="el" href="classdrake_1_1systems_1_1_system.html#a1c259e82a4e51da3c7ace27af64e0d3a" title="Creates a deep copy of this System, transmogrified to use the symbolic scalar type. ">ToSymbolic()</a>, but returns nullptr if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> does not support symbolic, instead of throwing an exception.  <a href="classdrake_1_1systems_1_1_system.html#ae49431db031c1d14de328a7231290e95">More...</a><br /></td></tr>
<tr class="separator:ae49431db031c1d14de328a7231290e95 inherit pub_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1systems_1_1_system_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdrake_1_1systems_1_1_system_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a></td></tr>
<tr class="memitem:ae7271d3848e9754bee3e07c53614100c inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ae7271d3848e9754bee3e07c53614100c">~SystemBase</a> () override</td></tr>
<tr class="separator:ae7271d3848e9754bee3e07c53614100c inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5260b9627048b854b45d05ed34adc22 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad5260b9627048b854b45d05ed34adc22">set_name</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:ad5260b9627048b854b45d05ed34adc22 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the system.  <a href="classdrake_1_1systems_1_1_system_base.html#ad5260b9627048b854b45d05ed34adc22">More...</a><br /></td></tr>
<tr class="separator:ad5260b9627048b854b45d05ed34adc22 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1591b1773209f55ccc85356efb639a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aea1591b1773209f55ccc85356efb639a">get_name</a> () const</td></tr>
<tr class="memdesc:aea1591b1773209f55ccc85356efb639a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name last supplied to <a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad5260b9627048b854b45d05ed34adc22" title="Sets the name of the system. ">set_name()</a>, if any.  <a href="classdrake_1_1systems_1_1_system_base.html#aea1591b1773209f55ccc85356efb639a">More...</a><br /></td></tr>
<tr class="separator:aea1591b1773209f55ccc85356efb639a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2143907221997b4bfd7cf5fc40b422 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#acf2143907221997b4bfd7cf5fc40b422">GetSystemName</a> () const final</td></tr>
<tr class="memdesc:acf2143907221997b4bfd7cf5fc40b422 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a human-readable name for this system, for use in messages and logging.  <a href="classdrake_1_1systems_1_1_system_base.html#acf2143907221997b4bfd7cf5fc40b422">More...</a><br /></td></tr>
<tr class="separator:acf2143907221997b4bfd7cf5fc40b422 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f54385db97ee385847ad7577dbe34e inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ac8f54385db97ee385847ad7577dbe34e">GetSystemPathname</a> () const final</td></tr>
<tr class="memdesc:ac8f54385db97ee385847ad7577dbe34e inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a human-readable full path name of this subsystem, for use in messages and logging.  <a href="classdrake_1_1systems_1_1_system_base.html#ac8f54385db97ee385847ad7577dbe34e">More...</a><br /></td></tr>
<tr class="separator:ac8f54385db97ee385847ad7577dbe34e inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283b89b5f6b6d1745bc590e6050177a9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a283b89b5f6b6d1745bc590e6050177a9">GetSystemType</a> () const final</td></tr>
<tr class="memdesc:a283b89b5f6b6d1745bc590e6050177a9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the most-derived type of this concrete <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> object as a human-readable string suitable for use in error messages.  <a href="classdrake_1_1systems_1_1_system_base.html#a283b89b5f6b6d1745bc590e6050177a9">More...</a><br /></td></tr>
<tr class="separator:a283b89b5f6b6d1745bc590e6050177a9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4efb09df0463ac35602f194f053348 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1f4efb09df0463ac35602f194f053348">ThrowIfContextNotCompatible</a> (const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context) const final</td></tr>
<tr class="memdesc:a1f4efb09df0463ac35602f194f053348 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception with an appropriate message if the given <code>context</code> is not compatible with this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#a1f4efb09df0463ac35602f194f053348">More...</a><br /></td></tr>
<tr class="separator:a1f4efb09df0463ac35602f194f053348 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e75aaff1fa28d033136d4073c59e097 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0e75aaff1fa28d033136d4073c59e097">AllocateContext</a> () const</td></tr>
<tr class="memdesc:a0e75aaff1fa28d033136d4073c59e097 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> suitable for use with this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#a0e75aaff1fa28d033136d4073c59e097">More...</a><br /></td></tr>
<tr class="separator:a0e75aaff1fa28d033136d4073c59e097 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cdbe6795af06e2bb415d5ab860e4e7 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af4cdbe6795af06e2bb415d5ab860e4e7">get_num_input_ports</a> () const</td></tr>
<tr class="memdesc:af4cdbe6795af06e2bb415d5ab860e4e7 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of input ports currently allocated in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#af4cdbe6795af06e2bb415d5ab860e4e7">More...</a><br /></td></tr>
<tr class="separator:af4cdbe6795af06e2bb415d5ab860e4e7 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e45f7b611946054bad75bf53685747 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a39e45f7b611946054bad75bf53685747">get_num_output_ports</a> () const</td></tr>
<tr class="memdesc:a39e45f7b611946054bad75bf53685747 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of output ports currently allocated in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#a39e45f7b611946054bad75bf53685747">More...</a><br /></td></tr>
<tr class="separator:a39e45f7b611946054bad75bf53685747 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209c59864026db2a428f593601ee7ffc inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port_base.html">InputPortBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a209c59864026db2a428f593601ee7ffc">get_input_port_base</a> (<a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a209c59864026db2a428f593601ee7ffc inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an <a class="el" href="classdrake_1_1systems_1_1_input_port.html" title="This extends InputPortBase with some scalar type-dependent methods. ">InputPort</a> given its <code>port_index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a209c59864026db2a428f593601ee7ffc">More...</a><br /></td></tr>
<tr class="separator:a209c59864026db2a428f593601ee7ffc inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa50d5f614683c52737a0694e245963 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port_base.html">OutputPortBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a2fa50d5f614683c52737a0694e245963">get_output_port_base</a> (<a class="el" href="namespacedrake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa">OutputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a2fa50d5f614683c52737a0694e245963 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an <a class="el" href="classdrake_1_1systems_1_1_output_port.html" title="An OutputPort belongs to a System and represents the properties of one of that System&#39;s output ports...">OutputPort</a> given its <code>port_index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a2fa50d5f614683c52737a0694e245963">More...</a><br /></td></tr>
<tr class="separator:a2fa50d5f614683c52737a0694e245963 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd5e53bbc12fdb8d9691fe9abcd951b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aedd5e53bbc12fdb8d9691fe9abcd951b">get_num_total_inputs</a> () const</td></tr>
<tr class="memdesc:aedd5e53bbc12fdb8d9691fe9abcd951b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total dimension of all of the vector-valued input ports (as if they were muxed).  <a href="classdrake_1_1systems_1_1_system_base.html#aedd5e53bbc12fdb8d9691fe9abcd951b">More...</a><br /></td></tr>
<tr class="separator:aedd5e53bbc12fdb8d9691fe9abcd951b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97dedd5343d8eb91b450ee15db973d90 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a97dedd5343d8eb91b450ee15db973d90">get_num_total_outputs</a> () const</td></tr>
<tr class="memdesc:a97dedd5343d8eb91b450ee15db973d90 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total dimension of all of the vector-valued output ports (as if they were muxed).  <a href="classdrake_1_1systems_1_1_system_base.html#a97dedd5343d8eb91b450ee15db973d90">More...</a><br /></td></tr>
<tr class="separator:a97dedd5343d8eb91b450ee15db973d90 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a98a257dc03eb749975de05778dbc8 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a87a98a257dc03eb749975de05778dbc8">num_cache_entries</a> () const</td></tr>
<tr class="memdesc:a87a98a257dc03eb749975de05778dbc8 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number nc of cache entries currently allocated in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#a87a98a257dc03eb749975de05778dbc8">More...</a><br /></td></tr>
<tr class="separator:a87a98a257dc03eb749975de05778dbc8 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517ae28d98adfc4e8381382d0a4c7be9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a517ae28d98adfc4e8381382d0a4c7be9">get_cache_entry</a> (<a class="el" href="namespacedrake_1_1systems.html#a06ac9ad764b14ccff79b6feb393be498">CacheIndex</a> index) const</td></tr>
<tr class="memdesc:a517ae28d98adfc4e8381382d0a4c7be9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to a <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> given its <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a517ae28d98adfc4e8381382d0a4c7be9">More...</a><br /></td></tr>
<tr class="separator:a517ae28d98adfc4e8381382d0a4c7be9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1480f0eb8db57c2ef6c67e47396ab9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aaa1480f0eb8db57c2ef6c67e47396ab9">CheckValidContext</a> (const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context) const</td></tr>
<tr class="memdesc:aaa1480f0eb8db57c2ef6c67e47396ab9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given context is valid for this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> and throws an exception with a helpful message if not.  <a href="classdrake_1_1systems_1_1_system_base.html#aaa1480f0eb8db57c2ef6c67e47396ab9">More...</a><br /></td></tr>
<tr class="separator:aaa1480f0eb8db57c2ef6c67e47396ab9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7f7189714d79a830e909e281324533 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0b7f7189714d79a830e909e281324533">SystemBase</a> (const <a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> &amp;)=delete</td></tr>
<tr class="separator:a0b7f7189714d79a830e909e281324533 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d56d3b45890e61f36e24199dd1e2aa inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af4d56d3b45890e61f36e24199dd1e2aa">operator=</a> (const <a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> &amp;)=delete</td></tr>
<tr class="separator:af4d56d3b45890e61f36e24199dd1e2aa inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e502b9bccb8c93c30f872d3eb00e9b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a14e502b9bccb8c93c30f872d3eb00e9b">SystemBase</a> (<a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a14e502b9bccb8c93c30f872d3eb00e9b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4f8b3ccb41a8d6ce26373c7ae3c477 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aee4f8b3ccb41a8d6ce26373c7ae3c477">operator=</a> (<a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aee4f8b3ccb41a8d6ce26373c7ae3c477 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb18001bedce2dfaf75b0ae8a14375e inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">AbstractValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a2cb18001bedce2dfaf75b0ae8a14375e">EvalAbstractInput</a> (const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:a2cb18001bedce2dfaf75b0ae8a14375e inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the input port with the given <code>port_index</code> as an <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html" title="A fully type-erased container class. ">AbstractValue</a>, which is permitted for ports of any type.  <a href="classdrake_1_1systems_1_1_system_base.html#a2cb18001bedce2dfaf75b0ae8a14375e">More...</a><br /></td></tr>
<tr class="separator:a2cb18001bedce2dfaf75b0ae8a14375e inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0d520318199bf36a45ec450612fdce inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:afc0d520318199bf36a45ec450612fdce inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplItemLeft" align="right" valign="top">const V *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#afc0d520318199bf36a45ec450612fdce">EvalInputValue</a> (const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:afc0d520318199bf36a45ec450612fdce inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of an abstract-valued input port with the given <code>port_index</code> as a value of known type <code>V</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#afc0d520318199bf36a45ec450612fdce">More...</a><br /></td></tr>
<tr class="separator:afc0d520318199bf36a45ec450612fdce inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb9927349d2ab8f1274429c6f132149 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a5eb9927349d2ab8f1274429c6f132149">DeclareCacheEntry</a> (std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html#a451b30ae2de34d5852363135f73861e1">CacheEntry::AllocCallback</a> alloc_function, <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html#a3947b9d8e95098739aaaea55af1d1ead">CacheEntry::CalcCallback</a> calc_function, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a5eb9927349d2ab8f1274429c6f132149 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a new CacheEntry in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> using the least-restrictive definitions for the associated functions.  <a href="classdrake_1_1systems_1_1_system_base.html#a5eb9927349d2ab8f1274429c6f132149">More...</a><br /></td></tr>
<tr class="separator:a5eb9927349d2ab8f1274429c6f132149 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde2cd0793189949f8200e961fd7f690 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:acde2cd0793189949f8200e961fd7f690 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#acde2cd0793189949f8200e961fd7f690">DeclareCacheEntry</a> (std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, ValueType(MySystem::*make)() const, void(MySystem::*calc)(const MyContext &amp;, ValueType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:acde2cd0793189949f8200e961fd7f690 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a cache entry by specifying member functions to use both for the allocator and calculator.  <a href="classdrake_1_1systems_1_1_system_base.html#acde2cd0793189949f8200e961fd7f690">More...</a><br /></td></tr>
<tr class="separator:acde2cd0793189949f8200e961fd7f690 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c71a0967652b31f86cad89742d9379 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:a16c71a0967652b31f86cad89742d9379 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a16c71a0967652b31f86cad89742d9379">DeclareCacheEntry</a> (std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, const ValueType &amp;model_value, void(MySystem::*calc)(const MyContext &amp;, ValueType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a16c71a0967652b31f86cad89742d9379 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a cache entry by specifying a model value of concrete type <code>ValueType</code> and a calculator function that is a class member function (method) with signature:  <a href="classdrake_1_1systems_1_1_system_base.html#a16c71a0967652b31f86cad89742d9379">More...</a><br /></td></tr>
<tr class="separator:a16c71a0967652b31f86cad89742d9379 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dd680b52b1d39a443a58ebf64708eb inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:ac0dd680b52b1d39a443a58ebf64708eb inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ac0dd680b52b1d39a443a58ebf64708eb">DeclareCacheEntry</a> (std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, const ValueType &amp;model_value, ValueType(MySystem::*calc)(const MyContext &amp;) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:ac0dd680b52b1d39a443a58ebf64708eb inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a cache entry by specifying a model value of concrete type <code>ValueType</code> and a calculator function that is a class member function (method) with signature:  <a href="classdrake_1_1systems_1_1_system_base.html#ac0dd680b52b1d39a443a58ebf64708eb">More...</a><br /></td></tr>
<tr class="separator:ac0dd680b52b1d39a443a58ebf64708eb inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb0a0db30a4e352fa2b59b63b22e513 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:afdb0a0db30a4e352fa2b59b63b22e513 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#afdb0a0db30a4e352fa2b59b63b22e513">DeclareCacheEntry</a> (std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, void(MySystem::*calc)(const MyContext &amp;, ValueType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:afdb0a0db30a4e352fa2b59b63b22e513 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a cache entry by specifying only a calculator function that is a class member function (method) with signature:  <a href="classdrake_1_1systems_1_1_system_base.html#afdb0a0db30a4e352fa2b59b63b22e513">More...</a><br /></td></tr>
<tr class="separator:afdb0a0db30a4e352fa2b59b63b22e513 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b9a14022a774ceaf5459aa30df8d6d inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplParams" colspan="2">template&lt;class MySystem , class MyContext , typename ValueType &gt; </td></tr>
<tr class="memitem:a80b9a14022a774ceaf5459aa30df8d6d inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a80b9a14022a774ceaf5459aa30df8d6d">DeclareCacheEntry</a> (std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, ValueType(MySystem::*calc)(const MyContext &amp;) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a80b9a14022a774ceaf5459aa30df8d6d inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a cache entry by specifying only a calculator function that is a class member function (method) with signature:  <a href="classdrake_1_1systems_1_1_system_base.html#a80b9a14022a774ceaf5459aa30df8d6d">More...</a><br /></td></tr>
<tr class="separator:a80b9a14022a774ceaf5459aa30df8d6d inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf86073429b07d388b0157956bfdbac6 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#adf86073429b07d388b0157956bfdbac6">discrete_state_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a> index) const</td></tr>
<tr class="memdesc:adf86073429b07d388b0157956bfdbac6 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular discrete state variable xdᵢ (may be a vector).  <a href="classdrake_1_1systems_1_1_system_base.html#adf86073429b07d388b0157956bfdbac6">More...</a><br /></td></tr>
<tr class="separator:adf86073429b07d388b0157956bfdbac6 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8d4f32034a610ea30a283699040708 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a4a8d4f32034a610ea30a283699040708">abstract_state_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a> index) const</td></tr>
<tr class="memdesc:a4a8d4f32034a610ea30a283699040708 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular abstract state variable xaᵢ.  <a href="classdrake_1_1systems_1_1_system_base.html#a4a8d4f32034a610ea30a283699040708">More...</a><br /></td></tr>
<tr class="separator:a4a8d4f32034a610ea30a283699040708 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e0bf1fd3096bff3df2587ec4f02285 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a45e0bf1fd3096bff3df2587ec4f02285">numeric_parameter_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#af11369a06c5bfd3fa18acb79f85777df">NumericParameterIndex</a> index) const</td></tr>
<tr class="memdesc:a45e0bf1fd3096bff3df2587ec4f02285 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular numeric parameter pnᵢ (may be a vector).  <a href="classdrake_1_1systems_1_1_system_base.html#a45e0bf1fd3096bff3df2587ec4f02285">More...</a><br /></td></tr>
<tr class="separator:a45e0bf1fd3096bff3df2587ec4f02285 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4ef0e0e633c6f722ee518308d7cb5a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1a4ef0e0e633c6f722ee518308d7cb5a">abstract_parameter_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#a86b350169906f6d5e07e9db46e36d57a">AbstractParameterIndex</a> index) const</td></tr>
<tr class="memdesc:a1a4ef0e0e633c6f722ee518308d7cb5a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular abstract parameter paᵢ.  <a href="classdrake_1_1systems_1_1_system_base.html#a1a4ef0e0e633c6f722ee518308d7cb5a">More...</a><br /></td></tr>
<tr class="separator:a1a4ef0e0e633c6f722ee518308d7cb5a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085e66b9f3f0c01647815b7e1ec07980 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a085e66b9f3f0c01647815b7e1ec07980">input_port_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> index)</td></tr>
<tr class="memdesc:a085e66b9f3f0c01647815b7e1ec07980 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on input port uᵢ indicated by <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a085e66b9f3f0c01647815b7e1ec07980">More...</a><br /></td></tr>
<tr class="separator:a085e66b9f3f0c01647815b7e1ec07980 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4404427da5dce64982087871448dc4e2 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a4404427da5dce64982087871448dc4e2">cache_entry_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#a06ac9ad764b14ccff79b6feb393be498">CacheIndex</a> index)</td></tr>
<tr class="memdesc:a4404427da5dce64982087871448dc4e2 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on the cache entry indicated by <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a4404427da5dce64982087871448dc4e2">More...</a><br /></td></tr>
<tr class="separator:a4404427da5dce64982087871448dc4e2 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71881f1aaa6e2372678419100e59d1c1 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a71881f1aaa6e2372678419100e59d1c1">output_port_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa">OutputPortIndex</a> index)</td></tr>
<tr class="memdesc:a71881f1aaa6e2372678419100e59d1c1 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a ticket indicating dependence on the output port indicated by <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a71881f1aaa6e2372678419100e59d1c1">More...</a><br /></td></tr>
<tr class="separator:a71881f1aaa6e2372678419100e59d1c1 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a03d2d5e70020145bd659eba780f967 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1a03d2d5e70020145bd659eba780f967">num_discrete_state_groups</a> () const</td></tr>
<tr class="memdesc:a1a03d2d5e70020145bd659eba780f967 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of declared discrete state groups (each group is a vector-valued discrete state variable).  <a href="classdrake_1_1systems_1_1_system_base.html#a1a03d2d5e70020145bd659eba780f967">More...</a><br /></td></tr>
<tr class="separator:a1a03d2d5e70020145bd659eba780f967 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c71c7988b370b4e93ea1c33a2a0e9b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad2c71c7988b370b4e93ea1c33a2a0e9b">num_abstract_states</a> () const</td></tr>
<tr class="memdesc:ad2c71c7988b370b4e93ea1c33a2a0e9b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of declared abstract state variables.  <a href="classdrake_1_1systems_1_1_system_base.html#ad2c71c7988b370b4e93ea1c33a2a0e9b">More...</a><br /></td></tr>
<tr class="separator:ad2c71c7988b370b4e93ea1c33a2a0e9b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6508ca0ff8f5e886e63fb9c830e36a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aff6508ca0ff8f5e886e63fb9c830e36a">num_numeric_parameter_groups</a> () const</td></tr>
<tr class="memdesc:aff6508ca0ff8f5e886e63fb9c830e36a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of declared numeric parameters (each of these is a vector-valued parameter).  <a href="classdrake_1_1systems_1_1_system_base.html#aff6508ca0ff8f5e886e63fb9c830e36a">More...</a><br /></td></tr>
<tr class="separator:aff6508ca0ff8f5e886e63fb9c830e36a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cd7f024c61032c807af46f19f6daef inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a91cd7f024c61032c807af46f19f6daef">DRAKE_DEPRECATED</a> (&quot;Use <a class="el" href="classdrake_1_1systems_1_1_system_base.html#aff6508ca0ff8f5e886e63fb9c830e36a">num_numeric_parameter_groups</a>().  This method will be&quot; &quot; removed after 2/15/19.&quot;) int num_numeric_parameters() const</td></tr>
<tr class="separator:a91cd7f024c61032c807af46f19f6daef inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0232523ac7f8337a392b321ffd282187 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0232523ac7f8337a392b321ffd282187">num_abstract_parameters</a> () const</td></tr>
<tr class="memdesc:a0232523ac7f8337a392b321ffd282187 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of declared abstract parameters.  <a href="classdrake_1_1systems_1_1_system_base.html#a0232523ac7f8337a392b321ffd282187">More...</a><br /></td></tr>
<tr class="separator:a0232523ac7f8337a392b321ffd282187 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a47a63154823dffd5838329527aafbd58"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a47a63154823dffd5838329527aafbd58"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a></td></tr>
<tr class="separator:a47a63154823dffd5838329527aafbd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42efef893a4d8eed1d593caff328f599"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a42efef893a4d8eed1d593caff328f599">MultibodyPlantTester</a></td></tr>
<tr class="separator:a42efef893a4d8eed1d593caff328f599"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classdrake_1_1systems_1_1_system"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classdrake_1_1systems_1_1_system')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_system.html">System&lt; T &gt;</a></td></tr>
<tr class="memitem:a12dccd7061415e910fff3a252ece2a88 inherit pub_static_methods_classdrake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class S = ::drake::systems::System&gt; </td></tr>
<tr class="memitem:a12dccd7061415e910fff3a252ece2a88 inherit pub_static_methods_classdrake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top">static std::unique_ptr&lt; S&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a12dccd7061415e910fff3a252ece2a88">ToAutoDiffXd</a> (const S&lt; T &gt; &amp;from)</td></tr>
<tr class="memdesc:a12dccd7061415e910fff3a252ece2a88 inherit pub_static_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of <code>from</code>, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives.  <a href="classdrake_1_1systems_1_1_system.html#a12dccd7061415e910fff3a252ece2a88">More...</a><br /></td></tr>
<tr class="separator:a12dccd7061415e910fff3a252ece2a88 inherit pub_static_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eddb9f14f9b26636316c045a2f5ea58 inherit pub_static_methods_classdrake_1_1systems_1_1_system"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class S = ::drake::systems::System&gt; </td></tr>
<tr class="memitem:a7eddb9f14f9b26636316c045a2f5ea58 inherit pub_static_methods_classdrake_1_1systems_1_1_system"><td class="memTemplItemLeft" align="right" valign="top">static std::unique_ptr&lt; S&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a7eddb9f14f9b26636316c045a2f5ea58">ToSymbolic</a> (const S&lt; T &gt; &amp;from)</td></tr>
<tr class="memdesc:a7eddb9f14f9b26636316c045a2f5ea58 inherit pub_static_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of <code>from</code>, transmogrified to use the symbolic scalar type.  <a href="classdrake_1_1systems_1_1_system.html#a7eddb9f14f9b26636316c045a2f5ea58">More...</a><br /></td></tr>
<tr class="separator:a7eddb9f14f9b26636316c045a2f5ea58 inherit pub_static_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classdrake_1_1systems_1_1_system_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classdrake_1_1systems_1_1_system_base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a></td></tr>
<tr class="memitem:a6fe75ddbd79ab1d862df9a50b3c8a624 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a6fe75ddbd79ab1d862df9a50b3c8a624">nothing_ticket</a> ()</td></tr>
<tr class="memdesc:a6fe75ddbd79ab1d862df9a50b3c8a624 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating that a computation does not depend on <em>any</em> source value; that is, it is a constant.  <a href="classdrake_1_1systems_1_1_system_base.html#a6fe75ddbd79ab1d862df9a50b3c8a624">More...</a><br /></td></tr>
<tr class="separator:a6fe75ddbd79ab1d862df9a50b3c8a624 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68516072b2dc51a601f2de699691f1c3 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a68516072b2dc51a601f2de699691f1c3">time_ticket</a> ()</td></tr>
<tr class="memdesc:a68516072b2dc51a601f2de699691f1c3 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on time.  <a href="classdrake_1_1systems_1_1_system_base.html#a68516072b2dc51a601f2de699691f1c3">More...</a><br /></td></tr>
<tr class="separator:a68516072b2dc51a601f2de699691f1c3 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad649083fc3bcb645671be3fad577d2ab inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad649083fc3bcb645671be3fad577d2ab">accuracy_ticket</a> ()</td></tr>
<tr class="memdesc:ad649083fc3bcb645671be3fad577d2ab inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on the accuracy setting in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#ad649083fc3bcb645671be3fad577d2ab">More...</a><br /></td></tr>
<tr class="separator:ad649083fc3bcb645671be3fad577d2ab inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d3cdadf7d6b62b055993148b82df19 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a41d3cdadf7d6b62b055993148b82df19">q_ticket</a> ()</td></tr>
<tr class="memdesc:a41d3cdadf7d6b62b055993148b82df19 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating that a computation depends on configuration state variables q.  <a href="classdrake_1_1systems_1_1_system_base.html#a41d3cdadf7d6b62b055993148b82df19">More...</a><br /></td></tr>
<tr class="separator:a41d3cdadf7d6b62b055993148b82df19 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab858ddb6f259d65f760c2032b3bd5164 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab858ddb6f259d65f760c2032b3bd5164">v_ticket</a> ()</td></tr>
<tr class="memdesc:ab858ddb6f259d65f760c2032b3bd5164 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on velocity state variables v.  <a href="classdrake_1_1systems_1_1_system_base.html#ab858ddb6f259d65f760c2032b3bd5164">More...</a><br /></td></tr>
<tr class="separator:ab858ddb6f259d65f760c2032b3bd5164 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340a9b088fc407f703a9e21ed9dee32e inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a340a9b088fc407f703a9e21ed9dee32e">z_ticket</a> ()</td></tr>
<tr class="memdesc:a340a9b088fc407f703a9e21ed9dee32e inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on any or all of the miscellaneous continuous state variables z.  <a href="classdrake_1_1systems_1_1_system_base.html#a340a9b088fc407f703a9e21ed9dee32e">More...</a><br /></td></tr>
<tr class="separator:a340a9b088fc407f703a9e21ed9dee32e inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385e0d5605b81db0fbfc6bdd57affb5e inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a385e0d5605b81db0fbfc6bdd57affb5e">xc_ticket</a> ()</td></tr>
<tr class="memdesc:a385e0d5605b81db0fbfc6bdd57affb5e inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> of the continuous state variables q, v, or z.  <a href="classdrake_1_1systems_1_1_system_base.html#a385e0d5605b81db0fbfc6bdd57affb5e">More...</a><br /></td></tr>
<tr class="separator:a385e0d5605b81db0fbfc6bdd57affb5e inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64938d044107c8eedc97f89aaf0e4a32 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a64938d044107c8eedc97f89aaf0e4a32">xd_ticket</a> ()</td></tr>
<tr class="memdesc:a64938d044107c8eedc97f89aaf0e4a32 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the numerical discrete state variables, in any discrete variable group.  <a href="classdrake_1_1systems_1_1_system_base.html#a64938d044107c8eedc97f89aaf0e4a32">More...</a><br /></td></tr>
<tr class="separator:a64938d044107c8eedc97f89aaf0e4a32 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19842775d11b50e5ae56abcc6d38ccc4 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a19842775d11b50e5ae56abcc6d38ccc4">xa_ticket</a> ()</td></tr>
<tr class="memdesc:a19842775d11b50e5ae56abcc6d38ccc4 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the abstract state variables in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#a19842775d11b50e5ae56abcc6d38ccc4">More...</a><br /></td></tr>
<tr class="separator:a19842775d11b50e5ae56abcc6d38ccc4 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2789768c5d75378c081683a8016f0784 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a2789768c5d75378c081683a8016f0784">all_state_ticket</a> ()</td></tr>
<tr class="memdesc:a2789768c5d75378c081683a8016f0784 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> state variables x in this system, including continuous variables xc, discrete (numeric) variables xd, and abstract state variables xa.  <a href="classdrake_1_1systems_1_1_system_base.html#a2789768c5d75378c081683a8016f0784">More...</a><br /></td></tr>
<tr class="separator:a2789768c5d75378c081683a8016f0784 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeae092662e78f50416eb6dc01ad3ddb inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aaeae092662e78f50416eb6dc01ad3ddb">pn_ticket</a> ()</td></tr>
<tr class="memdesc:aaeae092662e78f50416eb6dc01ad3ddb inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the numerical parameters in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#aaeae092662e78f50416eb6dc01ad3ddb">More...</a><br /></td></tr>
<tr class="separator:aaeae092662e78f50416eb6dc01ad3ddb inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c65473a41f73091c600eaead714fe2 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af3c65473a41f73091c600eaead714fe2">pa_ticket</a> ()</td></tr>
<tr class="memdesc:af3c65473a41f73091c600eaead714fe2 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the abstract parameters pa in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#af3c65473a41f73091c600eaead714fe2">More...</a><br /></td></tr>
<tr class="separator:af3c65473a41f73091c600eaead714fe2 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b63a1cb8922051fb1a7fe4b56092bf inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad6b63a1cb8922051fb1a7fe4b56092bf">all_parameters_ticket</a> ()</td></tr>
<tr class="memdesc:ad6b63a1cb8922051fb1a7fe4b56092bf inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> parameters p in this system, including numeric parameters pn, and abstract parameters pa.  <a href="classdrake_1_1systems_1_1_system_base.html#ad6b63a1cb8922051fb1a7fe4b56092bf">More...</a><br /></td></tr>
<tr class="separator:ad6b63a1cb8922051fb1a7fe4b56092bf inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7c526102c09a75195c57ebf5f54a11 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a6d7c526102c09a75195c57ebf5f54a11">all_input_ports_ticket</a> ()</td></tr>
<tr class="memdesc:a6d7c526102c09a75195c57ebf5f54a11 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> input ports u of this system.  <a href="classdrake_1_1systems_1_1_system_base.html#a6d7c526102c09a75195c57ebf5f54a11">More...</a><br /></td></tr>
<tr class="separator:a6d7c526102c09a75195c57ebf5f54a11 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b9bc9f93181e042bdb2c36f4dbea10 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a> ()</td></tr>
<tr class="memdesc:af0b9bc9f93181e042bdb2c36f4dbea10 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on every possible independent source value, including time, accuracy, state, input ports, and parameters (but not cache entries).  <a href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">More...</a><br /></td></tr>
<tr class="separator:af0b9bc9f93181e042bdb2c36f4dbea10 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28830dced98dcdc1f498d8d250db0ae4 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a28830dced98dcdc1f498d8d250db0ae4">configuration_ticket</a> ()</td></tr>
<tr class="memdesc:a28830dced98dcdc1f498d8d250db0ae4 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all source values that may affect configuration-dependent computations.  <a href="classdrake_1_1systems_1_1_system_base.html#a28830dced98dcdc1f498d8d250db0ae4">More...</a><br /></td></tr>
<tr class="separator:a28830dced98dcdc1f498d8d250db0ae4 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1291b5091aa55dbd03c9b5944dbced09 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1291b5091aa55dbd03c9b5944dbced09">kinematics_ticket</a> ()</td></tr>
<tr class="memdesc:a1291b5091aa55dbd03c9b5944dbced09 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all source values that may affect configuration- or velocity-dependent computations.  <a href="classdrake_1_1systems_1_1_system_base.html#a1291b5091aa55dbd03c9b5944dbced09">More...</a><br /></td></tr>
<tr class="separator:a1291b5091aa55dbd03c9b5944dbced09 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42cd3bff14253894eb0a29edf843b3f inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab42cd3bff14253894eb0a29edf843b3f">xcdot_ticket</a> ()</td></tr>
<tr class="memdesc:ab42cd3bff14253894eb0a29edf843b3f inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds time derivatives of the continuous variables.  <a href="classdrake_1_1systems_1_1_system_base.html#ab42cd3bff14253894eb0a29edf843b3f">More...</a><br /></td></tr>
<tr class="separator:ab42cd3bff14253894eb0a29edf843b3f inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f1689b1ae9f05b6e2f194db873927b inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a49f1689b1ae9f05b6e2f194db873927b">pe_ticket</a> ()</td></tr>
<tr class="memdesc:a49f1689b1ae9f05b6e2f194db873927b inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the potential energy calculation.  <a href="classdrake_1_1systems_1_1_system_base.html#a49f1689b1ae9f05b6e2f194db873927b">More...</a><br /></td></tr>
<tr class="separator:a49f1689b1ae9f05b6e2f194db873927b inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e1d9af27119011a497b78df6907b1a inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a66e1d9af27119011a497b78df6907b1a">ke_ticket</a> ()</td></tr>
<tr class="memdesc:a66e1d9af27119011a497b78df6907b1a inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the kinetic energy calculation.  <a href="classdrake_1_1systems_1_1_system_base.html#a66e1d9af27119011a497b78df6907b1a">More...</a><br /></td></tr>
<tr class="separator:a66e1d9af27119011a497b78df6907b1a inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc60bc4c201f17bd35bf40c13a183b3 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#afdc60bc4c201f17bd35bf40c13a183b3">pc_ticket</a> ()</td></tr>
<tr class="memdesc:afdc60bc4c201f17bd35bf40c13a183b3 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the conservative power calculation.  <a href="classdrake_1_1systems_1_1_system_base.html#afdc60bc4c201f17bd35bf40c13a183b3">More...</a><br /></td></tr>
<tr class="separator:afdc60bc4c201f17bd35bf40c13a183b3 inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afc9712c887706c12039e871476f30c inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0afc9712c887706c12039e871476f30c">pnc_ticket</a> ()</td></tr>
<tr class="memdesc:a0afc9712c887706c12039e871476f30c inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the non-conservative power calculation.  <a href="classdrake_1_1systems_1_1_system_base.html#a0afc9712c887706c12039e871476f30c">More...</a><br /></td></tr>
<tr class="separator:a0afc9712c887706c12039e871476f30c inherit pub_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html">MultibodyTreeSystem&lt; T &gt;</a></td></tr>
<tr class="memitem:ae73edc00d493b3f15ba7679cc14830a0 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#ae73edc00d493b3f15ba7679cc14830a0">SetDefaultState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state) const override</td></tr>
<tr class="separator:ae73edc00d493b3f15ba7679cc14830a0 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30385052678018b5c05a87203b54c4c2 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a30385052678018b5c05a87203b54c4c2">MultibodyTreeSystem</a> (<a class="el" href="classbool.html">bool</a> <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#ac87e33717da832d66c6587cac66f56a9">is_discrete</a>=false)</td></tr>
<tr class="memdesc:a30385052678018b5c05a87203b54c4c2 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor allocates a MultibodyTree, with the intent that it will be filled in later, using <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a08e63a0ff4a8a795ac82bfaca651fa86" title="Returns a mutable reference to the MultibodyTree owned by this class. ">mutable_tree()</a> for access.  <a href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a30385052678018b5c05a87203b54c4c2">More...</a><br /></td></tr>
<tr class="separator:a30385052678018b5c05a87203b54c4c2 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d5d85eecca0289abecd6069a32e58e inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a39d5d85eecca0289abecd6069a32e58e">MultibodyTreeSystem</a> (<a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">systems::SystemScalarConverter</a> converter, std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; T &gt;&gt; <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a875f49ab037712aeeeddd091161bee45">tree</a>, <a class="el" href="classbool.html">bool</a> <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#ac87e33717da832d66c6587cac66f56a9">is_discrete</a>=false)</td></tr>
<tr class="memdesc:a39d5d85eecca0289abecd6069a32e58e inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that specifies scalar-type conversion support.  <a href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a39d5d85eecca0289abecd6069a32e58e">More...</a><br /></td></tr>
<tr class="separator:a39d5d85eecca0289abecd6069a32e58e inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e63a0ff4a8a795ac82bfaca651fa86 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a08e63a0ff4a8a795ac82bfaca651fa86">mutable_tree</a> () const</td></tr>
<tr class="memdesc:a08e63a0ff4a8a795ac82bfaca651fa86 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the MultibodyTree owned by this class.  <a href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a08e63a0ff4a8a795ac82bfaca651fa86">More...</a><br /></td></tr>
<tr class="separator:a08e63a0ff4a8a795ac82bfaca651fa86 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fee61d7a783cade1a3d07fe86284d27 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27">Finalize</a> ()</td></tr>
<tr class="memdesc:a8fee61d7a783cade1a3d07fe86284d27 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the tree if that hasn't already been done, complete System construction, and declare any needed Context resources for the tree.  <a href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27">More...</a><br /></td></tr>
<tr class="separator:a8fee61d7a783cade1a3d07fe86284d27 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_tree_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1systems_1_1_leaf_system"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdrake_1_1systems_1_1_leaf_system')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html">LeafSystem&lt; T &gt;</a></td></tr>
<tr class="memitem:a01c2b703c560ad090b9601b743356c90 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a01c2b703c560ad090b9601b743356c90">LeafSystem</a> ()</td></tr>
<tr class="memdesc:a01c2b703c560ad090b9601b743356c90 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor that declares no inputs, outputs, state, parameters, events, nor scalar-type conversion support (AutoDiff, etc.).  <a href="classdrake_1_1systems_1_1_leaf_system.html#a01c2b703c560ad090b9601b743356c90">More...</a><br /></td></tr>
<tr class="separator:a01c2b703c560ad090b9601b743356c90 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7077d1af5bd9153ae403fe32969eba inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a8d7077d1af5bd9153ae403fe32969eba">LeafSystem</a> (<a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> converter)</td></tr>
<tr class="memdesc:a8d7077d1af5bd9153ae403fe32969eba inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that declares no inputs, outputs, state, parameters, or events, but allows subclasses to declare scalar-type conversion support (AutoDiff, etc.).  <a href="classdrake_1_1systems_1_1_leaf_system.html#a8d7077d1af5bd9153ae403fe32969eba">More...</a><br /></td></tr>
<tr class="separator:a8d7077d1af5bd9153ae403fe32969eba inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd6ca8a128bb2663ebaa27d6851c68d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a8bd6ca8a128bb2663ebaa27d6851c68d">DoValidateAllocatedLeafContext</a> (const <a class="el" href="classdrake_1_1systems_1_1_leaf_context.html">LeafContext</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a8bd6ca8a128bb2663ebaa27d6851c68d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes that impose restrictions on what resources are permitted should check those restrictions by implementing this.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a8bd6ca8a128bb2663ebaa27d6851c68d">More...</a><br /></td></tr>
<tr class="separator:a8bd6ca8a128bb2663ebaa27d6851c68d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f1eff5e4fd7f55d152a1b3b9d4bcd1 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">DoCalcWitnessValue</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &amp;witness_func) const final</td></tr>
<tr class="memdesc:ae1f1eff5e4fd7f55d152a1b3b9d4bcd1 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes will implement this method to evaluate a witness function at the given context.  <a href="classdrake_1_1systems_1_1_leaf_system.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">More...</a><br /></td></tr>
<tr class="separator:ae1f1eff5e4fd7f55d152a1b3b9d4bcd1 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3167bd30bfa014aa61d55fb50ed36f9 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#af3167bd30bfa014aa61d55fb50ed36f9">AddTriggeredWitnessFunctionToCompositeEventCollection</a> (<a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; *event, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const final</td></tr>
<tr class="memdesc:af3167bd30bfa014aa61d55fb50ed36f9 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <code>event</code> to <code>events</code> due to a witness function triggering.  <a href="classdrake_1_1systems_1_1_leaf_system.html#af3167bd30bfa014aa61d55fb50ed36f9">More...</a><br /></td></tr>
<tr class="separator:af3167bd30bfa014aa61d55fb50ed36f9 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c883b4b0aa7a507e29dee582d9ed0fb inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5c883b4b0aa7a507e29dee582d9ed0fb">DoCalcNextUpdateTime</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events, T *<a class="el" href="robot__plan__interpolator__test_8cc.html#a97f443479343d27ae6800e77d16ae3f1">time</a>) const override</td></tr>
<tr class="memdesc:a5c883b4b0aa7a507e29dee582d9ed0fb inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the next update time based on the configured periodic events, for scalar types that are arithmetic, or aborts for scalar types that are not arithmetic.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a5c883b4b0aa7a507e29dee582d9ed0fb">More...</a><br /></td></tr>
<tr class="separator:a5c883b4b0aa7a507e29dee582d9ed0fb inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac370e74eb508e94b3eee667977d7185a inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ac370e74eb508e94b3eee667977d7185a">GetGraphvizFragment</a> (<a class="el" href="classint.html">int</a> max_depth, std::stringstream *dot) const override</td></tr>
<tr class="memdesc:ac370e74eb508e94b3eee667977d7185a inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a graphviz fragment for this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#ac370e74eb508e94b3eee667977d7185a">More...</a><br /></td></tr>
<tr class="separator:ac370e74eb508e94b3eee667977d7185a inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd6d412aafdf2814ced8e8fe460fc23 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#acfd6d412aafdf2814ced8e8fe460fc23">GetGraphvizInputPortToken</a> (const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;port, <a class="el" href="classint.html">int</a> max_depth, std::stringstream *dot) const final</td></tr>
<tr class="memdesc:acfd6d412aafdf2814ced8e8fe460fc23 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a fragment to the <code>dot</code> stream identifying the graphviz node representing <code>port</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#acfd6d412aafdf2814ced8e8fe460fc23">More...</a><br /></td></tr>
<tr class="separator:acfd6d412aafdf2814ced8e8fe460fc23 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37060c889e34319f11652b5ad21cfbb9 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a37060c889e34319f11652b5ad21cfbb9">GetGraphvizOutputPortToken</a> (const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;port, <a class="el" href="classint.html">int</a> max_depth, std::stringstream *dot) const final</td></tr>
<tr class="memdesc:a37060c889e34319f11652b5ad21cfbb9 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a fragment to the <code>dot</code> stream identifying the graphviz node representing <code>port</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a37060c889e34319f11652b5ad21cfbb9">More...</a><br /></td></tr>
<tr class="separator:a37060c889e34319f11652b5ad21cfbb9 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c492962e0a2c6a16f71d4d1bd834ebd inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a4c492962e0a2c6a16f71d4d1bd834ebd">AllocateContinuousState</a> () const</td></tr>
<tr class="memdesc:a4c492962e0a2c6a16f71d4d1bd834ebd inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html" title="ContinuousState is a view of, and optionally a container for, all the continuous state variables xc o...">ContinuousState</a> used to implement both CreateDefaultContext and AllocateTimeDerivatives.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a4c492962e0a2c6a16f71d4d1bd834ebd">More...</a><br /></td></tr>
<tr class="separator:a4c492962e0a2c6a16f71d4d1bd834ebd inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c96c770105d0773b5b4bedc9b1b1a09 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a4c96c770105d0773b5b4bedc9b1b1a09">AllocateDiscreteState</a> () const</td></tr>
<tr class="memdesc:a4c96c770105d0773b5b4bedc9b1b1a09 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves the discrete state as required by CreateDefaultContext.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a4c96c770105d0773b5b4bedc9b1b1a09">More...</a><br /></td></tr>
<tr class="separator:a4c96c770105d0773b5b4bedc9b1b1a09 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb725ce8dde2297feaf4f90d8062691 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_abstract_values.html">AbstractValues</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#aaeb725ce8dde2297feaf4f90d8062691">AllocateAbstractState</a> () const</td></tr>
<tr class="memdesc:aaeb725ce8dde2297feaf4f90d8062691 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves the abstract state as required by CreateDefaultContext.  <a href="classdrake_1_1systems_1_1_leaf_system.html#aaeb725ce8dde2297feaf4f90d8062691">More...</a><br /></td></tr>
<tr class="separator:aaeb725ce8dde2297feaf4f90d8062691 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44e3ad0aeea409a8d82bab9d94b38f2 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ab44e3ad0aeea409a8d82bab9d94b38f2">AllocateParameters</a> () const</td></tr>
<tr class="memdesc:ab44e3ad0aeea409a8d82bab9d94b38f2 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves the parameters as required by CreateDefaultContext.  <a href="classdrake_1_1systems_1_1_leaf_system.html#ab44e3ad0aeea409a8d82bab9d94b38f2">More...</a><br /></td></tr>
<tr class="separator:ab44e3ad0aeea409a8d82bab9d94b38f2 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6516c166d4aedeab3ae31544bbaecbba inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a6516c166d4aedeab3ae31544bbaecbba">DeclareNumericParameter</a> (const <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector)</td></tr>
<tr class="memdesc:a6516c166d4aedeab3ae31544bbaecbba inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a numeric parameter using the given <code>model_vector</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a6516c166d4aedeab3ae31544bbaecbba">More...</a><br /></td></tr>
<tr class="separator:a6516c166d4aedeab3ae31544bbaecbba inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4a60af942a6a568694334837d19931 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class U = BasicVector&gt; </td></tr>
<tr class="memitem:a4e4a60af942a6a568694334837d19931 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">const U&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a4e4a60af942a6a568694334837d19931">GetNumericParameter</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="memdesc:a4e4a60af942a6a568694334837d19931 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the numeric parameters of type U from the <code>context</code> at <code>index</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a4e4a60af942a6a568694334837d19931">More...</a><br /></td></tr>
<tr class="separator:a4e4a60af942a6a568694334837d19931 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab003f82ede0c6e8e6f1f1862ea54b31d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class U = BasicVector&gt; </td></tr>
<tr class="memitem:ab003f82ede0c6e8e6f1f1862ea54b31d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">U&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ab003f82ede0c6e8e6f1f1862ea54b31d">GetMutableNumericParameter</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context, <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="memdesc:ab003f82ede0c6e8e6f1f1862ea54b31d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the numeric parameters of type U from the <code>context</code> at <code>index</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#ab003f82ede0c6e8e6f1f1862ea54b31d">More...</a><br /></td></tr>
<tr class="separator:ab003f82ede0c6e8e6f1f1862ea54b31d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f954e701d1bfba3f8aad91dd4d89ca inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ad7f954e701d1bfba3f8aad91dd4d89ca">DeclareAbstractParameter</a> (const <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">AbstractValue</a> &amp;model_value)</td></tr>
<tr class="memdesc:ad7f954e701d1bfba3f8aad91dd4d89ca inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an abstract parameter using the given <code>model_value</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#ad7f954e701d1bfba3f8aad91dd4d89ca">More...</a><br /></td></tr>
<tr class="separator:ad7f954e701d1bfba3f8aad91dd4d89ca inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6097cfca19ec7c027856fa2c9545a803 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;typename EventType &gt; </td></tr>
<tr class="memitem:a6097cfca19ec7c027856fa2c9545a803 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a6097cfca19ec7c027856fa2c9545a803">DeclarePeriodicEvent</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec)</td></tr>
<tr class="memdesc:a6097cfca19ec7c027856fa2c9545a803 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> has a simple, fixed-period event specified with no custom callback function, and its attribute field contains an Event&lt;T&gt;::PeriodicAttribute constructed from the specified <code>period_sec</code> and <code>offset_sec</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a6097cfca19ec7c027856fa2c9545a803">More...</a><br /></td></tr>
<tr class="separator:a6097cfca19ec7c027856fa2c9545a803 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e5397a57ec949d737f0a7aafd361c1 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;typename EventType &gt; </td></tr>
<tr class="memitem:a50e5397a57ec949d737f0a7aafd361c1 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a50e5397a57ec949d737f0a7aafd361c1">DeclarePeriodicEvent</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec, const EventType &amp;event)</td></tr>
<tr class="memdesc:a50e5397a57ec949d737f0a7aafd361c1 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> has a simple, fixed-period event specified by <code>event</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a50e5397a57ec949d737f0a7aafd361c1">More...</a><br /></td></tr>
<tr class="separator:a50e5397a57ec949d737f0a7aafd361c1 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262f71637a37127840acefca3bda8897 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a262f71637a37127840acefca3bda8897">DeclarePeriodicDiscreteUpdate</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec=0)</td></tr>
<tr class="memdesc:a262f71637a37127840acefca3bda8897 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a periodic discrete update event with period = <code>period_sec</code> and offset = <code>offset_sec</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a262f71637a37127840acefca3bda8897">More...</a><br /></td></tr>
<tr class="separator:a262f71637a37127840acefca3bda8897 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d2dbe47bcb217706226101ed7218bc inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a17d2dbe47bcb217706226101ed7218bc">DeclarePeriodicUnrestrictedUpdate</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec=0)</td></tr>
<tr class="memdesc:a17d2dbe47bcb217706226101ed7218bc inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a periodic unrestricted update event with period = <code>period_sec</code> and offset = <code>offset_sec</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a17d2dbe47bcb217706226101ed7218bc">More...</a><br /></td></tr>
<tr class="separator:a17d2dbe47bcb217706226101ed7218bc inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adf7020dee795fd1b34b023c447eb6f inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a1adf7020dee795fd1b34b023c447eb6f">DeclarePeriodicPublish</a> (<a class="el" href="classdouble.html">double</a> period_sec, <a class="el" href="classdouble.html">double</a> offset_sec=0)</td></tr>
<tr class="memdesc:a1adf7020dee795fd1b34b023c447eb6f inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a periodic publish event with period = <code>period_sec</code> and offset = <code>offset_sec</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a1adf7020dee795fd1b34b023c447eb6f">More...</a><br /></td></tr>
<tr class="separator:a1adf7020dee795fd1b34b023c447eb6f inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901aafa8a436a6988c5cd35527392700 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;typename EventType &gt; </td></tr>
<tr class="memitem:a901aafa8a436a6988c5cd35527392700 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a901aafa8a436a6988c5cd35527392700">DeclarePerStepEvent</a> (const EventType &amp;event)</td></tr>
<tr class="memdesc:a901aafa8a436a6988c5cd35527392700 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a per-step event using <code>event</code>, which is deep copied (the copy is maintained by <code>this</code>).  <a href="classdrake_1_1systems_1_1_leaf_system.html#a901aafa8a436a6988c5cd35527392700">More...</a><br /></td></tr>
<tr class="separator:a901aafa8a436a6988c5cd35527392700 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048bf857e2856f50fc08211a18348563 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;typename EventType &gt; </td></tr>
<tr class="memitem:a048bf857e2856f50fc08211a18348563 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a048bf857e2856f50fc08211a18348563">DeclareInitializationEvent</a> (const EventType &amp;event)</td></tr>
<tr class="memdesc:a048bf857e2856f50fc08211a18348563 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an initialization event by deep copying <code>event</code> and storing it internally.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a048bf857e2856f50fc08211a18348563">More...</a><br /></td></tr>
<tr class="separator:a048bf857e2856f50fc08211a18348563 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a61940dfe3f8f3f3f272513d6aa7c5 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a33a61940dfe3f8f3f3f272513d6aa7c5 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a33a61940dfe3f8f3f3f272513d6aa7c5">DeclareEqualityConstraint</a> (void(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *) const, <a class="el" href="classint.html">int</a> count, const std::string &amp;<a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>)</td></tr>
<tr class="memdesc:a33a61940dfe3f8f3f3f272513d6aa7c5 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a system constraint of the form f(context) = 0 by specifying a member function to use to calculate the (VectorX) constraint value with a signature:  <a href="classdrake_1_1systems_1_1_leaf_system.html#a33a61940dfe3f8f3f3f272513d6aa7c5">More...</a><br /></td></tr>
<tr class="separator:a33a61940dfe3f8f3f3f272513d6aa7c5 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92770eee9494ed687fb79a90ebee3c3a inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a92770eee9494ed687fb79a90ebee3c3a">DeclareEqualityConstraint</a> (typename <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt; T &gt;::CalcCallback calc, <a class="el" href="classint.html">int</a> count, const std::string &amp;<a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>)</td></tr>
<tr class="memdesc:a92770eee9494ed687fb79a90ebee3c3a inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a system constraint of the form f(context) = 0 by specifying a std::function to use to calculate the (Vector) constraint value with a signature:  <a href="classdrake_1_1systems_1_1_leaf_system.html#a92770eee9494ed687fb79a90ebee3c3a">More...</a><br /></td></tr>
<tr class="separator:a92770eee9494ed687fb79a90ebee3c3a inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b8ef2d99466af3d204048fb7416057 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a88b8ef2d99466af3d204048fb7416057 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a88b8ef2d99466af3d204048fb7416057">DeclareInequalityConstraint</a> (void(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *) const, <a class="el" href="classint.html">int</a> count, const std::string &amp;<a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>)</td></tr>
<tr class="memdesc:a88b8ef2d99466af3d204048fb7416057 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a system constraint of the form f(context) ≥ 0 by specifying a member function to use to calculate the (VectorX) constraint value with a signature:  <a href="classdrake_1_1systems_1_1_leaf_system.html#a88b8ef2d99466af3d204048fb7416057">More...</a><br /></td></tr>
<tr class="separator:a88b8ef2d99466af3d204048fb7416057 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0498f32b1164dc5ef3e82cfc735699ff inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a0498f32b1164dc5ef3e82cfc735699ff">DeclareInequalityConstraint</a> (typename <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt; T &gt;::CalcCallback calc, <a class="el" href="classint.html">int</a> count, const std::string &amp;<a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>)</td></tr>
<tr class="memdesc:a0498f32b1164dc5ef3e82cfc735699ff inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a system constraint of the form f(context) ≥ 0 by specifying a std::function to use to calculate the (Vector) constraint value with a signature:  <a href="classdrake_1_1systems_1_1_leaf_system.html#a0498f32b1164dc5ef3e82cfc735699ff">More...</a><br /></td></tr>
<tr class="separator:a0498f32b1164dc5ef3e82cfc735699ff inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6671aa860bee3579fd7573d5c86a7c8 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#af6671aa860bee3579fd7573d5c86a7c8">DoPublish</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; *&gt; &amp;events) const</td></tr>
<tr class="memdesc:af6671aa860bee3579fd7573d5c86a7c8 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived-class event handler for all simultaneous publish events in <code>events</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#af6671aa860bee3579fd7573d5c86a7c8">More...</a><br /></td></tr>
<tr class="separator:af6671aa860bee3579fd7573d5c86a7c8 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb33f7b81837dd9b2fa63315628d85d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#adfb33f7b81837dd9b2fa63315628d85d">DoCalcDiscreteVariableUpdates</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; *&gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state) const</td></tr>
<tr class="memdesc:adfb33f7b81837dd9b2fa63315628d85d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived-class event handler for all simultaneous discrete update events.  <a href="classdrake_1_1systems_1_1_leaf_system.html#adfb33f7b81837dd9b2fa63315628d85d">More...</a><br /></td></tr>
<tr class="separator:adfb33f7b81837dd9b2fa63315628d85d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a310c2914e5f99c5a76c0049e600148 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5a310c2914e5f99c5a76c0049e600148">DoCalcUnrestrictedUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; *&gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:a5a310c2914e5f99c5a76c0049e600148 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived-class event handler for all simultaneous unrestricted update events.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a5a310c2914e5f99c5a76c0049e600148">More...</a><br /></td></tr>
<tr class="separator:a5a310c2914e5f99c5a76c0049e600148 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edb34820bfc553a9956c65e648b517b inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a9edb34820bfc553a9956c65e648b517b">DeclareContinuousState</a> (<a class="el" href="classint.html">int</a> num_state_variables)</td></tr>
<tr class="memdesc:a9edb34820bfc553a9956c65e648b517b inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> should reserve continuous state with <code>num_state_variables</code> state variables, which have no second-order structure.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a9edb34820bfc553a9956c65e648b517b">More...</a><br /></td></tr>
<tr class="separator:a9edb34820bfc553a9956c65e648b517b inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc333ff0c045b371b5885f8350d8e0d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5dc333ff0c045b371b5885f8350d8e0d">DeclareContinuousState</a> (<a class="el" href="classint.html">int</a> num_q, <a class="el" href="classint.html">int</a> num_v, <a class="el" href="classint.html">int</a> num_z)</td></tr>
<tr class="memdesc:a5dc333ff0c045b371b5885f8350d8e0d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> should reserve continuous state with <code>num_q</code> generalized positions, <code>num_v</code> generalized velocities, and <code>num_z</code> miscellaneous state variables.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a5dc333ff0c045b371b5885f8350d8e0d">More...</a><br /></td></tr>
<tr class="separator:a5dc333ff0c045b371b5885f8350d8e0d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e506e194325a4456e4bc11800024272 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a2e506e194325a4456e4bc11800024272">DeclareContinuousState</a> (const <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector)</td></tr>
<tr class="memdesc:a2e506e194325a4456e4bc11800024272 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> should reserve continuous state with <code>model_vector.size()</code> miscellaneous state variables, stored in a vector cloned from <code>model_vector</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a2e506e194325a4456e4bc11800024272">More...</a><br /></td></tr>
<tr class="separator:a2e506e194325a4456e4bc11800024272 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071d625d476e34c1a239d58eaa8e8676 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a071d625d476e34c1a239d58eaa8e8676">DeclareContinuousState</a> (const <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector, <a class="el" href="classint.html">int</a> num_q, <a class="el" href="classint.html">int</a> num_v, <a class="el" href="classint.html">int</a> num_z)</td></tr>
<tr class="memdesc:a071d625d476e34c1a239d58eaa8e8676 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> should reserve continuous state with <code>num_q</code> generalized positions, <code>num_v</code> generalized velocities, and <code>num_z</code> miscellaneous state variables, stored in a vector cloned from <code>model_vector</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a071d625d476e34c1a239d58eaa8e8676">More...</a><br /></td></tr>
<tr class="separator:a071d625d476e34c1a239d58eaa8e8676 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ef984b4d9b8313d1239b76388882d2 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a47ef984b4d9b8313d1239b76388882d2">DeclareDiscreteState</a> (const <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector)</td></tr>
<tr class="memdesc:a47ef984b4d9b8313d1239b76388882d2 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a discrete state group with <code>model_vector.size()</code> state variables, stored in a vector cloned from <code>model_vector</code> (preserving the concrete type and value).  <a href="classdrake_1_1systems_1_1_leaf_system.html#a47ef984b4d9b8313d1239b76388882d2">More...</a><br /></td></tr>
<tr class="separator:a47ef984b4d9b8313d1239b76388882d2 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54115bda5b519f863e41d8e5463d24cb inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a54115bda5b519f863e41d8e5463d24cb">DeclareDiscreteState</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;model_vector)</td></tr>
<tr class="memdesc:a54115bda5b519f863e41d8e5463d24cb inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a discrete state group with <code>model_vector.size()</code> state variables, stored in a <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase. ">BasicVector</a> initialized with the contents of <code>model_vector</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a54115bda5b519f863e41d8e5463d24cb">More...</a><br /></td></tr>
<tr class="separator:a54115bda5b519f863e41d8e5463d24cb inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02cadb14746ff469fa338d2351a5e68 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ad02cadb14746ff469fa338d2351a5e68">DeclareDiscreteState</a> (<a class="el" href="classint.html">int</a> num_state_variables)</td></tr>
<tr class="memdesc:ad02cadb14746ff469fa338d2351a5e68 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a discrete state group with <code>num_state_variables</code> state variables, stored in a <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase. ">BasicVector</a> initialized to be all-zero.  <a href="classdrake_1_1systems_1_1_leaf_system.html#ad02cadb14746ff469fa338d2351a5e68">More...</a><br /></td></tr>
<tr class="separator:ad02cadb14746ff469fa338d2351a5e68 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709a4f26de52b89c79afe32d02d0250c inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a709a4f26de52b89c79afe32d02d0250c">DeclareAbstractState</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">AbstractValue</a> &gt; abstract_state)</td></tr>
<tr class="memdesc:a709a4f26de52b89c79afe32d02d0250c inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an abstract state.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a709a4f26de52b89c79afe32d02d0250c">More...</a><br /></td></tr>
<tr class="separator:a709a4f26de52b89c79afe32d02d0250c inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8f6aee361111b2b09c239e94c6199f inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a0c8f6aee361111b2b09c239e94c6199f">DeclareVectorInputPort</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector, <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt; random_type=<a class="el" href="namespacedrake.html#acd293644b847dc4549de80a090d66625">nullopt</a>)</td></tr>
<tr class="memdesc:a0c8f6aee361111b2b09c239e94c6199f inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a vector-valued input port using the given <code>model_vector</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a0c8f6aee361111b2b09c239e94c6199f">More...</a><br /></td></tr>
<tr class="separator:a0c8f6aee361111b2b09c239e94c6199f inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fed44d2fe8d059c629ca73a77d5744a inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a0fed44d2fe8d059c629ca73a77d5744a">DeclareAbstractInputPort</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">AbstractValue</a> &amp;model_value)</td></tr>
<tr class="memdesc:a0fed44d2fe8d059c629ca73a77d5744a inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an abstract-valued input port using the given <code>model_value</code>.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a0fed44d2fe8d059c629ca73a77d5744a">More...</a><br /></td></tr>
<tr class="separator:a0fed44d2fe8d059c629ca73a77d5744a inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee88308cf24ddc90f80e3cf9df72677 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a6ee88308cf24ddc90f80e3cf9df72677">DeclareVectorInputPort</a> (const <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector, <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt; random_type=<a class="el" href="namespacedrake.html#acd293644b847dc4549de80a090d66625">nullopt</a>)</td></tr>
<tr class="memdesc:a6ee88308cf24ddc90f80e3cf9df72677 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the nearly identical signature with an additional (first) argument specifying the port name.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a6ee88308cf24ddc90f80e3cf9df72677">More...</a><br /></td></tr>
<tr class="separator:a6ee88308cf24ddc90f80e3cf9df72677 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969b402d1c7a590576a6569c17fdf212 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a969b402d1c7a590576a6569c17fdf212">DeclareAbstractInputPort</a> (const <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">AbstractValue</a> &amp;model_value)</td></tr>
<tr class="memdesc:a969b402d1c7a590576a6569c17fdf212 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the nearly identical signature with an additional (first) argument specifying the port name.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a969b402d1c7a590576a6569c17fdf212">More...</a><br /></td></tr>
<tr class="separator:a969b402d1c7a590576a6569c17fdf212 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dab08bb5a96c26a2261d79accface0e inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename BasicVectorSubtype &gt; </td></tr>
<tr class="memitem:a0dab08bb5a96c26a2261d79accface0e inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a0dab08bb5a96c26a2261d79accface0e">DeclareVectorOutputPort</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const BasicVectorSubtype &amp;model_vector, void(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, BasicVectorSubtype *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a0dab08bb5a96c26a2261d79accface0e inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a vector-valued output port by specifying (1) a model vector of type BasicVectorSubtype derived from <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase. ">BasicVector</a> and initialized to the correct size and desired initial value, and (2) a calculator function that is a class member function (method) with signature:  <a href="classdrake_1_1systems_1_1_leaf_system.html#a0dab08bb5a96c26a2261d79accface0e">More...</a><br /></td></tr>
<tr class="separator:a0dab08bb5a96c26a2261d79accface0e inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7c2a085758a2663663830526eea38d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename BasicVectorSubtype &gt; </td></tr>
<tr class="memitem:a3c7c2a085758a2663663830526eea38d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a3c7c2a085758a2663663830526eea38d">DeclareVectorOutputPort</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, void(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, BasicVectorSubtype *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a3c7c2a085758a2663663830526eea38d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a vector-valued output port by specifying <em>only</em> a calculator function that is a class member function (method) with signature:  <a href="classdrake_1_1systems_1_1_leaf_system.html#a3c7c2a085758a2663663830526eea38d">More...</a><br /></td></tr>
<tr class="separator:a3c7c2a085758a2663663830526eea38d inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade82d5fa906aed5e8e2d8496e6474369 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ade82d5fa906aed5e8e2d8496e6474369">DeclareVectorOutputPort</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector, typename <a class="el" href="classdrake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcVectorCallback vector_calc_function, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:ade82d5fa906aed5e8e2d8496e6474369 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Declares a vector-valued output port using the given <code>model_vector</code> and a function for calculating the port's value at runtime.  <a href="classdrake_1_1systems_1_1_leaf_system.html#ade82d5fa906aed5e8e2d8496e6474369">More...</a><br /></td></tr>
<tr class="separator:ade82d5fa906aed5e8e2d8496e6474369 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5172c4d08c595e448adf93e1b6f9618 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename OutputType &gt; </td></tr>
<tr class="memitem:ac5172c4d08c595e448adf93e1b6f9618 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ac5172c4d08c595e448adf93e1b6f9618">DeclareAbstractOutputPort</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, const OutputType &amp;model_value, void(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:ac5172c4d08c595e448adf93e1b6f9618 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an abstract-valued output port by specifying a model value of concrete type <code>OutputType</code> and a calculator function that is a class member function (method) with signature:  <a href="classdrake_1_1systems_1_1_leaf_system.html#ac5172c4d08c595e448adf93e1b6f9618">More...</a><br /></td></tr>
<tr class="separator:ac5172c4d08c595e448adf93e1b6f9618 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa460e249694b049f486e54b0e1cce339 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename OutputType &gt; </td></tr>
<tr class="memitem:aa460e249694b049f486e54b0e1cce339 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#aa460e249694b049f486e54b0e1cce339">DeclareAbstractOutputPort</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, void(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:aa460e249694b049f486e54b0e1cce339 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an abstract-valued output port by specifying only a calculator function that is a class member function (method) with signature:  <a href="classdrake_1_1systems_1_1_leaf_system.html#aa460e249694b049f486e54b0e1cce339">More...</a><br /></td></tr>
<tr class="separator:aa460e249694b049f486e54b0e1cce339 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fceedef5172593d7d72d6e73577c40f inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename OutputType &gt; </td></tr>
<tr class="memitem:a3fceedef5172593d7d72d6e73577c40f inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a3fceedef5172593d7d72d6e73577c40f">DeclareAbstractOutputPort</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, OutputType(MySystem::*make)() const, void(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a3fceedef5172593d7d72d6e73577c40f inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an abstract-valued output port by specifying member functions to use both for the allocator and calculator.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a3fceedef5172593d7d72d6e73577c40f">More...</a><br /></td></tr>
<tr class="separator:a3fceedef5172593d7d72d6e73577c40f inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57d88b4d995532ef9c733d3b8915949 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ab57d88b4d995532ef9c733d3b8915949">DeclareAbstractOutputPort</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, typename <a class="el" href="classdrake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::AllocCallback alloc_function, typename <a class="el" href="classdrake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcCallback calc_function, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:ab57d88b4d995532ef9c733d3b8915949 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Declares an abstract-valued output port using the given allocator and calculator functions provided in their most generic forms.  <a href="classdrake_1_1systems_1_1_leaf_system.html#ab57d88b4d995532ef9c733d3b8915949">More...</a><br /></td></tr>
<tr class="separator:ab57d88b4d995532ef9c733d3b8915949 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ad4d4eefbda2dc6d7ef45c60add176 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename BasicVectorSubtype &gt; </td></tr>
<tr class="memitem:a60ad4d4eefbda2dc6d7ef45c60add176 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a60ad4d4eefbda2dc6d7ef45c60add176">DeclareVectorOutputPort</a> (const BasicVectorSubtype &amp;model_vector, void(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, BasicVectorSubtype *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a60ad4d4eefbda2dc6d7ef45c60add176 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the nearly identical signature with an additional (first) argument specifying the port name.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a60ad4d4eefbda2dc6d7ef45c60add176">More...</a><br /></td></tr>
<tr class="separator:a60ad4d4eefbda2dc6d7ef45c60add176 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c31db09ead639e9938ae4421e731a3 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename BasicVectorSubtype &gt; </td></tr>
<tr class="memitem:ad3c31db09ead639e9938ae4421e731a3 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ad3c31db09ead639e9938ae4421e731a3">DeclareVectorOutputPort</a> (void(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, BasicVectorSubtype *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:ad3c31db09ead639e9938ae4421e731a3 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the nearly identical signature with an additional (first) argument specifying the port name.  <a href="classdrake_1_1systems_1_1_leaf_system.html#ad3c31db09ead639e9938ae4421e731a3">More...</a><br /></td></tr>
<tr class="separator:ad3c31db09ead639e9938ae4421e731a3 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacd552ffd22b30c71a24e8a6eef2860 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#abacd552ffd22b30c71a24e8a6eef2860">DeclareVectorOutputPort</a> (const <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &amp;model_vector, typename <a class="el" href="classdrake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcVectorCallback vector_calc_function, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:abacd552ffd22b30c71a24e8a6eef2860 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the nearly identical signature with an additional (first) argument specifying the port name.  <a href="classdrake_1_1systems_1_1_leaf_system.html#abacd552ffd22b30c71a24e8a6eef2860">More...</a><br /></td></tr>
<tr class="separator:abacd552ffd22b30c71a24e8a6eef2860 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1ea020580043ab7b781583c3d722fa inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename OutputType &gt; </td></tr>
<tr class="memitem:afa1ea020580043ab7b781583c3d722fa inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_same&lt; OutputType, std::string &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#afa1ea020580043ab7b781583c3d722fa">DeclareAbstractOutputPort</a> (const OutputType &amp;model_value, void(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:afa1ea020580043ab7b781583c3d722fa inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the nearly identical signature with an additional (first) argument specifying the port name.  <a href="classdrake_1_1systems_1_1_leaf_system.html#afa1ea020580043ab7b781583c3d722fa">More...</a><br /></td></tr>
<tr class="separator:afa1ea020580043ab7b781583c3d722fa inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9d7ba0620192e37e0dd5c594f18f21 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename OutputType &gt; </td></tr>
<tr class="memitem:a6e9d7ba0620192e37e0dd5c594f18f21 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a6e9d7ba0620192e37e0dd5c594f18f21">DeclareAbstractOutputPort</a> (void(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a6e9d7ba0620192e37e0dd5c594f18f21 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the nearly identical signature with an additional (first) argument specifying the port name.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a6e9d7ba0620192e37e0dd5c594f18f21">More...</a><br /></td></tr>
<tr class="separator:a6e9d7ba0620192e37e0dd5c594f18f21 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201826f60a596cd0a6be834f1277a6f6 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem , typename OutputType &gt; </td></tr>
<tr class="memitem:a201826f60a596cd0a6be834f1277a6f6 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a201826f60a596cd0a6be834f1277a6f6">DeclareAbstractOutputPort</a> (OutputType(MySystem::*make)() const, void(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, OutputType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a201826f60a596cd0a6be834f1277a6f6 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the nearly identical signature with an additional (first) argument specifying the port name.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a201826f60a596cd0a6be834f1277a6f6">More...</a><br /></td></tr>
<tr class="separator:a201826f60a596cd0a6be834f1277a6f6 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b55e1f9869d60eca48f0336ec4a3dd9 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5b55e1f9869d60eca48f0336ec4a3dd9">DeclareAbstractOutputPort</a> (typename <a class="el" href="classdrake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::AllocCallback alloc_function, typename <a class="el" href="classdrake_1_1systems_1_1_leaf_output_port.html">LeafOutputPort</a>&lt; T &gt;::CalcCallback calc_function, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a5b55e1f9869d60eca48f0336ec4a3dd9 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the nearly identical signature with an additional (first) argument specifying the port name.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a5b55e1f9869d60eca48f0336ec4a3dd9">More...</a><br /></td></tr>
<tr class="separator:a5b55e1f9869d60eca48f0336ec4a3dd9 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c30e1004f67ca88994fbb32d1721fb6 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a6c30e1004f67ca88994fbb32d1721fb6 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a6c30e1004f67ca88994fbb32d1721fb6">DeclareWitnessFunction</a> (const std::string &amp;<a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, const <a class="el" href="namespacedrake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, T(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const) const</td></tr>
<tr class="memdesc:a6c30e1004f67ca88994fbb32d1721fb6 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, and calculator function; and with no event object.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a6c30e1004f67ca88994fbb32d1721fb6">More...</a><br /></td></tr>
<tr class="separator:a6c30e1004f67ca88994fbb32d1721fb6 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944960c2591d4a0b49792b31ee4ca06e inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a944960c2591d4a0b49792b31ee4ca06e">DeclareWitnessFunction</a> (const std::string &amp;<a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, const <a class="el" href="namespacedrake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, std::function&lt; T(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;)&gt; calc) const</td></tr>
<tr class="memdesc:a944960c2591d4a0b49792b31ee4ca06e inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, and calculator function; and with no event object.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a944960c2591d4a0b49792b31ee4ca06e">More...</a><br /></td></tr>
<tr class="separator:a944960c2591d4a0b49792b31ee4ca06e inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1e1e7ba5a5d89ebc0ad6e45bc922bc inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a4d1e1e7ba5a5d89ebc0ad6e45bc922bc inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a4d1e1e7ba5a5d89ebc0ad6e45bc922bc">DeclareWitnessFunction</a> (const std::string &amp;<a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, const <a class="el" href="namespacedrake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, T(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const, void(MySystem::*publish_callback)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, const <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &amp;) const) const</td></tr>
<tr class="memdesc:a4d1e1e7ba5a5d89ebc0ad6e45bc922bc inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, calculator function, and publish event callback function for when this triggers.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a4d1e1e7ba5a5d89ebc0ad6e45bc922bc">More...</a><br /></td></tr>
<tr class="separator:a4d1e1e7ba5a5d89ebc0ad6e45bc922bc inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04726fa6f1601cd8d67b00b3ac2466b4 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:a04726fa6f1601cd8d67b00b3ac2466b4 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a04726fa6f1601cd8d67b00b3ac2466b4">DeclareWitnessFunction</a> (const std::string &amp;<a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, const <a class="el" href="namespacedrake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, T(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const, void(MySystem::*du_callback)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, const <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &amp;, <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *) const) const</td></tr>
<tr class="memdesc:a04726fa6f1601cd8d67b00b3ac2466b4 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, calculator function, and discrete update event callback function for when this triggers.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a04726fa6f1601cd8d67b00b3ac2466b4">More...</a><br /></td></tr>
<tr class="separator:a04726fa6f1601cd8d67b00b3ac2466b4 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc92728a3a914ef7c040c4efbdb19512 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:acc92728a3a914ef7c040c4efbdb19512 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#acc92728a3a914ef7c040c4efbdb19512">DeclareWitnessFunction</a> (const std::string &amp;<a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, const <a class="el" href="namespacedrake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, T(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const, void(MySystem::*uu_callback)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, const <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &amp;, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *) const) const</td></tr>
<tr class="memdesc:acc92728a3a914ef7c040c4efbdb19512 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, calculator function, and unrestricted update event callback function for when this triggers.  <a href="classdrake_1_1systems_1_1_leaf_system.html#acc92728a3a914ef7c040c4efbdb19512">More...</a><br /></td></tr>
<tr class="separator:acc92728a3a914ef7c040c4efbdb19512 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83010cd682a419e2c880e37d520537a inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplParams" colspan="2">template&lt;class MySystem &gt; </td></tr>
<tr class="memitem:aa83010cd682a419e2c880e37d520537a inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#aa83010cd682a419e2c880e37d520537a">DeclareWitnessFunction</a> (const std::string &amp;<a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, const <a class="el" href="namespacedrake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, T(MySystem::*calc)(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;) const, const <a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; &amp;e) const</td></tr>
<tr class="memdesc:aa83010cd682a419e2c880e37d520537a inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, and calculator function, and with an object corresponding to the event that is to be dispatched when this witness function triggers.  <a href="classdrake_1_1systems_1_1_leaf_system.html#aa83010cd682a419e2c880e37d520537a">More...</a><br /></td></tr>
<tr class="separator:aa83010cd682a419e2c880e37d520537a inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7177648f70c566f605811dafbe96ebb5 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a7177648f70c566f605811dafbe96ebb5">DeclareWitnessFunction</a> (const std::string &amp;<a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, const <a class="el" href="namespacedrake_1_1systems.html#afe8fe136944074e97f02b7e3835347b3">WitnessFunctionDirection</a> &amp;direction_type, std::function&lt; T(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;)&gt; calc, const <a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; &amp;e) const</td></tr>
<tr class="memdesc:a7177648f70c566f605811dafbe96ebb5 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the witness function with the given description (used primarily for debugging and logging), direction type, and calculator function, and with an object corresponding to the event that is to be dispatched when this witness function triggers.  <a href="classdrake_1_1systems_1_1_leaf_system.html#a7177648f70c566f605811dafbe96ebb5">More...</a><br /></td></tr>
<tr class="separator:a7177648f70c566f605811dafbe96ebb5 inherit pro_methods_classdrake_1_1systems_1_1_leaf_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1systems_1_1_system"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdrake_1_1systems_1_1_system')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_system.html">System&lt; T &gt;</a></td></tr>
<tr class="memitem:aad67111baf766af9690537477790a6c4 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aad67111baf766af9690537477790a6c4">DoGetWitnessFunctions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; *&gt; *) const</td></tr>
<tr class="memdesc:aad67111baf766af9690537477790a6c4 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes can override this method to provide witness functions active for the given state.  <a href="classdrake_1_1systems_1_1_system.html#aad67111baf766af9690537477790a6c4">More...</a><br /></td></tr>
<tr class="separator:aad67111baf766af9690537477790a6c4 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fbf92ac77db4d805a5a5cf980de130 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ac9fbf92ac77db4d805a5a5cf980de130">AddConstraint</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt; T &gt;&gt; <a class="el" href="nlopt__solver_8cc.html#a3c57db1007715ab636108b253c041c17">constraint</a>)</td></tr>
<tr class="memdesc:ac9fbf92ac77db4d805a5a5cf980de130 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an already-created constraint to the list of constraints for this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system.html#ac9fbf92ac77db4d805a5a5cf980de130">More...</a><br /></td></tr>
<tr class="separator:ac9fbf92ac77db4d805a5a5cf980de130 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa532bcdc29e8be25c20b40968bb95b66 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa532bcdc29e8be25c20b40968bb95b66">get_forced_publish_events</a> () const</td></tr>
<tr class="separator:aa532bcdc29e8be25c20b40968bb95b66 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3137d050d040e4beb9ef60cd004ac112 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a3137d050d040e4beb9ef60cd004ac112">get_forced_discrete_update_events</a> () const</td></tr>
<tr class="separator:a3137d050d040e4beb9ef60cd004ac112 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac53f82a39ea0c5e3240a9bab52b1415 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aac53f82a39ea0c5e3240a9bab52b1415">get_forced_unrestricted_update_events</a> () const</td></tr>
<tr class="separator:aac53f82a39ea0c5e3240a9bab52b1415 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7240490688324a9f15132fee98e52ce inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ac7240490688324a9f15132fee98e52ce">set_forced_publish_events</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt;&gt;&gt; forced)</td></tr>
<tr class="separator:ac7240490688324a9f15132fee98e52ce inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0aacb96a01eb38099ac6cd4d12037b inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#afd0aacb96a01eb38099ac6cd4d12037b">set_forced_discrete_update_events</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt;&gt;&gt; forced)</td></tr>
<tr class="separator:afd0aacb96a01eb38099ac6cd4d12037b inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c5ab861b2f08ff5a29066458747b9a inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a75c5ab861b2f08ff5a29066458747b9a">set_forced_unrestricted_update_events</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt;&gt;&gt; forced)</td></tr>
<tr class="separator:a75c5ab861b2f08ff5a29066458747b9a inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b849c60d9ec6bbfeac42dc3c075a02 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa1b849c60d9ec6bbfeac42dc3c075a02">System</a> (<a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> converter)</td></tr>
<tr class="memdesc:aa1b849c60d9ec6bbfeac42dc3c075a02 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty System base class object and allocates base class resources, possibly supporting scalar-type conversion support (AutoDiff, etc.) using <code>converter</code>.  <a href="classdrake_1_1systems_1_1_system.html#aa1b849c60d9ec6bbfeac42dc3c075a02">More...</a><br /></td></tr>
<tr class="separator:aa1b849c60d9ec6bbfeac42dc3c075a02 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011a04791ece0fa2ae1efa90d9bf35cf inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a011a04791ece0fa2ae1efa90d9bf35cf">DeclareInputPort</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>, <a class="el" href="namespacedrake_1_1systems.html#ae516fceb67f15f61c7a232b9cc483fbe">PortDataType</a> <a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>, <a class="el" href="classint.html">int</a> <a class="el" href="lcm__image__array__to__images_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>, <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt; random_type=<a class="el" href="namespacedrake.html#acd293644b847dc4549de80a090d66625">nullopt</a>)</td></tr>
<tr class="memdesc:a011a04791ece0fa2ae1efa90d9bf35cf inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a port with the specified <code>type</code> and <code>size</code> to the input topology.  <a href="classdrake_1_1systems_1_1_system.html#a011a04791ece0fa2ae1efa90d9bf35cf">More...</a><br /></td></tr>
<tr class="separator:a011a04791ece0fa2ae1efa90d9bf35cf inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5f2153443d34fc439945fc34e64c5e inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#afc5f2153443d34fc439945fc34e64c5e">DeclareInputPort</a> (<a class="el" href="namespacedrake_1_1systems.html#ae516fceb67f15f61c7a232b9cc483fbe">PortDataType</a> <a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>, <a class="el" href="classint.html">int</a> <a class="el" href="lcm__image__array__to__images_8cc.html#a439227feff9d7f55384e8780cfc2eb82">size</a>, <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt; random_type=<a class="el" href="namespacedrake.html#acd293644b847dc4549de80a090d66625">nullopt</a>)</td></tr>
<tr class="memdesc:afc5f2153443d34fc439945fc34e64c5e inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the nearly identical signature with an additional (first) argument specifying the port name.  <a href="classdrake_1_1systems_1_1_system.html#afc5f2153443d34fc439945fc34e64c5e">More...</a><br /></td></tr>
<tr class="separator:afc5f2153443d34fc439945fc34e64c5e inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2b6bbca36ba86a269c9fd42ddfb6d0 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a2d2b6bbca36ba86a269c9fd42ddfb6d0">DoCalcTimeDerivatives</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *derivatives) const</td></tr>
<tr class="memdesc:a2d2b6bbca36ba86a269c9fd42ddfb6d0 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this if you have any continuous state variables <code>xc</code> in your concrete System to calculate their time derivatives.  <a href="classdrake_1_1systems_1_1_system.html#a2d2b6bbca36ba86a269c9fd42ddfb6d0">More...</a><br /></td></tr>
<tr class="separator:a2d2b6bbca36ba86a269c9fd42ddfb6d0 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f055c2fb422eefe50faf9a0979c1e0 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a40f055c2fb422eefe50faf9a0979c1e0">DoCalcPotentialEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a40f055c2fb422eefe50faf9a0979c1e0 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method for physical systems to calculate the potential energy PE currently stored in the configuration provided in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classdrake_1_1systems_1_1_system.html#a40f055c2fb422eefe50faf9a0979c1e0">More...</a><br /></td></tr>
<tr class="separator:a40f055c2fb422eefe50faf9a0979c1e0 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de30438c7fbda84a0cc9a35ca543c8e inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a8de30438c7fbda84a0cc9a35ca543c8e">DoCalcKineticEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a8de30438c7fbda84a0cc9a35ca543c8e inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method for physical systems to calculate the kinetic energy KE currently present in the motion provided in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classdrake_1_1systems_1_1_system.html#a8de30438c7fbda84a0cc9a35ca543c8e">More...</a><br /></td></tr>
<tr class="separator:a8de30438c7fbda84a0cc9a35ca543c8e inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa6ce88c0e7ba9f6592713d36bc4047 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aafa6ce88c0e7ba9f6592713d36bc4047">DoCalcConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aafa6ce88c0e7ba9f6592713d36bc4047 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method to return the rate Pc at which mechanical energy is being converted <em>from</em> potential energy <em>to</em> kinetic energy by this system in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="classdrake_1_1systems_1_1_system.html#aafa6ce88c0e7ba9f6592713d36bc4047">More...</a><br /></td></tr>
<tr class="separator:aafa6ce88c0e7ba9f6592713d36bc4047 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc39e42fbb88d08592d2f7e7c12637d inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a3bc39e42fbb88d08592d2f7e7c12637d">DoCalcNonConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a3bc39e42fbb88d08592d2f7e7c12637d inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method to return the rate Pnc at which work W is done on the system by non-conservative forces.  <a href="classdrake_1_1systems_1_1_system.html#a3bc39e42fbb88d08592d2f7e7c12637d">More...</a><br /></td></tr>
<tr class="separator:a3bc39e42fbb88d08592d2f7e7c12637d inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8545168ea9a0a202bd82b3aeb08f5530 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a8545168ea9a0a202bd82b3aeb08f5530">DoMapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;qdot, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *generalized_velocity) const</td></tr>
<tr class="memdesc:a8545168ea9a0a202bd82b3aeb08f5530 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the substantive implementation of <a class="el" href="classdrake_1_1systems_1_1_system.html#a10eba167739bfe8e7e419b5c8ae41537" title="Transforms the time derivative qdot of the generalized configuration q to generalized velocities v...">MapQDotToVelocity()</a>.  <a href="classdrake_1_1systems_1_1_system.html#a8545168ea9a0a202bd82b3aeb08f5530">More...</a><br /></td></tr>
<tr class="separator:a8545168ea9a0a202bd82b3aeb08f5530 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2922fc55384af89c4a3734a476af08f inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#aa2922fc55384af89c4a3734a476af08f">DoMapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;generalized_velocity, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *qdot) const</td></tr>
<tr class="memdesc:aa2922fc55384af89c4a3734a476af08f inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the substantive implementation of <a class="el" href="classdrake_1_1systems_1_1_system.html#a05cc5df6d0d0fe4ea54b522ae776ca39" title="Transforms a given generalized velocity v to the time derivative qdot of the generalized configuratio...">MapVelocityToQDot()</a>.  <a href="classdrake_1_1systems_1_1_system.html#aa2922fc55384af89c4a3734a476af08f">More...</a><br /></td></tr>
<tr class="separator:aa2922fc55384af89c4a3734a476af08f inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92f74ba8239aeca3a325e3a77c53478 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#af92f74ba8239aeca3a325e3a77c53478">do_get_num_constraint_equations</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:af92f74ba8239aeca3a325e3a77c53478 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of constraint equations for this system from the given context.  <a href="classdrake_1_1systems_1_1_system.html#af92f74ba8239aeca3a325e3a77c53478">More...</a><br /></td></tr>
<tr class="separator:af92f74ba8239aeca3a325e3a77c53478 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73640bb8a630f97962b71df8035a7fc2 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a73640bb8a630f97962b71df8035a7fc2">DoEvalConstraintEquations</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a73640bb8a630f97962b71df8035a7fc2 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the constraint equations for the system at the generalized coordinates and generalized velocity specified by the context.  <a href="classdrake_1_1systems_1_1_system.html#a73640bb8a630f97962b71df8035a7fc2">More...</a><br /></td></tr>
<tr class="separator:a73640bb8a630f97962b71df8035a7fc2 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11da6dcf33e2196ef99444666969d7dd inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a11da6dcf33e2196ef99444666969d7dd">DoEvalConstraintEquationsDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a11da6dcf33e2196ef99444666969d7dd inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the time derivative of each constraint equation, evaluated at the generalized coordinates and generalized velocity specified by the context.  <a href="classdrake_1_1systems_1_1_system.html#a11da6dcf33e2196ef99444666969d7dd">More...</a><br /></td></tr>
<tr class="separator:a11da6dcf33e2196ef99444666969d7dd inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae033a9554c35fda06c022cb890621583 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#ae033a9554c35fda06c022cb890621583">DoCalcVelocityChangeFromConstraintImpulses</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::MatrixXd &amp;J, const Eigen::VectorXd &amp;lambda) const</td></tr>
<tr class="memdesc:ae033a9554c35fda06c022cb890621583 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the change in velocity from applying the given constraint forces to the system at the given context.  <a href="classdrake_1_1systems_1_1_system.html#ae033a9554c35fda06c022cb890621583">More...</a><br /></td></tr>
<tr class="separator:ae033a9554c35fda06c022cb890621583 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d42c7934ea48286f9eaa1c57e65e0b5 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a7d42c7934ea48286f9eaa1c57e65e0b5">DoCalcConstraintErrorNorm</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::VectorXd &amp;error) const</td></tr>
<tr class="memdesc:a7d42c7934ea48286f9eaa1c57e65e0b5 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the norm of the constraint error.  <a href="classdrake_1_1systems_1_1_system.html#a7d42c7934ea48286f9eaa1c57e65e0b5">More...</a><br /></td></tr>
<tr class="separator:a7d42c7934ea48286f9eaa1c57e65e0b5 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224803a17e7cb76634565ce6def996d8 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system.html#a224803a17e7cb76634565ce6def996d8">GetMutableOutputVector</a> (<a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *output, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:a224803a17e7cb76634565ce6def996d8 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable <a class="el" href="namespace_eigen.html">Eigen</a> expression for a vector valued output port with index <code>port_index</code> in this system.  <a href="classdrake_1_1systems_1_1_system.html#a224803a17e7cb76634565ce6def996d8">More...</a><br /></td></tr>
<tr class="separator:a224803a17e7cb76634565ce6def996d8 inherit pro_methods_classdrake_1_1systems_1_1_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1systems_1_1_system_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdrake_1_1systems_1_1_system_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a></td></tr>
<tr class="memitem:a1cd0ce5bd76208e8110ad85a956e3127 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1cd0ce5bd76208e8110ad85a956e3127">SystemBase</a> ()=default</td></tr>
<tr class="memdesc:a1cd0ce5bd76208e8110ad85a956e3127 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Default constructor.  <a href="classdrake_1_1systems_1_1_system_base.html#a1cd0ce5bd76208e8110ad85a956e3127">More...</a><br /></td></tr>
<tr class="separator:a1cd0ce5bd76208e8110ad85a956e3127 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83ce091f3aba8ecb71e72262fc1fd6b inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab83ce091f3aba8ecb71e72262fc1fd6b">AddInputPort</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_input_port_base.html">InputPortBase</a> &gt; port)</td></tr>
<tr class="memdesc:ab83ce091f3aba8ecb71e72262fc1fd6b inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Adds an already-constructed input port to this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#ab83ce091f3aba8ecb71e72262fc1fd6b">More...</a><br /></td></tr>
<tr class="separator:ab83ce091f3aba8ecb71e72262fc1fd6b inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89be3ba9e76827e83fb1e139e5b750cc inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a89be3ba9e76827e83fb1e139e5b750cc">AddOutputPort</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_output_port_base.html">OutputPortBase</a> &gt; port)</td></tr>
<tr class="memdesc:a89be3ba9e76827e83fb1e139e5b750cc inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Adds an already-constructed output port to this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>.  <a href="classdrake_1_1systems_1_1_system_base.html#a89be3ba9e76827e83fb1e139e5b750cc">More...</a><br /></td></tr>
<tr class="separator:a89be3ba9e76827e83fb1e139e5b750cc inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af663ea589da3acdb084bdc608b1a4255 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af663ea589da3acdb084bdc608b1a4255">NextInputPortName</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; given_name) const</td></tr>
<tr class="memdesc:af663ea589da3acdb084bdc608b1a4255 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a name for the next input port, using the given name if it isn't kUseDefaultName, otherwise making up a name like "u3" from the next available input port index.  <a href="classdrake_1_1systems_1_1_system_base.html#af663ea589da3acdb084bdc608b1a4255">More...</a><br /></td></tr>
<tr class="separator:af663ea589da3acdb084bdc608b1a4255 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3697edc2cfdba03b33e7f39474531d3 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab3697edc2cfdba03b33e7f39474531d3">NextOutputPortName</a> (<a class="el" href="namespacedrake.html#ae98164c05774e687076c1562cf8d7593">variant</a>&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; given_name) const</td></tr>
<tr class="memdesc:ab3697edc2cfdba03b33e7f39474531d3 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a name for the next output port, using the given name if it isn't kUseDefaultName, otherwise making up a name like "y3" from the next available output port index.  <a href="classdrake_1_1systems_1_1_system_base.html#ab3697edc2cfdba03b33e7f39474531d3">More...</a><br /></td></tr>
<tr class="separator:ab3697edc2cfdba03b33e7f39474531d3 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e83668b3fecff021600eff4390cc2a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab4e83668b3fecff021600eff4390cc2a">AddDiscreteStateGroup</a> (<a class="el" href="namespacedrake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a> index)</td></tr>
<tr class="memdesc:ab4e83668b3fecff021600eff4390cc2a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns a ticket to a new discrete variable group with the given <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#ab4e83668b3fecff021600eff4390cc2a">More...</a><br /></td></tr>
<tr class="separator:ab4e83668b3fecff021600eff4390cc2a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af329e5c00e271bc61a65b0227d34c76e inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af329e5c00e271bc61a65b0227d34c76e">AddAbstractState</a> (<a class="el" href="namespacedrake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a> index)</td></tr>
<tr class="memdesc:af329e5c00e271bc61a65b0227d34c76e inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns a ticket to a new abstract state variable with the given <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#af329e5c00e271bc61a65b0227d34c76e">More...</a><br /></td></tr>
<tr class="separator:af329e5c00e271bc61a65b0227d34c76e inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794ca537e26044e254cda9ccba0a6385 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a794ca537e26044e254cda9ccba0a6385">AddNumericParameter</a> (<a class="el" href="namespacedrake_1_1systems.html#af11369a06c5bfd3fa18acb79f85777df">NumericParameterIndex</a> index)</td></tr>
<tr class="memdesc:a794ca537e26044e254cda9ccba0a6385 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns a ticket to a new numeric parameter with the given <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a794ca537e26044e254cda9ccba0a6385">More...</a><br /></td></tr>
<tr class="separator:a794ca537e26044e254cda9ccba0a6385 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accca12932eb38b764d93ab6bed8f02fc inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#accca12932eb38b764d93ab6bed8f02fc">AddAbstractParameter</a> (<a class="el" href="namespacedrake_1_1systems.html#a86b350169906f6d5e07e9db46e36d57a">AbstractParameterIndex</a> index)</td></tr>
<tr class="memdesc:accca12932eb38b764d93ab6bed8f02fc inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns a ticket to a new abstract parameter with the given <code>index</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#accca12932eb38b764d93ab6bed8f02fc">More...</a><br /></td></tr>
<tr class="separator:accca12932eb38b764d93ab6bed8f02fc inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97150e242d9cc6d62d4dc592fd321b0d inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a97150e242d9cc6d62d4dc592fd321b0d">DeclareCacheEntryWithKnownTicket</a> (<a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> known_ticket, std::string <a class="el" href="proximity__engine__test_8cc.html#a0f6aed3e388afb968642d5e6199f767f">description</a>, <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html#a451b30ae2de34d5852363135f73861e1">CacheEntry::AllocCallback</a> alloc_function, <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html#a3947b9d8e95098739aaaea55af1d1ead">CacheEntry::CalcCallback</a> calc_function, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a97150e242d9cc6d62d4dc592fd321b0d inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) This is for cache entries associated with pre-defined tickets, for example the cache entry for time derivatives.  <a href="classdrake_1_1systems_1_1_system_base.html#a97150e242d9cc6d62d4dc592fd321b0d">More...</a><br /></td></tr>
<tr class="separator:a97150e242d9cc6d62d4dc592fd321b0d inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bcdc5ff465681009f4a32470ebfb26 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const internal::SystemParentServiceInterface *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab8bcdc5ff465681009f4a32470ebfb26">get_parent_service</a> () const</td></tr>
<tr class="memdesc:ab8bcdc5ff465681009f4a32470ebfb26 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the service interface of the immediately enclosing <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> if one has been set, otherwise nullptr.  <a href="classdrake_1_1systems_1_1_system_base.html#ab8bcdc5ff465681009f4a32470ebfb26">More...</a><br /></td></tr>
<tr class="separator:ab8bcdc5ff465681009f4a32470ebfb26 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161f7073ea98c0a25ca55f5dd4186dca inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a161f7073ea98c0a25ca55f5dd4186dca">assign_next_dependency_ticket</a> ()</td></tr>
<tr class="memdesc:a161f7073ea98c0a25ca55f5dd4186dca inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns the next unused dependency ticket number, unique only within a particular system.  <a href="classdrake_1_1systems_1_1_system_base.html#a161f7073ea98c0a25ca55f5dd4186dca">More...</a><br /></td></tr>
<tr class="separator:a161f7073ea98c0a25ca55f5dd4186dca inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f89d878ae72c67da5af5acb06f48a22 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html">AbstractValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a4f89d878ae72c67da5af5acb06f48a22">EvalAbstractInputImpl</a> (const char *func, const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a4f89d878ae72c67da5af5acb06f48a22 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Shared code for updating an input port and returning a pointer to its abstract value, or nullptr if the port is not connected.  <a href="classdrake_1_1systems_1_1_system_base.html#a4f89d878ae72c67da5af5acb06f48a22">More...</a><br /></td></tr>
<tr class="separator:a4f89d878ae72c67da5af5acb06f48a22 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa640b3592c2af42c76fac2d8a048d25c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aa640b3592c2af42c76fac2d8a048d25c">ThrowNegativePortIndex</a> (const char *func, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:aa640b3592c2af42c76fac2d8a048d25c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::out_of_range to report a negative <code>port_index</code> that was passed to API method <code>func</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#aa640b3592c2af42c76fac2d8a048d25c">More...</a><br /></td></tr>
<tr class="separator:aa640b3592c2af42c76fac2d8a048d25c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9295e809fe1cff333430e1b00a84520c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a9295e809fe1cff333430e1b00a84520c">ThrowInputPortIndexOutOfRange</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a9295e809fe1cff333430e1b00a84520c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::out_of_range to report bad input <code>port_index</code> that was passed to API method <code>func</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#a9295e809fe1cff333430e1b00a84520c">More...</a><br /></td></tr>
<tr class="separator:a9295e809fe1cff333430e1b00a84520c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58594b987a3e5b1684d4e38bf00767e inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af58594b987a3e5b1684d4e38bf00767e">ThrowOutputPortIndexOutOfRange</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa">OutputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:af58594b987a3e5b1684d4e38bf00767e inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::out_of_range to report bad output <code>port_index</code> that was passed to API method <code>func</code>.  <a href="classdrake_1_1systems_1_1_system_base.html#af58594b987a3e5b1684d4e38bf00767e">More...</a><br /></td></tr>
<tr class="separator:af58594b987a3e5b1684d4e38bf00767e inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2dfff6a2db34da2c791a7971e2af0c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aee2dfff6a2db34da2c791a7971e2af0c">ThrowNotAVectorInputPort</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:aee2dfff6a2db34da2c791a7971e2af0c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::logic_error because someone misused API method <code>func</code>, that is only allowed for declared-vector input ports, on an abstract port whose index is given here.  <a href="classdrake_1_1systems_1_1_system_base.html#aee2dfff6a2db34da2c791a7971e2af0c">More...</a><br /></td></tr>
<tr class="separator:aee2dfff6a2db34da2c791a7971e2af0c inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2200e7d8b6b39e758e5df64ee81c356a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a2200e7d8b6b39e758e5df64ee81c356a">ThrowInputPortHasWrongType</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index, const std::string &amp;expected_type, const std::string &amp;actual_type) const</td></tr>
<tr class="memdesc:a2200e7d8b6b39e758e5df64ee81c356a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::logic_error because someone called API method <code>func</code> claiming the input port had some value type that was wrong.  <a href="classdrake_1_1systems_1_1_system_base.html#a2200e7d8b6b39e758e5df64ee81c356a">More...</a><br /></td></tr>
<tr class="separator:a2200e7d8b6b39e758e5df64ee81c356a inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bc2d35e014b293b9564cb9e85e5390 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a49bc2d35e014b293b9564cb9e85e5390">ThrowCantEvaluateInputPort</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a49bc2d35e014b293b9564cb9e85e5390 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::logic_error because someone called API method <code>func</code>, that requires this input port to be evaluatable, but the port was neither fixed nor connected.  <a href="classdrake_1_1systems_1_1_system_base.html#a49bc2d35e014b293b9564cb9e85e5390">More...</a><br /></td></tr>
<tr class="separator:a49bc2d35e014b293b9564cb9e85e5390 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace57c456b11046f56381f7b4ab7e2343 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port_base.html">InputPortBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ace57c456b11046f56381f7b4ab7e2343">GetInputPortBaseOrThrow</a> (const char *func, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:ace57c456b11046f56381f7b4ab7e2343 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns the <a class="el" href="classdrake_1_1systems_1_1_input_port_base.html" title="An InputPort is a System resource that describes the kind of input a System accepts, on a given port. ">InputPortBase</a> at index <code>port_index</code>, throwing std::out_of_range we don't like the port index.  <a href="classdrake_1_1systems_1_1_system_base.html#ace57c456b11046f56381f7b4ab7e2343">More...</a><br /></td></tr>
<tr class="separator:ace57c456b11046f56381f7b4ab7e2343 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18146b3800f5a63bbe4d08eae828883 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port_base.html">OutputPortBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab18146b3800f5a63bbe4d08eae828883">GetOutputPortBaseOrThrow</a> (const char *func, <a class="el" href="classint.html">int</a> port_index) const</td></tr>
<tr class="memdesc:ab18146b3800f5a63bbe4d08eae828883 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns the <a class="el" href="classdrake_1_1systems_1_1_output_port_base.html" title="OutputPortBase handles the scalar type-independent aspects of an OutputPort. ">OutputPortBase</a> at index <code>port_index</code>, throwing std::out_of_range we don't like the port index.  <a href="classdrake_1_1systems_1_1_system_base.html#ab18146b3800f5a63bbe4d08eae828883">More...</a><br /></td></tr>
<tr class="separator:ab18146b3800f5a63bbe4d08eae828883 inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb74936487f1ae4658b54979195fa1b inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0eb74936487f1ae4658b54979195fa1b">InitializeContextBase</a> (<a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> *context) const</td></tr>
<tr class="memdesc:a0eb74936487f1ae4658b54979195fa1b inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be invoked from within derived class <a class="el" href="classdrake_1_1systems_1_1_system_base.html#acfa7f79f981ab30a3919aa36e829b62a" title="Derived class implementations should allocate a suitable concrete Context type, then invoke the above...">DoAllocateContext()</a> implementations right after the concrete <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> object has been allocated.  <a href="classdrake_1_1systems_1_1_system_base.html#a0eb74936487f1ae4658b54979195fa1b">More...</a><br /></td></tr>
<tr class="separator:a0eb74936487f1ae4658b54979195fa1b inherit pro_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classdrake_1_1systems_1_1_system_base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classdrake_1_1systems_1_1_system_base')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a></td></tr>
<tr class="memitem:abbed6ab1f586a7b4d4a6131c6fa415ab inherit pro_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#abbed6ab1f586a7b4d4a6131c6fa415ab">set_parent_service</a> (<a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a> *child, const internal::SystemParentServiceInterface *parent_service)</td></tr>
<tr class="memdesc:abbed6ab1f586a7b4d4a6131c6fa415ab inherit pro_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Declares that <code>parent_service</code> is the service interface of the <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> that owns this subsystem.  <a href="classdrake_1_1systems_1_1_system_base.html#abbed6ab1f586a7b4d4a6131c6fa415ab">More...</a><br /></td></tr>
<tr class="separator:abbed6ab1f586a7b4d4a6131c6fa415ab inherit pro_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414a090dc2d413d6d83bb2143e931dba inherit pro_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a414a090dc2d413d6d83bb2143e931dba">ThrowInputPortHasWrongType</a> (const char *func, const std::string &amp;system_pathname, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a>, const std::string &amp;expected_type, const std::string &amp;actual_type)</td></tr>
<tr class="memdesc:a414a090dc2d413d6d83bb2143e931dba inherit pro_static_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::logic_error because someone called API method <code>func</code> claiming the input port had some value type that was wrong.  <a href="classdrake_1_1systems_1_1_system_base.html#a414a090dc2d413d6d83bb2143e931dba">More...</a><br /></td></tr>
<tr class="separator:a414a090dc2d413d6d83bb2143e931dba inherit pro_static_methods_classdrake_1_1systems_1_1_system_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::MultibodyPlant&lt; T &gt;</h3>

<p>MultibodyPlant is a Drake system framework representation (see <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">systems::System</a>) for the model of a physical system consisting of a collection of interconnected bodies. </p>
<p>See <a class="el" href="group__multibody.html">Multibody Dynamics</a> for an overview of concepts/notation.</p>
<p>MultibodyPlant provides a user-facing API to:</p>
<ul>
<li>add bodies, joints, force elements, and constraints,</li>
<li>register geometries to a provided SceneGraph instance,</li>
<li>create and manipulate its Context,</li>
<li>perform Context-dependent computational queries.</li>
</ul>
<h1><a class="anchor" id="equations_of_motion"></a>
System dynamics</h1>
<p>The state of a multibody system <code>x = [q; v]</code> is given by its generalized positions vector q, of size <code>nq</code> (see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model. ">num_positions()</a>), and by its generalized velocities vector v, of size <code>nv</code> (see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model. ">num_velocities()</a>). As a Drake System, MultibodyPlant implements the governing equations for a multibody dynamical system in the form <code>ẋ = f(t, x, u)</code> with t being the time and u the input vector of actuation forces. The governing equations for the dynamics of a multibody system modeled with MultibodyPlant are [Featherstone 2008, Jain 2010]: </p><pre>
         q̇ = N(q)v
  (1)    M(q)v̇ + C(q, v)v = tau
</pre><p> where <code>M(q)</code> is the mass matrix of the multibody system, <code>C(q, v)v</code> corresponds to the bias term containing Coriolis and gyroscopic effects and <code>N(q)</code> is the kinematic coupling matrix describing the relationship between the rate of change of the generalized coordinates and the generalized velocities, [Seth 2010]. N(q) is an <code>nq x nv</code> matrix. The vector <code>tau ∈ ℝⁿᵛ</code> on the right hand side of Eq. (1) corresponds to generalized forces applied on the system. These can include externally applied body forces, constraint forces, and contact forces.</p>
<h1><a class="anchor" id="sdf_loading"></a>
Loading models from SDF files</h1>
<p>Drake has the capability of loading multibody models from SDF and URDF files. Consider the example below which loads an acrobot model: </p><div class="fragment"><div class="line">MultibodyPlant&lt;T&gt; acrobot;</div><div class="line">SceneGraph&lt;T&gt; scene_graph;</div><div class="line">Parser parser(&amp;acrobot, &amp;scene_graph);</div><div class="line"><span class="keyword">const</span> std::string relative_name =</div><div class="line">  <span class="stringliteral">&quot;drake/multibody/benchmarks/acrobot/acrobot.sdf&quot;</span>;</div><div class="line"><span class="keyword">const</span> std::string full_name = <a class="code" href="namespacedrake.html#a9171553d06ababb5f24e9c9ab26c6c7e">FindResourceOrThrow</a>(relative_name);</div><div class="line">parser.AddModelFromFile(full_name);</div></div><!-- fragment --><p> As in the example above, for models including visual geometry, collision geometry or both, the user must specify a SceneGraph for geometry handling. You can find a full example of the LQR controlled acrobot in <a class="el" href="multibody_2acrobot_2run__lqr_8cc.html">examples/multibody/acrobot/run_lqr.cc</a>.</p>
<p>AddModelFromFile() can be invoked multiple times on the same plant in order to load multiple model instances. Other methods are available on <a class="el" href="classdrake_1_1multibody_1_1_parser.html" title="Parses SDF and URDF input files into a MultibodyPlant and (optionally) a SceneGraph. ">Parser</a> such as AddAllModelsFromFile() which allows creating model instances per each <code>&lt;model&gt;</code> tag found in the file. Please refer to each of these methods' documentation for further details.</p>
<h1><a class="anchor" id="adding_elements"></a>
Adding modeling elements</h1>
<p>Clients of a MultibodyPlant can add multibody elements with the following methods:</p>
<ul>
<li>Bodies: <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f6a68c31772eaa0c855ebb44eeaa0b7" title="Creates a rigid body with the provided name and spatial inertia. ">AddRigidBody()</a>.</li>
<li>Joints: <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a437f86026a2268c0fb06936b899ba8d7" title="This method adds a Joint of type JointType between two bodies. ">AddJoint()</a>.</li>
</ul>
<p>All modeling elements <b>must</b> be added pre-finalize.</p>
<h1><a class="anchor" id="geometry_registration"></a>
Registering geometry with a SceneGraph</h1>
<p>MultibodyPlant users can register geometry with a SceneGraph for essentially two purposes; a) visualization and, b) contact modeling.Before any geometry registration takes place, a user <b>must</b> first make a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4a6d28ce9c8119bee923e827eb6f02ed" title="Registers this plant to serve as a source for an instance of SceneGraph. ">RegisterAsSourceForSceneGraph()</a> in order to register the MultibodyPlant as a client of a SceneGraph instance, point at which the plant will have assigned a valid <a class="el" href="namespacedrake_1_1geometry.html#a32581e3a9c8879bcf23192e248df49c7" title="Type used to identify geometry sources in SceneGraph. ">geometry::SourceId</a>. At <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>, MultibodyPlant will declare input/output ports as appropriate to communicate with the SceneGraph instance on which registrations took place. All geometry registration <b>must</b> be performed pre-finalize.</p>
<p>If MultibodyPlant registers geometry with a SceneGraph via calls to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4ff674ee03885b0b47b6eb6859cf6a4a" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for the contact modeling o...">RegisterCollisionGeometry()</a>, an input port for geometric queries will be declared at <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> time, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a38d417c47f17405fb748b5bb02140bcd" title="Returns a constant reference to the input port used to perform geometric queries on a SceneGraph...">get_geometry_query_input_port()</a>. Users must connect this input port to the output port for geometric queries of the SceneGraph used for registration, which can be obtained with <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html#a26da55d64bd1dda5bda1ea5ae8b985c4" title="Returns the output port which produces the QueryObject for performing geometric queries. ">SceneGraph::get_query_output_port()</a>. In summary, if MultibodyPlant registers collision geometry, the setup process will include:</p>
<ol type="1">
<li>Call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4a6d28ce9c8119bee923e827eb6f02ed" title="Registers this plant to serve as a source for an instance of SceneGraph. ">RegisterAsSourceForSceneGraph()</a>.</li>
<li>Calls to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4ff674ee03885b0b47b6eb6859cf6a4a" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for the contact modeling o...">RegisterCollisionGeometry()</a>, as many as needed.</li>
<li>Call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>, user is done specifying the model.</li>
<li>Connect <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html#a26da55d64bd1dda5bda1ea5ae8b985c4" title="Returns the output port which produces the QueryObject for performing geometric queries. ">SceneGraph::get_query_output_port()</a> to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a38d417c47f17405fb748b5bb02140bcd" title="Returns a constant reference to the input port used to perform geometric queries on a SceneGraph...">get_geometry_query_input_port()</a>.</li>
</ol>
<p>Refer to the documentation provided in each of the methods above for further details.</p>
<h1><a class="anchor" id="finalize_stage"></a>
Finalize() stage</h1>
<p>Once the user is done adding modeling elements and registering geometry, a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> must be performed. This call will:</p>
<ul>
<li>Build the underlying MultibodyTree topology, see <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the tree (joints, bodies, force elements, constraints) were added and before any computations are performed. ">MultibodyTree::Finalize()</a> for details,</li>
<li>declare the plant's state,</li>
<li>declare the plant's input and output ports,</li>
<li>declare input and output ports for communication with a SceneGraph. <h3>References </h3>
</li>
</ul>
<ul>
<li>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics algorithms. Springer.</li>
<li>[Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis and algorithms. Springer Science &amp; Business Media.</li>
<li>[Seth 2010] Seth, A., Sherman, M., Eastman, P. and Delp, S., 2010. Minimal formulation of joint motion for biomechanisms. Nonlinear dynamics, 62(1), pp.291-303.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type. Must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar.</td></tr>
  </table>
  </dd>
</dl>
<p>Instantiated templates for the following kinds of T's are provided:</p>
<ul>
<li>double</li>
<li>AutoDiffXd</li>
</ul>
<p>They are already available to link against in the containing library. No other values for T are currently supported. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3aeb03d90d213da4702f2dc5e484fc86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aeb03d90d213da4702f2dc5e484fc86">&#9670;&nbsp;</a></span>MultibodyPlant() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a359ae04bf7eabd0461c5f12ab35fee1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359ae04bf7eabd0461c5f12ab35fee1d">&#9670;&nbsp;</a></span>MultibodyPlant() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a042f9f9407c26eceeec309377eadcfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042f9f9407c26eceeec309377eadcfa2">&#9670;&nbsp;</a></span>MultibodyPlant() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>time_step</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor creates a plant with a single "world" body. </p>
<p>Therefore, right after creation, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af92b53211e54243aff4490a700168eb4" title="Returns the number of bodies in the model, including the &quot;world&quot; body, which is always part of the mo...">num_bodies()</a> returns one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time_step</td><td>An optional parameter indicating whether <code>this</code> plant is modeled as a continuous system (<code>time_step = 0</code>) or as a discrete system with periodic updates of period <code>time_step &gt; 0</code>. <br />
 <em>Default:</em> 0.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>time_step</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a912adb84c4940893eb4634155e6e7e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912adb84c4940893eb4634155e6e7e8b">&#9670;&nbsp;</a></span>MultibodyPlant() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar-converting copy constructor. See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a48009c793b01c5a6dd079d33265435a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48009c793b01c5a6dd079d33265435a3">&#9670;&nbsp;</a></span>AddForceElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ForceElementType&lt;T&gt;&amp; AddForceElement </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new force element model of type <code>ForceElementType</code> to <code>this</code> MultibodyPlant. </p>
<p>The arguments to this method <code>args</code> are forwarded to <code>ForceElementType</code>'s constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Zero or more parameters provided to the constructor of the new force element. It must be the case that <code>JointType&lt;T&gt;(args)</code> is a valid constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForceElementType</td><td>The type of the <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> to add. This method can only be called once for elements of type <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html" title="This ForceElement allows modeling the effect of a uniform gravity field as felt by bodies on the surf...">UniformGravityFieldElement</a>. That is, gravity can only be specified once. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> just added, of type <code>ForceElementType&lt;T&gt;</code> specialized on the scalar type T of <code>this</code> MultibodyPlant. It will remain valid for the lifetime of <code>this</code> MultibodyPlant. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>The <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> class'<a class="el" href="geometry__properties__test_8cc.html#aa8270a1ba8295884567e0a0c93135f05">s</a> documentation for further details on how a <a class="el" href="system__identification__test_8cc.html#aab6099c236e628500314462a9b259d66">force</a> element is defined. </dd></dl>

</div>
</div>
<a id="a63b73dad60ddee877aec7e1b5ea678b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b73dad60ddee877aec7e1b5ea678b6">&#9670;&nbsp;</a></span>AddForceElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;ForceElementType&lt;T&gt;, <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html">UniformGravityFieldElement</a>&lt;T&gt; &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const ForceElementType&lt;T&gt;&amp;&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> AddForceElement </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a474c90a0b3e4f9349533207026413186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474c90a0b3e4f9349533207026413186">&#9670;&nbsp;</a></span>AddFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const FrameType&lt;T&gt;&amp; AddFrame </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; FrameType&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method adds a <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> of type <code>FrameType&lt;T&gt;</code>. </p>
<p>For more information, please see the corresponding constructor of <code>FrameType</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FrameType</td><td>Template which will be instantiated on <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>Unique pointer frame instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> just added, which will remain valid for the lifetime of <code>this</code> MultibodyPlant. </dd></dl>

</div>
</div>
<a id="a437f86026a2268c0fb06936b899ba8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437f86026a2268c0fb06936b899ba8d7">&#9670;&nbsp;</a></span>AddJoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const JointType&lt;T&gt;&amp; AddJoint </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; JointType&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>joint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <code>JointType</code> between two bodies. </p>
<p>For more information, see the below overload of <code>AddJoint&lt;&gt;</code>, and the related <code><a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html#a437f86026a2268c0fb06936b899ba8d7" title="This method adds a Joint of type JointType between the frames specified by the joint. ">MultibodyTree::AddJoint</a>&lt;&gt;</code> method. </p>

</div>
</div>
<a id="ac828f1c818a0ed3f47ff5f342fa0ee0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac828f1c818a0ed3f47ff5f342fa0ee0c">&#9670;&nbsp;</a></span>AddJoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const JointType&lt;T&gt;&amp; AddJoint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X_PF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <code>JointType</code> between two bodies. </p>
<p>The two bodies connected by this <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> object are referred to as the <em>parent</em> and <em>child</em> bodies. Although the terms <em>parent</em> and <em>child</em> are sometimes used synonymously to describe the relationship between inboard and outboard bodies in multibody models, this usage is wholly unrelated and implies nothing about the inboard-outboard relationship between the bodies. As explained in the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class's documentation, in Drake we define a frame F attached to the parent body P with pose <code>X_PF</code> and a frame M attached to the child body B with pose <code>X_BM</code>. This method helps creating a joint between two bodies with fixed poses <code>X_PF</code> and <code>X_BM</code>. Refer to the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class's documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>A string that uniquely identifies the new joint to be added to <code>this</code> model. A std::runtime_error is thrown if a joint named <code>name</code> already is part of the model. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a02c811258a0d93dd116d61648334a392">HasJointNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_joint.html#ad8227ba86a01f26e4f173cd5e219d5d1" title="Returns the name of this joint. ">Joint::name()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The parent body connected by the new joint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_PF</td><td>The fixed pose of frame F attached to the parent body, measured in the frame P of that body. <code>X_PF</code> is an optional parameter; empty curly braces <code>{}</code> imply that frame F <b>is</b> the same body frame P. If instead your intention is to make a frame F with pose <code>X_PF</code> equal to the identity pose, provide <code>Isometry3&lt;double&gt;::Identity()</code> as your input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child</td><td>The child body connected by the new joint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_BM</td><td>The fixed pose of frame M attached to the child body, measured in the frame B of that body. <code>X_BM</code> is an optional parameter; empty curly braces <code>{}</code> imply that frame M <b>is</b> the same body frame B. If instead your intention is to make a frame M with pose <code>X_BM</code> equal to the identity pose, provide <code>Isometry3&lt;double&gt;::Identity()</code> as your input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Zero or more parameters provided to the constructor of the new joint. It must be the case that <code>JointType&lt;T&gt;( const std::string&amp;, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a>&lt;T&gt;&amp;, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a>&lt;T&gt;&amp;, args)</code> is a valid constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JointType</td><td>The type of the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new joint just added, of type <code>JointType&lt;T&gt;</code> specialized on the scalar type T of <code>this</code> MultibodyPlant. It will remain valid for the lifetime of <code>this</code> MultibodyPlant.</dd></dl>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyPlant&lt;T&gt; plant;</div><div class="line"><span class="comment">// Code to define bodies serving as the joint&#39;s parent and child bodies.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="class_rigid_body.html">RigidBody&lt;double&gt;</a>&amp; body_1 =</div><div class="line">  plant.AddRigidBody(<span class="stringliteral">&quot;Body1&quot;</span>, SpatialInertia&lt;double&gt;(...));</div><div class="line"><span class="keyword">const</span> <a class="code" href="class_rigid_body.html">RigidBody&lt;double&gt;</a>&amp; body_2 =</div><div class="line">  plant.AddRigidBody(<span class="stringliteral">&quot;Body2&quot;</span>, SpatialInertia&lt;double&gt;(...));</div><div class="line"><span class="comment">// Body 1 serves as parent, Body 2 serves as child.</span></div><div class="line"><span class="comment">// Define the pose X_BM of a frame M rigidly atached to child body B.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="class_revolute_joint.html">RevoluteJoint&lt;double&gt;</a>&amp; elbow =</div><div class="line">  plant.AddJoint&lt;<a class="code" href="class_revolute_joint.html">RevoluteJoint</a>&gt;(</div><div class="line">    <span class="stringliteral">&quot;Elbow&quot;</span>,                <span class="comment">/* joint name */</span></div><div class="line">    body_1,                 <span class="comment">/* parent body */</span></div><div class="line">    {},                     <span class="comment">/* frame F IS the parent body frame P */</span></div><div class="line">    body_2,                 <span class="comment">/* child body, the pendulum */</span></div><div class="line">    X_BM,                   <span class="comment">/* pose of frame M in the body frame B */</span></div><div class="line">    Vector3d::UnitZ());     <span class="comment">/* revolute axis in this case */</span></div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>this</code> MultibodyPlant already contains a joint with the given <code>name</code>. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a02c811258a0d93dd116d61648334a392">HasJointNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_joint.html#ad8227ba86a01f26e4f173cd5e219d5d1" title="Returns the name of this joint. ">Joint::name()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>The <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class'<a class="el" href="geometry__properties__test_8cc.html#aa8270a1ba8295884567e0a0c93135f05">s</a> documentation for further details on how a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> is defined. </dd></dl>

</div>
</div>
<a id="a5096160ffb18ddc72e2e29c0edfc5064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5096160ffb18ddc72e2e29c0edfc5064">&#9670;&nbsp;</a></span>AddJointActuator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt;T&gt;&amp; AddJointActuator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and adds a <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> model for an actuator acting on a given <code>joint</code>. </p>
<p>This method returns a constant reference to the actuator just added, which will remain valid for the lifetime of <code>this</code> plant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that uniquely identifies the new actuator to be added to <code>this</code> model. A std::runtime_error is thrown if an actuator with the same name already exists in the model. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a30dd7e61bafa3221193e7d68e4be7cbc">HasJointActuatorNamed()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">joint</td><td>The <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> to be actuated by the new <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> just added, which will remain valid for the lifetime of <code>this</code> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>joint.num_velocities() &gt; 1</code> since for now we only support actuators for single dof joints. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4edf1daa65069a26255c903b02bce4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edf1daa65069a26255c903b02bce4c6">&#9670;&nbsp;</a></span>AddModelInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> AddModelInstance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new model instance. </p>
<p>Returns the index for the model instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that uniquely identifies the new instance to be added to <code>this</code> model. An exception is thrown if an instance with the same name already exists in the model. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a05b71664c8e2e91bc3fc92fef222a9bf">HasModelInstanceNamed()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f6a68c31772eaa0c855ebb44eeaa0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6a68c31772eaa0c855ebb44eeaa0b7">&#9670;&nbsp;</a></span>AddRigidBody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; AddRigidBody </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_BBo_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rigid body with the provided name and spatial inertia. </p>
<p>This method returns a constant reference to the body just added, which will remain valid for the lifetime of <code>this</code> MultibodyPlant.</p>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyPlant&lt;T&gt; plant;</div><div class="line"><span class="comment">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span></div><div class="line"><a class="code" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance = plant.AddModelInstance(<span class="stringliteral">&quot;instance&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="class_rigid_body.html">RigidBody&lt;T&gt;</a>&amp; body =</div><div class="line">  plant.AddRigidBody(<span class="stringliteral">&quot;BodyName&quot;</span>, model_instance, spatial_inertia);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that identifies the new body to be added to <code>this</code> model. A std::runtime_error is thrown if a body named <code>name</code> already is part of <code>model_instance</code>. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_body.html#ad8227ba86a01f26e4f173cd5e219d5d1" title="Gets the name associated with this body. ">Body::name()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instance</td><td>A model instance index which this body is part of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M_BBo_B</td><td>The <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia. ">SpatialInertia</a> of the new rigid body to be added to <code>this</code> MultibodyPlant, computed about the body frame origin <code>Bo</code> and expressed in the body frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> just added, which will remain valid for the lifetime of <code>this</code> MultibodyPlant. </dd></dl>

</div>
</div>
<a id="a461a59b672f8c3f7c0dcc5caed56d245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461a59b672f8c3f7c0dcc5caed56d245">&#9670;&nbsp;</a></span>AddRigidBody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; AddRigidBody </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_BBo_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rigid body with the provided name and spatial inertia. </p>
<p>This method returns a constant reference to the body just added, which will remain valid for the lifetime of <code>this</code> MultibodyPlant. The body will use the default model instance (<a class="el" href="model__instance_8h.html#model_instance">more on model instances</a>).</p>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyPlant&lt;T&gt; plant;</div><div class="line"><span class="comment">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="class_rigid_body.html">RigidBody&lt;T&gt;</a>&amp; body =</div><div class="line">  plant.AddRigidBody(<span class="stringliteral">&quot;BodyName&quot;</span>, spatial_inertia);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that identifies the new body to be added to <code>this</code> model. A std::runtime_error is thrown if a body named <code>name</code> already is part of the model in the default model instance. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_body.html#ad8227ba86a01f26e4f173cd5e219d5d1" title="Gets the name associated with this body. ">Body::name()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M_BBo_B</td><td>The <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia. ">SpatialInertia</a> of the new rigid body to be added to <code>this</code> MultibodyPlant, computed about the body frame origin <code>Bo</code> and expressed in the body frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> just added, which will remain valid for the lifetime of <code>this</code> MultibodyPlant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if additional model instances have been created beyond the world and default instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecfe3aca1ea2eba1caea19eb0bc0fb9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfe3aca1ea2eba1caea19eb0bc0fb9b">&#9670;&nbsp;</a></span>CalcBiasForFrameGeometricJacobianExpressedInWorld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a>&lt;T&gt; CalcBiasForFrameGeometricJacobianExpressedInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a frame <code>Fp</code> defined by shifting a frame F from its origin <code>Fo</code> to a new origin <code>P</code>, this method computes the bias term <code>Ab_WFp</code> associated with the spatial acceleration <code>A_WFp</code> a frame <code>Fp</code> instantaneously moving with a frame F at a fixed position <code>p_FP</code>. </p>
<p>That is, the spatial acceleration of frame <code>Fp</code> can be computed as: </p><pre>
  A_WFp = Jv_WFp(q)⋅v̇ + Ab_WFp(q, v)
</pre><p> where <code>Ab_WFp(q, v) = J̇v_WFp(q, v)⋅v</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a45405f29fd8ad82a7459fd05642b329e" title="Given a frame Fp defined by shifting a frame F from its origin Fo to a new origin P...">CalcFrameGeometricJacobianExpressedInWorld()</a> to compute the geometric Jacobian <code>Jv_WFp(q)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q and generalized velocities v. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_F</td><td>The position <code>p_FP</code> of frame <code>Fp</code> is measured and expressed in this frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_FP</td><td>The (fixed) position of the origin <code>P</code> of frame <code>Fp</code> as measured and expressed in frame F. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ab_WFp The bias term, function of the generalized positions q and the generalized velocities v as stored in <code>context</code>. The returned vector is of size 6, with the first three elements related to the bias in angular acceleration and the with the last three elements related to the bias in translational acceleration. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>SpatialAcceleration(Ab_WFp) defines a valid <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html" title="This class is used to represent a spatial acceleration that combines rotational (angular acceleration...">SpatialAcceleration</a>. </dd></dl>

</div>
</div>
<a id="aea824dec31f83e23d490b82be35b076a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea824dec31f83e23d490b82be35b076a">&#9670;&nbsp;</a></span>CalcBiasForPointsGeometricJacobianExpressedInWorld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; CalcBiasForPointsGeometricJacobianExpressedInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FP_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bias term <code>b_WFp</code> associated with the translational acceleration <code>a_WFp</code> of a point <code>P</code> instantaneously moving with a frame F. </p>
<p>That is, the translational acceleration of point <code>P</code> can be computed as: </p><pre>
  a_WFp = Jv_WFp(q)⋅v̇ + b_WFp(q, v)
</pre><p> where <code>b_WFp = J̇v_WFp(q, v)⋅v</code>.</p>
<p>This method computes <code>b_WFp</code> for each point <code>P</code> in <code>p_FP_list</code> defined by its position <code>p_FP</code> in <code>frame_F</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae28789d38fa6e3e0fc382fa3b0b0b882" title="Given a list of points with fixed position vectors p_FP in a frame F, (that is, their time derivative...">CalcPointsGeometricJacobianExpressedInWorld()</a> to compute the geometric Jacobian <code>Jv_WFp(q)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q and generalized velocities v. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_F</td><td>Points <code>P</code> in the list instantaneously move with this frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_FP_list</td><td>A matrix with the fixed position of a list of points <code>P</code> measured and expressed in <code>frame_F</code>. Each column of this matrix contains the position vector <code>p_FP</code> for a point <code>P</code> measured and expressed in frame F. Therefore this input matrix lives in ℝ³ˣⁿᵖ with <code>np</code> the number of points in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>b_WFp The bias term, function of the generalized positions q and the generalized velocities v as stored in <code>context</code>. The returned vector has size <code>3⋅np</code>, with np the number of points in <code>p_FP_list</code>, and concatenates the bias terms for each point <code>P</code> in the list in the same order they are specified on input.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>p_FP_list</code> does not have 3 rows. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a843e1ba389c017c706df10935784b4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843e1ba389c017c706df10935784b4e5">&#9670;&nbsp;</a></span>CalcBiasTerm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcBiasTerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Cv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bias term <code>C(q, v)v</code> containing Coriolis and gyroscopic effects of the multibody equations of motion: </p>
<pre>
  M(q)v̇ + C(q, v)v = tau_app + ∑ J_WBᵀ(q) Fapp_Bo_W
</pre><p> where <code>M(q)</code> is the multibody model's mass matrix and <code>tau_app</code> consists of a vector applied generalized forces. The last term is a summation over all bodies in the model where <code>Fapp_Bo_W</code> is an applied spatial force on body B at <code>Bo</code> which gets projected into the space of generalized forces with the geometric Jacobian <code>J_WB(q)</code> which maps generalized velocities into body B spatial velocity as <code>V_WB = J_WB(q)v</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q and the generalized velocities v. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Cv</td><td>On output, <code>Cv</code> will contain the product <code>C(q, v)v</code>. It must be a valid (non-null) pointer to a column vector in <code>ℛⁿ</code> with n the number of generalized velocities (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model. ">num_velocities()</a>) of the model. This method aborts if Cv is nullptr or if it does not have the proper size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5d32c695cacd92615cb9b3773a17eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d32c695cacd92615cb9b3773a17eb9">&#9670;&nbsp;</a></span>CalcConservativePower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CalcConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the power generated by conservative forces in the multibody model. </p>
<p>This quantity is defined to be positive when the potential energy is decreasing. In other words, if <code>U(q)</code> is the potential energy as defined by <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a35681a2d7d9d4026b6bc61f08da861f8" title="Computes and returns the total potential energy stored in this multibody model for the configuration ...">CalcPotentialEnergy()</a>, then the conservative power, <code>Pc</code>, is <code>Pc = -U̇(q)</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a35681a2d7d9d4026b6bc61f08da861f8" title="Computes and returns the total potential energy stored in this multibody model for the configuration ...">CalcPotentialEnergy()</a> </dd></dl>

</div>
</div>
<a id="ae1b54c8562f107e4d6e11b4b0f8d53c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b54c8562f107e4d6e11b4b0f8d53c5">&#9670;&nbsp;</a></span>CalcForceElementsContribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcForceElementsContribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>forces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the combined force contribution of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> objects in the model. </p>
<p>A <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> can apply forces as a spatial force per body or as generalized forces, depending on the <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> model. <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> contributions are a function of the state and time only. The output from this method can immediately be used as input to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#afcb4de9b58cb375d056da7e8ec30937a" title="Given the state of this model in context and a known vector of generalized accelerations vdot...">CalcInverseDynamics()</a> to include the effect of applied forces by force elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of this model. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">forces</td><td>A pointer to a valid, non nullptr, multibody forces object. On output <code>forces</code> will store the forces exerted by all the <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> objects in the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>forces</code> is null or not compatible with this model, per MultibodyForces::CheckInvariants(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45405f29fd8ad82a7459fd05642b329e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45405f29fd8ad82a7459fd05642b329e">&#9670;&nbsp;</a></span>CalcFrameGeometricJacobianExpressedInWorld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcFrameGeometricJacobianExpressedInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jv_WFp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a frame <code>Fp</code> defined by shifting a frame F from its origin <code>Fo</code> to a new origin <code>P</code>, this method computes the geometric Jacobian <code>Jv_WFp</code> for frame <code>Fp</code>. </p>
<p>The new origin <code>P</code> is specified by the position vector <code>p_FP</code> in frame F. The frame geometric Jacobian <code>Jv_WFp</code> is defined by: </p><pre>
  V_WFp(q, v) = Jv_WFp(q)⋅v
</pre><p> where <code>V_WFp(q, v)</code> is the spatial velocity of frame <code>Fp</code> measured and expressed in the world frame W and q and v are the vectors of generalized position and velocity, respectively. The geometric Jacobian <code>Jv_WFp(q)</code> is a function of the generalized coordinates q only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_F</td><td>The position <code>p_FP</code> of frame <code>Fp</code> is measured and expressed in this frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_FP</td><td>The (fixed) position of the origin <code>P</code> of frame <code>Fp</code> as measured and expressed in frame F. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Jv_WFp</td><td>The geometric Jacobian <code>Jv_WFp(q)</code>, function of the generalized positions q only. This Jacobian relates to the spatial velocity <code>V_WFp</code> of frame <code>Fp</code> by: <pre>
    V_WFp(q, v) = Jv_WFp(q)⋅v
  </pre> Therefore <code>Jv_WFp</code> is a matrix of size <code>6 x nv</code>, with <code>nv</code> the number of generalized velocities. On input, matrix <code>Jv_WFp</code> <b>must</b> have size <code>6 x nv</code> or this method throws an exception. The top rows of this matrix (which can be accessed with Jv_WFp.topRows&lt;3&gt;()) is the Jacobian <code>Hw_WFp</code> related to the angular velocity of <code>Fp</code> in W by <code>w_WFp = Hw_WFp⋅v</code>. The bottom rows of this matrix (which can be accessed with Jv_WFp.bottomRows&lt;3&gt;()) is the Jacobian <code>Hv_WFp</code> related to the translational velocity of the origin <code>P</code> of frame <code>Fp</code> in W by <code>v_WFpo = Hv_WFp⋅v</code>. This ordering is consistent with the internal storage of the <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html" title="This class is used to represent a spatial velocity (also called a twist) that combines rotational (an...">SpatialVelocity</a> class. Therefore the following operations results in a valid spatial velocity: <pre>
    <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity&lt;double&gt;</a> Jv_WFp_times_v(Jv_WFp * v);
  </pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>J_WFp</code> is nullptr or if it is not of size <code>6 x nv</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad877d988ac4cd1942aa84e91e3c5d49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad877d988ac4cd1942aa84e91e3c5d49a">&#9670;&nbsp;</a></span>CalcGravityGeneralizedForces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; CalcGravityGeneralizedForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the generalized forces <code>tau_g(q)</code> due to gravity as a function of the generalized positions <code>q</code> stored in the input <code>context</code>. </p>
<p>The vector of generalized forces due to gravity <code>tau_g(q)</code> is defined such that it appears on the right hand side of the equations of motion together with any other generalized forces, like so: </p><pre>
  Mv̇ + C(q, v)v = tau_g(q) + tau_app
</pre><p> where <code>tau_app</code> includes any other generalized forces applied on the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context storing the state of the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tau_g A vector containing the generalized forces due to gravity. The generalized forces are consistent with the vector of generalized velocities <code>v</code> for <code>this</code> so that the inner product <code>v⋅tau_g</code> corresponds to the power applied by the gravity forces on the mechanical system. That is, <code>v⋅tau_g &gt; 0</code> corresponds to potential energy going into the system, as either mechanical kinetic energy, some other potential energy, or heat, and therefore to a decrease of the gravitational potential energy. </dd></dl>

</div>
</div>
<a id="afcb4de9b58cb375d056da7e8ec30937a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb4de9b58cb375d056da7e8ec30937a">&#9670;&nbsp;</a></span>CalcInverseDynamics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; CalcInverseDynamics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>known_vdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>external_forces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the state of this model in <code>context</code> and a known vector of generalized accelerations <code>vdot</code>, this method computes the set of generalized forces <code>tau</code> that would need to be applied in order to attain the specified generalized accelerations. </p>
<p>Mathematically, this method computes: </p><pre>
  tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W
</pre><p> where <code>M(q)</code> is the model's mass matrix, <code>C(q, v)v</code> is the bias term containing Coriolis and gyroscopic effects and <code>tau_app</code> consists of a vector applied generalized forces. The last term is a summation over all bodies in the model where <code>Fapp_Bo_W</code> is an applied spatial force on body B at <code>Bo</code> which gets projected into the space of generalized forces with the geometric Jacobian <code>J_WB(q)</code> which maps generalized velocities into body B spatial velocity as <code>V_WB = J_WB(q)v</code>. This method does not compute explicit expressions for the mass matrix nor for the bias term, which would be of at least <code>O(n²)</code> complexity, but it implements an <code>O(n)</code> Newton-Euler recursive algorithm, where n is the number of bodies in the model. The explicit formation of the mass matrix <code>M(q)</code> would require the calculation of <code>O(n²)</code> entries while explicitly forming the product <code>C(q, v) * v</code> could require up to <code>O(n³)</code> operations (see [Featherstone 1987, §4]), depending on the implementation. The recursive Newton-Euler algorithm is the most efficient currently known general method for solving inverse dynamics [Featherstone 2008].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">known_vdot</td><td>A vector with the known generalized accelerations <code>vdot</code> for the full model. Use the provided <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> APIs in order to access entries into this array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">external_forces</td><td>A set of forces to be applied to the system either as body spatial forces <code>Fapp_Bo_W</code> or generalized forces <code>tau_app</code>, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html" title="A class to hold a set of forces applied to a MultibodyTree system. ">MultibodyForces</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector of generalized forces that would need to be applied to the mechanical system in order to achieve the desired acceleration given by <code>known_vdot</code>. </dd></dl>

</div>
</div>
<a id="a78c0dbd7529fadcbf1fd550a9fd2e80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c0dbd7529fadcbf1fd550a9fd2e80b">&#9670;&nbsp;</a></span>CalcJacobianSpatialVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcJacobianSpatialVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a>&#160;</td>
          <td class="paramname"><em>with_respect_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jw_ABp_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Jacobian of spatial velocity for a frame instantaneously moving with a specified frame in the model. </p>
<p>Consider a point P instantaneously moving with a frame B with position <code>p_BP</code> in that frame. <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> <code>Bp</code> is the frame defined by shifting frame B with origin at <code>Bo</code> to a new origin at point P. The spatial velocity <code>V_ABp_E</code> of frame <code>Bp</code> measured in a frame A and expressed in a frame E can be expressed as: </p><pre>
  V_ABp_E(q, w) = Jw_ABp_E(q)⋅w
</pre><p> where w represents</p><ul>
<li>the time derivative of the generalized position vector q̇, if <code>with_respect_to</code> is <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b">JacobianWrtVariable::kQDot</a>.</li>
<li>the generalized velocity vector v, if <code>with_respect_to</code> is <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂q̇ ">JacobianWrtVariable::kV</a>.</li>
</ul>
<p>This method computes <code>Jw_ABp_E(q)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum indicating whether <code>Jw_ABp_E</code> converts generalized velocities or time-derivatives of generalized positions to spatial velocities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The position <code>p_BP</code> of point P is measured and expressed in this frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BP</td><td>The (fixed) position of the origin <code>P</code> of frame <code>Bp</code> as measured and expressed in frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The second frame in which the spatial velocity <code>V_ABp</code> is measured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td><a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> in which the velocity V_ABp_E, and therefore the Jacobian Jw_ABp_E is expressed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Jw_ABp_E</td><td>The Jacobian <code>Jw_ABp_E(q)</code>, function of the generalized positions q only. This Jacobian relates to the spatial velocity <code>V_ABp_E</code> of frame <code>Bp</code> in <code>A</code> and expressed in <code>E</code> by: <pre>
    V_ABp_E(q, w) = Jw_ABp_E(q)⋅w </pre> Therefore <code>Jw_ABp_E</code> is a matrix of size <code>6 x nz</code>, where <code>nz</code> is the number of elements in w. On input, matrix <code>Jv_ABp_E</code> <b>must</b> have size <code>6 x nz</code> or this method throws an exception. Given a <code>6 x nz</code> Jacobian J, let Jr be the <code>3 x nz</code> rotational part (top 3 rows) and Jt be the translational part (bottom 3 rows). These can be obtained as follows: <div class="fragment"><div class="line">Jr_ABp_E = Jw_ABp_E.topRows&lt;3&gt;();</div><div class="line">Jt_ABp_E = Jw_ABp_E.bottomRows&lt;3&gt;();</div></div><!-- fragment --> This ordering is consistent with the internal storage of the <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html" title="This class is used to represent a spatial velocity (also called a twist) that combines rotational (an...">SpatialVelocity</a> class. Therefore the following operations results in a valid spatial velocity: <pre>
    <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity&lt;double&gt;</a> V_ABp(Jw_ABp * w); </pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>Jw_ABp_E</code> is nullptr or if it is not of size <code>6 x nz</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3238273c2c927101e4515147bed17f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3238273c2c927101e4515147bed17f6">&#9670;&nbsp;</a></span>CalcMassMatrixViaInverseDynamics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcMassMatrixViaInverseDynamics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the computation of the mass matrix <code>M(q)</code> of the model using inverse dynamics, where the generalized positions q are stored in <code>context</code>. </p>
<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#afcb4de9b58cb375d056da7e8ec30937a" title="Given the state of this model in context and a known vector of generalized accelerations vdot...">CalcInverseDynamics()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td>A valid (non-null) pointer to a squared matrix in <code>ℛⁿˣⁿ</code> with n the number of generalized velocities (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model. ">num_velocities()</a>) of the model. This method aborts if H is nullptr or if it does not have the proper size.</td></tr>
  </table>
  </dd>
</dl>
<p>The algorithm used to build <code>M(q)</code> consists in computing one column of <code>M(q)</code> at a time using inverse dynamics. The result from inverse dynamics, with no applied forces, is the vector of generalized forces: </p><pre>
  tau = M(q)v̇ + C(q, v)v
</pre><p> where q and v are the generalized positions and velocities, respectively. When <code>v = 0</code> the Coriolis and gyroscopic forces term <code>C(q, v)v</code> is zero. Therefore the <code>i-th</code> column of <code>M(q)</code> can be obtained performing inverse dynamics with an acceleration vector <code>v̇ = eᵢ</code>, with <code>eᵢ</code> the standard (or natural) basis of <code>ℛⁿ</code> with n the number of generalized velocities. We write this as: </p><pre>
  H.ᵢ(q) = M(q) * e_i
</pre><p> where <code>H.ᵢ(q)</code> (notice the dot for the rows index) denotes the <code>i-th</code> column in M(q).</p>
<dl class="section warning"><dt>Warning</dt><dd>This is an O(n²) algorithm. Avoid the explicit computation of the mass matrix whenever possible. </dd></dl>

</div>
</div>
<a id="aa08a137307614d55094430b858f0e8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08a137307614d55094430b858f0e8cb">&#9670;&nbsp;</a></span>CalcPointsAnalyticalJacobianExpressedInWorld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcPointsAnalyticalJacobianExpressedInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FP_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>p_WP_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jq_WFp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of points with fixed position vectors <code>p_FP</code> in a frame F, (that is, their time derivative <code>DtF(p_FP)</code> in frame F is zero), this method computes the analytical Jacobian <code>Jq_WFp(q)</code>. </p>
<p>The analytical Jacobian <code>Jq_WFp(q)</code> is defined by: </p><pre>
  Jq_WFp(q) = d(p_WFp(q))/dq
</pre><p> where <code>p_WFp(q)</code> is the position of point P, which moves with frame F, in the world frame W.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_F</td><td>The positions <code>p_FP</code> of each point in the input set are measured and expressed in this frame F and are constant (fixed) in this frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_FP_list</td><td>A matrix with the fixed position of a set of points <code>P</code> measured and expressed in <code>frame_F</code>. Each column of this matrix contains the position vector <code>p_FP</code> for a point <code>P</code> measured and expressed in frame F. Therefore this input matrix lives in ℝ³ˣⁿᵖ with <code>np</code> the number of points in the set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_WP_list</td><td>The output positions of each point <code>P</code> now measured and expressed in computing the geometric Jacobian <code>J_WP</code> and therefore external storage must be provided. The output <code>p_WP_list</code> <b>must</b> have the same size as the input set <code>p_FP_list</code> or otherwise this method throws a std::runtime_error exception. That is <code>p_WP_list</code> <b>must</b> be in <code>ℝ³ˣⁿᵖ</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Jq_WFp</td><td>The analytical Jacobian <code>Jq_WFp(q)</code>, function of the generalized positions q only. We stack the positions of each point P in the world frame W into a column vector p_WFp = [p_WFp1; p_WFp2; ...] of size 3⋅np, with np the number of points in p_FP_list. Then the analytical Jacobian is defined as: <pre>
    Jq_WFp(q) = ∇(p_WFp(q))
  </pre> with <code>∇(⋅)</code> the gradient operator with respect to the generalized positions q. Therefore <code>Jq_WFp</code> is a matrix of size <code>3⋅np x nq</code>, with <code>nq</code> the number of generalized positions. On input, matrix <code>Jq_WFp</code> <b>must</b> have size <code>3⋅np x nq</code> or this method throws a std::runtime_error exception.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the output <code>p_WP_list</code> is nullptr or does not have the same size as the input array <code>p_FP_list</code>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>Jq_WFp</code> is nullptr or if it does not have the appropriate size, see documentation for <code>Jq_WFp</code> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae28789d38fa6e3e0fc382fa3b0b0b882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28789d38fa6e3e0fc382fa3b0b0b882">&#9670;&nbsp;</a></span>CalcPointsGeometricJacobianExpressedInWorld() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcPointsGeometricJacobianExpressedInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FP_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>p_WP_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jv_WFp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a list of points with fixed position vectors <code>p_FP</code> in a frame F, (that is, their time derivative <code>DtF(p_FP)</code> in frame F is zero), this method computes the geometric Jacobian <code>Jv_WFp</code> defined by: </p>
<pre>
  v_WP(q, v) = Jv_WFp(q)⋅v
</pre><p> where <code>v_WP(q, v)</code> is the translational velocity of point <code>P</code> in the world frame W and q and v are the vectors of generalized position and velocity, respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_F</td><td>The positions <code>p_FP</code> of each point in the input set are measured and expressed in this frame F and are constant (fixed) in this frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_FP_list</td><td>A matrix with the fixed position of a set of points <code>P</code> measured and expressed in <code>frame_F</code>. Each column of this matrix contains the position vector <code>p_FP</code> for a point <code>P</code> measured and expressed in frame F. Therefore this input matrix lives in ℝ³ˣⁿᵖ with <code>np</code> the number of points in the set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_WP_list</td><td>The output positions of each point <code>P</code> now measured and expressed in computing the geometric Jacobian <code>J_WP</code> and therefore external storage must be provided. The output <code>p_WP_list</code> <b>must</b> have the same size as the input set <code>p_FP_list</code> or otherwise this method throws a std::runtime_error exception. That is <code>p_WP_list</code> <b>must</b> be in <code>ℝ³ˣⁿᵖ</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Jv_WFp</td><td>The geometric Jacobian <code>Jv_WFp(q)</code>, function of the generalized positions q only. This Jacobian relates the translational velocity <code>v_WP</code> of each point <code>P</code> in the input set by: <pre>
    v_WP(q, v) = Jv_WFp(q)⋅v
  </pre> so that <code>v_WP</code> is a column vector of size <code>3⋅np</code> concatenating the velocity of all points <code>P</code> in the same order they were given in the input set. Therefore <code>J_WFp</code> is a matrix of size <code>3⋅np x nv</code>, with <code>nv</code> the number of generalized velocities. On input, matrix <code>J_WFp</code> <b>must</b> have size <code>3⋅np x nv</code> or this method throws a std::runtime_error exception.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the output <code>p_WP_list</code> is nullptr or does not have the same size as the input array <code>p_FP_list</code>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>Jv_WFp</code> is nullptr or if it does not have the appropriate size, see documentation for <code>Jv_WFp</code> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4978894bc930fdb65827c03214ac9103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4978894bc930fdb65827c03214ac9103">&#9670;&nbsp;</a></span>CalcPointsGeometricJacobianExpressedInWorld() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcPointsGeometricJacobianExpressedInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_WP_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jv_WFp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a variant to compute the geometric Jacobian <code>Jv_WFp</code> for a list of points <code>P</code> moving with <code>frame_F</code>, given that we know the position <code>p_WP</code> of each point in the list measured and expressed in the world frame W. </p>
<p>The geometric Jacobian <code>Jv_WFp</code> is defined such that: </p><pre>
  v_WP(q, v) = Jv_WFp(q)⋅v
</pre><p> where <code>v_WP(q, v)</code> is the translational velocity of point <code>P</code> in the world frame W and q and v are the vectors of generalized position and velocity, respectively. Since the spatial velocity of each point <code>P</code> is linear in the generalized velocities, the geometric Jacobian <code>Jv_WFp</code> is a function of the generalized coordinates q only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_F</td><td>Points <code>P</code> in the list instantaneously move with this frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_WP_list</td><td>A matrix with the fixed position of a list of points <code>P</code> measured and expressed in the world frame W. Each column of this matrix contains the position vector <code>p_WP</code> for a point <code>P</code> measured and expressed in the world frame W. Therefore this input matrix lives in ℝ³ˣⁿᵖ with <code>np</code> the number of points in the list. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Jv_WFp</td><td>The geometric Jacobian <code>Jv_WFp(q)</code>, function of the generalized positions q only. This Jacobian relates the translational velocity <code>v_WP</code> of each point <code>P</code> in the input list by: <pre>
    `v_WP(q, v) = Jv_WFp(q)⋅v`
  </pre> so that <code>v_WP</code> is a column vector of size <code>3⋅np</code> concatenating the velocity of all points <code>P</code> in the same order they were given in the input list. Therefore <code>J_WP</code> is a matrix of size <code>3⋅np x nv</code>, with <code>nv</code> the number of generalized velocities. On input, matrix <code>J_WP</code> <b>must</b> have size <code>3⋅np x nv</code> or this method throws a std::runtime_error exception.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>Jv_WFp</code> is nullptr or if it does not have the appropriate size, see documentation for <code>Jv_WFp</code> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27bce36db6170b2ed1ee53481f8017a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bce36db6170b2ed1ee53481f8017a5">&#9670;&nbsp;</a></span>CalcPointsPositions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcPointsPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BQi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>p_AQi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the positions <code>p_BQi</code> for a set of points <code>Qi</code> measured and expressed in a frame B, this method computes the positions <code>p_AQi(q)</code> of each point <code>Qi</code> in the set as measured and expressed in another frame A, as a function of the generalized positions q of the model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame B in which the positions <code>p_BQi</code> of a set of points <code>Qi</code> are given. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BQi</td><td>The input positions of each point <code>Qi</code> in frame B. <code>p_BQi ∈ ℝ³ˣⁿᵖ</code> with <code>np</code> the number of points in the set. Each column of <code>p_BQi</code> corresponds to a vector in ℝ³ holding the position of one of the points in the set as measured and expressed in frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame A in which it is desired to compute the positions <code>p_AQi</code> of each point <code>Qi</code> in the set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_AQi</td><td>The output positions of each point <code>Qi</code> now computed as measured and expressed in frame A. The output <code>p_AQi</code> <b>must</b> have the same size as the input <code>p_BQi</code> or otherwise this method aborts. That is <code>p_AQi</code> <b>must</b> be in <code>ℝ³ˣⁿᵖ</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Both <code>p_BQi</code> and <code>p_AQi</code> must have three rows. Otherwise this method will throw a std::runtime_error exception. This method also throws a std::runtime_error exception if <code>p_BQi</code> and <code>p_AQi</code> differ in the number of columns. </dd></dl>

</div>
</div>
<a id="a35681a2d7d9d4026b6bc61f08da861f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35681a2d7d9d4026b6bc61f08da861f8">&#9670;&nbsp;</a></span>CalcPotentialEnergy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CalcPotentialEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the total potential energy stored in <code>this</code> multibody model for the configuration given by <code>context</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total potential energy stored in <code>this</code> multibody model. </dd></dl>

</div>
</div>
<a id="ad9852a710b6fdd9e08d3bbc328485734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9852a710b6fdd9e08d3bbc328485734">&#9670;&nbsp;</a></span>CalcRelativeFrameGeometricJacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CalcRelativeFrameGeometricJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jv_ABp_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the geometric Jacobian for a point moving with a given frame. </p>
<p>Consider a point P instantaneously moving with a frame B with position <code>p_BP</code> in that frame. <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> <code>Bp</code> is the frame defined by shifting frame B with origin at <code>Bo</code> to a new origin at point P. The spatial velocity <code>V_ABp_E</code> of frame <code>Bp</code> measured in a frame A and expressed in a frame E relates to the generalized velocities of the system by the geometric Jacobian <code>Jv_ABp_E(q)</code> by: </p><pre>
  V_ABp_E(q, v) = Jv_ABp_E(q)⋅v
</pre><p> This method computes the geometric Jacobian <code>Jv_ABp_E(q)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The position <code>p_BP</code> of point P is measured and expressed in this frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BP</td><td>The (fixed) position of the origin <code>P</code> of frame <code>Bp</code> as measured and expressed in frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The second frame in which the spatial velocity <code>V_ABp</code> is measured and expressed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td><a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> in which the velocity V_ABp_E is expressed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Jv_ABp_E</td><td>The geometric Jacobian <code>Jv_ABp_E(q)</code>, function of the generalized positions q only. This Jacobian relates to the spatial velocity <code>V_ABp_E</code> of frame <code>Bp</code> in A and expressed in E by: <pre>
    V_ABp_E(q, v) = Jv_ABp_E(q)⋅v
  </pre> Therefore <code>Jv_ABp_E</code> is a matrix of size <code>6 x nv</code>, with <code>nv</code> the number of generalized velocities. On input, matrix <code>Jv_ABp_E</code> <b>must</b> have size <code>6 x nv</code> or this method throws an exception. Given a <code>6 x nv</code> spatial Jacobian Jv, let Jvr be the <code>3 x nv</code> rotational part (top 3 rows) and Jvt be the translational part (bottom 3 rows). These can be obtained as follows: <pre>
    Jvr_ABp = Jv_ABp.topRows&lt;3&gt;();
    Jvt_ABp = Jv_ABp.bottomRows&lt;3&gt;();
  </pre> This ordering is consistent with the internal storage of the <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html" title="This class is used to represent a spatial velocity (also called a twist) that combines rotational (an...">SpatialVelocity</a> class. Therefore the following operations results in a valid spatial velocity: <pre>
    <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity&lt;double&gt;</a> V_ABp(Jv_ABp * v);
  </pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>J_ABp</code> is nullptr or if it is not of size <code>6 x nv</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad807aa2b29b917462f14d0ca0dd7293f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad807aa2b29b917462f14d0ca0dd7293f">&#9670;&nbsp;</a></span>CalcRelativeTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt;T&gt; CalcRelativeTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the relative transform <code>X_AB(q)</code> from a frame B to a frame A, as a function of the generalized positions q of the model. </p>
<p>That is, the position <code>p_AQ</code> of a point Q measured and expressed in frame A can be computed from the position <code>p_BQ</code> of this point measured and expressed in frame B using the transformation <code>p_AQ = X_AB⋅p_BQ</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The target frame A in the computed relative transform <code>X_AB</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The source frame B in the computed relative transform <code>X_AB</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_AB</td><td>The relative transform from frame B to frame A, such that <code>p_AQ = X_AB⋅p_BQ</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefa1c5393d7cab419a944009cc93aa6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa1c5393d7cab419a944009cc93aa6c">&#9670;&nbsp;</a></span>CalcSpatialAccelerationsFromVdot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcSpatialAccelerationsFromVdot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>known_vdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>A_WB_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the state of this model in <code>context</code> and a known vector of generalized accelerations <code>known_vdot</code>, this method computes the spatial acceleration <code>A_WB</code> for each body as measured and expressed in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of this model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">known_vdot</td><td>A vector with the generalized accelerations for the full model. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_WB_array</td><td>A pointer to a valid, non nullptr, vector of spatial accelerations containing the spatial acceleration <code>A_WB</code> for each body. It must be of size equal to the number of bodies in the model. On output, entries will be ordered by BodyIndex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if A_WB_array is not of size <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af92b53211e54243aff4490a700168eb4" title="Returns the number of bodies in the model, including the &quot;world&quot; body, which is always part of the mo...">num_bodies()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4af854169fcb6b3080234c5f5ce78894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af854169fcb6b3080234c5f5ce78894">&#9670;&nbsp;</a></span>CollectRegisteredGeometries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a> CollectRegisteredGeometries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>bodies</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each of the provided <code>bodies</code>, collects up all geometries that have been registered to that body. </p>
<p>Intended to be used in conjunction with <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html#a91e9026cf3cd253a4e7260c6dc054921" title="Excludes geometry pairs from collision evaluation by updating the candidate pair set C = C - P...">SceneGraph::ExcludeCollisionsWithin()</a> and <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html#a822b987f8d0fed87bcd53dd90345bce1" title="Excludes geometry pairs from collision evaluation by updating the candidate pair set C = C - P...">SceneGraph::ExcludeCollisionsBetween()</a> to filter collisions between the geometries registered to the bodies.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="comment">// Don&#39;t report on collisions between geometries affixed to `body1`,</span></div><div class="line"><span class="comment">// `body2`, or `body3`.</span></div><div class="line">std::vector&lt;const RigidBody&lt;T&gt;*&gt; bodies{&amp;body1, &amp;body2, &amp;body3};</div><div class="line">geometry::GeometrySet <span class="keyword">set</span> = plant.CollectRegisteredGeometries(bodies);</div><div class="line">scene_graph.ExcludeCollisionsWithin(<span class="keyword">set</span>);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>There is a <em>very</em> specific order of operations:</dd></dl>
<ol type="1">
<li>Bodies and geometries must be added to the MultibodyPlant.</li>
<li>The MultibodyPlant must be finalized (via <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>).</li>
<li>Create GeometrySet instances from bodies (via this method).</li>
<li>Invoke SceneGraph::ExcludeCollisions*() to filter collisions.</li>
<li>Allocate context.</li>
</ol>
<p>Changing the order will cause exceptions to be thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38608634b36afab217b71de1f31fbc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38608634b36afab217b71de1f31fbc85">&#9670;&nbsp;</a></span>default_coulomb_friction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; default_coulomb_friction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the friction coefficients provided during geometry registration for the given geometry <code>id</code>. </p>
<p>We call these the "default" coefficients but note that we mean user-supplied per-geometry default, not something more global. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>id</code> does not correspond to a geometry in <code>this</code> model registered for contact modeling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4ff674ee03885b0b47b6eb6859cf6a4a" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for the contact modeling o...">RegisterCollisionGeometry()</a> for details on <a class="el" href="namespacedrake_1_1geometry.html">geometry</a> registration. </dd></dl>

</div>
</div>
<a id="aae776848d1a35d25966711e9df8ead6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae776848d1a35d25966711e9df8ead6b">&#9670;&nbsp;</a></span>EvalBodyPoseInWorld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt;T&gt;&amp; EvalBodyPoseInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the pose <code>X_WB</code> of a body B in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context storing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_B</td><td>The body B for which the pose is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_WB</td><td>The pose of body frame B in the world frame W. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> was not called on <code>this</code> model or if <code>body_B</code> does not belong to this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8377774b012b4975b46941b3197f29c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8377774b012b4975b46941b3197f29c3">&#9670;&nbsp;</a></span>EvalBodySpatialVelocityInWorld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt;T&gt;&amp; EvalBodySpatialVelocityInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the spatial velocity <code>V_WB</code> of a body B in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context storing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_B</td><td>The body B for which the spatial velocity is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>V_WB The spatial velocity of body frame B in the world frame W. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> was not called on <code>this</code> model or if <code>body_B</code> does not belong to this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c5987c219df6a53a55fde8a06d5c1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5987c219df6a53a55fde8a06d5c1f1">&#9670;&nbsp;</a></span>Finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>scene_graph</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method must be called after all elements in the model (joints, bodies, force elements, constraints, etc.) are added and before any computations are performed. </p>
<p>It essentially compiles all the necessary "topological information", i.e. how bodies, joints and, any other elements connect with each other, and performs all the required pre-processing to enable computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this MultibodyPlant is valid, meaning that the topology is up-to-date after this call. No more multibody elements can be added after a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>.</p>
<p>At <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>, state and input/output ports for <code>this</code> plant are declared. If <code>this</code> plant registered geometry with a SceneGraph, input and output ports to enable communication with that SceneGraph are declared as well.</p>
<p>If geometry has been registered on a SceneGraph instance, that instance must be provided to the <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> method so that any geometric implications of the finalization process can be appropriately handled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#acf7bb2a3531c09a97fb3623ac582d840" title="Returns true if this MultibodyPlant was finalized with a call to Finalize(). ">is_finalized()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if<ol type="1">
<li>the MultibodyPlant has already been finalized or</li>
<li>a different scene_graph instance is provided than the one for which this plant is a geometry source. </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad783d7e7e513feb7a73384c8080041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad783d7e7e513feb7a73384c8080041">&#9670;&nbsp;</a></span>geometry_source_is_registered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> geometry_source_is_registered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>this</code> MultibodyPlant was registered with a SceneGraph. </p>
<p>This method can be called at any time during the lifetime of <code>this</code> plant to query if <code>this</code> plant has been registered with a SceneGraph, either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. </p>

</div>
</div>
<a id="a69ef9262ffab02b34bdf20449aab7551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ef9262ffab02b34bdf20449aab7551">&#9670;&nbsp;</a></span>get_actuation_input_port() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp; get_actuation_input_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the input port for external actuation for the case where only one model instance has actuated dofs. </p>
<p>This input port is a vector valued port, which can be set with <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a0124c80b63b5acc2980e3a57107c43be" title="Given the actuation values u_instance for this actuator, this method sets the actuation vector u for ...">JointActuator::set_actuation_vector()</a>. </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> was already called on <code>this</code> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>, if the model does not contain any actuators, or if multiple model instances have actuated dofs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a776f6189a7a33efee4aed2a9135f5150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776f6189a7a33efee4aed2a9135f5150">&#9670;&nbsp;</a></span>get_actuation_input_port() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp; get_actuation_input_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the input port for external actuation for a specific model instance. </p>
<p>This input port is a vector valued port, which can be set with <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a0124c80b63b5acc2980e3a57107c43be" title="Given the actuation values u_instance for this actuator, this method sets the actuation vector u for ...">JointActuator::set_actuation_vector()</a>. </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> was already called on <code>this</code> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> or if the model instance does not contain any actuators. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the model instance does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada9547075b5a67b2354f3dabf0f2f787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9547075b5a67b2354f3dabf0f2f787">&#9670;&nbsp;</a></span>get_body()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;&amp; get_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the body with unique index <code>body_index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body_index</code> does not correspond to a body in this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3338392f611d5d9f93d0ea90e172c68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3338392f611d5d9f93d0ea90e172c68c">&#9670;&nbsp;</a></span>get_contact_penalty_method_time_scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_contact_penalty_method_time_scale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a time-scale estimate <code>tc</code> based on the requested penetration allowance δ set with <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8cdb3408c412b2af94476886dc35cc71" title="Sets the penetration allowance used to estimate the coefficients in the penalty method used to impose...">set_penetration_allowance()</a>. </p>
<p>For the penalty method in use to enforce non-penetration, this time scale relates to the time it takes the relative normal velocity between two bodies to go to zero. This time scale <code>tc</code> is artificially introduced by the penalty method and goes to zero in the limit to ideal rigid contact. Since numerical integration methods for continuum systems must be able to resolve a system's dynamics, the time step used by an integrator must in general be much smaller than the time scale <code>tc</code>. How much smaller will depend on the details of the problem and the convergence characteristics of the integrator and should be tuned appropriately. Another factor to take into account for setting up the simulation's time step is the speed of the objects in your simulation. If <code>vn</code> represents a reference velocity scale for the normal relative velocity between bodies, the new time scale <code>tn = δ / vn</code> represents the time it would take for the distance between two bodies approaching with relative normal velocity <code>vn</code> to decrease by the penetration_allowance δ. In this case a user should choose a time step for simulation that can resolve the smallest of the two time scales <code>tc</code> and <code>tn</code>. </p>

</div>
</div>
<a id="a38514bf9e20aa4b85ad82a0a2009a65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38514bf9e20aa4b85ad82a0a2009a65f">&#9670;&nbsp;</a></span>get_contact_results_output_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_contact_results_output_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the port that outputs <a class="el" href="classdrake_1_1multibody_1_1_contact_results.html" title="A container class storing the contact results information for each contact pair for a given state of ...">ContactResults</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>this</code> plant is not modeled as a discrete system with periodic updates. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa51493ea8545a5f1b985076dd783bf23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51493ea8545a5f1b985076dd783bf23">&#9670;&nbsp;</a></span>get_continuous_state_output_port() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_continuous_state_output_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port for the full continuous state of the model. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> was already called on <code>this</code> plant. </dd></dl>

</div>
</div>
<a id="a44c4a71ba69cecc95f478584e176775e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c4a71ba69cecc95f478584e176775e">&#9670;&nbsp;</a></span>get_continuous_state_output_port() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_continuous_state_output_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port for the continuous state of a specific model instance. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> was already called on <code>this</code> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> or if the model instance does not have any state. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the model instance does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95cafdc0efac53fe097f9380b955e396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cafdc0efac53fe097f9380b955e396">&#9670;&nbsp;</a></span>get_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;T&gt;&amp; get_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a>&#160;</td>
          <td class="paramname"><em>frame_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the frame with unique index <code>frame_index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>frame_index</code> does not correspond to a frame in this plant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64b671623de5eecd130ce235995ac320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b671623de5eecd130ce235995ac320">&#9670;&nbsp;</a></span>get_generalized_contact_forces_output_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_generalized_contact_forces_output_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port of generalized contact forces for a specific model instance. </p>
<p>This output port is only available when modeling the plant as a discrete system with periodic updates, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#ac87e33717da832d66c6587cac66f56a9">is_discrete()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> was already called on <code>this</code> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>this</code> plant is not modeled as a discrete system with periodic updates. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> or if the model instance does not have any generalized velocities. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the model instance does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89666082450a254fc4feda5aae4d01e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89666082450a254fc4feda5aae4d01e0">&#9670;&nbsp;</a></span>get_geometry_poses_output_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp; get_geometry_poses_output_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output port of frames' poses to communicate with a SceneGraph. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this system was not registered with a SceneGraph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38d417c47f17405fb748b5bb02140bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d417c47f17405fb748b5bb02140bcd">&#9670;&nbsp;</a></span>get_geometry_query_input_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp; get_geometry_query_input_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the input port used to perform geometric queries on a SceneGraph. </p>
<p>See <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html#a26da55d64bd1dda5bda1ea5ae8b985c4" title="Returns the output port which produces the QueryObject for performing geometric queries. ">SceneGraph::get_query_output_port()</a>. Refer to section <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#geometry_registration">Registering geometry with a SceneGraph</a> of this class's documentation for further details on collision geometry registration and connection with a SceneGraph. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this system was not registered with a SceneGraph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad293b63a81a28c455fdfb7e5f04c35b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad293b63a81a28c455fdfb7e5f04c35b0">&#9670;&nbsp;</a></span>get_joint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt;T&gt;&amp; get_joint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a>&#160;</td>
          <td class="paramname"><em>joint_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the joint with unique index <code>joint_index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when <code>joint_index</code> does not correspond to a joint in this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb237ffaadc7323d817ba0e07e78a8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb237ffaadc7323d817ba0e07e78a8f4">&#9670;&nbsp;</a></span>get_joint_actuator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt;T&gt;&amp; get_joint_actuator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a>&#160;</td>
          <td class="paramname"><em>actuator_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the joint actuator with unique index <code>actuator_index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>actuator_index</code> does not correspond to a joint actuator in this tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef692dc2241640a308801f7dfae902ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef692dc2241640a308801f7dfae902ba">&#9670;&nbsp;</a></span>get_source_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt;<a class="el" href="namespacedrake_1_1geometry.html#a32581e3a9c8879bcf23192e248df49c7">geometry::SourceId</a>&gt; get_source_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the unique id identifying <code>this</code> plant as a source for a SceneGraph. </p>
<p>Returns <code>nullopt</code> if <code>this</code> plant did not register any geometry. This method can be called at any time during the lifetime of <code>this</code> plant to query if <code>this</code> plant has been registered with a SceneGraph, either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. However, a <a class="el" href="namespacedrake_1_1geometry.html#a32581e3a9c8879bcf23192e248df49c7" title="Type used to identify geometry sources in SceneGraph. ">geometry::SourceId</a> is only assigned once at the first call of any of this plant's geometry registration methods, and it does not change after that. Post-finalize calls will always return the same value. </p>

</div>
</div>
<a id="a10f1718383aaaf709d076d844943dfa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f1718383aaaf709d076d844943dfa8">&#9670;&nbsp;</a></span>GetBodiesWeldedTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; * &gt; GetBodiesWeldedTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all bodies that are transitively welded, or rigidly affixed, to <code>body</code>, per these two definitions: </p>
<ol type="1">
<li>A body is always considered welded to itself.</li>
<li>Two unique bodies are considered welded together exclusively by the presence of a weld joint, not by other constructs that prevent mobility (e.g. constraints).</li>
</ol>
<p>Meant to be used with <code>CollectRegisteredGeometries</code>.</p>
<p>The following example demonstrates filtering collisions between all bodies rigidly affixed to a door (which could be moving) and all bodies rigidly affixed to the world: </p><div class="fragment"><div class="line">GeometrySet g_world = plant.CollectRegisteredGeometries(</div><div class="line">    plant.GetBodiesWeldedTo(plant.world_body()));</div><div class="line">GeometrySet g_door = plant.CollectRegisteredGeometries(</div><div class="line">    plant.GetBodiesWeldedTo(plant.GetBodyByName(<span class="stringliteral">&quot;door&quot;</span>)));</div><div class="line">scene_graph.ExcludeCollisionsBetweeen(g_world, g_door);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Usages akin to this example may introduce redundant collision filtering; this will not have a functional impact, but may have a minor performance impact.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>all bodies rigidly fixed to <code>body</code>. This does not return the bodies in any prescribed order. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not part of this plant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3b40d661d83759731ad9a54553fc13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b40d661d83759731ad9a54553fc13f">&#9670;&nbsp;</a></span>GetBodyByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;&amp; GetBodyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These queries can be performed at any time during the lifetime of a MultibodyPlant, i.e. </p>
<p>there is no restriction on whether they must be called before or after <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. This implies that these queries can be performed while new multibody elements are being added to the model.</p>
<p>If the named element is present in more than one model instance and a model instance is not explicitly specified, std::logic_error is thrown.Returns a constant reference to a body that is identified by the string <code>name</code> in <code>this</code> MultibodyPlant. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no body with the requested name. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the body name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a> to query if there exists a body in <code>this</code> MultibodyPlant with a given specified <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>. </dd></dl>

</div>
</div>
<a id="a3d93818409f0144bb63248dc64a9130f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d93818409f0144bb63248dc64a9130f">&#9670;&nbsp;</a></span>GetBodyByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;&amp; GetBodyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the body that is uniquely identified by the string <code>name</code> and <code>model_instance</code> in <code>this</code> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no body with the requested name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a> to query if there exists a body in <code>this</code> MultibodyPlant with a given specified <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>. </dd></dl>

</div>
</div>
<a id="a52ca6d32db3c06c6ef91ad42fc36052c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ca6d32db3c06c6ef91ad42fc36052c">&#9670;&nbsp;</a></span>GetBodyFrameIdIfExists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt;<a class="el" href="namespacedrake_1_1geometry.html#a13b34d2644a785d87ebaaade93f287d3">geometry::FrameId</a>&gt; GetBodyFrameIdIfExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the body with <code>body_index</code> has geometry registered with it, it returns the <a class="el" href="namespacedrake_1_1geometry.html#a13b34d2644a785d87ebaaade93f287d3" title="Type used to identify geometry frames in SceneGraph. ">geometry::FrameId</a> associated with it. </p>
<p>Otherwise, it returns nullopt. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdcdcb4e7798a5aef9bc3111402dfa5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcdcb4e7798a5aef9bc3111402dfa5e">&#9670;&nbsp;</a></span>GetBodyFrameIdOrThrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry.html#a13b34d2644a785d87ebaaade93f287d3">geometry::FrameId</a> GetBodyFrameIdOrThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the body with <code>body_index</code> has geometry registered with it, it returns the <a class="el" href="namespacedrake_1_1geometry.html#a13b34d2644a785d87ebaaade93f287d3" title="Type used to identify geometry frames in SceneGraph. ">geometry::FrameId</a> associated with it. </p>
<p>Otherwise this method throws an exception. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if no geometry has been registered with the body indicated by <code>body_index</code>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf36bc0dadc3f1e72bc17072c5f9e4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf36bc0dadc3f1e72bc17072c5f9e4f2">&#9670;&nbsp;</a></span>GetBodyFromFrameId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;* GetBodyFromFrameId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a13b34d2644a785d87ebaaade93f287d3">geometry::FrameId</a>&#160;</td>
          <td class="paramname"><em>frame_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a geometry frame identifier, returns a pointer to the body associated with that id (nullptr if there is no such body). </p>

</div>
</div>
<a id="a0eead1b1e0bac74e55fc0db28f8f2528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eead1b1e0bac74e55fc0db28f8f2528">&#9670;&nbsp;</a></span>GetCollisionGeometriesForBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a> &gt; &amp; GetCollisionGeometriesForBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of GeometryId's identifying the different contact geometries for <code>body</code> previously registered with a SceneGraph. </p>
<dl class="section note"><dt>Note</dt><dd>This method can be called at any time during the lifetime of <code>this</code> plant, either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. Post-finalize calls will always return the same value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4ff674ee03885b0b47b6eb6859cf6a4a" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for the contact modeling o...">RegisterCollisionGeometry()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> </dd></dl>

</div>
</div>
<a id="a4b557087f117859fd5246112f0d829cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b557087f117859fd5246112f0d829cd">&#9670;&nbsp;</a></span>GetFrameByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;T&gt;&amp; GetFrameByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to a frame that is identified by the string <code>name</code> in <code>this</code> model. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no frame with the requested name. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the frame name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3530f8f6747cb603a24accba5901bd00">HasFrameNamed()</a> to query if there exists a frame in <code>this</code> <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1c1029d223ec3d0db0dc14d643fa7c88" title="Returns a constant reference to the underlying MultibodyTree model for this plant. ">model</a> with a given specified <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>. </dd></dl>

</div>
</div>
<a id="af4d552a24e1ad06c0b16004cec20fe94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d552a24e1ad06c0b16004cec20fe94">&#9670;&nbsp;</a></span>GetFrameByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;T&gt;&amp; GetFrameByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the frame that is uniquely identified by the string <code>name</code> in <code>model_instance</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no frame with the requested name. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3530f8f6747cb603a24accba5901bd00">HasFrameNamed()</a> to query if there exists a frame in <code>this</code> <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1c1029d223ec3d0db0dc14d643fa7c88" title="Returns a constant reference to the underlying MultibodyTree model for this plant. ">model</a> with a given specified <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>. </dd></dl>

</div>
</div>
<a id="ab835365a3c40185b23454f7e08cad083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab835365a3c40185b23454f7e08cad083">&#9670;&nbsp;</a></span>GetJointActuatorByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt;T&gt;&amp; GetJointActuatorByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to an actuator that is identified by the string <code>name</code> in <code>this</code> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no actuator with the requested name. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the actuator name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a30dd7e61bafa3221193e7d68e4be7cbc">HasJointActuatorNamed()</a> to query if there exists an actuator in <code>this</code> MultibodyPlant with a given specified <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>. </dd></dl>

</div>
</div>
<a id="a760fbe4384415d8cfd39c9e7e4f31422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760fbe4384415d8cfd39c9e7e4f31422">&#9670;&nbsp;</a></span>GetJointActuatorByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt;T&gt;&amp; GetJointActuatorByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the actuator that is uniquely identified by the string <code>name</code> and <code>model_instance</code> in <code>this</code> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no actuator with the requested name. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a30dd7e61bafa3221193e7d68e4be7cbc">HasJointActuatorNamed()</a> to query if there exists an actuator in <code>this</code> MultibodyPlant with a given specified <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>. </dd></dl>

</div>
</div>
<a id="af72d95f825442702e3efb64787a80cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72d95f825442702e3efb64787a80cb5">&#9670;&nbsp;</a></span>GetJointByName() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt;T&gt;&amp; GetJointByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to a joint that is identified by the string <code>name</code> in <code>this</code> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no joint with the requested name. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the joint name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a02c811258a0d93dd116d61648334a392">HasJointNamed()</a> to query if there exists a joint in <code>this</code> MultibodyPlant with a given specified <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>. </dd></dl>

</div>
</div>
<a id="a049f388354fd2cd63faa9d0004f23c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049f388354fd2cd63faa9d0004f23c33">&#9670;&nbsp;</a></span>GetJointByName() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt;T&gt;&amp; GetJointByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the joint that is uniquely identified by the string <code>name</code> and <code>model_instance</code> in <code>this</code> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no joint with the requested name. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a02c811258a0d93dd116d61648334a392">HasJointNamed()</a> to query if there exists a joint in <code>this</code> MultibodyPlant with a given specified <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>. </dd></dl>

</div>
</div>
<a id="accc8cfa422ad74560dd8a28fbf8296fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc8cfa422ad74560dd8a28fbf8296fa">&#9670;&nbsp;</a></span>GetJointByName() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const JointType&lt;T&gt;&amp; GetJointByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A templated version of <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af72d95f825442702e3efb64787a80cb5" title="Returns a constant reference to a joint that is identified by the string name in this MultibodyPlant...">GetJointByName()</a> to return a constant reference of the specified type <code>JointType</code> in place of the base <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class. </p>
<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af72d95f825442702e3efb64787a80cb5" title="Returns a constant reference to a joint that is identified by the string name in this MultibodyPlant...">GetJointByName()</a> for details. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JointType</td><td>The specific type of the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> to be retrieved. It must be a subclass of <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the named joint is not of type <code>JointType</code> or if there is no <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> with that name. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the joint name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a02c811258a0d93dd116d61648334a392">HasJointNamed()</a> to query if there exists a joint in <code>this</code> MultibodyPlant with a given specified <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>. </dd></dl>

</div>
</div>
<a id="a222a13bd716a6b59b9393fcfef1c18ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222a13bd716a6b59b9393fcfef1c18ff">&#9670;&nbsp;</a></span>GetJointByName() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const JointType&lt;T&gt;&amp; GetJointByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A templated version of <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af72d95f825442702e3efb64787a80cb5" title="Returns a constant reference to a joint that is identified by the string name in this MultibodyPlant...">GetJointByName()</a> to return a constant reference of the specified type <code>JointType</code> in place of the base <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class. </p>
<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af72d95f825442702e3efb64787a80cb5" title="Returns a constant reference to a joint that is identified by the string name in this MultibodyPlant...">GetJointByName()</a> for details. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JointType</td><td>The specific type of the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> to be retrieved. It must be a subclass of <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the named joint is not of type <code>JointType</code> or if there is no <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> with that name. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a02c811258a0d93dd116d61648334a392">HasJointNamed()</a> to query if there exists a joint in <code>this</code> MultibodyPlant with a given specified <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>. </dd></dl>

</div>
</div>
<a id="a2a177e855cc5efe12d15adc4c697930f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a177e855cc5efe12d15adc4c697930f">&#9670;&nbsp;</a></span>GetModelInstanceByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> GetModelInstanceByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index to the model instance that is uniquely identified by the string <code>name</code> in <code>this</code> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no instance with the requested name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a05b71664c8e2e91bc3fc92fef222a9bf">HasModelInstanceNamed()</a> to query if there exists an instance in <code>this</code> MultibodyPlant with a given specified <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>. </dd></dl>

</div>
</div>
<a id="ab99be499eb59f00037b05ec60b51e177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99be499eb59f00037b05ec60b51e177">&#9670;&nbsp;</a></span>GetModelInstanceName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; GetModelInstanceName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of a <code>model_instance</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>when <code>model_instance</code> does not correspond to a model in this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace2984079483027345739f5e1bc8a19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2984079483027345739f5e1bc8a19c">&#9670;&nbsp;</a></span>GetMutablePositions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetMutablePositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Returns a mutable vector reference containing the vector of generalized positions (<b>see warning</b>). </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You should use <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abfb9f945ca5577141351e60bd45156ef" title="Sets all generalized positions from the given vector. ">SetPositions()</a> instead of this method unless you are fully aware of the possible interactions with the caching mechanism (see <a class="el" href="classdrake_1_1systems_1_1_context.html#dangerous_get_mutable">dangerous_get_mutable</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr or if it does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1036e869271ac77a82f891a5f7187210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1036e869271ac77a82f891a5f7187210">&#9670;&nbsp;</a></span>GetMutablePositionsAndVelocities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetMutablePositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Returns a mutable vector containing the vector <code>[q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities (<b>see warning</b>). </p>
<dl class="section warning"><dt>Warning</dt><dd>You should use <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5f77c6666edaa725dbd5dd060d2f5b00" title="Sets all generalized positions and velocities from the given vector [q; v]. ">SetPositionsAndVelocities()</a> instead of this method unless you are fully aware of the interactions with the caching mechanism (see <a class="el" href="classdrake_1_1systems_1_1_context.html#dangerous_get_mutable">dangerous_get_mutable</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr or if it does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fe7c6fe93604e71b9d277b76fab5932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe7c6fe93604e71b9d277b76fab5932">&#9670;&nbsp;</a></span>GetMutableVelocities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetMutableVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Returns a mutable vector reference containing the vector of generalized velocities (<b>see warning</b>). </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You should use <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1ee483fa25d16a1ab99da1e0bface016" title="Sets all generalized velocities from the given vector. ">SetVelocities()</a> instead of this method unless you are fully aware of the possible interactions with the caching mechanism (see <a class="el" href="classdrake_1_1systems_1_1_context.html#dangerous_get_mutable">dangerous_get_mutable</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr or the context does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b48791a474f442ccb628dc9b76a24b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b48791a474f442ccb628dc9b76a24b9">&#9670;&nbsp;</a></span>GetPositions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const vector reference containing the vector of generalized positions. </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe2a085e96321a9d821551c479aed347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2a085e96321a9d821551c479aed347">&#9670;&nbsp;</a></span>GetPositions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; GetPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an vector containing the generalized positions (<code>q</code>) for the given model instance. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns a dense vector of dimension <code>q.size()</code> associated with <code>model_instance</code> in O(<code>q.size()</code>) time. </dd></dl>

</div>
</div>
<a id="abda564c1168979bb8422343d46925b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda564c1168979bb8422343d46925b9a">&#9670;&nbsp;</a></span>GetPositionsAndVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const vector reference containing the vector <code>[q; v]</code> with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities. </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa0be270734139ba7fd908effc13dd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0be270734139ba7fd908effc13dd54">&#9670;&nbsp;</a></span>GetPositionsAndVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; GetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vector <code>[q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities for model instance <code>model_instance</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> does not correspond to the context for a multibody model or <code>model_instance</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns a dense vector of dimension <code>q.size() + v.size()</code> associated with <code>model_instance</code> in O(<code>q.size()</code>) time. </dd></dl>

</div>
</div>
<a id="a9b8a17ef762452f820bdd351f8bb41b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8a17ef762452f820bdd351f8bb41b4">&#9670;&nbsp;</a></span>GetPositionsFromArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; GetPositionsFromArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of generalized positions for <code>model_instance</code> from a vector <code>q_array</code> of generalized positions for the entire model model. </p>
<p>This method throws an exception if <code>q</code> is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model. ">MultibodyPlant::num_positions()</a>. </p>

</div>
</div>
<a id="a1ef21c2455a83e7a086df24f8411e26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef21c2455a83e7a086df24f8411e26b">&#9670;&nbsp;</a></span>GetRigidBodyByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; GetRigidBodyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to a rigid body that is identified by the string <code>name</code> in <code>this</code> model. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no body with the requested name. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the body name occurs in multiple model instances. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the requested body is not a <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a> to query if there exists a body in <code>this</code> <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1c1029d223ec3d0db0dc14d643fa7c88" title="Returns a constant reference to the underlying MultibodyTree model for this plant. ">model</a> with a given specified <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>. </dd></dl>

</div>
</div>
<a id="a0b1b9a39c20706b20221ea2c142d2cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1b9a39c20706b20221ea2c142d2cfd">&#9670;&nbsp;</a></span>GetRigidBodyByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; GetRigidBodyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the rigid body that is uniquely identified by the string <code>name</code> in <code>model_instance</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no body with the requested name. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the requested body is not a <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a>. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a> to query if there exists a body in <code>this</code> <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1c1029d223ec3d0db0dc14d643fa7c88" title="Returns a constant reference to the underlying MultibodyTree model for this plant. ">model</a> with a given specified <a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>. </dd></dl>

</div>
</div>
<a id="a800453060fc1f94455dff6c07dfde2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800453060fc1f94455dff6c07dfde2d1">&#9670;&nbsp;</a></span>GetVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const vector reference containing the generalized velocities. </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>

</div>
</div>
<a id="acbcd0c2630b23058791b7a3d6bac07a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcd0c2630b23058791b7a3d6bac07a8">&#9670;&nbsp;</a></span>GetVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; GetVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the generalized velocities (<code>v</code>) for the given model instance. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns a dense vector of dimension <code>v.size()</code> associated with <code>model_instance</code> in O(<code>v.size()</code>) time. </dd></dl>

</div>
</div>
<a id="aab7edf9b06b97e2f1b7045cc1d9f56f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7edf9b06b97e2f1b7045cc1d9f56f9">&#9670;&nbsp;</a></span>GetVelocitiesFromArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; GetVelocitiesFromArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of generalized velocities for <code>model_instance</code> from a vector <code>v</code> of generalized velocities for the entire <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> model. </p>
<p>This method throws an exception if the input array is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model. ">MultibodyPlant::num_velocities()</a>. </p>

</div>
</div>
<a id="ac311fb9ac3a4450ba1a4b74a4c72a9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac311fb9ac3a4450ba1a4b74a4c72a9f6">&#9670;&nbsp;</a></span>GetVisualGeometriesForBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a> &gt; &amp; GetVisualGeometriesForBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of GeometryId's identifying the different visual geometries for <code>body</code> previously registered with a SceneGraph. </p>
<dl class="section note"><dt>Note</dt><dd>This method can be called at any time during the lifetime of <code>this</code> plant, either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. Post-finalize calls will always return the same value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a53549e4f65d1647147ff8b011712d96e" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for visualization of a giv...">RegisterVisualGeometry()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a> </dd></dl>

</div>
</div>
<a id="a89a198b6549e543018c7c9873d4e6dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a198b6549e543018c7c9873d4e6dc1">&#9670;&nbsp;</a></span>HasBodyNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasBodyNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a body named <code>name</code> was added to the MultibodyPlant. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f6a68c31772eaa0c855ebb44eeaa0b7" title="Creates a rigid body with the provided name and spatial inertia. ">AddRigidBody()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the body name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c5aa85a70a9f0f196091ed298266c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5aa85a70a9f0f196091ed298266c57">&#9670;&nbsp;</a></span>HasBodyNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasBodyNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a body named <code>name</code> was added to the MultibodyPlant in <code>model_instance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f6a68c31772eaa0c855ebb44eeaa0b7" title="Creates a rigid body with the provided name and spatial inertia. ">AddRigidBody()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3530f8f6747cb603a24accba5901bd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3530f8f6747cb603a24accba5901bd00">&#9670;&nbsp;</a></span>HasFrameNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasFrameNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a frame named <code>name</code> was added to the model. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a474c90a0b3e4f9349533207026413186" title="This method adds a Frame of type FrameType&lt;T&gt;. ">AddFrame()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the frame name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ab3a66ab482037c12c4d556800c550a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab3a66ab482037c12c4d556800c550a">&#9670;&nbsp;</a></span>HasFrameNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasFrameNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a frame named <code>name</code> was added to <code>model_instance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a474c90a0b3e4f9349533207026413186" title="This method adds a Frame of type FrameType&lt;T&gt;. ">AddFrame()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30dd7e61bafa3221193e7d68e4be7cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30dd7e61bafa3221193e7d68e4be7cbc">&#9670;&nbsp;</a></span>HasJointActuatorNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasJointActuatorNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an actuator named <code>name</code> was added to this model. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5096160ffb18ddc72e2e29c0edfc5064" title="Creates and adds a JointActuator model for an actuator acting on a given joint. ">AddJointActuator()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the actuator name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f6ad707643bf5220e76678e71291175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6ad707643bf5220e76678e71291175">&#9670;&nbsp;</a></span>HasJointActuatorNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasJointActuatorNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an actuator named <code>name</code> was added to <code>model_instance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5096160ffb18ddc72e2e29c0edfc5064" title="Creates and adds a JointActuator model for an actuator acting on a given joint. ">AddJointActuator()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c811258a0d93dd116d61648334a392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c811258a0d93dd116d61648334a392">&#9670;&nbsp;</a></span>HasJointNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasJointNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a joint named <code>name</code> was added to this model. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a437f86026a2268c0fb06936b899ba8d7" title="This method adds a Joint of type JointType between two bodies. ">AddJoint()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the joint name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7ebee03109f4cb8990124949e97caa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ebee03109f4cb8990124949e97caa1">&#9670;&nbsp;</a></span>HasJointNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasJointNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a joint named <code>name</code> was added to <code>model_instance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a437f86026a2268c0fb06936b899ba8d7" title="This method adds a Joint of type JointType between two bodies. ">AddJoint()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05b71664c8e2e91bc3fc92fef222a9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b71664c8e2e91bc3fc92fef222a9bf">&#9670;&nbsp;</a></span>HasModelInstanceNamed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> HasModelInstanceNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a model instance named <code>name</code> was added to this model. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4edf1daa65069a26255c903b02bce4c6" title="Creates a new model instance. ">AddModelInstance()</a>. </dd></dl>

</div>
</div>
<a id="acf7bb2a3531c09a97fb3623ac582d840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7bb2a3531c09a97fb3623ac582d840">&#9670;&nbsp;</a></span>is_finalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> is_finalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this MultibodyPlant was finalized with a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. </dd></dl>

</div>
</div>
<a id="a0d7f5496735d233ea0b984c5a290671f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7f5496735d233ea0b984c5a290671f">&#9670;&nbsp;</a></span>MakeActuatorSelectorMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; MakeActuatorSelectorMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>user_to_actuator_index_map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method allows user to map a vector <code>uₛ</code> containing the actuation for a set of selected actuators into the vector u containing the actuation values for <code>this</code> full model. </p>
<p>The mapping, or selection, is returned in the form of a selector matrix Su such that <code>u = Su⋅uₛ</code>. The size nₛ of uₛ is always smaller or equal than the size of the full vector of actuation values u. That is, a user might be interested in only a given subset of actuators in the model.</p>
<p>This selection matrix is particularly useful when adding PID control on a portion of the state, see <a class="el" href="classdrake_1_1systems_1_1controllers_1_1_pid_controller.html" title="Implements the PID controller. ">systems::controllers::PidController</a>.</p>
<p>A user specifies the preferred order in uₛ via <code>user_to_actuator_index_map</code>. The actuation values in uₛ are a concatenation of the values for each actuator in the order they appear in <code>user_to_actuator_index_map</code>. The full vector of actuation values u is ordered by JointActuatorIndex. </p>

</div>
</div>
<a id="a029244fdbe2f10a7bfaf5c21175d834c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029244fdbe2f10a7bfaf5c21175d834c">&#9670;&nbsp;</a></span>MakeActuatorSelectorMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; MakeActuatorSelectorMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>user_to_joint_index_map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative signature to build an actuation selector matrix <code>Su</code> such that <code>u = Su⋅uₛ</code>, where u is the vector of actuation values for the full model (ordered by JointActuatorIndex) and uₛ is a vector of actuation values for the actuators acting on the joints listed by <code>user_to_joint_index_map</code>. </p>
<p>It is assumed that all joints referenced by <code>user_to_joint_index_map</code> are actuated. See MakeActuatorSelectorMatrix(const std::vector&lt;JointActuatorIndex&gt;&amp;) for details. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if any of the joints in <code>user_to_joint_index_map</code> does not have an actuator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c7b2e7b0c09b6479d25250405ffd0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7b2e7b0c09b6479d25250405ffd0c4">&#9670;&nbsp;</a></span>MakeStateSelectorMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; MakeStateSelectorMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>user_to_joint_index_map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method allows users to map the state of <code>this</code> model, x, into a vector of selected state xₛ with a given preferred ordering. </p>
<p>The mapping, or selection, is returned in the form of a selector matrix Sx such that <code>xₛ = Sx⋅x</code>. The size nₛ of xₛ is always smaller or equal than the size of the full state x. That is, a user might be interested in only a given portion of the full state x.</p>
<p>This selection matrix is particularly useful when adding PID control on a portion of the state, see <a class="el" href="classdrake_1_1systems_1_1controllers_1_1_pid_controller.html" title="Implements the PID controller. ">systems::controllers::PidController</a>.</p>
<p>A user specifies the preferred order in xₛ via <code>user_to_joint_index_map</code>. The selected state is built such that selected positions are followed by selected velocities, as in <code>xₛ = [qₛ, vₛ]</code>. The positions in qₛ are a concatenation of the positions for each joint in the order they appear in <code>user_to_joint_index_map</code>. That is, the positions for <code>user_to_joint_index_map[0]</code> are first, followed by the positions for <code>user_to_joint_index_map[1]</code>, etc. Similarly for the selected velocities vₛ.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there are repeated indexes in <code>user_to_joint_index_map</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab128a8bba10523922358bc35df103753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab128a8bba10523922358bc35df103753">&#9670;&nbsp;</a></span>MapQDotToVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MapQDotToVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the time derivative <code>qdot</code> of the generalized positions vector <code>q</code> (stored in <code>context</code>) to generalized velocities <code>v</code>. </p>
<p><code>v</code> and <code>q̇</code> are related linearly by <code>q̇ = N(q)⋅v</code>. Although <code>N(q)</code> is not necessarily square, its left pseudo-inverse <code>N⁺(q)</code> can be used to invert that relationship without residual error, provided that <code>qdot</code> is in the range space of <code>N(q)</code> (that is, if it <em>could</em> have been produced as <code>q̇ = N(q)⋅v</code> for some <code>v</code>). Using the configuration <code>q</code> stored in the given <code>context</code> this method calculates <code>v = N⁺(q)⋅q̇</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qdot</td><td>A vector containing the time derivatives of the generalized positions. This method aborts if <code>qdot</code> is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model. ">num_positions()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>A valid (non-null) pointer to a vector in <code>ℛⁿ</code> with n the number of generalized velocities. This method aborts if v is nullptr or if it is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model. ">num_velocities()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a7bb24fed19f16a76450eece1857b92dc" title="Transforms generalized velocities v to time derivatives qdot of the generalized positions vector q (s...">MapVelocityToQDot()</a> </dd>
<dd>
<a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a2186b0940efa312260a78d9ae97cd645" title="Computes the mapping v = N⁺(q)⋅q̇ from time derivatives of the generalized positions qdot to genera...">Mobilizer::MapQDotToVelocity()</a> </dd></dl>

</div>
</div>
<a id="a7bb24fed19f16a76450eece1857b92dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb24fed19f16a76450eece1857b92dc">&#9670;&nbsp;</a></span>MapVelocityToQDot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MapVelocityToQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms generalized velocities v to time derivatives <code>qdot</code> of the generalized positions vector <code>q</code> (stored in <code>context</code>). </p>
<p><code>v</code> and <code>qdot</code> are related linearly by <code>q̇ = N(q)⋅v</code>. Using the configuration <code>q</code> stored in the given <code>context</code> this method calculates <code>q̇ = N(q)⋅v</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A vector of of generalized velocities for this model. This method aborts if v is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model. ">num_velocities()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qdot</td><td>A valid (non-null) pointer to a vector in <code>ℝⁿ</code> with n being the number of generalized positions in this model, given by <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model. ">num_positions()</a></code>. This method aborts if <code>qdot</code> is nullptr or if it is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model. ">num_positions()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab128a8bba10523922358bc35df103753" title="Transforms the time derivative qdot of the generalized positions vector q (stored in context) to gene...">MapQDotToVelocity()</a> </dd>
<dd>
<a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a1dbd64e78f3a522c007e242334223e93" title="Computes the kinematic mapping q̇ = N(q)⋅v between generalized velocities v and time derivatives of ...">Mobilizer::MapVelocityToQDot()</a> </dd></dl>

</div>
</div>
<a id="a1c1029d223ec3d0db0dc14d643fa7c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1029d223ec3d0db0dc14d643fa7c88">&#9670;&nbsp;</a></span>model()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1internal_1_1_multibody_tree.html">MultibodyTree</a>&lt;T&gt;&amp; model </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the underlying MultibodyTree model for <code>this</code> plant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3fc8de8de8eaf2d37a24c79d6be8e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fc8de8de8eaf2d37a24c79d6be8e97">&#9670;&nbsp;</a></span>num_actuated_dofs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_actuated_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of actuated degrees of freedom. </p>
<p>That is, the vector of actuation values u has this size. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5096160ffb18ddc72e2e29c0edfc5064" title="Creates and adds a JointActuator model for an actuator acting on a given joint. ">AddJointActuator()</a>. </p>

</div>
</div>
<a id="a279e31367e76849d4a45fd7db0f116f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279e31367e76849d4a45fd7db0f116f1">&#9670;&nbsp;</a></span>num_actuated_dofs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_actuated_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of actuated degrees of freedom for a specific model instance. </p>
<p>That is, the vector of actuation values u has this size. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5096160ffb18ddc72e2e29c0edfc5064" title="Creates and adds a JointActuator model for an actuator acting on a given joint. ">AddJointActuator()</a>. </p>

</div>
</div>
<a id="a8601c026e9807127b4dd41e7585d2cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8601c026e9807127b4dd41e7585d2cfc">&#9670;&nbsp;</a></span>num_actuators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_actuators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of joint actuators in the model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5096160ffb18ddc72e2e29c0edfc5064" title="Creates and adds a JointActuator model for an actuator acting on a given joint. ">AddJointActuator()</a>. </dd></dl>

</div>
</div>
<a id="af92b53211e54243aff4490a700168eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92b53211e54243aff4490a700168eb4">&#9670;&nbsp;</a></span>num_bodies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_bodies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bodies in the model, including the "world" body, which is always part of the model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f6a68c31772eaa0c855ebb44eeaa0b7" title="Creates a rigid body with the provided name and spatial inertia. ">AddRigidBody()</a>. </dd></dl>

</div>
</div>
<a id="ac1b107ecf3446e56cb203461440200c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b107ecf3446e56cb203461440200c1">&#9670;&nbsp;</a></span>num_collision_geometries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_collision_geometries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of geometries registered for contact modeling. </p>
<p>This method can be called at any time during the lifetime of <code>this</code> plant, either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. Post-finalize calls will always return the same value. </p>

</div>
</div>
<a id="a6b7f0267d163693025fa04f78bb18333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7f0267d163693025fa04f78bb18333">&#9670;&nbsp;</a></span>num_force_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_force_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model...">ForceElement</a> objects. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a48009c793b01c5a6dd079d33265435a3" title="Adds a new force element model of type ForceElementType to this MultibodyPlant. ">AddForceElement()</a>. </dd></dl>

</div>
</div>
<a id="ada7f02e861a8f89fc0b575b2f30333d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7f02e861a8f89fc0b575b2f30333d3">&#9670;&nbsp;</a></span>num_frames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_frames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> objects in this model. </p>
<p>Frames include body frames associated with each of the bodies, including the <em>world</em> body. This means the minimum number of frames is one. </p>

</div>
</div>
<a id="a636804b6c40e538d83d5c2dfefb7929e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636804b6c40e538d83d5c2dfefb7929e">&#9670;&nbsp;</a></span>num_joints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_joints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of joints in the model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a437f86026a2268c0fb06936b899ba8d7" title="This method adds a Joint of type JointType between two bodies. ">AddJoint()</a>. </dd></dl>

</div>
</div>
<a id="ac89140adb93cb9e507f71c30eb783198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89140adb93cb9e507f71c30eb783198">&#9670;&nbsp;</a></span>num_model_instances()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_model_instances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of model instances in the model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4edf1daa65069a26255c903b02bce4c6" title="Creates a new model instance. ">AddModelInstance()</a>. </dd></dl>

</div>
</div>
<a id="ac80c61762d32b97a34f02a0374fc6fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80c61762d32b97a34f02a0374fc6fe3">&#9670;&nbsp;</a></span>num_multibody_states()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_multibody_states </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the multibody system state vector <code>x = [q; v]</code>. </p>
<p>This will be <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model. ">num_positions()</a> plus <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model. ">num_velocities()</a>. </p>

</div>
</div>
<a id="aba2887f0ca1fbbdfb49cf6b0ee21e553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">&#9670;&nbsp;</a></span>num_positions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_positions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the generalized position vector <code>q</code> for this model. </p>

</div>
</div>
<a id="ab669e070e6178c4aeeb067a1f4b6122e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab669e070e6178c4aeeb067a1f4b6122e">&#9670;&nbsp;</a></span>num_positions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_positions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the generalized position vector <code>q</code> for a specific model instance. </p>

</div>
</div>
<a id="ae0163ac0976659d811e3337647ff0313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0163ac0976659d811e3337647ff0313">&#9670;&nbsp;</a></span>num_velocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_velocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the generalized velocity vector <code>v</code> for this model. </p>

</div>
</div>
<a id="a0a686a8389beffdc5fb8a7690967e741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a686a8389beffdc5fb8a7690967e741">&#9670;&nbsp;</a></span>num_velocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_velocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the generalized velocity vector <code>v</code> for a specific model instance. </p>

</div>
</div>
<a id="aa7c0b698e0102d42f085ca39f337b019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c0b698e0102d42f085ca39f337b019">&#9670;&nbsp;</a></span>num_visual_geometries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_visual_geometries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of geometries registered for visualization. </p>
<p>This method can be called at any time during the lifetime of <code>this</code> plant, either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. Post-finalize calls will always return the same value. </p>

</div>
</div>
<a id="af4f43a6f72128af8e926d32c37ed7580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f43a6f72128af8e926d32c37ed7580">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecc2576d314d5baf56ad6ad593b26f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc2576d314d5baf56ad6ad593b26f9f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a6d28ce9c8119bee923e827eb6f02ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6d28ce9c8119bee923e827eb6f02ed">&#9670;&nbsp;</a></span>RegisterAsSourceForSceneGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry.html#a32581e3a9c8879bcf23192e248df49c7">geometry::SourceId</a> RegisterAsSourceForSceneGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>scene_graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers <code>this</code> plant to serve as a source for an instance of SceneGraph. </p>
<p>This registration allows MultibodyPlant to register geometry with <code>scene_graph</code> for visualization and/or collision queries. Successive registration calls with SceneGraph <b>must</b> be performed on the same instance to which the pointer argument <code>scene_graph</code> points to. Failure to do so will result in runtime exceptions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_graph</td><td>A valid non nullptr to the SceneGraph instance for which <code>this</code> plant will sever as a source, see SceneGraph documentation for further details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the SourceId of <code>this</code> plant in <code>scene_graph</code>. It can also later on be retrieved with <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aef692dc2241640a308801f7dfae902ba" title="Returns the unique id identifying this plant as a source for a SceneGraph. ">get_source_id()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called post-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>scene_graph</code> is the nullptr. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called more than once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ff674ee03885b0b47b6eb6859cf6a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff674ee03885b0b47b6eb6859cf6a4a">&#9670;&nbsp;</a></span>RegisterCollisionGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a> RegisterCollisionGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coulomb_friction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>scene_graph</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers geometry in a SceneGraph with a given <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications. ">geometry::Shape</a> to be used for the contact modeling of a given <code>body</code>. </p>
<p>More than one geometry can be registered with a body, in which case the body's contact geometry is the union of all geometries registered to that body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td>The body for which geometry is being registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_BG</td><td>The fixed pose of the geometry frame G in the body frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications. ">geometry::Shape</a> used for visualization. E.g.: <a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere. ">geometry::Sphere</a>, <a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder. ">geometry::Cylinder</a>, etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coulomb_friction</td><td>Coulomb's law of friction coefficients to model friction on the surface of <code>shape</code> for the given <code>body</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scene_graph</td><td>(Deprecated) A valid, non-null pointer to a SceneGraph on which geometry will get registered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called post-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>scene_graph</code> does not correspond to the same instance with which <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4a6d28ce9c8119bee923e827eb6f02ed" title="Registers this plant to serve as a source for an instance of SceneGraph. ">RegisterAsSourceForSceneGraph()</a> was called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53549e4f65d1647147ff8b011712d96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53549e4f65d1647147ff8b011712d96e">&#9670;&nbsp;</a></span>RegisterVisualGeometry() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a> RegisterVisualGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">geometry::IllustrationProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>scene_graph</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers geometry in a SceneGraph with a given <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications. ">geometry::Shape</a> to be used for visualization of a given <code>body</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td>The body for which geometry is being registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_BG</td><td>The fixed pose of the geometry frame G in the body frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications. ">geometry::Shape</a> used for visualization. E.g.: <a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere. ">geometry::Sphere</a>, <a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder. ">geometry::Cylinder</a>, etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name for the geometry. It must satisfy the requirements defined in <a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html" title="A geometry instance combines a geometry definition (i.e., a shape of some sort), a pose (relative to ...">drake::geometry::GeometryInstance</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">properties</td><td>The illustration properties for this geometry. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scene_graph</td><td>(Deprecated) A valid non nullptr to a SceneGraph on which geometry will get registered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called post-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>scene_graph</code> does not correspond to the same instance with which <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4a6d28ce9c8119bee923e827eb6f02ed" title="Registers this plant to serve as a source for an instance of SceneGraph. ">RegisterAsSourceForSceneGraph()</a> was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id for the registered geometry. </dd></dl>

</div>
</div>
<a id="aee4b17e7296370d22fa3962a7e5b2f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4b17e7296370d22fa3962a7e5b2f00">&#9670;&nbsp;</a></span>RegisterVisualGeometry() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a> RegisterVisualGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>diffuse_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>scene_graph</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for visual geometry registration; it converts the <code>diffuse_color</code> (RGBA with values in the range [0, 1]) into a <a class="el" href="namespacedrake_1_1geometry.html#a23299f33d6cf943a2b929b5f10d03c48" title="Implements ConnectDrakeVisualizer, but using pose_bundle_output_port to explicitly specify the output...">geometry::ConnectDrakeVisualizer()</a>-compatible set of <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role. ">geometry::IllustrationProperties</a>. </p>

</div>
</div>
<a id="a85a41c96ae150a32a1c60eac72c97931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a41c96ae150a32a1c60eac72c97931">&#9670;&nbsp;</a></span>RegisterVisualGeometry() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry.html#ace2b5888497987dd93df850bbc0b241a">geometry::GeometryId</a> RegisterVisualGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>scene_graph</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for visual geometry registration; it relies on the downstream <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role. ">geometry::IllustrationProperties</a> <em>consumer</em> to provide default parameter values (see <a class="el" href="group__geometry__roles.html">Geometry Roles</a> for details). </p>

</div>
</div>
<a id="a8cdb3408c412b2af94476886dc35cc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdb3408c412b2af94476886dc35cc71">&#9670;&nbsp;</a></span>set_penetration_allowance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_penetration_allowance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>penetration_allowance</em> = <code>0.001</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the penetration allowance used to estimate the coefficients in the penalty method used to impose non-penetration among bodies. </p>
<p>Refer to the section <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_penalty_method">Contact by penalty method</a> for further details. </p>

</div>
</div>
<a id="a3ce165180ba1d40e2a120eea631e4cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce165180ba1d40e2a120eea631e4cb1">&#9670;&nbsp;</a></span>set_stiction_tolerance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_stiction_tolerance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v_stiction</em> = <code>0.001</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the stiction tolerance <code>v_stiction</code> for the Stribeck model, where <code>v_stiction</code> must be specified in m/s (meters per second.) <code>v_stiction</code> defaults to a value of 1 millimeter per second. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>v_stiction</code> is non-positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec851e17ae2c34da1b87a03ce85f460a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec851e17ae2c34da1b87a03ce85f460a">&#9670;&nbsp;</a></span>SetActuationInArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetActuationInArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>u_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the actuation values <code>u_instance</code> for all actuators in <code>model_instance</code>, this method sets the actuation vector u for the entire model to which this actuator belongs to. </p>
<p>This method throws an exception if the size of <code>u_instance</code> is not equal to the number of degrees of freedom of all of the actuated joints in <code>model_instance</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u_instance</td><td>Actuation values for the actuators. It must be of size equal to the number of degrees of freedom of all of the actuated joints in <code>model_instance</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>The vector containing the actuation values for the entire model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a098f3fd21ecb96e2769dbd4bb4c124f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098f3fd21ecb96e2769dbd4bb4c124f2">&#9670;&nbsp;</a></span>SetDefaultContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets default values in the context. </p>
<p>For mobilizers, this method sets them to their <em>zero</em> state according to <a class="el" href="classdrake_1_1multibody_1_1_mobilizer.html#a5aa27a24c2c9e5ddc38d771e455c3b88" title="Sets the state to what will be considered to be the zero state (position and velocity) for this mobil...">Mobilizer::set_zero_state()</a>. </p>

</div>
</div>
<a id="ae73edc00d493b3f15ba7679cc14830a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73edc00d493b3f15ba7679cc14830a0">&#9670;&nbsp;</a></span>SetDefaultState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the state in <code>context</code> so that generalized positions and velocities are zero. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2afeb2fce8493fe177dd3cd155819bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afeb2fce8493fe177dd3cd155819bb9">&#9670;&nbsp;</a></span>SetFreeBodyPose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>context</code> to store the pose <code>X_WB</code> of a given <code>body</code> B in the world frame W. </p>
<dl class="section note"><dt>Note</dt><dd>In general setting the pose and/or velocity of a body in the model would involve a complex inverse kinematics problem. This method allows us to simplify this process when we know the body is free in space. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44d819b895df9f2c35cc4c75269b0d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d819b895df9f2c35cc4c75269b0d2a">&#9670;&nbsp;</a></span>SetFreeBodyPose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>state</code> to store the pose <code>X_WB</code> of a given <code>body</code> B in the world frame W, for a given <code>context</code> of <code>this</code> model. </p>
<dl class="section note"><dt>Note</dt><dd>In general setting the pose and/or velocity of a body in the model would involve a complex inverse kinematics problem. This method allows us to simplify this process when we know the body is free in space. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8eb477b56c4408f94ff5f3d4b4e47f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8eb477b56c4408f94ff5f3d4b4e47f1">&#9670;&nbsp;</a></span>SetFreeBodyPoseInAnchoredFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPoseInAnchoredFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>context</code> to store the pose <code>X_FB</code> of a given <code>body</code> B in a frame F. </p>
<p><a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame), meaning that it is associated with a material point of a Body. ">Frame</a> F must be anchored, meaning that it is either directly welded to the world frame W or, more generally, that there is a kinematic path between frame F and the world frame W that only includes weld joints. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if frame F is not anchored to the world. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8acfdadb90c4901f9b66c41d2bfea0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8acfdadb90c4901f9b66c41d2bfea0d">&#9670;&nbsp;</a></span>SetFreeBodyPoseInWorldFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPoseInWorldFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>context</code> to store the pose <code>X_WB</code> of a given <code>body</code> B in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context to store the pose <code>X_WB</code> of <code>body_B</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_B</td><td>The body B corresponding to the pose <code>X_WB</code> to be stored in <code>context</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_WB</td><td>The pose of body frame B in the world frame W. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In general setting the pose and/or velocity of a body in the model would involve a complex inverse kinematics problem. This method allows us to simplify this process when we know the body is free in space. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4c3b2ef66032df5f2a377c47e90ccb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c3b2ef66032df5f2a377c47e90ccb7">&#9670;&nbsp;</a></span>SetFreeBodySpatialVelocity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodySpatialVelocity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>context</code> to store the spatial velocity <code>V_WB</code> of a given <code>body</code> B in the world frame W. </p>
<dl class="section note"><dt>Note</dt><dd>In general setting the pose and/or velocity of a body in the model would involve a complex inverse kinematics problem. This method allows us to simplify this process when we know the body is free in space. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ecd07546b94fae6038ff66f389b7d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecd07546b94fae6038ff66f389b7d23">&#9670;&nbsp;</a></span>SetFreeBodySpatialVelocity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodySpatialVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>state</code> to store the spatial velocity <code>V_WB</code> of a given <code>body</code> B in the world frame W, for a given <code>context</code> of <code>this</code> model. </p>
<dl class="section note"><dt>Note</dt><dd>In general setting the pose and/or velocity of a body in the model would involve a complex inverse kinematics problem. This method allows us to simplify this process when we know the body is free in space. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfb9f945ca5577141351e60bd45156ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb9f945ca5577141351e60bd45156ef">&#9670;&nbsp;</a></span>SetPositions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all generalized positions from the given vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr, if the context does not correspond to the context for a multibody model, or if the length of <code>q</code> is not equal to <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model. ">num_positions()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0258f954570e8d3df3b81e5e1f6e192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0258f954570e8d3df3b81e5e1f6e192">&#9670;&nbsp;</a></span>SetPositions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the positions for a particular model instance from the given vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr, if the context does not correspond to the context for a multibody model, if the model instance index is invalid, or if the length of <code>q_instance</code> is not equal to <code>num_positions(model_instance)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f77c6666edaa725dbd5dd060d2f5b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f77c6666edaa725dbd5dd060d2f5b00">&#9670;&nbsp;</a></span>SetPositionsAndVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all generalized positions and velocities from the given vector [q; v]. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr, if the context does not correspond to the context for a multibody model, or if the length of <code>q_v</code> is not equal to <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model. ">num_positions()</a> + <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model. ">num_velocities()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16955a0cd87697a6806d99e9d6de0651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16955a0cd87697a6806d99e9d6de0651">&#9670;&nbsp;</a></span>SetPositionsAndVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets generalized positions and velocities from the given vector [q; v] for the specified model instance. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr, if the context does not correspond to the context for a multibody model, if the model instance index is invalid, or if the length of <code>q_v</code> is not equal to <code>num_positions(model_instance) + num_velocities(model_instance)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de72c319632f5a263fe6c9e96c70614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de72c319632f5a263fe6c9e96c70614">&#9670;&nbsp;</a></span>SetPositionsInArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetPositionsInArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>q_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the vector of generalized positions for <code>model_instance</code> in <code>q</code> using <code>q_instance</code>, leaving all other elements in the array untouched. </p>
<p>This method throws an exception if <code>q</code> is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model. ">MultibodyPlant::num_positions()</a> or <code>q_instance</code> is not of size <code>MultibodyPlant::num_positions(model_instance)</code>. </p>

</div>
</div>
<a id="a1ee483fa25d16a1ab99da1e0bface016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee483fa25d16a1ab99da1e0bface016">&#9670;&nbsp;</a></span>SetVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all generalized velocities from the given vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr, if the context does not correspond to the context for a multibody model, or if the length of <code>v</code> is not equal to <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model. ">num_velocities()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acac13b1f67afe352e62d292c1bd3a6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac13b1f67afe352e62d292c1bd3a6e0">&#9670;&nbsp;</a></span>SetVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the generalized velocities for a particular model instance from the given vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr, if the context does not correspond to the context for a multibody model, if the model instance index is invalid, or if the length of <code>v_instance</code> is not equal to <code>num_velocities(model_instance)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3e24d7263c7886bdf1adab111e34f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e24d7263c7886bdf1adab111e34f33">&#9670;&nbsp;</a></span>SetVelocitiesInArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetVelocitiesInArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>model_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>v_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the vector of generalized velocities for <code>model_instance</code> in <code>v</code> using <code>v_instance</code>, leaving all other elements in the array untouched. </p>
<p>This method throws an exception if <code>v</code> is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model. ">MultibodyPlant::num_velocities()</a> or <code>v_instance</code> is not of size <code>MultibodyPlant::num_positions(model_instance)</code>. </p>

</div>
</div>
<a id="a8daceb7a3c384d6ad9f305e42b5fc1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8daceb7a3c384d6ad9f305e42b5fc1c6">&#9670;&nbsp;</a></span>time_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> time_step </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The time step (or period) used to model <code>this</code> plant as a discrete system with periodic updates. </p>
<p>Returns 0 (zero) if the plant is modeled as a continuous system. This property of the plant is specified at construction and therefore this query can be performed either pre- or post- finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_tree_system.html#a8fee61d7a783cade1a3d07fe86284d27" title="Finalize the tree if that hasn&#39;t already been done, complete System construction, and declare any nee...">Finalize()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a042f9f9407c26eceeec309377eadcfa2" title="Default constructor creates a plant with a single &quot;world&quot; body. ">MultibodyPlant::MultibodyPlant(double)</a> </dd></dl>

</div>
</div>
<a id="a63eff4541522744b3ea5079c9ef1cbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63eff4541522744b3ea5079c9ef1cbc3">&#9670;&nbsp;</a></span>WeldFrames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html">WeldJoint</a>&lt; T &gt; &amp; WeldFrames </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_AB</em> = <code><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Welds frames A and B with relative pose <code>X_AB</code>. </p>
<p>That is, the pose of frame B in frame A is fixed, with value <code>X_AB</code>. The call to this method creates and adds a new <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html" title="This Joint fixes the relative pose between two frames as if &quot;welding&quot; them together. ">WeldJoint</a> to the model. The new <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html" title="This Joint fixes the relative pose between two frames as if &quot;welding&quot; them together. ">WeldJoint</a> is named as: A.name() + "_welds_to_" + B.name(). </p><dl class="section return"><dt>Returns</dt><dd>a constant reference to the <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html" title="This Joint fixes the relative pose between two frames as if &quot;welding&quot; them together. ">WeldJoint</a> welding frames A and B. </dd></dl>

</div>
</div>
<a id="a29ef779ddfeea96c5d80c27d68a4f864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ef779ddfeea96c5d80c27d68a4f864">&#9670;&nbsp;</a></span>world_body()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; world_body </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the <em>world</em> body. </p>

</div>
</div>
<a id="ac95da38020c32452f62a8cf973057c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95da38020c32452f62a8cf973057c7a">&#9670;&nbsp;</a></span>world_frame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html">BodyFrame</a>&lt;T&gt;&amp; world_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the <em>world</em> frame. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a47a63154823dffd5838329527aafbd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a63154823dffd5838329527aafbd58">&#9670;&nbsp;</a></span>MultibodyPlant</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42efef893a4d8eed1d593caff328f599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42efef893a4d8eed1d593caff328f599">&#9670;&nbsp;</a></span>MultibodyPlantTester</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant_tester.html">MultibodyPlantTester</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/multibody/plant/<a class="el" href="multibody__plant_8h.html">multibody_plant.h</a></li>
<li>drake/multibody/plant/<a class="el" href="multibody__plant_8cc.html">multibody_plant.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
