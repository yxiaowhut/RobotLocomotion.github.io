<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: MobyLCPSolver&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1solvers_1_1_moby_l_c_p_solver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classdrake_1_1solvers_1_1_moby_l_c_p_solver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MobyLCPSolver&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for solving Linear Complementarity Problems (LCPs).  
 <a href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#details">More...</a></p>

<p><code>#include &lt;drake/solvers/moby_lcp_solver.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8921d25ba263738dc7d487e3dc0b872e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a8921d25ba263738dc7d487e3dc0b872e">MobyLCPSolver</a> ()=default</td></tr>
<tr class="separator:a8921d25ba263738dc7d487e3dc0b872e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb81504651f5281ac80489ed3b23c8fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#aeb81504651f5281ac80489ed3b23c8fc">~MobyLCPSolver</a> () override=default</td></tr>
<tr class="separator:aeb81504651f5281ac80489ed3b23c8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac324298c671d9098ebbfacb0fdc3644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#aac324298c671d9098ebbfacb0fdc3644">SetLoggingEnabled</a> (<a class="el" href="classbool.html">bool</a> enabled)</td></tr>
<tr class="separator:aac324298c671d9098ebbfacb0fdc3644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e270f319dccd9f904773b7bb86cc8b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a8e270f319dccd9f904773b7bb86cc8b9">SolveLcpFast</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;M, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;q, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *<a class="el" href="vtk__util__test_8cc.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>, const T &amp;zero_tol=T(-1)) const</td></tr>
<tr class="memdesc:a8e270f319dccd9f904773b7bb86cc8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A is positive definite).  <a href="#a8e270f319dccd9f904773b7bb86cc8b9">More...</a><br /></td></tr>
<tr class="separator:a8e270f319dccd9f904773b7bb86cc8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9869f5947096ab22cdbb57d0c1cb3ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#ab9869f5947096ab22cdbb57d0c1cb3ce">SolveLcpFastRegularized</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;M, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;q, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *<a class="el" href="vtk__util__test_8cc.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>, <a class="el" href="classint.html">int</a> min_exp=-20, unsigned step_exp=4, <a class="el" href="classint.html">int</a> max_exp=20, const T &amp;zero_tol=T(-1)) const</td></tr>
<tr class="memdesc:ab9869f5947096ab22cdbb57d0c1cb3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regularized version of the fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A is positive definite).  <a href="#ab9869f5947096ab22cdbb57d0c1cb3ce">More...</a><br /></td></tr>
<tr class="separator:ab9869f5947096ab22cdbb57d0c1cb3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8622e1d6cfcb3d7f126fac1064b8999c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a8622e1d6cfcb3d7f126fac1064b8999c">SolveLcpLemke</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;M, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;q, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *<a class="el" href="vtk__util__test_8cc.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>, const T &amp;piv_tol=T(-1), const T &amp;zero_tol=T(-1)) const</td></tr>
<tr class="memdesc:a8622e1d6cfcb3d7f126fac1064b8999c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lemke's Algorithm for solving LCPs in the matrix class E, which contains all strictly semimonotone matrices, all P-matrices, and all strictly copositive matrices.  <a href="#a8622e1d6cfcb3d7f126fac1064b8999c">More...</a><br /></td></tr>
<tr class="separator:a8622e1d6cfcb3d7f126fac1064b8999c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d480e61f99325ebbc2ab35dc33c09f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a28d480e61f99325ebbc2ab35dc33c09f">SolveLcpLemkeRegularized</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;M, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;q, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *<a class="el" href="vtk__util__test_8cc.html#ab3e6ed577a7c669c19de1f9c1b46c872">z</a>, <a class="el" href="classint.html">int</a> min_exp=-20, unsigned step_exp=1, <a class="el" href="classint.html">int</a> max_exp=1, const T &amp;piv_tol=T(-1), const T &amp;zero_tol=T(-1)) const</td></tr>
<tr class="memdesc:a28d480e61f99325ebbc2ab35dc33c09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lemke's Algorithm for solving LCPs in the matrix class E, which contains all strictly semimonotone matrices, all P-matrices, and all strictly copositive matrices.  <a href="#a28d480e61f99325ebbc2ab35dc33c09f">More...</a><br /></td></tr>
<tr class="separator:a28d480e61f99325ebbc2ab35dc33c09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac910159108658c34a743b0806d81ab10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#ac910159108658c34a743b0806d81ab10">available</a> () const override</td></tr>
<tr class="memdesc:ac910159108658c34a743b0806d81ab10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff this solver was enabled at compile-time.  <a href="#ac910159108658c34a743b0806d81ab10">More...</a><br /></td></tr>
<tr class="separator:ac910159108658c34a743b0806d81ab10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccfbaa73e7a744f9339d671ac2f3832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#aeccfbaa73e7a744f9339d671ac2f3832">Solve</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>) const override</td></tr>
<tr class="memdesc:aeccfbaa73e7a744f9339d671ac2f3832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets values for the decision variables on the given <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> <code>prog</code>, or:  <a href="#aeccfbaa73e7a744f9339d671ac2f3832">More...</a><br /></td></tr>
<tr class="separator:aeccfbaa73e7a744f9339d671ac2f3832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae822f158c8b0b8bb10bc8e8350431d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#aae822f158c8b0b8bb10bc8e8350431d8">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>, const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; Eigen::VectorXd &gt; &amp;initial_guess, const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;solver_options, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> *<a class="el" href="ipopt__solver_8cc.html#a1b96859d8d2b1bddf6e5c68171983df3">result</a>) const override</td></tr>
<tr class="memdesc:aae822f158c8b0b8bb10bc8e8350431d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an optimization program with optional initial guess and solver options.  <a href="#aae822f158c8b0b8bb10bc8e8350431d8">More...</a><br /></td></tr>
<tr class="separator:aae822f158c8b0b8bb10bc8e8350431d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3da8c3a4a8bd641915f170d18e6c15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#ace3da8c3a4a8bd641915f170d18e6c15">solver_id</a> () const override</td></tr>
<tr class="memdesc:ace3da8c3a4a8bd641915f170d18e6c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identifier of this solver.  <a href="#ace3da8c3a4a8bd641915f170d18e6c15">More...</a><br /></td></tr>
<tr class="separator:ace3da8c3a4a8bd641915f170d18e6c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1a542e00b9735c56bb11b57e8f6bdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a0a1a542e00b9735c56bb11b57e8f6bdf">AreProgramAttributesSatisfied</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>) const override</td></tr>
<tr class="memdesc:a0a1a542e00b9735c56bb11b57e8f6bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the program attributes are satisfied by the solver's capability.  <a href="#a0a1a542e00b9735c56bb11b57e8f6bdf">More...</a><br /></td></tr>
<tr class="separator:a0a1a542e00b9735c56bb11b57e8f6bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2f977a2be04239fe82e5257f1970a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a9f2f977a2be04239fe82e5257f1970a8">get_num_pivots</a> () const</td></tr>
<tr class="memdesc:a9f2f977a2be04239fe82e5257f1970a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of pivoting operations made by the last LCP solve.  <a href="#a9f2f977a2be04239fe82e5257f1970a8">More...</a><br /></td></tr>
<tr class="separator:a9f2f977a2be04239fe82e5257f1970a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940b243c1e6bc23203756a73f2c80c6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a940b243c1e6bc23203756a73f2c80c6b">reset_num_pivots</a> ()</td></tr>
<tr class="memdesc:a940b243c1e6bc23203756a73f2c80c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the number of pivoting operations made by the last LCP solver to zero.  <a href="#a940b243c1e6bc23203756a73f2c80c6b">More...</a><br /></td></tr>
<tr class="separator:a940b243c1e6bc23203756a73f2c80c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6443e6080dac0553904e9ac680ff64f8"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6443e6080dac0553904e9ac680ff64f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a6443e6080dac0553904e9ac680ff64f8">Solve</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;) const</td></tr>
<tr class="memdesc:a6443e6080dac0553904e9ac680ff64f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets values for the decision variables on the given <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> <code>prog</code>, or:  <a href="#a6443e6080dac0553904e9ac680ff64f8">More...</a><br /></td></tr>
<tr class="separator:a6443e6080dac0553904e9ac680ff64f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57f0c676cb9cff8b39312706b046fd7"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab57f0c676cb9cff8b39312706b046fd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#ab57f0c676cb9cff8b39312706b046fd7">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;, const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; Eigen::VectorXd &gt; &amp;, const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> *) const</td></tr>
<tr class="memdesc:ab57f0c676cb9cff8b39312706b046fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an optimization program with optional initial guess and solver options.  <a href="#ab57f0c676cb9cff8b39312706b046fd7">More...</a><br /></td></tr>
<tr class="separator:ab57f0c676cb9cff8b39312706b046fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:abb7ccd441693e16fa57b4526cad6b3e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#abb7ccd441693e16fa57b4526cad6b3e5">MobyLCPSolver</a> (const <a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a> &amp;)=delete</td></tr>
<tr class="separator:abb7ccd441693e16fa57b4526cad6b3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea743dcac17de35bc2565bf0a178bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a4ea743dcac17de35bc2565bf0a178bdb">operator=</a> (const <a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a> &amp;)=delete</td></tr>
<tr class="separator:a4ea743dcac17de35bc2565bf0a178bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4703ed5696e5c0310d1eeca515e3f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a8f4703ed5696e5c0310d1eeca515e3f1">MobyLCPSolver</a> (<a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a8f4703ed5696e5c0310d1eeca515e3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f77847e110cce8b14e9ae35ce949ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#ac1f77847e110cce8b14e9ae35ce949ba">operator=</a> (<a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac1f77847e110cce8b14e9ae35ce949ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html">MathematicalProgramSolverInterface</a></td></tr>
<tr class="memitem:a113db5a638841dd95744db70e648246a inherit pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html#a113db5a638841dd95744db70e648246a">MathematicalProgramSolverInterface</a> ()=default</td></tr>
<tr class="separator:a113db5a638841dd95744db70e648246a inherit pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafebeca586a701fd20e2e975fd887f5d inherit pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html#aafebeca586a701fd20e2e975fd887f5d">~MathematicalProgramSolverInterface</a> ()=default</td></tr>
<tr class="separator:aafebeca586a701fd20e2e975fd887f5d inherit pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab895aca20008e6d48b807513e748e2d8 inherit pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html#ab895aca20008e6d48b807513e748e2d8">MathematicalProgramSolverInterface</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html">MathematicalProgramSolverInterface</a> &amp;)=delete</td></tr>
<tr class="separator:ab895aca20008e6d48b807513e748e2d8 inherit pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac541a726967d207c1bfbcd45ed94f4da inherit pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html">MathematicalProgramSolverInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html#ac541a726967d207c1bfbcd45ed94f4da">operator=</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html">MathematicalProgramSolverInterface</a> &amp;)=delete</td></tr>
<tr class="separator:ac541a726967d207c1bfbcd45ed94f4da inherit pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59df65c5413055deb36732538cdf92d inherit pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html#ac59df65c5413055deb36732538cdf92d">MathematicalProgramSolverInterface</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html">MathematicalProgramSolverInterface</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac59df65c5413055deb36732538cdf92d inherit pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7929b3e932cb228b5b58e31e41f1a383 inherit pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html">MathematicalProgramSolverInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html#a7929b3e932cb228b5b58e31e41f1a383">operator=</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html">MathematicalProgramSolverInterface</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a7929b3e932cb228b5b58e31e41f1a383 inherit pub_methods_classdrake_1_1solvers_1_1_mathematical_program_solver_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa58e376b7b5873a22bcdb6f8d3a0b42c"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:aa58e376b7b5873a22bcdb6f8d3a0b42c"><td class="memTemplItemLeft" align="right" valign="top">static U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#aa58e376b7b5873a22bcdb6f8d3a0b42c">ComputeZeroTolerance</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; U &gt; &amp;M)</td></tr>
<tr class="memdesc:aa58e376b7b5873a22bcdb6f8d3a0b42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the zero tolerance that the solver would compute if the user does not specify a tolerance.  <a href="#aa58e376b7b5873a22bcdb6f8d3a0b42c">More...</a><br /></td></tr>
<tr class="separator:aa58e376b7b5873a22bcdb6f8d3a0b42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277134785588d69bb461a4a402877e7a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a277134785588d69bb461a4a402877e7a">is_available</a> ()</td></tr>
<tr class="separator:a277134785588d69bb461a4a402877e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897b26da95cce4dd89d5eb4fbec9b829"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a897b26da95cce4dd89d5eb4fbec9b829">ProgramAttributesSatisfied</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>)</td></tr>
<tr class="separator:a897b26da95cce4dd89d5eb4fbec9b829"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class drake::solvers::MobyLCPSolver&lt; T &gt;</h3>

<p>A class for solving Linear Complementarity Problems (LCPs). </p>
<p>Solving a LCP requires finding a solution to the problem:</p><pre>
Mz + q = w
z ≥ 0
w ≥ 0
zᵀw = 0
</pre><p> (where M ∈ ℝⁿˣⁿ and q ∈ ℝⁿ are problem inputs and z ∈ ℝⁿ and w ∈ ℝⁿ are unknown vectors) or correctly reporting that such a solution does not exist. In spite of their linear structure, solving LCPs is NP-Hard [Cottle 1992]. However, some LCPs are significantly easier to solve. For instance, it can be seen that the LCP is solvable in worst-case polynomial time for the case of symmetric positive-semi-definite M by formulating it as the following convex quadratic program:</p><pre>
minimize:   f(z) = zᵀw = zᵀ(Mz + q)
subject to: z ≥ 0
            Mz + q ≥ 0
</pre><p> Note that this quadratic program's (QP) objective function at the minimum z cannot be less than zero, and the LCP is only solved if the objective function at the minimum is equal to zero. Since the seminal result of Karmarkar, it has been known that convex QPs are solvable in polynomial time [Karmarkar 1984].</p>
<p>The difficulty of solving an LCP is characterized by the properties of its particular matrix, namely the class of matrices it belongs to. Classes include, for example, Q, Q₀, P, P₀, copositive, and Z matrices. [Cottle 1992] and <a href="see pp. 224-230 in the latter">Murty 1998</a> describe relevant matrix classes in more detail.</p>
<ul>
<li>[Cottle 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear Complementarity Problem. Academic Press, 1992.</li>
<li>[Karmarkar 1984] N. Karmarkar. A New Polynomial-Time Algorithm for Linear Programming. Combinatorica, 4(4), pp. 373-395.</li>
<li>[Murty 1988] K. Murty. Linear Complementarity, Linear and Nonlinear Programming. Heldermann Verlag, 1988. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abb7ccd441693e16fa57b4526cad6b3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7ccd441693e16fa57b4526cad6b3e5">&#9670;&nbsp;</a></span>MobyLCPSolver() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f4703ed5696e5c0310d1eeca515e3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4703ed5696e5c0310d1eeca515e3f1">&#9670;&nbsp;</a></span>MobyLCPSolver() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8921d25ba263738dc7d487e3dc0b872e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8921d25ba263738dc7d487e3dc0b872e">&#9670;&nbsp;</a></span>MobyLCPSolver() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb81504651f5281ac80489ed3b23c8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb81504651f5281ac80489ed3b23c8fc">&#9670;&nbsp;</a></span>~MobyLCPSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0a1a542e00b9735c56bb11b57e8f6bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1a542e00b9735c56bb11b57e8f6bdf">&#9670;&nbsp;</a></span>AreProgramAttributesSatisfied()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AreProgramAttributesSatisfied </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the program attributes are satisfied by the solver's capability. </p>

<p>Implements <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html#a7a9200fb686048e552f8b009386963b0">MathematicalProgramSolverInterface</a>.</p>

</div>
</div>
<a id="ac910159108658c34a743b0806d81ab10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac910159108658c34a743b0806d81ab10">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff this solver was enabled at compile-time. </p>

<p>Implements <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html#a1e8fcd942e045810b3847510fd0528fa">MathematicalProgramSolverInterface</a>.</p>

</div>
</div>
<a id="aa58e376b7b5873a22bcdb6f8d3a0b42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58e376b7b5873a22bcdb6f8d3a0b42c">&#9670;&nbsp;</a></span>ComputeZeroTolerance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static U ComputeZeroTolerance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the zero tolerance that the solver would compute if the user does not specify a tolerance. </p>

</div>
</div>
<a id="a9f2f977a2be04239fe82e5257f1970a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2f977a2be04239fe82e5257f1970a8">&#9670;&nbsp;</a></span>get_num_pivots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> get_num_pivots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of pivoting operations made by the last LCP solve. </p>

</div>
</div>
<a id="a277134785588d69bb461a4a402877e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277134785588d69bb461a4a402877e7a">&#9670;&nbsp;</a></span>is_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> is_available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ea743dcac17de35bc2565bf0a178bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea743dcac17de35bc2565bf0a178bdb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1f77847e110cce8b14e9ae35ce949ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f77847e110cce8b14e9ae35ce949ba">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a897b26da95cce4dd89d5eb4fbec9b829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897b26da95cce4dd89d5eb4fbec9b829">&#9670;&nbsp;</a></span>ProgramAttributesSatisfied()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ProgramAttributesSatisfied </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a940b243c1e6bc23203756a73f2c80c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940b243c1e6bc23203756a73f2c80c6b">&#9670;&nbsp;</a></span>reset_num_pivots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reset_num_pivots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the number of pivoting operations made by the last LCP solver to zero. </p>

</div>
</div>
<a id="aac324298c671d9098ebbfacb0fdc3644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac324298c671d9098ebbfacb0fdc3644">&#9670;&nbsp;</a></span>SetLoggingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetLoggingEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6443e6080dac0553904e9ac680ff64f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6443e6080dac0553904e9ac680ff64f8">&#9670;&nbsp;</a></span>Solve() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> Solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets values for the decision variables on the given <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> <code>prog</code>, or: </p>
<ul>
<li>If no solver is available, throws std::runtime_error</li>
<li>If the solver returns an error, returns a nonzero SolutionResult. </li>
</ul>

<p>Implements <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html#abc5c243ac382b9c7c5b1f328da86e3f3">MathematicalProgramSolverInterface</a>.</p>

</div>
</div>
<a id="ab57f0c676cb9cff8b39312706b046fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57f0c676cb9cff8b39312706b046fd7">&#9670;&nbsp;</a></span>Solve() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves an optimization program with optional initial guess and solver options. </p>
<p>Note that these initial guess and solver options are not written to <code>prog</code>. If the <code>prog</code> has set an option for a solver, and <code>solver_options</code> contains a different value for the same option on the same solver, then <code>solver_options</code> takes priority. </p>

<p>Implements <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html#a00a61e9a68e9e5e5889854febb32b051">MathematicalProgramSolverInterface</a>.</p>

</div>
</div>
<a id="aeccfbaa73e7a744f9339d671ac2f3832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccfbaa73e7a744f9339d671ac2f3832">&#9670;&nbsp;</a></span>Solve() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> Solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets values for the decision variables on the given <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> <code>prog</code>, or: </p>
<ul>
<li>If no solver is available, throws std::runtime_error</li>
<li>If the solver returns an error, returns a nonzero SolutionResult. </li>
</ul>

<p>Implements <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html#abc5c243ac382b9c7c5b1f328da86e3f3">MathematicalProgramSolverInterface</a>.</p>

</div>
</div>
<a id="aae822f158c8b0b8bb10bc8e8350431d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae822f158c8b0b8bb10bc8e8350431d8">&#9670;&nbsp;</a></span>Solve() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves an optimization program with optional initial guess and solver options. </p>
<p>Note that these initial guess and solver options are not written to <code>prog</code>. If the <code>prog</code> has set an option for a solver, and <code>solver_options</code> contains a different value for the same option on the same solver, then <code>solver_options</code> takes priority. </p>

<p>Implements <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html#a00a61e9a68e9e5e5889854febb32b051">MathematicalProgramSolverInterface</a>.</p>

</div>
</div>
<a id="a8e270f319dccd9f904773b7bb86cc8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e270f319dccd9f904773b7bb86cc8b9">&#9670;&nbsp;</a></span>SolveLcpFast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SolveLcpFast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>zero_tol</em> = <code>T(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A is positive definite). </p>
<p>Therefore, q is in the range of P and M is positive semi-definite. An LCP of this form is also guaranteed to have a solution [Cottle 1992].</p>
<p>This particular implementation focuses on the case where the solution requires few nonzero nonbasic variables, meaning that few z variables need be nonzero to find a solution to Mz + q = w. This algorithm, which is based off of Dantzig's Principle Pivoting Method I [Cottle 1992] is described in [Drumwright 2015]. This algorithm is able to use "warm" starting- a solution to a "nearby" LCP can be used to find the solution to a given LCP more quickly.</p>
<p>Although this solver is theoretically guaranteed to give a solution to the LCPs described above, accumulated floating point error from pivoting operations could cause the solver to fail. Additionally, the solver can be applied with some success to problems outside of its guaranteed matrix class. For these reasons, the solver returns a flag indicating success/failure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>the LCP matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>the LCP vector. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">z</td><td>the solution to the LCP on return (if the solver succeeds). If the length of z is equal to the length of q, the solver will attempt to use z's value as a starting solution. If the solver fails (returns <code>false</code>), <code>z</code> will be set to the zero vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero_tol</td><td>The tolerance for testing against zero. If the tolerance is negative (default) the solver will determine a generally reasonable tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if M is non-square or M's dimensions do not equal q's dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the solver succeeded and <code>false</code> otherwise.</dd></dl>
<ul>
<li>[Cottle 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear Complementarity Problem. Academic Press, 1992.</li>
<li>[Drumwright 2015] E. Drumwright. Rapidly computable viscous friction and no-slip rigid contact models. arXiv: 1504.00719v1. 2015. </li>
</ul>

</div>
</div>
<a id="ab9869f5947096ab22cdbb57d0c1cb3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9869f5947096ab22cdbb57d0c1cb3ce">&#9670;&nbsp;</a></span>SolveLcpFastRegularized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SolveLcpFastRegularized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>min_exp</em> = <code>-20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>step_exp</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_exp</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>zero_tol</em> = <code>T(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regularized version of the fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A is positive definite). </p>
<p>Therefore, q is in the range of P and M is positive semi-definite. Please see <a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a8e270f319dccd9f904773b7bb86cc8b9" title="Fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ...">SolveLcpFast()</a> for more documentation about the particular algorithm.</p>
<p>This implementation wraps that algorithm with a Tikhonov-type regularization approach. Specifically, this implementation repeatedly attempts to solve the LCP:</p><pre>
(M + Iα)z + q = w
z ≥ 0
w ≥ 0
zᵀw = 0
</pre><p> where I is the identity matrix and α ≪ 1, using geometrically increasing values of α, until the LCP is solved. Cottle et al. describe how, for sufficiently large α, the LCP will always be solvable [Cottle 1992], p. 493.</p>
<p>Although this solver is theoretically guaranteed to give a solution to the LCPs described above, accumulated floating point error from pivoting operations could cause the solver to fail. Additionally, the solver can be applied with some success to problems outside of its guaranteed matrix class. For these reasons, the solver returns a flag indicating success/failure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>the LCP matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>the LCP vector. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">z</td><td>the solution to the LCP on return (if the solver succeeds). If the length of z is equal to the length of q, the solver will attempt to use z's value as a starting solution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_exp</td><td>The minimum exponent for computing α over [10ᵝ, 10ᵞ] in steps of 10ᵟ, where β is the minimum exponent, γ is the maximum exponent, and δ is the stepping exponent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step_exp</td><td>The stepping exponent for computing α over [10ᵝ, 10ᵞ] in steps of 10ᵟ, where β is the minimum exponent, γ is the maximum exponent, and δ is the stepping exponent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_exp</td><td>The maximum exponent for computing α over [10ᵝ, 10ᵞ] in steps of 10ᵟ, where β is the minimum exponent, γ is the maximum exponent, and δ is the stepping exponent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero_tol</td><td>The tolerance for testing against zero. If the tolerance is negative (default) the solver will determine a generally reasonable tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if M is non-square or M's dimensions do not equal q's dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the solver succeeded and <code>false</code> if the solver did not find a solution for α = 10ᵞ. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a8e270f319dccd9f904773b7bb86cc8b9" title="Fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ...">SolveLcpFast()</a></dd></dl>
<ul>
<li>[Cottle, 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear Complementarity Problem. Academic Press, 1992. </li>
</ul>

</div>
</div>
<a id="a8622e1d6cfcb3d7f126fac1064b8999c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8622e1d6cfcb3d7f126fac1064b8999c">&#9670;&nbsp;</a></span>SolveLcpLemke()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SolveLcpLemke </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>piv_tol</em> = <code>T(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>zero_tol</em> = <code>T(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lemke's Algorithm for solving LCPs in the matrix class E, which contains all strictly semimonotone matrices, all P-matrices, and all strictly copositive matrices. </p>
<p>Lemke's Algorithm is described in [Cottle 1992], Section 4.4. This implementation was adapted from the LEMKE Library [LEMKE] for Matlab; this particular implementation fixes a bug in LEMKE that could occur when multiple indices passed the minimum ratio test.</p>
<p>Although this solver is theoretically guaranteed to give a solution to the LCPs described above, accumulated floating point error from pivoting operations could cause the solver to fail. Additionally, the solver can be applied with some success to problems outside of its guaranteed matrix classes. For these reasons, the solver returns a flag indicating success/failure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>the LCP matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>the LCP vector. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">z</td><td>the solution to the LCP on return (if the solver succeeds). If the length of z is equal to the length of q, the solver will attempt to use z's value as a starting solution. <b>This warmstarting is generally not recommended</b>: it has a predisposition to lead to a failing pivoting sequence. If the solver fails (returns <code>false</code>), <code>z</code> will be set to the zero vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero_tol</td><td>The tolerance for testing against zero. If the tolerance is negative (default) the solver will determine a generally reasonable tolerance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">piv_tol</td><td>The tolerance for testing against zero, specifically used for the purpose of finding variables for pivoting. If the tolerance is negative (default) the solver will determine a generally reasonable tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the solver <b>believes</b> it has computed a solution (which it determines by the ability to "pivot out" the "artificial" variable (see [Cottle 1992]) and <code>false</code> otherwise. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The caller should verify that the algorithm has solved the LCP to the desired tolerances on returns indicating success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if M is not square or the dimensions of M do not match the length of q.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>[Cottle 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear Complementarity Problem. Academic Press, 1992.</li>
<li>[LEMKE] P. Fackler and M. Miranda. LEMKE. <a href="http://people.sc.fsu.edu/~burkardt/m_src/lemke/lemke.m">http://people.sc.fsu.edu/~burkardt/m_src/lemke/lemke.m</a> </li>
</ul>

</div>
</div>
<a id="a28d480e61f99325ebbc2ab35dc33c09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d480e61f99325ebbc2ab35dc33c09f">&#9670;&nbsp;</a></span>SolveLcpLemkeRegularized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> SolveLcpLemkeRegularized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>min_exp</em> = <code>-20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>step_exp</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_exp</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>piv_tol</em> = <code>T(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>zero_tol</em> = <code>T(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lemke's Algorithm for solving LCPs in the matrix class E, which contains all strictly semimonotone matrices, all P-matrices, and all strictly copositive matrices. </p>
<p>Lemke's Algorithm is described in [Cottle 1992], Section 4.4.</p>
<p>This implementation wraps that algorithm with a Tikhonov-type regularization approach. Specifically, this implementation repeatedly attempts to solve the LCP:</p><pre>
(M + Iα)z + q = w
z ≥ 0
w ≥ 0
zᵀw = 0
</pre><p> where I is the identity matrix and α ≪ 1, using geometrically increasing values of α, until the LCP is solved. See <a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#ab9869f5947096ab22cdbb57d0c1cb3ce" title="Regularized version of the fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A is positive definite). ">SolveLcpFastRegularized()</a> for description of the regularization process and the function parameters, which are identical. See <a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a8622e1d6cfcb3d7f126fac1064b8999c" title="Lemke&#39;s Algorithm for solving LCPs in the matrix class E, which contains all strictly semimonotone ma...">SolveLcpLemke()</a> for a description of Lemke's Algorithm. See <a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#ab9869f5947096ab22cdbb57d0c1cb3ce" title="Regularized version of the fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A is positive definite). ">SolveLcpFastRegularized()</a> for a description of all calling parameters other than <code>z</code>, which apply equally well to this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">z</td><td>the solution to the LCP on return (if the solver succeeds). If the length of z is equal to the length of q, the solver will attempt to use z's value as a starting solution. <b>This warmstarting is generally not recommended</b>: it has a predisposition to lead to a failing pivoting sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#ab9869f5947096ab22cdbb57d0c1cb3ce" title="Regularized version of the fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A is positive definite). ">SolveLcpFastRegularized()</a> </dd>
<dd>
<a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#a8622e1d6cfcb3d7f126fac1064b8999c" title="Lemke&#39;s Algorithm for solving LCPs in the matrix class E, which contains all strictly semimonotone ma...">SolveLcpLemke()</a></dd></dl>
<ul>
<li>[Cottle 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear Complementarity Problem. Academic Press, 1992. </li>
</ul>

</div>
</div>
<a id="ace3da8c3a4a8bd641915f170d18e6c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3da8c3a4a8bd641915f170d18e6c15">&#9670;&nbsp;</a></span>solver_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> solver_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the identifier of this solver. </p>

<p>Implements <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_solver_interface.html#a97e6e96f4fdf50c424c68b6583f33023">MathematicalProgramSolverInterface</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/solvers/<a class="el" href="moby__lcp__solver_8h.html">moby_lcp_solver.h</a></li>
<li>drake/solvers/<a class="el" href="moby__lcp__solver_8cc.html">moby_lcp_solver.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1solvers.html">solvers</a></li><li class="navelem"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
