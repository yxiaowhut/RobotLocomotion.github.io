<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: WorldSimTreeBuilder&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">WorldSimTreeBuilder&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A helper class to construct robot world <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> objects from model (URDF/SDF) files.  
 <a href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#details">More...</a></p>

<p><code>#include &lt;drake/attic/manipulation/util/world_sim_tree_builder.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4092ad8fe191e4d66279c9aa7bacaf67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a4092ad8fe191e4d66279c9aa7bacaf67">WorldSimTreeBuilder</a> (<a class="el" href="classbool.html">bool</a> compile_tree=true, std::unique_ptr&lt; <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; T &gt;&gt; base_tree=nullptr)</td></tr>
<tr class="memdesc:a4092ad8fe191e4d66279c9aa7bacaf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html" title="A helper class to construct robot world RigidBodyTree objects from model (URDF/SDF) files...">WorldSimTreeBuilder</a> object and specifies whether a call to any of the add model instance functions should compile the tree.  <a href="#a4092ad8fe191e4d66279c9aa7bacaf67">More...</a><br /></td></tr>
<tr class="separator:a4092ad8fe191e4d66279c9aa7bacaf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d39ddb5f3daa4546d9c727bcdab8c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a35d39ddb5f3daa4546d9c727bcdab8c2">~WorldSimTreeBuilder</a> ()</td></tr>
<tr class="separator:a35d39ddb5f3daa4546d9c727bcdab8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c27b1010d3bdb9e205ae969bf75e5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a61c27b1010d3bdb9e205ae969bf75e5e">AddFixedModelInstance</a> (const std::string &amp;model_name, const Eigen::Vector3d &amp;xyz, const Eigen::Vector3d &amp;<a class="el" href="rgbd__camera__publish__lcm__example_8cc.html#adcd24d59c62f70778c30dd0d4466b202">rpy</a>=Eigen::Vector3d::Zero())</td></tr>
<tr class="memdesc:a61c27b1010d3bdb9e205ae969bf75e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a fixed model instance specified by its name, <code>model_name</code>, to the <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code> being built at the pose specified by position <code>xyz</code> and orientation <code>rpy</code>.  <a href="#a61c27b1010d3bdb9e205ae969bf75e5e">More...</a><br /></td></tr>
<tr class="separator:a61c27b1010d3bdb9e205ae969bf75e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2aa0bc4c4049787641c1d128e36bc11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#ae2aa0bc4c4049787641c1d128e36bc11">AddFloatingModelInstance</a> (const std::string &amp;model_name, const Eigen::Vector3d &amp;xyz, const Eigen::Vector3d &amp;<a class="el" href="rgbd__camera__publish__lcm__example_8cc.html#adcd24d59c62f70778c30dd0d4466b202">rpy</a>=Eigen::Vector3d::Zero())</td></tr>
<tr class="memdesc:ae2aa0bc4c4049787641c1d128e36bc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a floating model instance specified by its name, <code>model_name</code>, to the <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code> being built at the pose specified by position <code>xyz</code> and orientation <code>rpy</code>.  <a href="#ae2aa0bc4c4049787641c1d128e36bc11">More...</a><br /></td></tr>
<tr class="separator:ae2aa0bc4c4049787641c1d128e36bc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4a977f6fbe28db479a52012407e0e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a9a4a977f6fbe28db479a52012407e0e6">AddModelInstanceToFrame</a> (const std::string &amp;model_name, std::shared_ptr&lt; <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt;&gt; weld_to_frame, const <a class="el" href="namespacedrake_1_1multibody_1_1joints.html#a50cf3eda4d4ab9469c222364b683710b">drake::multibody::joints::FloatingBaseType</a> floating_base_type=<a class="el" href="namespacedrake_1_1multibody_1_1joints.html#a50cf3eda4d4ab9469c222364b683710baf0cb52fcb65ba1ee2e93ef655d5c7693">drake::multibody::joints::kFixed</a>)</td></tr>
<tr class="memdesc:a9a4a977f6fbe28db479a52012407e0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a model instance specified by its model name, <code>model_name</code>, to the <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code> being built.  <a href="#a9a4a977f6fbe28db479a52012407e0e6">More...</a><br /></td></tr>
<tr class="separator:a9a4a977f6fbe28db479a52012407e0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32dcd794764ac6a4e234e7a25aeaddd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#ad32dcd794764ac6a4e234e7a25aeaddd">AddModelInstanceToFrame</a> (const std::string &amp;model_name, const std::string &amp;weld_to_body_name, <a class="el" href="classint.html">int</a> weld_to_body_model_instance_id, const std::string &amp;frame_name, const Eigen::Isometry3d &amp;X_BF, const <a class="el" href="namespacedrake_1_1multibody_1_1joints.html#a50cf3eda4d4ab9469c222364b683710b">drake::multibody::joints::FloatingBaseType</a> floating_base_type)</td></tr>
<tr class="memdesc:ad32dcd794764ac6a4e234e7a25aeaddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a model instance specified by its model name, <code>model_name</code>, to the <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code> being built.  <a href="#ad32dcd794764ac6a4e234e7a25aeaddd">More...</a><br /></td></tr>
<tr class="separator:ad32dcd794764ac6a4e234e7a25aeaddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a50632c7c233007989c474beff70775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a8a50632c7c233007989c474beff70775">AddGround</a> ()</td></tr>
<tr class="memdesc:a8a50632c7c233007989c474beff70775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a flat terrain to the simulation.  <a href="#a8a50632c7c233007989c474beff70775">More...</a><br /></td></tr>
<tr class="separator:a8a50632c7c233007989c474beff70775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208877aa67e09bb8a92ca2eb2e4b9b6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a208877aa67e09bb8a92ca2eb2e4b9b6d">WorldSimTreeBuilder</a> (const <a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html">WorldSimTreeBuilder</a>&lt; T &gt; &amp;other)=delete</td></tr>
<tr class="separator:a208877aa67e09bb8a92ca2eb2e4b9b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e02f33f1daf23ea4751149f754686f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html">WorldSimTreeBuilder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a0e02f33f1daf23ea4751149f754686f4">operator=</a> (const <a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html">WorldSimTreeBuilder</a>&lt; T &gt; &amp;other)=delete</td></tr>
<tr class="separator:a0e02f33f1daf23ea4751149f754686f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931023e70ecd1ac8a8e1c3eacc6fd48f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a931023e70ecd1ac8a8e1c3eacc6fd48f">StoreModel</a> (const std::string &amp;model_name, const std::string &amp;absolute_model_path)</td></tr>
<tr class="memdesc:a931023e70ecd1ac8a8e1c3eacc6fd48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a model to the internal model database.  <a href="#a931023e70ecd1ac8a8e1c3eacc6fd48f">More...</a><br /></td></tr>
<tr class="separator:a931023e70ecd1ac8a8e1c3eacc6fd48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174ce8ada1af4c75e8921bde5119a19d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a174ce8ada1af4c75e8921bde5119a19d">StoreDrakeModel</a> (const std::string &amp;model_name, const std::string &amp;model_path)</td></tr>
<tr class="memdesc:a174ce8ada1af4c75e8921bde5119a19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like StoreModel, but uses FindResourceOrThrow to search inside the drake resource search path.  <a href="#a174ce8ada1af4c75e8921bde5119a19d">More...</a><br /></td></tr>
<tr class="separator:a174ce8ada1af4c75e8921bde5119a19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fc2fde4eadd1b5d4dd113a80ad42a9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a80fc2fde4eadd1b5d4dd113a80ad42a9">Build</a> (void)</td></tr>
<tr class="memdesc:a80fc2fde4eadd1b5d4dd113a80ad42a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a unique pointer to the <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code> that was built.  <a href="#a80fc2fde4eadd1b5d4dd113a80ad42a9">More...</a><br /></td></tr>
<tr class="separator:a80fc2fde4eadd1b5d4dd113a80ad42a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9a1cc0c142ee80577229c31da22fbf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#abf9a1cc0c142ee80577229c31da22fbf">tree</a> () const</td></tr>
<tr class="memdesc:abf9a1cc0c142ee80577229c31da22fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (not yet built) tree.  <a href="#abf9a1cc0c142ee80577229c31da22fbf">More...</a><br /></td></tr>
<tr class="separator:abf9a1cc0c142ee80577229c31da22fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758272619eeadeed3fdb1248ec791a97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a758272619eeadeed3fdb1248ec791a97">mutable_tree</a> ()</td></tr>
<tr class="memdesc:a758272619eeadeed3fdb1248ec791a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the (not yet built) mutable tree.  <a href="#a758272619eeadeed3fdb1248ec791a97">More...</a><br /></td></tr>
<tr class="separator:a758272619eeadeed3fdb1248ec791a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcff848a2ba4c48cbb10fbb435015c58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1manipulation_1_1util_1_1_model_instance_info.html">ModelInstanceInfo</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#adcff848a2ba4c48cbb10fbb435015c58">get_model_info_for_instance</a> (<a class="el" href="classint.html">int</a> <a class="el" href="multilane_2loader_8cc.html#afd0d68c6d31ff249f3ae8662162663c3">id</a>)</td></tr>
<tr class="separator:adcff848a2ba4c48cbb10fbb435015c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394c39a34e5bfe5e5b90c9d8eda3e004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1systems_1_1_compliant_contact_model_parameters.html">systems::CompliantContactModelParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a394c39a34e5bfe5e5b90c9d8eda3e004">contact_model_parameters</a> () const</td></tr>
<tr class="memdesc:a394c39a34e5bfe5e5b90c9d8eda3e004"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compliant contact model parameters to use with the default material parameters; these values should be passed to the plant.  <a href="#a394c39a34e5bfe5e5b90c9d8eda3e004">More...</a><br /></td></tr>
<tr class="separator:a394c39a34e5bfe5e5b90c9d8eda3e004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879e9de27c32f287c9a9479b6ab14061"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_compliant_material.html">systems::CompliantMaterial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a879e9de27c32f287c9a9479b6ab14061">default_contact_material</a> () const</td></tr>
<tr class="separator:a879e9de27c32f287c9a9479b6ab14061"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::manipulation::util::WorldSimTreeBuilder&lt; T &gt;</h3>

<p>A helper class to construct robot world <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> objects from model (URDF/SDF) files. </p>
<p>Models (e.g., robots, objects for manipulation, etc.) can be stored and added to the tree to be built.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> ScalarType.</td></tr>
  </table>
  </dd>
</dl>
<p>Instantiated templates for the following ScalarTypes are provided:</p>
<ul>
<li>double </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4092ad8fe191e4d66279c9aa7bacaf67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4092ad8fe191e4d66279c9aa7bacaf67">&#9670;&nbsp;</a></span>WorldSimTreeBuilder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html">WorldSimTreeBuilder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>compile_tree</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>base_tree</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html" title="A helper class to construct robot world RigidBodyTree objects from model (URDF/SDF) files...">WorldSimTreeBuilder</a> object and specifies whether a call to any of the add model instance functions should compile the tree. </p>
<p>Setting <code>compile_tree</code> to false will cause the parser to bypass tree compilation such that modifications to the recently parsed tree can be made at run time (e.g., accessing/modifying collision filters declared in the corresponding urdf/sdf file). The user is responsible for calling compile() on the tree. Take the following snippet as an example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tree_builder = std::make_unique&lt;WorldSimTreeBuilder&lt;double&gt;&gt;(<span class="keyword">false</span>);</div><div class="line">tree_builder-&gt;StoreDrakeModel(<span class="stringliteral">&quot;mymodel&quot;</span>, kModelUrdf);</div><div class="line">tree_builder-&gt;AddFixedModelInstance(<span class="stringliteral">&quot;mymodel&quot;</span>, Eigen::Vector3d::Zero());</div><div class="line"><span class="keyword">auto</span> mtree = tree_builder-&gt;mutable_tree();</div><div class="line"><span class="comment">//  modify the tree here</span></div><div class="line">mtree-&gt;compile();</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compile_tree</td><td>Specifies whether the tree should be automatically compiled. Defaults to true. </td></tr>
    <tr><td class="paramname">base_tree</td><td>If not null, new models will be added to this tree instead of to an empty tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35d39ddb5f3daa4546d9c727bcdab8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d39ddb5f3daa4546d9c727bcdab8c2">&#9670;&nbsp;</a></span>~WorldSimTreeBuilder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html">WorldSimTreeBuilder</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a208877aa67e09bb8a92ca2eb2e4b9b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208877aa67e09bb8a92ca2eb2e4b9b6d">&#9670;&nbsp;</a></span>WorldSimTreeBuilder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html">WorldSimTreeBuilder</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html">WorldSimTreeBuilder</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a61c27b1010d3bdb9e205ae969bf75e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c27b1010d3bdb9e205ae969bf75e5e">&#9670;&nbsp;</a></span>AddFixedModelInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> AddFixedModelInstance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>rpy</em> = <code>Eigen::Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a fixed model instance specified by its name, <code>model_name</code>, to the <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code> being built at the pose specified by position <code>xyz</code> and orientation <code>rpy</code>. </p>
<p>The model name must have been previously loaded via a call to <a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a931023e70ecd1ac8a8e1c3eacc6fd48f" title="Adds a model to the internal model database. ">StoreModel()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>model_instance_id of the object that is added. </dd></dl>

</div>
</div>
<a id="ae2aa0bc4c4049787641c1d128e36bc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2aa0bc4c4049787641c1d128e36bc11">&#9670;&nbsp;</a></span>AddFloatingModelInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> AddFloatingModelInstance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>rpy</em> = <code>Eigen::Vector3d::Zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a floating model instance specified by its name, <code>model_name</code>, to the <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code> being built at the pose specified by position <code>xyz</code> and orientation <code>rpy</code>. </p>
<p>The model name must have been previously loaded via a call to <a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a931023e70ecd1ac8a8e1c3eacc6fd48f" title="Adds a model to the internal model database. ">StoreModel()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>model_instance_id of the object that is added. </dd></dl>

</div>
</div>
<a id="a8a50632c7c233007989c474beff70775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a50632c7c233007989c474beff70775">&#9670;&nbsp;</a></span>AddGround()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddGround </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a flat terrain to the simulation. </p>

</div>
</div>
<a id="a9a4a977f6fbe28db479a52012407e0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4a977f6fbe28db479a52012407e0e6">&#9670;&nbsp;</a></span>AddModelInstanceToFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> AddModelInstanceToFrame </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>weld_to_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1multibody_1_1joints.html#a50cf3eda4d4ab9469c222364b683710b">drake::multibody::joints::FloatingBaseType</a>&#160;</td>
          <td class="paramname"><em>floating_base_type</em> = <code><a class="el" href="namespacedrake_1_1multibody_1_1joints.html#a50cf3eda4d4ab9469c222364b683710baf0cb52fcb65ba1ee2e93ef655d5c7693">drake::multibody::joints::kFixed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a model instance specified by its model name, <code>model_name</code>, to the <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code> being built. </p>
<p>The model instance is connected to the existing world based on a <code>weld_to_frame</code> using a joint of type <code>floating_base_type</code>. The model name must have been previously loaded via a call to <a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a931023e70ecd1ac8a8e1c3eacc6fd48f" title="Adds a model to the internal model database. ">StoreModel()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>model_instance_id of the object that is added. </dd></dl>

</div>
</div>
<a id="ad32dcd794764ac6a4e234e7a25aeaddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32dcd794764ac6a4e234e7a25aeaddd">&#9670;&nbsp;</a></span>AddModelInstanceToFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> AddModelInstanceToFrame </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>weld_to_body_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>weld_to_body_model_instance_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frame_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Isometry3d &amp;&#160;</td>
          <td class="paramname"><em>X_BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1multibody_1_1joints.html#a50cf3eda4d4ab9469c222364b683710b">drake::multibody::joints::FloatingBaseType</a>&#160;</td>
          <td class="paramname"><em>floating_base_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a model instance specified by its model name, <code>model_name</code>, to the <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code> being built. </p>
<p>The model instance is welded to a new frame <code>F</code> constructed within this function. This new frame <code>F</code> is fixed on a body of name <code>weld_to_body_name</code>, with a transformation to this body as <code>X_BF</code>, where <code>B</code> is the body frame. The new frame is named <code>frame_name</code>. The model instance is connected to the body using a joint of type <code>floating_base_type</code>. The model name must have been previously loaded via a call to <a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a931023e70ecd1ac8a8e1c3eacc6fd48f" title="Adds a model to the internal model database. ">StoreModel()</a>. The function will search for the body with name <code>weld_to_body_name</code>, on the model with ID <code>weld_to_body_model_instance_id</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model_name</td><td>The model with this name will be added to the tree. </td></tr>
    <tr><td class="paramname">weld_to_body_name</td><td>The added model will be welded to a body with this name. </td></tr>
    <tr><td class="paramname">weld_to_body_model_instance_id</td><td>The added model will be welded to a body with this model instance ID. </td></tr>
    <tr><td class="paramname">frame_name</td><td>The name of the newly added frame. </td></tr>
    <tr><td class="paramname">X_BF</td><td>The pose of the newly added frame <code>F</code> in the added body frame <code>B</code>. </td></tr>
    <tr><td class="paramname">floating_base_type</td><td>The type of the joint to weld the added model to the frame <code>F</code> on the body <code>B</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>model_instance_id of the object that is added. </dd></dl>

</div>
</div>
<a id="a80fc2fde4eadd1b5d4dd113a80ad42a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fc2fde4eadd1b5d4dd113a80ad42a9">&#9670;&nbsp;</a></span>Build()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt;T&gt; &gt; Build </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a unique pointer to the <code><a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a></code> that was built. </p>
<p>This method can only be called if it was not previously called. Ownership of the manufactured <a class="el" href="class_rigid_body_tree.html" title="Maintains a vector of RigidBody objects that are arranged into a kinematic tree via DrakeJoint object...">RigidBodyTree</a> is transferred to the calling code. The instance of this class should be discarded after this method is called. </p>

</div>
</div>
<a id="a394c39a34e5bfe5e5b90c9d8eda3e004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394c39a34e5bfe5e5b90c9d8eda3e004">&#9670;&nbsp;</a></span>contact_model_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1systems_1_1_compliant_contact_model_parameters.html">systems::CompliantContactModelParameters</a> contact_model_parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The compliant contact model parameters to use with the default material parameters; these values should be passed to the plant. </p>

</div>
</div>
<a id="a879e9de27c32f287c9a9479b6ab14061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879e9de27c32f287c9a9479b6ab14061">&#9670;&nbsp;</a></span>default_contact_material()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_compliant_material.html">systems::CompliantMaterial</a> default_contact_material </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adcff848a2ba4c48cbb10fbb435015c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcff848a2ba4c48cbb10fbb435015c58">&#9670;&nbsp;</a></span>get_model_info_for_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1manipulation_1_1util_1_1_model_instance_info.html">ModelInstanceInfo</a>&lt;T&gt; get_model_info_for_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a758272619eeadeed3fdb1248ec791a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758272619eeadeed3fdb1248ec791a97">&#9670;&nbsp;</a></span>mutable_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt;T&gt;* mutable_tree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the (not yet built) mutable tree. </p>
<p>This is useful when one needs to programmatically modify a recently parsed, uncompiled tree (e.g., accessing/modifying collision filters declared in the corresponding urdf/sdf file). </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a80fc2fde4eadd1b5d4dd113a80ad42a9" title="Gets a unique pointer to the RigidBodyTree that was built. ">Build()</a> must not have been called yet. </dd></dl>

</div>
</div>
<a id="a0e02f33f1daf23ea4751149f754686f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e02f33f1daf23ea4751149f754686f4">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html">WorldSimTreeBuilder</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html">WorldSimTreeBuilder</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a174ce8ada1af4c75e8921bde5119a19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174ce8ada1af4c75e8921bde5119a19d">&#9670;&nbsp;</a></span>StoreDrakeModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StoreDrakeModel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like StoreModel, but uses FindResourceOrThrow to search inside the drake resource search path. </p>

</div>
</div>
<a id="a931023e70ecd1ac8a8e1c3eacc6fd48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931023e70ecd1ac8a8e1c3eacc6fd48f">&#9670;&nbsp;</a></span>StoreModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StoreModel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>model_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>absolute_model_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a model to the internal model database. </p>
<p>Models are described by <code>model_name</code> coupled with URDF/SDF paths in <code>absolute_model_path</code>. Instances of these models can then be added to the world via the various <code>AddFoo()</code> methods provided by this class. Note that <code>model_name</code> is user-selectable but must be unique among all of the models that are stored.</p>
<dl class="section see"><dt>See also</dt><dd>AddObjectToFrame </dd>
<dd>
AddFloatingObject </dd>
<dd>
AddFixedObject </dd></dl>

</div>
</div>
<a id="abf9a1cc0c142ee80577229c31da22fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9a1cc0c142ee80577229c31da22fbf">&#9670;&nbsp;</a></span>tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_rigid_body_tree.html">RigidBodyTree</a>&lt;T&gt;&amp; tree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the (not yet built) tree. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html#a80fc2fde4eadd1b5d4dd113a80ad42a9" title="Gets a unique pointer to the RigidBodyTree that was built. ">Build()</a> must not have been called yet. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/attic/manipulation/util/<a class="el" href="world__sim__tree__builder_8h.html">world_sim_tree_builder.h</a></li>
<li>drake/attic/manipulation/util/<a class="el" href="world__sim__tree__builder_8cc.html">world_sim_tree_builder.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1manipulation.html">manipulation</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1manipulation_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classdrake_1_1manipulation_1_1util_1_1_world_sim_tree_builder.html">WorldSimTreeBuilder</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
