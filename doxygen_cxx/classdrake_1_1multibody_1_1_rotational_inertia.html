<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: RotationalInertia&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_rotational_inertia.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1_rotational_inertia-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RotationalInertia&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class helps describe the mass distribution (inertia properties) of a body or composite body about a particular point.  
 <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#details">More...</a></p>

<p><code>#include &lt;drake/multibody/multibody_tree/rotational_inertia.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3ffc4a4e197a2a2155641d75c2a7c49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab3ffc4a4e197a2a2155641d75c2a7c49">RotationalInertia</a> ()</td></tr>
<tr class="memdesc:ab3ffc4a4e197a2a2155641d75c2a7c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rotational inertia that has all its moments/products of inertia equal to NaN (helps quickly detect uninitialized values).  <a href="#ab3ffc4a4e197a2a2155641d75c2a7c49">More...</a><br /></td></tr>
<tr class="separator:ab3ffc4a4e197a2a2155641d75c2a7c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36dbdaa401764e4df48b07d3b6ad7d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#af36dbdaa401764e4df48b07d3b6ad7d4">RotationalInertia</a> (const T &amp;Ixx, const T &amp;Iyy, const T &amp;Izz)</td></tr>
<tr class="memdesc:af36dbdaa401764e4df48b07d3b6ad7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rotational inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with each product of inertia set to zero.  <a href="#af36dbdaa401764e4df48b07d3b6ad7d4">More...</a><br /></td></tr>
<tr class="separator:af36dbdaa401764e4df48b07d3b6ad7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319d6a0feeb306267605332cdd1906d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a319d6a0feeb306267605332cdd1906d6">RotationalInertia</a> (const T &amp;Ixx, const T &amp;Iyy, const T &amp;Izz, const T &amp;Ixy, const T &amp;Ixz, const T &amp;Iyz)</td></tr>
<tr class="memdesc:a319d6a0feeb306267605332cdd1906d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rotational inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with products of inertia <code>Ixy</code>, <code>Ixz</code>, <code>Iyz</code>.  <a href="#a319d6a0feeb306267605332cdd1906d6">More...</a><br /></td></tr>
<tr class="separator:a319d6a0feeb306267605332cdd1906d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ee8d395f9f46a1086071be0faa8e37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a73ee8d395f9f46a1086071be0faa8e37">RotationalInertia</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PQ_E)</td></tr>
<tr class="memdesc:a73ee8d395f9f46a1086071be0faa8e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rotational inertia for a particle Q of mass <code>mass</code>, whose position vector from about-point P is p_PQ_E (E is expressed-in frame).  <a href="#a73ee8d395f9f46a1086071be0faa8e37">More...</a><br /></td></tr>
<tr class="separator:a73ee8d395f9f46a1086071be0faa8e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad107abcacb84cbabb41b87ba81360f91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ad107abcacb84cbabb41b87ba81360f91">rows</a> () const</td></tr>
<tr class="memdesc:ad107abcacb84cbabb41b87ba81360f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">For consistency with <a class="el" href="namespace_eigen.html">Eigen</a>'s API, the <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ad107abcacb84cbabb41b87ba81360f91" title="For consistency with Eigen&#39;s API, the rows() method returns 3. ">rows()</a> method returns 3.  <a href="#ad107abcacb84cbabb41b87ba81360f91">More...</a><br /></td></tr>
<tr class="separator:ad107abcacb84cbabb41b87ba81360f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8509d6f7951179378f848f5f4cc37720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a8509d6f7951179378f848f5f4cc37720">cols</a> () const</td></tr>
<tr class="memdesc:a8509d6f7951179378f848f5f4cc37720"><td class="mdescLeft">&#160;</td><td class="mdescRight">For consistency with <a class="el" href="namespace_eigen.html">Eigen</a>'s API, the <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a8509d6f7951179378f848f5f4cc37720" title="For consistency with Eigen&#39;s API, the cols() method returns 3. ">cols()</a> method returns 3.  <a href="#a8509d6f7951179378f848f5f4cc37720">More...</a><br /></td></tr>
<tr class="separator:a8509d6f7951179378f848f5f4cc37720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63faf9877a005bf08269b508f2d17b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a63faf9877a005bf08269b508f2d17b42">get_moments</a> () const</td></tr>
<tr class="memdesc:a63faf9877a005bf08269b508f2d17b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz].  <a href="#a63faf9877a005bf08269b508f2d17b42">More...</a><br /></td></tr>
<tr class="separator:a63faf9877a005bf08269b508f2d17b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73703796210df51bb25acbb19168913a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a73703796210df51bb25acbb19168913a">get_products</a> () const</td></tr>
<tr class="memdesc:a73703796210df51bb25acbb19168913a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz].  <a href="#a73703796210df51bb25acbb19168913a">More...</a><br /></td></tr>
<tr class="separator:a73703796210df51bb25acbb19168913a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23798f37ae600d4d79b8a2e71586c4c7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a23798f37ae600d4d79b8a2e71586c4c7">Trace</a> () const</td></tr>
<tr class="memdesc:a23798f37ae600d4d79b8a2e71586c4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a rotational inertia's trace (i.e., Ixx + Iyy + Izz, the sum of the diagonal elements of the inertia matrix).  <a href="#a23798f37ae600d4d79b8a2e71586c4c7">More...</a><br /></td></tr>
<tr class="separator:a23798f37ae600d4d79b8a2e71586c4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3751c9eaa974909523b6d8d3fd0833a8"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a3751c9eaa974909523b6d8d3fd0833a8">CalcMaximumPossibleMomentOfInertia</a> () const</td></tr>
<tr class="memdesc:a3751c9eaa974909523b6d8d3fd0833a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible moment of inertia for <code>this</code> rotational inertia about-point P for any expressed-in frame E.  <a href="#a3751c9eaa974909523b6d8d3fd0833a8">More...</a><br /></td></tr>
<tr class="separator:a3751c9eaa974909523b6d8d3fd0833a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae48d85764cacfd54fc3001250b4eac"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#afae48d85764cacfd54fc3001250b4eac">operator()</a> (<a class="el" href="classint.html">int</a> <a class="el" href="geometry__properties__test_8cc.html#acb559820d9ca11295b4500f179ef6392">i</a>, <a class="el" href="classint.html">int</a> j) const</td></tr>
<tr class="memdesc:afae48d85764cacfd54fc3001250b4eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const access to the <code>(i, j)</code> element of this rotational inertia.  <a href="#afae48d85764cacfd54fc3001250b4eac">More...</a><br /></td></tr>
<tr class="separator:afae48d85764cacfd54fc3001250b4eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38985b256018ac664935ee8423bbe8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#af38985b256018ac664935ee8423bbe8b">CopyToFullMatrix3</a> () const</td></tr>
<tr class="memdesc:af38985b256018ac664935ee8423bbe8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a full 3x3 matrix copy of this rotational inertia.  <a href="#af38985b256018ac664935ee8423bbe8b">More...</a><br /></td></tr>
<tr class="separator:af38985b256018ac664935ee8423bbe8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0546b3ac658fccec61a5156a926765dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a0546b3ac658fccec61a5156a926765dd">IsNearlyEqualTo</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;other, <a class="el" href="classdouble.html">double</a> precision) const</td></tr>
<tr class="memdesc:a0546b3ac658fccec61a5156a926765dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <code>this</code> rotational inertia to <code>other</code> rotional inertia within the specified <code>precision</code> (which is a dimensionless number specifying the relative precision to which the comparison is performed).  <a href="#a0546b3ac658fccec61a5156a926765dd">More...</a><br /></td></tr>
<tr class="separator:a0546b3ac658fccec61a5156a926765dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d65a4cd4dd6105398ee79ad825035f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a22d65a4cd4dd6105398ee79ad825035f">operator+=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:a22d65a4cd4dd6105398ee79ad825035f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotational inertia <code>I_BP_E</code> to <code>this</code> rotational inertia.  <a href="#a22d65a4cd4dd6105398ee79ad825035f">More...</a><br /></td></tr>
<tr class="separator:a22d65a4cd4dd6105398ee79ad825035f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b4714f1ad30911025024f1eda4d72e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab3b4714f1ad30911025024f1eda4d72e">operator+</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E) const</td></tr>
<tr class="memdesc:ab3b4714f1ad30911025024f1eda4d72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotational inertia <code>I_BP_E</code> to <code>this</code> rotational inertia.  <a href="#ab3b4714f1ad30911025024f1eda4d72e">More...</a><br /></td></tr>
<tr class="separator:ab3b4714f1ad30911025024f1eda4d72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9616b9b963139066953c80ac978c362a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a9616b9b963139066953c80ac978c362a">operator-=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:a9616b9b963139066953c80ac978c362a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia.  <a href="#a9616b9b963139066953c80ac978c362a">More...</a><br /></td></tr>
<tr class="separator:a9616b9b963139066953c80ac978c362a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff3c0d26ee10bb5d824ee6d3498eb4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#aaff3c0d26ee10bb5d824ee6d3498eb4d">operator-</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E) const</td></tr>
<tr class="memdesc:aaff3c0d26ee10bb5d824ee6d3498eb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia.  <a href="#aaff3c0d26ee10bb5d824ee6d3498eb4d">More...</a><br /></td></tr>
<tr class="separator:aaff3c0d26ee10bb5d824ee6d3498eb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65b0fb94c4a5a8b580c8db31e7ce659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab65b0fb94c4a5a8b580c8db31e7ce659">operator*=</a> (const T &amp;nonnegative_scalar)</td></tr>
<tr class="memdesc:ab65b0fb94c4a5a8b580c8db31e7ce659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> rotational inertia by a nonnegative scalar (&gt;= 0).  <a href="#ab65b0fb94c4a5a8b580c8db31e7ce659">More...</a><br /></td></tr>
<tr class="separator:ab65b0fb94c4a5a8b580c8db31e7ce659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cbefdc664161fc4775ab5d719e67bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a19cbefdc664161fc4775ab5d719e67bf">operator*</a> (const T &amp;nonnegative_scalar) const</td></tr>
<tr class="memdesc:a19cbefdc664161fc4775ab5d719e67bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> rotational inertia by a nonnegative scalar (&gt;= 0).  <a href="#a19cbefdc664161fc4775ab5d719e67bf">More...</a><br /></td></tr>
<tr class="separator:a19cbefdc664161fc4775ab5d719e67bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad317217e02206a32e8a46b11f206bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#aad317217e02206a32e8a46b11f206bbe">operator*</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;w_E) const</td></tr>
<tr class="memdesc:aad317217e02206a32e8a46b11f206bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> rotational inertia about-point P, expressed-in frame E by the vector w_E (which <em>must</em> also have the same expressed-in frame E).  <a href="#aad317217e02206a32e8a46b11f206bbe">More...</a><br /></td></tr>
<tr class="separator:aad317217e02206a32e8a46b11f206bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb6014636db3579a84defd7824ee4c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a3cb6014636db3579a84defd7824ee4c1">operator/=</a> (const T &amp;positive_scalar)</td></tr>
<tr class="memdesc:a3cb6014636db3579a84defd7824ee4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides <code>this</code> rotational inertia by a positive scalar (&gt; 0).  <a href="#a3cb6014636db3579a84defd7824ee4c1">More...</a><br /></td></tr>
<tr class="separator:a3cb6014636db3579a84defd7824ee4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0d8c42739dc16a87225c2b0057517b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a7a0d8c42739dc16a87225c2b0057517b">operator/</a> (const T &amp;positive_scalar) const</td></tr>
<tr class="memdesc:a7a0d8c42739dc16a87225c2b0057517b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides <code>this</code> rotational inertia by a positive scalar(&gt; 0).  <a href="#a7a0d8c42739dc16a87225c2b0057517b">More...</a><br /></td></tr>
<tr class="separator:a7a0d8c42739dc16a87225c2b0057517b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae461fd75b1b4eba6c95a57621adb4e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ae461fd75b1b4eba6c95a57621adb4e9d">SetToNaN</a> ()</td></tr>
<tr class="memdesc:ae461fd75b1b4eba6c95a57621adb4e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> rotational inertia so all its elements are equal to NaN.  <a href="#ae461fd75b1b4eba6c95a57621adb4e9d">More...</a><br /></td></tr>
<tr class="separator:ae461fd75b1b4eba6c95a57621adb4e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57e5aca5db002545e4b9335c8d9dbfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ae57e5aca5db002545e4b9335c8d9dbfa">SetZero</a> ()</td></tr>
<tr class="memdesc:ae57e5aca5db002545e4b9335c8d9dbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> rotational inertia so all its moments/products of inertia are zero, e.g., for convenient initialization before a computation or for inertia calculations involving a particle (point-mass).  <a href="#ae57e5aca5db002545e4b9335c8d9dbfa">More...</a><br /></td></tr>
<tr class="separator:ae57e5aca5db002545e4b9335c8d9dbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a73339c4b21bba9c3fa975f7a6c4220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a1a73339c4b21bba9c3fa975f7a6c4220">IsNaN</a> () const</td></tr>
<tr class="memdesc:a1a73339c4b21bba9c3fa975f7a6c4220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any moment/product in <code>this</code> rotational inertia is NaN.  <a href="#a1a73339c4b21bba9c3fa975f7a6c4220">More...</a><br /></td></tr>
<tr class="separator:a1a73339c4b21bba9c3fa975f7a6c4220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1e01c37486db2e78263fb70eaff550"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:afa1e01c37486db2e78263fb70eaff550"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#afa1e01c37486db2e78263fb70eaff550">cast</a> () const</td></tr>
<tr class="memdesc:afa1e01c37486db2e78263fb70eaff550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new RotationalInertia object templated on <code>Scalar</code> initialized from the values of <code>this</code> rotational inertia's entries.  <a href="#afa1e01c37486db2e78263fb70eaff550">More...</a><br /></td></tr>
<tr class="separator:afa1e01c37486db2e78263fb70eaff550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b63ae12f2b1cc131b2584efe07a2b6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a6b63ae12f2b1cc131b2584efe07a2b6b">CalcPrincipalMomentsOfInertia</a> () const</td></tr>
<tr class="memdesc:a6b63ae12f2b1cc131b2584efe07a2b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method takes <code>this</code> rotational inertia about-point P, expressed-in- frame E, and computes its principal moments of inertia about-point P, but expressed-in a frame aligned with the principal axes.  <a href="#a6b63ae12f2b1cc131b2584efe07a2b6b">More...</a><br /></td></tr>
<tr class="separator:a6b63ae12f2b1cc131b2584efe07a2b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e71eb4bd2a7648a411e1cbaf94812b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b">CouldBePhysicallyValid</a> () const</td></tr>
<tr class="memdesc:a03e71eb4bd2a7648a411e1cbaf94812b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs several necessary checks to verify whether <code>this</code> rotational inertia <em>could</em> be physically valid, including:  <a href="#a03e71eb4bd2a7648a411e1cbaf94812b">More...</a><br /></td></tr>
<tr class="separator:a03e71eb4bd2a7648a411e1cbaf94812b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18d9151885c8c0ab91a24db506d4270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab18d9151885c8c0ab91a24db506d4270">ReExpressInPlace</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_AE)</td></tr>
<tr class="memdesc:ab18d9151885c8c0ab91a24db506d4270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-expresses <code>this</code> rotational inertia <code>I_BP_E</code> to <code>I_BP_A</code>.  <a href="#ab18d9151885c8c0ab91a24db506d4270">More...</a><br /></td></tr>
<tr class="separator:ab18d9151885c8c0ab91a24db506d4270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c03fdc2e8311a8d71c14ef89e64260c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a8c03fdc2e8311a8d71c14ef89e64260c">DRAKE_DEPRECATED</a> (&quot;Use <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab18d9151885c8c0ab91a24db506d4270">ReExpressInPlace</a>(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February 5, 2019.&quot;) RotationalInertia&lt; T &gt; &amp;<a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab18d9151885c8c0ab91a24db506d4270">ReExpressInPlace</a>(const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R_AE)</td></tr>
<tr class="separator:a8c03fdc2e8311a8d71c14ef89e64260c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eb5284c5ec57a645aee167798a1f2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a08eb5284c5ec57a645aee167798a1f2c">ReExpress</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_AE) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:a08eb5284c5ec57a645aee167798a1f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-expresses <code>this</code> rotational inertia <code>I_BP_E</code> to <code>I_BP_A</code> i.e., re-expresses body B's rotational inertia from frame E to frame A.  <a href="#a08eb5284c5ec57a645aee167798a1f2c">More...</a><br /></td></tr>
<tr class="separator:a08eb5284c5ec57a645aee167798a1f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93df06a03ac0135b2a06e56be3144273"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a93df06a03ac0135b2a06e56be3144273">DRAKE_DEPRECATED</a> (&quot;Use <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a08eb5284c5ec57a645aee167798a1f2c">RotationalInertia::ReExpress</a>(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February 5, 2019.&quot;) RotationalInertia&lt; T &gt; <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a08eb5284c5ec57a645aee167798a1f2c">ReExpress</a>(const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R_AE) const __attribute__((warn_unused_result))</td></tr>
<tr class="separator:a93df06a03ac0135b2a06e56be3144273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a719e23ae8c26b0c8cf0c7f30dd112559"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a719e23ae8c26b0c8cf0c7f30dd112559">RotationalInertia</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;)=default</td></tr>
<tr class="separator:a719e23ae8c26b0c8cf0c7f30dd112559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78d207e550d7d227b7e7f37557fb66a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab78d207e550d7d227b7e7f37557fb66a">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;)=default</td></tr>
<tr class="separator:ab78d207e550d7d227b7e7f37557fb66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e215bccd4ce720b787f8b5195a7551"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a87e215bccd4ce720b787f8b5195a7551">RotationalInertia</a> (<a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a87e215bccd4ce720b787f8b5195a7551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25060922d76f06276ac5f169e748ebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ac25060922d76f06276ac5f169e748ebd">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ac25060922d76f06276ac5f169e748ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shift methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Each shift method shifts a body's rotational inertia from one about-point to another about-point.</p>
<p>The expressed-in frame is unchanged.</p>
<table class="doxtable">
<tr>
<th>In-place methods (<code>this</code> changes) </th><th>Const methods  </th></tr>
<tr>
<td>ShiftFromCenterOfMassInPlace </td><td>ShiftFromCenterOfMass </td></tr>
<tr>
<td>ShiftToCenterOfMassInPlace </td><td>ShiftToCenterOfMass </td></tr>
<tr>
<td>ShiftToThenAwayFromCenterOfMassInPlace </td><td>ShiftToThenAwayFromCenterOfMass </td></tr>
</table>
</div></td></tr>
<tr class="memitem:a233d049441510e6de4347afa89eff0e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a233d049441510e6de4347afa89eff0e0">ShiftFromCenterOfMassInPlace</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_BcmQ_E)</td></tr>
<tr class="memdesc:a233d049441510e6de4347afa89eff0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q.  <a href="#a233d049441510e6de4347afa89eff0e0">More...</a><br /></td></tr>
<tr class="separator:a233d049441510e6de4347afa89eff0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6d68bf65261dba0c10a00174fed83c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a5a6d68bf65261dba0c10a00174fed83c">ShiftFromCenterOfMass</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_BcmQ_E) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:a5a6d68bf65261dba0c10a00174fed83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q.  <a href="#a5a6d68bf65261dba0c10a00174fed83c">More...</a><br /></td></tr>
<tr class="separator:a5a6d68bf65261dba0c10a00174fed83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a43d32c412efc0f5e1b6ccc1b1cc17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a82a43d32c412efc0f5e1b6ccc1b1cc17">ShiftToCenterOfMassInPlace</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E)</td></tr>
<tr class="memdesc:a82a43d32c412efc0f5e1b6ccc1b1cc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point Q to about-point <code>Bcm</code> (B's center of mass).  <a href="#a82a43d32c412efc0f5e1b6ccc1b1cc17">More...</a><br /></td></tr>
<tr class="separator:a82a43d32c412efc0f5e1b6ccc1b1cc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef27cf48918c4ca310e1e5d67de50f7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#aef27cf48918c4ca310e1e5d67de50f7a">ShiftToCenterOfMass</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:aef27cf48918c4ca310e1e5d67de50f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point Q to about-point <code>Bcm</code> (B's center of mass).  <a href="#aef27cf48918c4ca310e1e5d67de50f7a">More...</a><br /></td></tr>
<tr class="separator:aef27cf48918c4ca310e1e5d67de50f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631d7db4d8c28e6108d78b8309dabc2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a631d7db4d8c28e6108d78b8309dabc2b">ShiftToThenAwayFromCenterOfMassInPlace</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PBcm_E, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E)</td></tr>
<tr class="memdesc:a631d7db4d8c28e6108d78b8309dabc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass).  <a href="#a631d7db4d8c28e6108d78b8309dabc2b">More...</a><br /></td></tr>
<tr class="separator:a631d7db4d8c28e6108d78b8309dabc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa36a24a9c8fa583631e45d1ad366ce3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#afa36a24a9c8fa583631e45d1ad366ce3">ShiftToThenAwayFromCenterOfMass</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PBcm_E, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:afa36a24a9c8fa583631e45d1ad366ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass).  <a href="#afa36a24a9c8fa583631e45d1ad366ce3">More...</a><br /></td></tr>
<tr class="separator:afa36a24a9c8fa583631e45d1ad366ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a96949d335bfe501c62587705d47ce6ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a96949d335bfe501c62587705d47ce6ad">TriaxiallySymmetric</a> (const T &amp;I_triaxial)</td></tr>
<tr class="memdesc:a96949d335bfe501c62587705d47ce6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rotational inertia with equal moments of inertia along its diagonal and with each product of inertia set to zero.  <a href="#a96949d335bfe501c62587705d47ce6ad">More...</a><br /></td></tr>
<tr class="separator:a96949d335bfe501c62587705d47ce6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af016e2a9451f4692a56bec5209ddbaf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#af016e2a9451f4692a56bec5209ddbaf5">MinusEqualsUnchecked</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:af016e2a9451f4692a56bec5209ddbaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia.  <a href="#af016e2a9451f4692a56bec5209ddbaf5">More...</a><br /></td></tr>
<tr class="separator:af016e2a9451f4692a56bec5209ddbaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a82936d10a31afe3ae91f3025a39d3224"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:a82936d10a31afe3ae91f3025a39d3224"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a></td></tr>
<tr class="separator:a82936d10a31afe3ae91f3025a39d3224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ec7d834d6d03f2ce93baaa79a4a1f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a18ec7d834d6d03f2ce93baaa79a4a1f5">operator*</a> (const T &amp;nonnegative_scalar, const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:a18ec7d834d6d03f2ce93baaa79a4a1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia <code>I_BP_E</code>.  <a href="#a18ec7d834d6d03f2ce93baaa79a4a1f5">More...</a><br /></td></tr>
<tr class="separator:a18ec7d834d6d03f2ce93baaa79a4a1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ab220ab02073a10f117b7b355a7596010"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab220ab02073a10f117b7b355a7596010"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab220ab02073a10f117b7b355a7596010">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I)</td></tr>
<tr class="memdesc:ab220ab02073a10f117b7b355a7596010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion operator to write RotationalInertia's into a <code>std::ostream</code>.  <a href="#ab220ab02073a10f117b7b355a7596010">More...</a><br /></td></tr>
<tr class="separator:ab220ab02073a10f117b7b355a7596010"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::RotationalInertia&lt; T &gt;</h3>

<p>This class helps describe the mass distribution (inertia properties) of a body or composite body about a particular point. </p>
<p>Herein, "composite body" means one body or a collection of bodies that are welded together. In this documentation, "body" and "composite body" are used interchangeably.</p>
<p>A <b>rigid</b> body's mass distribution is described by three quantities: the body's mass; the body's center of mass; and the body's rotational inertia about a particular point. The term <b>rotational inertia</b> is used here and by [Jain 2010] to distinguish from a body's <b>spatial inertia</b>. In this class, a 3x3 <b>inertia matrix</b> I represents a body's rotational inertia about a point and expressed in a frame (e.g., about-point P and expressed-in frame E with right-handed orthogonal unit vectors x̂, ŷ, ẑ). </p><pre>
    | Ixx Ixy Ixz |
I = | Ixy Iyy Iyz |
    | Ixz Iyz Izz |
</pre><p> The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz, Iyz are defined in terms of the mass dm of a differential volume of the body. The position of dm from about-point P is xx̂ + yŷ + zẑ = [x, y, z]_E. </p><pre>
Ixx = ∫ (y² + z²) dm
Iyy = ∫ (x² + z²) dm
Izz = ∫ (x² + y²) dm
Ixy = - ∫ x y dm
Ixz = - ∫ x z dm
Iyz = - ∫ y z dm
</pre><p> We use the negated convention for products of inertia, so that I serves to relate angular velocity ω and angular momentum h via <code>h = I ⋅ ω</code>. Ensure your products of inertia follow this negative sign convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments of inertia) and off-diagonal elements (products of inertia) are associated with a body (or composite body) S, an about-point P, and an expressed-in- frame E (x̂, ŷ, ẑ). A rotational inertia is ill-defined unless there is a body S, about-point P, and expressed-in frame E. The user of this class is responsible for tracking the body S, about-point P and expressed-in frame E (none of these are stored in this class).</p>
<dl class="section note"><dt>Note</dt><dd>This class does not store the about-point nor the expressed-in frame, nor does this class help enforce consistency of the about-point or expressed-in frame. To help users of this class track the about-point and expressed-in frame, we strongly recommend the following notation.</dd></dl>
<p>In typeset material, use the symbol \( [I^{S/P}]_E \) to represent the rotational inertia (inertia matrix) of a body (or composite body) S about-point P, expressed in frame E. In code and comments, use the monogram notation <code>I_SP_E</code> (e.g., as described in <a class="el" href="group__multibody__spatial__inertia.html">Spatial Mass Matrix (Spatial Inertia)</a>). If the about-point P is fixed to a body B, the point is named \( B_P \) and this appears in code/comments as <code>Bp</code>. Examples: <code>I_BBp_E</code> is rigid body B's rotational inertia about-point Bp expressed-in frame E; I_BBo_E is B's rotational inertia about-point <code>Bo</code> (body B's origin) expressed-in frame E; and I_BBcm_E is B's inertia matrix about-point <code>Bcm</code> (B's center of mass) expressed-in frame E.</p>
<dl class="section note"><dt>Note</dt><dd>The rotational inertia (inertia matrix) can be re-expressed in terms of a special frame whose orthogonal unit vectors are parallel to <b>principal axes of inertia</b> so that the inertia matrix is diagonalized with elements called <b>principal moments of inertia</b>.</dd>
<dd>
Several methods in this class throw a std::exception for invalid rotational inertia operations in debug releases only. This provides speed in a release build while facilitating debugging in debug builds. In addition, these validity tests are only performed for scalar types for which <a class="el" href="structdrake_1_1scalar__predicate.html#ab6fdcd06e06c892b3492eb6ea8f15be2" title="Whether type is bool. ">drake::scalar_predicate&lt;T&gt;::is_bool</a> is <code>true</code>. For instance, validity checks are not performed when T is <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">symbolic::Expression</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The underlying scalar type. Must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar. Various methods in this class require numerical (not symbolic) data types.</td></tr>
  </table>
  </dd>
</dl>
<p>Instantiated templates for the following kinds of T's are provided:</p>
<ul>
<li>double</li>
<li>AutoDiffXd</li>
<li><a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">symbolic::Expression</a></li>
</ul>
<p>They are already available to link against in the containing library. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a719e23ae8c26b0c8cf0c7f30dd112559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719e23ae8c26b0c8cf0c7f30dd112559">&#9670;&nbsp;</a></span>RotationalInertia() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87e215bccd4ce720b787f8b5195a7551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e215bccd4ce720b787f8b5195a7551">&#9670;&nbsp;</a></span>RotationalInertia() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3ffc4a4e197a2a2155641d75c2a7c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ffc4a4e197a2a2155641d75c2a7c49">&#9670;&nbsp;</a></span>RotationalInertia() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a rotational inertia that has all its moments/products of inertia equal to NaN (helps quickly detect uninitialized values). </p>

</div>
</div>
<a id="af36dbdaa401764e4df48b07d3b6ad7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36dbdaa401764e4df48b07d3b6ad7d4">&#9670;&nbsp;</a></span>RotationalInertia() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Iyy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Izz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rotational inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with each product of inertia set to zero. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for Debug builds if not <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a319d6a0feeb306267605332cdd1906d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319d6a0feeb306267605332cdd1906d6">&#9670;&nbsp;</a></span>RotationalInertia() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Iyy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Izz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Iyz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rotational inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with products of inertia <code>Ixy</code>, <code>Ixz</code>, <code>Iyz</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for Debug builds if not <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73ee8d395f9f46a1086071be0faa8e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ee8d395f9f46a1086071be0faa8e37">&#9670;&nbsp;</a></span>RotationalInertia() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PQ_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a rotational inertia for a particle Q of mass <code>mass</code>, whose position vector from about-point P is p_PQ_E (E is expressed-in frame). </p>
<p>This std::logic_error exception only occurs if <code>mass</code> &lt; 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of particle Q. </td></tr>
    <tr><td class="paramname">p_PQ_E</td><td>Position from about-point P to Q, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_QP_E,Q's</td><td>rotational inertia about-point P expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector p_PQ_E has no affect on the result. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for Debug builds if not <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3751c9eaa974909523b6d8d3fd0833a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3751c9eaa974909523b6d8d3fd0833a8">&#9670;&nbsp;</a></span>CalcMaximumPossibleMomentOfInertia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CalcMaximumPossibleMomentOfInertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum possible moment of inertia for <code>this</code> rotational inertia about-point P for any expressed-in frame E. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The maximum moment Imax has range: trace / 3 &lt;= Imax &lt;= trace / 2. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a23798f37ae600d4d79b8a2e71586c4c7" title="Returns a rotational inertia&#39;s trace (i.e., Ixx + Iyy + Izz, the sum of the diagonal elements of the ...">Trace()</a> </dd></dl>

</div>
</div>
<a id="a6b63ae12f2b1cc131b2584efe07a2b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b63ae12f2b1cc131b2584efe07a2b6b">&#9670;&nbsp;</a></span>CalcPrincipalMomentsOfInertia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; CalcPrincipalMomentsOfInertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method takes <code>this</code> rotational inertia about-point P, expressed-in- frame E, and computes its principal moments of inertia about-point P, but expressed-in a frame aligned with the principal axes. </p>
<dl class="section note"><dt>Note</dt><dd>: This method only works for a rotational inertia with scalar type T that can be converted to a double (discarding any supplemental scalar data such as derivatives of an AutoDiffScalar).</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">principal_moments</td><td>The vector of principal moments of inertia <code>[Ixx Iyy Izz]</code> sorted in ascending order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if eigenvalue solver fails or if scalar type T cannot be converted to a double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa1e01c37486db2e78263fb70eaff550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1e01c37486db2e78263fb70eaff550">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;Scalar&gt; cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new RotationalInertia object templated on <code>Scalar</code> initialized from the values of <code>this</code> rotational inertia's entries. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type on which the new rotational inertia will be templated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class helps describe the mass distribution (inertia properties) of a body or composite body abou...">RotationalInertia</a>&lt;From&gt;::cast&lt;To&gt;()</code> creates a new <code><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class helps describe the mass distribution (inertia properties) of a body or composite body abou...">RotationalInertia</a>&lt;To&gt;</code> from a <code><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class helps describe the mass distribution (inertia properties) of a body or composite body abou...">RotationalInertia</a>&lt;From&gt;</code> but only if type <code>To</code> is constructible from type <code>From</code>. This cast method works in accordance with <a class="el" href="namespace_eigen.html">Eigen</a>'s cast method for <a class="el" href="namespace_eigen.html">Eigen</a>'s Matrix3 that underlies this RotationalInertia. For example, <a class="el" href="namespace_eigen.html">Eigen</a> currently allows cast from type double to AutoDiffXd, but not vice-versa. </dd></dl>

</div>
</div>
<a id="a8509d6f7951179378f848f5f4cc37720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8509d6f7951179378f848f5f4cc37720">&#9670;&nbsp;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For consistency with <a class="el" href="namespace_eigen.html">Eigen</a>'s API, the <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a8509d6f7951179378f848f5f4cc37720" title="For consistency with Eigen&#39;s API, the cols() method returns 3. ">cols()</a> method returns 3. </p>

</div>
</div>
<a id="af38985b256018ac664935ee8423bbe8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38985b256018ac664935ee8423bbe8b">&#9670;&nbsp;</a></span>CopyToFullMatrix3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt;T&gt; CopyToFullMatrix3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a full 3x3 matrix copy of this rotational inertia. </p>
<p>The returned copy is symmetric and includes both lower and upper parts of the matrix. </p>

</div>
</div>
<a id="a03e71eb4bd2a7648a411e1cbaf94812b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e71eb4bd2a7648a411e1cbaf94812b">&#9670;&nbsp;</a></span>CouldBePhysicallyValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; CouldBePhysicallyValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs several necessary checks to verify whether <code>this</code> rotational inertia <em>could</em> be physically valid, including: </p>
<ul>
<li>No NaN moments or products of inertia.</li>
<li>Ixx, Iyy, Izz and principal moments are all non-negative.</li>
<li>Ixx, Iyy Izz and principal moments satisfy the triangle inequality:<ul>
<li><code>Ixx + Iyy &gt;= Izz</code></li>
<li><code>Ixx + Izz &gt;= Iyy</code></li>
<li><code>Iyy + Izz &gt;= Ixx</code></li>
</ul>
</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>These checks are necessary (but NOT sufficient) conditions for a rotational inertia to be physically valid. The sufficient condition requires a rotational inertia to satisfy the above checks <em>after</em> <code>this</code> is shifted to the center of mass, i.e., the sufficient condition requires calling <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a> when the about-point is Bcm (the body's center of mass). Note: this class does not know its about-point or its center of mass location.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> for a plausible rotational inertia passing the above necessary but insufficient checks and <code>false</code> otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if principal moments of inertia cannot be calculated (eigenvalue solver) or if scalar type T cannot be converted to a double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c03fdc2e8311a8d71c14ef89e64260c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c03fdc2e8311a8d71c14ef89e64260c">&#9670;&nbsp;</a></span>DRAKE_DEPRECATED() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DRAKE_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;Use <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab18d9151885c8c0ab91a24db506d4270">ReExpressInPlace</a>(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February&#160;</td>
          <td class="paramname"><em>5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2019.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93df06a03ac0135b2a06e56be3144273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93df06a03ac0135b2a06e56be3144273">&#9670;&nbsp;</a></span>DRAKE_DEPRECATED() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DRAKE_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;Use <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;::<a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a08eb5284c5ec57a645aee167798a1f2c">ReExpress</a>(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February&#160;</td>
          <td class="paramname"><em>5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2019.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63faf9877a005bf08269b508f2d17b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63faf9877a005bf08269b508f2d17b42">&#9670;&nbsp;</a></span>get_moments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; get_moments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz]. </p>

</div>
</div>
<a id="a73703796210df51bb25acbb19168913a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73703796210df51bb25acbb19168913a">&#9670;&nbsp;</a></span>get_products()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; get_products </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz]. </p>

</div>
</div>
<a id="a1a73339c4b21bba9c3fa975f7a6c4220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a73339c4b21bba9c3fa975f7a6c4220">&#9670;&nbsp;</a></span>IsNaN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if any moment/product in <code>this</code> rotational inertia is NaN. </p>
<p>Otherwise returns <code>false</code>. </p>

</div>
</div>
<a id="a0546b3ac658fccec61a5156a926765dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0546b3ac658fccec61a5156a926765dd">&#9670;&nbsp;</a></span>IsNearlyEqualTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsNearlyEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <code>this</code> rotational inertia to <code>other</code> rotional inertia within the specified <code>precision</code> (which is a dimensionless number specifying the relative precision to which the comparison is performed). </p>
<p>Denoting <code>I_maxA</code> as the largest element value that can appear in a valid <code>this</code> rotational inertia (independent of the expressed-in frame E) and denoting <code>I_maxB</code> as the largest element value that can appear in a valid <code>other</code> rotational inertia (independent of the expressed-in frame E), <code>this</code> and <code>other</code> are considered nearly equal to each other, if: ‖this - other‖∞ &lt; precision * min(I_maxA, I_maxB)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Rotational inertia to compare with <code>this</code> rotational inertia. </td></tr>
    <tr><td class="paramname">precision</td><td>is a dimensionless real positive number that is usually based on two factors, namely expected accuracy of moments/products of inertia (e.g., from end-user or CAD) and/or machine-precision. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the absolute value of each moment/product of inertia in <code>this</code> is within <code>epsilon</code> of the corresponding moment/ product absolute value in <code>other</code>. Otherwise returns <code>false</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>: This method only works if all moments of inertia with scalar type T in <code>this</code> and <code>other</code> can be converted to a double (discarding supplemental scalar data such as derivatives of an AutoDiffScalar). It fails at runtime if type T cannot be converted to <code>double</code>. </dd></dl>

</div>
</div>
<a id="af016e2a9451f4692a56bec5209ddbaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af016e2a9451f4692a56bec5209ddbaf5">&#9670;&nbsp;</a></span>MinusEqualsUnchecked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; MinusEqualsUnchecked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_BP_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia. </p>
<p>No check is done to determine if the result is physically valid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be subtracted from <code>this</code> rotational inertia. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia. <code>this</code> changes since rotational inertia <code>I_BP_E</code> has been subtracted from it. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#aaff3c0d26ee10bb5d824ee6d3498eb4d" title="Subtracts a rotational inertia I_BP_E from this rotational inertia. ">operator-()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operator may produce an invalid rotational inertia. Use <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a9616b9b963139066953c80ac978c362a" title="Subtracts a rotational inertia I_BP_E from this rotational inertia. ">operator-=()</a> to perform necessary (but insufficient) checks on the physical validity of the resulting rotational inertia. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>: Although this method is mathematically useful, it may result in a rotational inertia that is physically invalid. This method helps perform intermediate calculations which do not necessarily represent a real rotational inertia. For example, an efficient way to shift a rotational inertia from an arbitrary point P to an arbitrary point Q is mathematical equivalent to a + (b - c). Although <code>a</code> must be physically valid and the result <code>a + (b - c)</code> must be physically valid, the intermediate quantity (b - c) is not necessarily physically valid. This method allows (b - c) to be calculated without requiring (b - c) to be physically valid. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a9616b9b963139066953c80ac978c362a" title="Subtracts a rotational inertia I_BP_E from this rotational inertia. ">operator-=()</a>. </dd></dl>

</div>
</div>
<a id="afae48d85764cacfd54fc3001250b4eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae48d85764cacfd54fc3001250b4eac">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const access to the <code>(i, j)</code> element of this rotational inertia. </p>
<dl class="section remark"><dt>Remarks</dt><dd>A mutable version of operator() is intentionally absent so as to prevent an end-user from directly setting elements. This prevents the creation of a non-physical (or non-symmetric) rotational inertia. </dd></dl>

</div>
</div>
<a id="a19cbefdc664161fc4775ab5d719e67bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cbefdc664161fc4775ab5d719e67bf">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>nonnegative_scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> rotational inertia by a nonnegative scalar (&gt;= 0). </p>
<p>In debug builds, throws std::logic_error if <code>nonnegative_scalar</code> &lt; 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonnegative_scalar</td><td>Nonnegative scalar which multiplies <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> rotational inertia multiplied by <code>nonnegative_scalar</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab65b0fb94c4a5a8b580c8db31e7ce659" title="Multiplies this rotational inertia by a nonnegative scalar (&gt;= 0). ">operator*=()</a>, <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a18ec7d834d6d03f2ce93baaa79a4a1f5" title="Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia I_BP_E. ">operator*(const T&amp;, const RotationalInertia&lt;T&gt;&amp;)</a> </dd></dl>

</div>
</div>
<a id="aad317217e02206a32e8a46b11f206bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad317217e02206a32e8a46b11f206bbe">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> rotational inertia about-point P, expressed-in frame E by the vector w_E (which <em>must</em> also have the same expressed-in frame E). </p>
<dl class="section note"><dt>Note</dt><dd>This calculation is equivalent to regarding <code>this</code> rotational inertia as an inertia dyadic and dot-multiplying it by w_E. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w_E</td><td>Vector to post-multiply with <code>this</code> rotational inertia. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Vector that results from multiplying <code>this</code> by <code>w_E</code>. </dd></dl>

</div>
</div>
<a id="ab65b0fb94c4a5a8b580c8db31e7ce659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65b0fb94c4a5a8b580c8db31e7ce659">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>nonnegative_scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> rotational inertia by a nonnegative scalar (&gt;= 0). </p>
<p>In debug builds, throws std::exception if <code>nonnegative_scalar</code> &lt; 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonnegative_scalar</td><td>Nonnegative scalar which multiplies <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia. <code>this</code> changes since <code>this</code> has been multiplied by <code>nonnegative_scalar</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a19cbefdc664161fc4775ab5d719e67bf" title="Multiplies this rotational inertia by a nonnegative scalar (&gt;= 0). ">operator*()</a>, <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a18ec7d834d6d03f2ce93baaa79a4a1f5" title="Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia I_BP_E. ">operator*(const T&amp;, const RotationalInertia&lt;T&gt;&amp;)</a>. </dd></dl>

</div>
</div>
<a id="ab3b4714f1ad30911025024f1eda4d72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b4714f1ad30911025024f1eda4d72e">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_BP_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a rotational inertia <code>I_BP_E</code> to <code>this</code> rotational inertia. </p>
<p>This method requires both rotational inertias (<code>I_BP_E</code> and <code>this</code>) to have the same about-point P and the same expressed-in frame E. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be added to <code>this</code> rotational inertia. <code>I_BP_E</code> and <code>this</code> must have the same about-point P and expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of <code>this</code> rotational inertia and <code>I_BP_E</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a22d65a4cd4dd6105398ee79ad825035f" title="Adds a rotational inertia I_BP_E to this rotational inertia. ">operator+=()</a>. </dd></dl>

</div>
</div>
<a id="a22d65a4cd4dd6105398ee79ad825035f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d65a4cd4dd6105398ee79ad825035f">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_BP_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a rotational inertia <code>I_BP_E</code> to <code>this</code> rotational inertia. </p>
<p>This method requires both rotational inertias (<code>I_BP_E</code> and <code>this</code>) to have the same about-point P and the same expressed-in frame E. The += operator updates <code>this</code> so <code>I_BP_E</code> is added to <code>this</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be added to <code>this</code> rotational inertia. <code>I_BP_E</code> and <code>this</code> must have the same about-point P and expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia. <code>this</code> changes since rotational inertia <code>I_BP_E</code> has been added to it. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab3b4714f1ad30911025024f1eda4d72e" title="Adds a rotational inertia I_BP_E to this rotational inertia. ">operator+()</a>. </dd></dl>

</div>
</div>
<a id="aaff3c0d26ee10bb5d824ee6d3498eb4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff3c0d26ee10bb5d824ee6d3498eb4d">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_BP_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia. </p>
<p>This method requires both rotational inertias (<code>I_BP_E</code> and <code>this</code>) to have the same about-point P and the same expressed-in frame E. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be subtracted from <code>this</code> rotational inertia. <code>I_BP_E</code> and <code>this</code> must have the same about-point P and expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The subtraction of <code>I_BP_E</code> from <code>this</code> rotational inertia. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for Debug builds if not <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a9616b9b963139066953c80ac978c362a" title="Subtracts a rotational inertia I_BP_E from this rotational inertia. ">operator-=()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>See warning and documentation for <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a9616b9b963139066953c80ac978c362a" title="Subtracts a rotational inertia I_BP_E from this rotational inertia. ">operator-=()</a>. </dd></dl>

</div>
</div>
<a id="a9616b9b963139066953c80ac978c362a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9616b9b963139066953c80ac978c362a">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_BP_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia. </p>
<p>This method requires both rotational inertias (<code>I_BP_E</code> and <code>this</code>) to have the same about-point P and the same expressed-in frame E. The -= operator updates <code>this</code> so <code>I_BP_E</code> is subtracted from <code>this</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be subtracted from <code>this</code> rotational inertia. <code>I_BP_E</code> and <code>this</code> must have the same about-point P and expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia. <code>this</code> changes since rotational inertia <code>I_BP_E</code> has been subtracted from it. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for Debug builds if not <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#aaff3c0d26ee10bb5d824ee6d3498eb4d" title="Subtracts a rotational inertia I_BP_E from this rotational inertia. ">operator-()</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This subtract operator is useful for computing rotational inertia of a body with a hole. First the rotational inertia of a fully solid body S (without the hole) is calculated, then the rotational inertia of the hole (treated as a massive solid body B) is calculated. The rotational inertia of a composite body C (comprised of S and -B) is computed by subtracting B's rotational inertia from S's rotational inertia. </dd></dl>

</div>
</div>
<a id="a7a0d8c42739dc16a87225c2b0057517b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0d8c42739dc16a87225c2b0057517b">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>positive_scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides <code>this</code> rotational inertia by a positive scalar(&gt; 0). </p>
<p>In debug builds, throws std::logic_error if <code>positive_scalar</code> &lt;= 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positive_scalar</td><td>Positive scalar (&gt; 0) which divides <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> rotational inertia divided by <code>positive_scalar</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a3cb6014636db3579a84defd7824ee4c1" title="Divides this rotational inertia by a positive scalar (&gt; 0). ">operator/=()</a>. </dd></dl>

</div>
</div>
<a id="a3cb6014636db3579a84defd7824ee4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb6014636db3579a84defd7824ee4c1">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>positive_scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides <code>this</code> rotational inertia by a positive scalar (&gt; 0). </p>
<p>In debug builds, throws std::exception if <code>positive_scalar</code> &lt;= 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positive_scalar</td><td>Positive scalar (&gt; 0) which divides <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia. <code>this</code> changes since <code>this</code> has been divided by <code>positive_scalar</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a7a0d8c42739dc16a87225c2b0057517b" title="Divides this rotational inertia by a positive scalar(&gt; 0). ">operator/()</a>. </dd></dl>

</div>
</div>
<a id="ab78d207e550d7d227b7e7f37557fb66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78d207e550d7d227b7e7f37557fb66a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac25060922d76f06276ac5f169e748ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25060922d76f06276ac5f169e748ebd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08eb5284c5ec57a645aee167798a1f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eb5284c5ec57a645aee167798a1f2c">&#9670;&nbsp;</a></span>ReExpress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; ReExpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_AE</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-expresses <code>this</code> rotational inertia <code>I_BP_E</code> to <code>I_BP_A</code> i.e., re-expresses body B's rotational inertia from frame E to frame A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_AE</td><td>RotationMatrix relating frames A and E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_BP_A</td><td>Rotational inertia of B about-point P expressed-in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for Debug builds if the rotational inertia that is re-expressed-in frame A violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab18d9151885c8c0ab91a24db506d4270" title="Re-expresses this rotational inertia I_BP_E to I_BP_A. ">ReExpressInPlace()</a> </dd></dl>

</div>
</div>
<a id="ab18d9151885c8c0ab91a24db506d4270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18d9151885c8c0ab91a24db506d4270">&#9670;&nbsp;</a></span>ReExpressInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; ReExpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_AE</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-expresses <code>this</code> rotational inertia <code>I_BP_E</code> to <code>I_BP_A</code>. </p>
<p>In other words, starts with <code>this</code> rotational inertia of a body (or composite body) B about-point P expressed-in frame E and re-expresses to B's rotational inertia about-point P expressed-in frame A, i.e., <code>I_BP_A = R_AE * I_BP_E * (R_AE)ᵀ</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_AE</td><td>RotationMatrix relating frames A and E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia about-point P, but with <code>this</code> expressed in frame A (instead of frame E). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for Debug builds if the rotational inertia that is re-expressed-in frame A violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a08eb5284c5ec57a645aee167798a1f2c" title="Re-expresses this rotational inertia I_BP_E to I_BP_A i.e., re-expresses body B&#39;s rotational inertia ...">ReExpress()</a>. </dd></dl>

</div>
</div>
<a id="ad107abcacb84cbabb41b87ba81360f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad107abcacb84cbabb41b87ba81360f91">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For consistency with <a class="el" href="namespace_eigen.html">Eigen</a>'s API, the <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ad107abcacb84cbabb41b87ba81360f91" title="For consistency with Eigen&#39;s API, the rows() method returns 3. ">rows()</a> method returns 3. </p>

</div>
</div>
<a id="ae461fd75b1b4eba6c95a57621adb4e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae461fd75b1b4eba6c95a57621adb4e9d">&#9670;&nbsp;</a></span>SetToNaN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetToNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>this</code> rotational inertia so all its elements are equal to NaN. </p>
<p>This helps quickly detect uninitialized moments/products of inertia. </p>

</div>
</div>
<a id="ae57e5aca5db002545e4b9335c8d9dbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57e5aca5db002545e4b9335c8d9dbfa">&#9670;&nbsp;</a></span>SetZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>this</code> rotational inertia so all its moments/products of inertia are zero, e.g., for convenient initialization before a computation or for inertia calculations involving a particle (point-mass). </p>
<p>Note: Real 3D massive physical objects have non-zero moments of inertia. </p>

</div>
</div>
<a id="a5a6d68bf65261dba0c10a00174fed83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6d68bf65261dba0c10a00174fed83c">&#9670;&nbsp;</a></span>ShiftFromCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; ShiftFromCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BcmQ_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q. </p>
<p>I.e., shifts <code>I_BBcm_E</code> to <code>I_BQ_E</code> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_BcmQ_E</td><td>Position vector from Bcm to Q, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_BQ_E</td><td>B's rotational inertia about-point Q expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for Debug builds if the rotational inertia that is shifted to about-point Q violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector p_BcmQ_E has no affect on the result. </dd></dl>

</div>
</div>
<a id="a233d049441510e6de4347afa89eff0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233d049441510e6de4347afa89eff0e0">&#9670;&nbsp;</a></span>ShiftFromCenterOfMassInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; ShiftFromCenterOfMassInPlace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BcmQ_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q. </p>
<p>I.e., shifts <code>I_BBcm_E</code> to <code>I_BQ_E</code> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_BcmQ_E</td><td>Position vector from Bcm to Q, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia expressed-in frame E, but with <code>this</code> shifted from about-point Bcm to about-point Q. i.e., returns I_BQ_E, B's rotational inertia about-point Bcm expressed-in frame E. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for Debug builds if the rotational inertia that is shifted to about-point Q violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector p_BcmQ_E has no affect on the result. </dd></dl>

</div>
</div>
<a id="aef27cf48918c4ca310e1e5d67de50f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef27cf48918c4ca310e1e5d67de50f7a">&#9670;&nbsp;</a></span>ShiftToCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; ShiftToCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_QBcm_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point Q to about-point <code>Bcm</code> (B's center of mass). </p>
<p>I.e., shifts <code>I_BQ_E</code> to <code>I_BBcm_E</code> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_QBcm_E</td><td>Position vector from Q to <code>Bcm</code>, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_BBcm_E</td><td>B's rotational inertia about-point <code>Bcm</code> expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for Debug builds if the rotational inertia that is shifted to about-point <code>Bcm</code> violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector <code>p_QBcm_E</code> has no affect on the result. </dd></dl>

</div>
</div>
<a id="a82a43d32c412efc0f5e1b6ccc1b1cc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a43d32c412efc0f5e1b6ccc1b1cc17">&#9670;&nbsp;</a></span>ShiftToCenterOfMassInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; ShiftToCenterOfMassInPlace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_QBcm_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point Q to about-point <code>Bcm</code> (B's center of mass). </p>
<p>I.e., shifts <code>I_BQ_E</code> to <code>I_BBcm_E</code> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_QBcm_E</td><td>Position vector from Q to <code>Bcm</code>, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia expressed-in frame E, but with <code>this</code> shifted from about-point Q to about-point <code>Bcm</code>, i.e., returns <code>I_BBcm_E</code>, B's rotational inertia about-point <code>Bcm</code> expressed-in frame E. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for Debug builds if the rotational inertia that is shifted to about-point <code>Bcm</code> violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector <code>p_QBcm_E</code> has no affect on the result. </dd></dl>

</div>
</div>
<a id="afa36a24a9c8fa583631e45d1ad366ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa36a24a9c8fa583631e45d1ad366ce3">&#9670;&nbsp;</a></span>ShiftToThenAwayFromCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; ShiftToThenAwayFromCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PBcm_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_QBcm_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass). </p>
<p>I.e., shifts <code>I_BP_E</code> to <code>I_BQ_E</code> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_PBcm_E</td><td>Position vector from P to Bcm, expressed-in frame E. </td></tr>
    <tr><td class="paramname">p_QBcm_E</td><td>Position vector from Q to Bcm, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_BQ_E,B's</td><td>rotational inertia about-point Q expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for Debug builds if the rotational inertia that is shifted to about-point Q violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating either (or both) position vectors p_PBcm_E and p_QBcm_E has no affect on the result. </dd></dl>

</div>
</div>
<a id="a631d7db4d8c28e6108d78b8309dabc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631d7db4d8c28e6108d78b8309dabc2b">&#9670;&nbsp;</a></span>ShiftToThenAwayFromCenterOfMassInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; ShiftToThenAwayFromCenterOfMassInPlace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PBcm_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_QBcm_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass). </p>
<p>I.e., shifts <code>I_BP_E</code> to <code>I_BQ_E</code> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_PBcm_E</td><td>Position vector from P to Bcm, expressed-in frame E. </td></tr>
    <tr><td class="paramname">p_QBcm_E</td><td>Position vector from Q to Bcm, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia expressed-in frame E, but with <code>this</code> shifted from about-point P to about-point Q, i.e., returns I_BQ_E, B's rotational inertia about-point Q expressed-in frame E. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>for Debug builds if the rotational inertia that is shifted to about-point Q violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating either (or both) position vectors p_PBcm_E and p_QBcm_E has no affect on the result. </dd>
<dd>
This method is more efficient (by 6 multiplications) than first shifting to the center of mass, then shifting away, e.g., as (<a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a82a43d32c412efc0f5e1b6ccc1b1cc17" title="Shifts this rotational inertia for a body (or composite body) B from about-point Q to about-point Bcm...">ShiftToCenterOfMassInPlace()</a>).<a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a233d049441510e6de4347afa89eff0e0" title="Shifts this rotational inertia for a body (or composite body) B from about-point Bcm (B&#39;s center of m...">ShiftFromCenterOfMassInPlace()</a>; </dd></dl>

</div>
</div>
<a id="a23798f37ae600d4d79b8a2e71586c4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23798f37ae600d4d79b8a2e71586c4c7">&#9670;&nbsp;</a></span>Trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a rotational inertia's trace (i.e., Ixx + Iyy + Izz, the sum of the diagonal elements of the inertia matrix). </p>
<p>The trace happens to be invariant to its expressed-in frame (i.e., the trace does not depend on the frame in which it is expressed). The trace is useful because the largest moment of inertia Imax has range: trace / 3 &lt;= Imax &lt;= trace / 2, and the largest possible product of inertia must be &lt;= Imax / 2. Hence, trace / 3 and trace / 2 give a lower and upper bound on the largest possible element that can be in a valid rotational inertia. </p>

</div>
</div>
<a id="a96949d335bfe501c62587705d47ce6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96949d335bfe501c62587705d47ce6ad">&#9670;&nbsp;</a></span>TriaxiallySymmetric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; TriaxiallySymmetric </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>I_triaxial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a rotational inertia with equal moments of inertia along its diagonal and with each product of inertia set to zero. </p>
<p>This factory is useful for the rotational inertia of a uniform-density sphere or cube. In debug builds, throws std::logic_error if I_triaxial is negative/NaN. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a18ec7d834d6d03f2ce93baaa79a4a1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ec7d834d6d03f2ce93baaa79a4a1f5">&#9670;&nbsp;</a></span>operator*</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>nonnegative_scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_BP_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia <code>I_BP_E</code>. </p>
<p>In debug builds, throws std::logic_error if <code>nonnegative_scalar</code> &lt; 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonnegative_scalar</td><td>Nonnegative scalar which multiplies <code>I_BP_E</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>nonnegative_scalar</code> multiplied by rotational inertia <code>I_BP_E</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab65b0fb94c4a5a8b580c8db31e7ce659" title="Multiplies this rotational inertia by a nonnegative scalar (&gt;= 0). ">operator*=()</a>, <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a19cbefdc664161fc4775ab5d719e67bf" title="Multiplies this rotational inertia by a nonnegative scalar (&gt;= 0). ">operator*()</a> </dd></dl>
<p>Multiplication of a scalar with a rotational matrix is commutative. </p>

</div>
</div>
<a id="ab220ab02073a10f117b7b355a7596010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab220ab02073a10f117b7b355a7596010">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion operator to write RotationalInertia's into a <code>std::ostream</code>. </p>
<p>Especially useful for debugging. </p>

</div>
</div>
<a id="a82936d10a31afe3ae91f3025a39d3224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82936d10a31afe3ae91f3025a39d3224">&#9670;&nbsp;</a></span>RotationalInertia</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/multibody_tree/<a class="el" href="rotational__inertia_8h.html">rotational_inertia.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
