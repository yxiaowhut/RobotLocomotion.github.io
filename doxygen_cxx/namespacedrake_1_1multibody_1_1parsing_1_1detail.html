<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::multibody::parsing::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacedrake_1_1multibody_1_1parsing_1_1detail.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drake::multibody::parsing::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abfd00d0007459c207b623fc278389108"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, Eigen::Vector4d &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a></td></tr>
<tr class="memdesc:abfd00d0007459c207b623fc278389108"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map from the name of a material to its color.  <a href="#abfd00d0007459c207b623fc278389108">More...</a><br /></td></tr>
<tr class="separator:abfd00d0007459c207b623fc278389108"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acdd3120d8bd21b09aca3fb1a3862d6e5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#acdd3120d8bd21b09aca3fb1a3862d6e5">MakeShapeFromSdfGeometry</a> (const sdf::Geometry &amp;sdf_geometry)</td></tr>
<tr class="memdesc:acdd3120d8bd21b09aca3fb1a3862d6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an sdf::Geometry object representing a &lt;geometry&gt; element from an SDF file, this method makes a new <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications. ">drake::geometry::Shape</a> object from this specification.  <a href="#acdd3120d8bd21b09aca3fb1a3862d6e5">More...</a><br /></td></tr>
<tr class="separator:acdd3120d8bd21b09aca3fb1a3862d6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3676511637c127d84a8bb589d2d90f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">GeometryInstance</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#a5b3676511637c127d84a8bb589d2d90f">MakeGeometryInstanceFromSdfVisual</a> (const sdf::Visual &amp;sdf_visual)</td></tr>
<tr class="memdesc:a5b3676511637c127d84a8bb589d2d90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an sdf::Visual object representing a &lt;visual&gt; element from an SDF file, this method makes a new <a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html" title="A geometry instance combines a geometry definition (i.e., a shape of some sort), a pose (relative to ...">drake::geometry::GeometryInstance</a> object from this specification.  <a href="#a5b3676511637c127d84a8bb589d2d90f">More...</a><br /></td></tr>
<tr class="separator:a5b3676511637c127d84a8bb589d2d90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae316355b614ffe49ee6e0a4f0a7dbfc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_visual_material.html">VisualMaterial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#ae316355b614ffe49ee6e0a4f0a7dbfc3">MakeVisualMaterialFromSdfVisual</a> (const sdf::Visual &amp;sdf_visual)</td></tr>
<tr class="memdesc:ae316355b614ffe49ee6e0a4f0a7dbfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an sdf::Visual object representing a &lt;visual&gt; element from an SDF file, this method makes a new <a class="el" href="classdrake_1_1geometry_1_1_visual_material.html">VisualMaterial</a> object from the specification.  <a href="#ae316355b614ffe49ee6e0a4f0a7dbfc3">More...</a><br /></td></tr>
<tr class="separator:ae316355b614ffe49ee6e0a4f0a7dbfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830c5cfd5f8d2b0979c74914e4517031"><td class="memItemLeft" align="right" valign="top">Isometry3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#a830c5cfd5f8d2b0979c74914e4517031">MakeGeometryPoseFromSdfCollision</a> (const sdf::Collision &amp;sdf_collision)</td></tr>
<tr class="memdesc:a830c5cfd5f8d2b0979c74914e4517031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>sdf_collision</code> stemming from the parsing of a <code>&lt;collision&gt;</code> element in an SDF file, this method makes the pose <code>X_LG</code> of frame G for the geometry of that collision element in the frame L of the link it belongs to.  <a href="#a830c5cfd5f8d2b0979c74914e4517031">More...</a><br /></td></tr>
<tr class="separator:a830c5cfd5f8d2b0979c74914e4517031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72989d7f800971772b29a84014351aff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1multibody__plant_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#a72989d7f800971772b29a84014351aff">MakeCoulombFrictionFromSdfCollisionOde</a> (const sdf::Collision &amp;sdf_collision)</td></tr>
<tr class="memdesc:a72989d7f800971772b29a84014351aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses friction coefficients from <code>sdf_collision</code>.  <a href="#a72989d7f800971772b29a84014351aff">More...</a><br /></td></tr>
<tr class="separator:a72989d7f800971772b29a84014351aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3563e8e670341154735943584a408c58"><td class="memItemLeft" align="right" valign="top">sdf::Visual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#a3563e8e670341154735943584a408c58">ResolveVisualUri</a> (const sdf::Visual &amp;original, const <a class="el" href="classdrake_1_1multibody_1_1parsing_1_1_package_map.html">parsing::PackageMap</a> &amp;package_map, const std::string &amp;root_dir)</td></tr>
<tr class="memdesc:a3563e8e670341154735943584a408c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an sdf::Visual object representing a &lt;visual&gt; element from an SDF file, this method makes a new Visual object which resolves the uri for the mesh element, if present.  <a href="#a3563e8e670341154735943584a408c58">More...</a><br /></td></tr>
<tr class="separator:a3563e8e670341154735943584a408c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eca6e02e85ffc38a4d5dcd6ad52a07d"><td class="memItemLeft" align="right" valign="top">Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#a0eca6e02e85ffc38a4d5dcd6ad52a07d">ToVector3</a> (const ignition::math::Vector3d &amp;<a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">vector</a>)</td></tr>
<tr class="memdesc:a0eca6e02e85ffc38a4d5dcd6ad52a07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to express an ignition::math::Vector3d instance as a Vector3d instance.  <a href="#a0eca6e02e85ffc38a4d5dcd6ad52a07d">More...</a><br /></td></tr>
<tr class="separator:a0eca6e02e85ffc38a4d5dcd6ad52a07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13dbb8038dd521c47b627fee0f1c8f8"><td class="memItemLeft" align="right" valign="top">Isometry3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#ad13dbb8038dd521c47b627fee0f1c8f8">ToIsometry3</a> (const ignition::math::Pose3d &amp;<a class="el" href="pose__smoother__test_8cc.html#a52d2d9a6c62244da2b2367bf389d0546">pose</a>)</td></tr>
<tr class="memdesc:ad13dbb8038dd521c47b627fee0f1c8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to express an ignition::math::Pose3d instance as an Isometry3d instance.  <a href="#ad13dbb8038dd521c47b627fee0f1c8f8">More...</a><br /></td></tr>
<tr class="separator:ad13dbb8038dd521c47b627fee0f1c8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffa8aaeb73c0156e955ed126d012e7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#a3ffa8aaeb73c0156e955ed126d012e7a">ParseStringAttribute</a> (const tinyxml2::XMLElement *node, const char *attribute_name, std::string *val)</td></tr>
<tr class="memdesc:a3ffa8aaeb73c0156e955ed126d012e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a string attribute of <code>node</code> named <code>attribute_name</code> into <code>val</code>.  <a href="#a3ffa8aaeb73c0156e955ed126d012e7a">More...</a><br /></td></tr>
<tr class="separator:a3ffa8aaeb73c0156e955ed126d012e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8addd4deaf7393247738c4099dff88ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#a8addd4deaf7393247738c4099dff88ce">ParseScalarAttribute</a> (const tinyxml2::XMLElement *node, const char *attribute_name, <a class="el" href="classdouble.html">double</a> *val)</td></tr>
<tr class="memdesc:a8addd4deaf7393247738c4099dff88ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a scalar attribute of <code>node</code> named <code>attribute_name</code> into <code>val</code>.  <a href="#a8addd4deaf7393247738c4099dff88ce">More...</a><br /></td></tr>
<tr class="separator:a8addd4deaf7393247738c4099dff88ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40a8c6836f446facd11fca258f18453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#ac40a8c6836f446facd11fca258f18453">ParseVectorAttribute</a> (const tinyxml2::XMLElement *node, const char *attribute_name, Eigen::Vector3d *val)</td></tr>
<tr class="memdesc:ac40a8c6836f446facd11fca258f18453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an attribute of <code>node</code> named <code>attribute_name</code> consisting of 3 scalar values into <code>val</code>.  <a href="#ac40a8c6836f446facd11fca258f18453">More...</a><br /></td></tr>
<tr class="separator:ac40a8c6836f446facd11fca258f18453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d7ab8ac8103f1eec39cbc658b6b17b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#a64d7ab8ac8103f1eec39cbc658b6b17b">ParseVectorAttribute</a> (const tinyxml2::XMLElement *node, const char *attribute_name, Eigen::Vector4d *val)</td></tr>
<tr class="memdesc:a64d7ab8ac8103f1eec39cbc658b6b17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an attribute of <code>node</code> named <code>attribute_name</code> consisting of 4 scalar values into <code>val</code>.  <a href="#a64d7ab8ac8103f1eec39cbc658b6b17b">More...</a><br /></td></tr>
<tr class="separator:a64d7ab8ac8103f1eec39cbc658b6b17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cccf8ea14d8d14818d324fd09db242"><td class="memItemLeft" align="right" valign="top">Eigen::Isometry3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#af3cccf8ea14d8d14818d324fd09db242">OriginAttributesToTransform</a> (const tinyxml2::XMLElement *node)</td></tr>
<tr class="memdesc:af3cccf8ea14d8d14818d324fd09db242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses "xyz" and "rpy" attributes from <code>node</code> and returns an Isometry3d created from them.  <a href="#af3cccf8ea14d8d14818d324fd09db242">More...</a><br /></td></tr>
<tr class="separator:af3cccf8ea14d8d14818d324fd09db242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d43126f7596ab1e3a48016e29a07d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#a27d43126f7596ab1e3a48016e29a07d2">ParseThreeVectorAttribute</a> (const tinyxml2::XMLElement *node, const char *attribute_name, Eigen::Vector3d *val)</td></tr>
<tr class="memdesc:a27d43126f7596ab1e3a48016e29a07d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a three vector value from parameter <code>node</code>, which is an XML node.  <a href="#a27d43126f7596ab1e3a48016e29a07d2">More...</a><br /></td></tr>
<tr class="separator:a27d43126f7596ab1e3a48016e29a07d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10f9c0f1b5ec2c3f7b4d4323ed0d40a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#ad10f9c0f1b5ec2c3f7b4d4323ed0d40a">ParseMaterial</a> (const XMLElement *node, <a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *materials)</td></tr>
<tr class="separator:ad10f9c0f1b5ec2c3f7b4d4323ed0d40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7754f802cb296d28e2554479ea71bba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#ac7754f802cb296d28e2554479ea71bba">ParseVisual</a> (const std::string &amp;parent_element_name, const <a class="el" href="classdrake_1_1multibody_1_1parsing_1_1_package_map.html">PackageMap</a> &amp;package_map, const std::string &amp;root_dir, const XMLElement *node, <a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *materials)</td></tr>
<tr class="separator:ac7754f802cb296d28e2554479ea71bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fb56048d2e7cc94be869615e6feebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#ac2fb56048d2e7cc94be869615e6feebd">ParseCollision</a> (const std::string &amp;parent_element_name, const <a class="el" href="classdrake_1_1multibody_1_1parsing_1_1_package_map.html">PackageMap</a> &amp;package_map, const std::string &amp;root_dir, const XMLElement *node, <a class="el" href="classdrake_1_1multibody_1_1multibody__plant_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *friction)</td></tr>
<tr class="separator:ac2fb56048d2e7cc94be869615e6feebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ee1b5f3c96366559b614f384a9048a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#a64ee1b5f3c96366559b614f384a9048a">ParseMaterial</a> (const tinyxml2::XMLElement *node, <a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *materials)</td></tr>
<tr class="memdesc:a64ee1b5f3c96366559b614f384a9048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a "material" element in <code>node</code> and adds the result to <code>materials</code>.  <a href="#a64ee1b5f3c96366559b614f384a9048a">More...</a><br /></td></tr>
<tr class="separator:a64ee1b5f3c96366559b614f384a9048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199b207841f940ce3c22f4bea11baf8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#a199b207841f940ce3c22f4bea11baf8a">ParseVisual</a> (const std::string &amp;parent_element_name, const <a class="el" href="classdrake_1_1multibody_1_1parsing_1_1_package_map.html">PackageMap</a> &amp;package_map, const std::string &amp;root_dir, const tinyxml2::XMLElement *node, <a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *materials)</td></tr>
<tr class="memdesc:a199b207841f940ce3c22f4bea11baf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a "visual" element in <code>node</code>.  <a href="#a199b207841f940ce3c22f4bea11baf8a">More...</a><br /></td></tr>
<tr class="separator:a199b207841f940ce3c22f4bea11baf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ac89a01c73af0766dcb905684eebed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#a14ac89a01c73af0766dcb905684eebed">ParseCollision</a> (const std::string &amp;parent_element_name, const <a class="el" href="classdrake_1_1multibody_1_1parsing_1_1_package_map.html">PackageMap</a> &amp;package_map, const std::string &amp;root_dir, const tinyxml2::XMLElement *node, <a class="el" href="classdrake_1_1multibody_1_1multibody__plant_1_1_coulomb_friction.html">multibody_plant::CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *friction)</td></tr>
<tr class="memdesc:a14ac89a01c73af0766dcb905684eebed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a "collision" element in <code>node</code>.  <a href="#a14ac89a01c73af0766dcb905684eebed">More...</a><br /></td></tr>
<tr class="separator:a14ac89a01c73af0766dcb905684eebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abfd00d0007459c207b623fc278389108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd00d0007459c207b623fc278389108">&#9670;&nbsp;</a></span>MaterialMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, Eigen::Vector4d&gt; <a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map from the name of a material to its color. </p>
<p>The color is specified in RGBA (Red, Green, Blue, Alpha) format. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a72989d7f800971772b29a84014351aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72989d7f800971772b29a84014351aff">&#9670;&nbsp;</a></span>MakeCoulombFrictionFromSdfCollisionOde()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1multibody__plant_1_1_coulomb_friction.html">multibody_plant::CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; MakeCoulombFrictionFromSdfCollisionOde </td>
          <td>(</td>
          <td class="paramtype">const sdf::Collision &amp;&#160;</td>
          <td class="paramname"><em>sdf_collision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses friction coefficients from <code>sdf_collision</code>. </p>
<p>This method looks for the definitions specific to ODE, as given by the SDF specification in <code>&lt;collision&gt;&lt;surface&gt;&lt;friction&gt;&lt;ode&gt;</code>. Drake understands <code>&lt;mu&gt;</code> as the static coefficient of friction and <code>&lt;mu2&gt;</code> as the dynamic coefficient of friction. Consider the example below: </p><div class="fragment"><div class="line">&lt;<span class="keywordtype">collision</span>&gt;</div><div class="line">  &lt;<span class="keywordtype">surface</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">friction</span>&gt;</div><div class="line">      &lt;<span class="keywordtype">ode</span>&gt;</div><div class="line">        &lt;<span class="keywordtype">mu</span>&gt;0.8&lt;/<span class="keywordtype">mu</span>&gt;</div><div class="line">        &lt;<span class="keywordtype">mu2</span>&gt;0.3&lt;/<span class="keywordtype">mu2</span>&gt;</div><div class="line">      &lt;/<span class="keywordtype">ode</span>&gt;</div><div class="line">    &lt;/<span class="keywordtype">friction</span>&gt;</div><div class="line">  &lt;/<span class="keywordtype">surface</span>&gt;</div><div class="line">&lt;/<span class="keywordtype">collision</span>&gt;</div></div><!-- fragment --><p> If a <code>&lt;surface&gt;</code> is not found, it returns the coefficients for a frictionless surface. If <code>&lt;surface&gt;</code> is found, all other nested elements are required and an exception is thrown if not present. </p>

</div>
</div>
<a id="a5b3676511637c127d84a8bb589d2d90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3676511637c127d84a8bb589d2d90f">&#9670;&nbsp;</a></span>MakeGeometryInstanceFromSdfVisual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a> &gt; MakeGeometryInstanceFromSdfVisual </td>
          <td>(</td>
          <td class="paramtype">const sdf::Visual &amp;&#160;</td>
          <td class="paramname"><em>sdf_visual</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an sdf::Visual object representing a &lt;visual&gt; element from an SDF file, this method makes a new <a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html" title="A geometry instance combines a geometry definition (i.e., a shape of some sort), a pose (relative to ...">drake::geometry::GeometryInstance</a> object from this specification. </p>
<p>This method returns nullptr when the given SDF specification corresponds to a geometry of type <code>sdf::GeometryType::EMPTY</code> (&lt;empty&gt; SDF tag.) </p>

</div>
</div>
<a id="a830c5cfd5f8d2b0979c74914e4517031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830c5cfd5f8d2b0979c74914e4517031">&#9670;&nbsp;</a></span>MakeGeometryPoseFromSdfCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Isometry3d MakeGeometryPoseFromSdfCollision </td>
          <td>(</td>
          <td class="paramtype">const sdf::Collision &amp;&#160;</td>
          <td class="paramname"><em>sdf_collision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given <code>sdf_collision</code> stemming from the parsing of a <code>&lt;collision&gt;</code> element in an SDF file, this method makes the pose <code>X_LG</code> of frame G for the geometry of that collision element in the frame L of the link it belongs to. </p>

</div>
</div>
<a id="acdd3120d8bd21b09aca3fb1a3862d6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd3120d8bd21b09aca3fb1a3862d6e5">&#9670;&nbsp;</a></span>MakeShapeFromSdfGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &gt; MakeShapeFromSdfGeometry </td>
          <td>(</td>
          <td class="paramtype">const sdf::Geometry &amp;&#160;</td>
          <td class="paramname"><em>sdf_geometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an sdf::Geometry object representing a &lt;geometry&gt; element from an SDF file, this method makes a new <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications. ">drake::geometry::Shape</a> object from this specification. </p>
<p>For <code>sdf_geometry.Type() == sdf::GeometryType::EMPTY</code>, corresponding to the &lt;empty&gt; SDF tag, it returns <code>nullptr</code>. </p>

</div>
</div>
<a id="ae316355b614ffe49ee6e0a4f0a7dbfc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae316355b614ffe49ee6e0a4f0a7dbfc3">&#9670;&nbsp;</a></span>MakeVisualMaterialFromSdfVisual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_visual_material.html">geometry::VisualMaterial</a> MakeVisualMaterialFromSdfVisual </td>
          <td>(</td>
          <td class="paramtype">const sdf::Visual &amp;&#160;</td>
          <td class="paramname"><em>sdf_visual</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an sdf::Visual object representing a &lt;visual&gt; element from an SDF file, this method makes a new <a class="el" href="classdrake_1_1geometry_1_1_visual_material.html">VisualMaterial</a> object from the specification. </p>
<p>The visual material comes from the child &lt;material&gt; tag. E.g., </p><div class="fragment"><div class="line">&lt;<span class="keywordtype">visual</span>&gt;</div><div class="line">  &lt;<span class="keywordtype">geometry</span>&gt;</div><div class="line">  ...</div><div class="line">  &lt;/<span class="keywordtype">geometry</span>&gt;</div><div class="line">  &lt;<span class="keywordtype">material</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">ambient</span>&gt;<span class="keyword">r_a</span> <span class="keyword">g_a</span> <span class="keyword">b_a</span> <span class="keyword">a_a</span>&lt;/<span class="keywordtype">ambient</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">diffuse</span>&gt;<span class="keyword">r_d</span> <span class="keyword">g_d</span> <span class="keyword">b_d</span> <span class="keyword">a_d</span>&lt;/<span class="keywordtype">diffuse</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">specular</span>&gt;<span class="keyword">r_s</span> <span class="keyword">g_s</span> <span class="keyword">b_s</span> <span class="keyword">a_s</span>&lt;/<span class="keywordtype">specular</span>&gt;</div><div class="line">    &lt;<span class="keywordtype">emissive</span>&gt;<span class="keyword">r_e</span> <span class="keyword">g_e</span> <span class="keyword">b_e</span> <span class="keyword">a_e</span>&lt;/<span class="keywordtype">emissive</span>&gt;</div><div class="line">  &lt;/<span class="keywordtype">material</span>&gt;</div><div class="line">&lt;/<span class="keywordtype">visual</span>&gt;</div></div><!-- fragment --><p> If there is no material tag, the supported material tags are missing, or there is an error parsing the supported values, the instantiated VisualMaterial will use default values. (See <a class="el" href="classdrake_1_1geometry_1_1_visual_material.html" title="Definition of material for simple visualization. ">geometry::VisualMaterial</a> for description of the default color.)</p>
<dl class="section note"><dt>Note</dt><dd>Currently, only the diffuse value is included in the VisualMaterial. </dd></dl>

</div>
</div>
<a id="af3cccf8ea14d8d14818d324fd09db242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cccf8ea14d8d14818d324fd09db242">&#9670;&nbsp;</a></span>OriginAttributesToTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Isometry3d OriginAttributesToTransform </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses "xyz" and "rpy" attributes from <code>node</code> and returns an Isometry3d created from them. </p>
<p>If either the "xyz" or "rpy" attributes are omitted they will be initialized with zero values.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the "xyz" or "rpy" attributes are malformed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14ac89a01c73af0766dcb905684eebed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ac89a01c73af0766dcb905684eebed">&#9670;&nbsp;</a></span>ParseCollision() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a> drake::multibody::parsing::detail::ParseCollision </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parent_element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1parsing_1_1_package_map.html">PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1multibody__plant_1_1_coulomb_friction.html">multibody_plant::CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>friction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a "collision" element in <code>node</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent_element_name</td><td>The name of the parent link element, used to construct default geometry names and for error reporting. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">friction</td><td>Coulomb friction for the associated geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2fb56048d2e7cc94be869615e6feebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fb56048d2e7cc94be869615e6feebd">&#9670;&nbsp;</a></span>ParseCollision() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a> drake::multibody::parsing::detail::ParseCollision </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parent_element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1parsing_1_1_package_map.html">PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1multibody__plant_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>friction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64ee1b5f3c96366559b614f384a9048a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ee1b5f3c96366559b614f384a9048a">&#9670;&nbsp;</a></span>ParseMaterial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::multibody::parsing::detail::ParseMaterial </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *&#160;</td>
          <td class="paramname"><em>materials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a "material" element in <code>node</code> and adds the result to <code>materials</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the material is missing required attributes or if it was already defined with different properties. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad10f9c0f1b5ec2c3f7b4d4323ed0d40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10f9c0f1b5ec2c3f7b4d4323ed0d40a">&#9670;&nbsp;</a></span>ParseMaterial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::multibody::parsing::detail::ParseMaterial </td>
          <td>(</td>
          <td class="paramtype">const XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *&#160;</td>
          <td class="paramname"><em>materials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8addd4deaf7393247738c4099dff88ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8addd4deaf7393247738c4099dff88ce">&#9670;&nbsp;</a></span>ParseScalarAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParseScalarAttribute </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a scalar attribute of <code>node</code> named <code>attribute_name</code> into <code>val</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>false if the attribute is not present</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the attribute doesn't contain a single numeric value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ffa8aaeb73c0156e955ed126d012e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffa8aaeb73c0156e955ed126d012e7a">&#9670;&nbsp;</a></span>ParseStringAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParseStringAttribute </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a string attribute of <code>node</code> named <code>attribute_name</code> into <code>val</code>. </p>
<p>If the attribute is not present, <code>val</code> will be cleared.</p>
<dl class="section return"><dt>Returns</dt><dd>false if the attribute is not present </dd></dl>

</div>
</div>
<a id="a27d43126f7596ab1e3a48016e29a07d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d43126f7596ab1e3a48016e29a07d2">&#9670;&nbsp;</a></span>ParseThreeVectorAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParseThreeVectorAttribute </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a three vector value from parameter <code>node</code>, which is an XML node. </p>
<p>Parses a three vector value from parameter <code>node</code>, which is an XML node.</p>
<p>The value is specified by an attribute within the XML whose name is apecified by parameter <code>attribute_name</code>. This method also supports a three vector specified by a single scalar value, which it automatically converts into a three vector by using the same scalar value for all three dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A pointer to the XML element node that contains an attribute with a three vector or a scalar value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">attribute_name</td><td>The name of the attribute containing the three vector or scalar value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">val</td><td>The three vector where the results should be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the attribute is not present</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If any problem is encountered parsing the three vector value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac40a8c6836f446facd11fca258f18453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40a8c6836f446facd11fca258f18453">&#9670;&nbsp;</a></span>ParseVectorAttribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParseVectorAttribute </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses an attribute of <code>node</code> named <code>attribute_name</code> consisting of 3 scalar values into <code>val</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>false if the attribute is not present</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the attribute doesn't contain three numeric values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64d7ab8ac8103f1eec39cbc658b6b17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d7ab8ac8103f1eec39cbc658b6b17b">&#9670;&nbsp;</a></span>ParseVectorAttribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParseVectorAttribute </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4d *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses an attribute of <code>node</code> named <code>attribute_name</code> consisting of 4 scalar values into <code>val</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>false if the attribute is not present</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the attribute doesn't contain four numeric values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a199b207841f940ce3c22f4bea11baf8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199b207841f940ce3c22f4bea11baf8a">&#9670;&nbsp;</a></span>ParseVisual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a> drake::multibody::parsing::detail::ParseVisual </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parent_element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1parsing_1_1_package_map.html">PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *&#160;</td>
          <td class="paramname"><em>materials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a "visual" element in <code>node</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent_element_name</td><td>The name of the parent link element, used to construct default geometry names and for error reporting. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">materials</td><td>The MaterialMap is used to look up materials which are referenced by name only in the visual element. New materials which are specified by both color and name will be added to the map and can be used by later visual elements. Material definitions may be repeated if the material properties are identical. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7754f802cb296d28e2554479ea71bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7754f802cb296d28e2554479ea71bba">&#9670;&nbsp;</a></span>ParseVisual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a> drake::multibody::parsing::detail::ParseVisual </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parent_element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1parsing_1_1_package_map.html">PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XMLElement *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html#abfd00d0007459c207b623fc278389108">MaterialMap</a> *&#160;</td>
          <td class="paramname"><em>materials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3563e8e670341154735943584a408c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3563e8e670341154735943584a408c58">&#9670;&nbsp;</a></span>ResolveVisualUri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sdf::Visual ResolveVisualUri </td>
          <td>(</td>
          <td class="paramtype">const sdf::Visual &amp;&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1parsing_1_1_package_map.html">parsing::PackageMap</a> &amp;&#160;</td>
          <td class="paramname"><em>package_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an sdf::Visual object representing a &lt;visual&gt; element from an SDF file, this method makes a new Visual object which resolves the uri for the mesh element, if present. </p>
<p>If the mesh element is not present, the new object will be identical to the original. See <a class="el" href="namespacedrake_1_1multibody_1_1parsing.html#a5fc07620bf1b295c191ac2327a68c850" title="Resolves the full path of a file. ">parsers::ResolveFilename()</a> for more detail on this operation.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the &lt;mesh&gt; tag is present but missing &lt;uri&gt; or if the file referenced in &lt;uri&gt; can not be found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad13dbb8038dd521c47b627fee0f1c8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13dbb8038dd521c47b627fee0f1c8f8">&#9670;&nbsp;</a></span>ToIsometry3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Isometry3d ToIsometry3 </td>
          <td>(</td>
          <td class="paramtype">const ignition::math::Pose3d &amp;&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to express an ignition::math::Pose3d instance as an Isometry3d instance. </p>

</div>
</div>
<a id="a0eca6e02e85ffc38a4d5dcd6ad52a07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eca6e02e85ffc38a4d5dcd6ad52a07d">&#9670;&nbsp;</a></span>ToVector3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d ToVector3 </td>
          <td>(</td>
          <td class="paramtype">const ignition::math::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to express an ignition::math::Vector3d instance as a Vector3d instance. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody_1_1parsing.html">parsing</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody_1_1parsing_1_1detail.html">detail</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
