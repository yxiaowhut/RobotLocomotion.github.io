<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: SpatialInertia&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_spatial_inertia.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1_spatial_inertia-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SpatialInertia&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents the physical concept of a <em>Spatial Inertia</em>.  
 <a href="classdrake_1_1multibody_1_1_spatial_inertia.html#details">More...</a></p>

<p><code>#include &lt;drake/multibody/multibody_tree/spatial_inertia.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a70f239bc8c7a515ee38b9e26aad808"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a4a70f239bc8c7a515ee38b9e26aad808">SpatialInertia</a> ()</td></tr>
<tr class="memdesc:a4a70f239bc8c7a515ee38b9e26aad808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia. ">SpatialInertia</a> constructor initializes mass, center of mass and rotational inertia to invalid NaN's for a quick detection of uninitialized values.  <a href="#a4a70f239bc8c7a515ee38b9e26aad808">More...</a><br /></td></tr>
<tr class="separator:a4a70f239bc8c7a515ee38b9e26aad808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e94087f9349bc468ad0d628d901959"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a28e94087f9349bc468ad0d628d901959">SpatialInertia</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PScm_E, const <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;G_SP_E)</td></tr>
<tr class="memdesc:a28e94087f9349bc468ad0d628d901959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a spatial inertia for a physical body or composite body S about a point P from a given mass, center of mass and rotational inertia.  <a href="#a28e94087f9349bc468ad0d628d901959">More...</a><br /></td></tr>
<tr class="separator:a28e94087f9349bc468ad0d628d901959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751136a22e2d0980679dd41429d54c62"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a751136a22e2d0980679dd41429d54c62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a751136a22e2d0980679dd41429d54c62">cast</a> () const</td></tr>
<tr class="memdesc:a751136a22e2d0980679dd41429d54c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new SpatialInertia object templated on <code>Scalar</code> initialized from the value of <code>this</code> spatial inertia.  <a href="#a751136a22e2d0980679dd41429d54c62">More...</a><br /></td></tr>
<tr class="separator:a751136a22e2d0980679dd41429d54c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1664b38f6c4fad624a7ab777c9642a7e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a1664b38f6c4fad624a7ab777c9642a7e">get_mass</a> () const</td></tr>
<tr class="memdesc:a1664b38f6c4fad624a7ab777c9642a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a constant reference to the mass of this spatial inertia.  <a href="#a1664b38f6c4fad624a7ab777c9642a7e">More...</a><br /></td></tr>
<tr class="separator:a1664b38f6c4fad624a7ab777c9642a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d857a6e2165c421949804eb2afbe7c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a1d857a6e2165c421949804eb2afbe7c7">get_com</a> () const</td></tr>
<tr class="memdesc:a1d857a6e2165c421949804eb2afbe7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a constant reference to the position vector <code>p_PScm_E</code> from the <em>about point</em> P to the center of mass <code>Scm</code> of the body or composite body S, expressed in frame E.  <a href="#a1d857a6e2165c421949804eb2afbe7c7">More...</a><br /></td></tr>
<tr class="separator:a1d857a6e2165c421949804eb2afbe7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1c2e2b7b334839c460e022d4686f54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a3a1c2e2b7b334839c460e022d4686f54">CalcComMoment</a> () const</td></tr>
<tr class="memdesc:a3a1c2e2b7b334839c460e022d4686f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the center of mass moment vector <code>mass * p_PScm_E</code> given the position vector <code>p_PScm_E</code> from the <em>about point</em> P to the center of mass <code>Scm</code> of the body or composite body S, expressed in frame E.  <a href="#a3a1c2e2b7b334839c460e022d4686f54">More...</a><br /></td></tr>
<tr class="separator:a3a1c2e2b7b334839c460e022d4686f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fbc3778a7090443b7b5102861ebe9a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#aa7fbc3778a7090443b7b5102861ebe9a">get_unit_inertia</a> () const</td></tr>
<tr class="memdesc:aa7fbc3778a7090443b7b5102861ebe9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a constant reference to the unit inertia <code>G_SP_E</code> of this spatial inertia, computed about point P and expressed in frame E.  <a href="#aa7fbc3778a7090443b7b5102861ebe9a">More...</a><br /></td></tr>
<tr class="separator:aa7fbc3778a7090443b7b5102861ebe9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025a1eb3a6fcfd673edc15b7ba85de9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a025a1eb3a6fcfd673edc15b7ba85de9e">CalcRotationalInertia</a> () const</td></tr>
<tr class="memdesc:a025a1eb3a6fcfd673edc15b7ba85de9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rotational inertia <code>I_SP_E = mass * G_SP_E</code> of this spatial inertia, computed about point P and expressed in frame E.  <a href="#a025a1eb3a6fcfd673edc15b7ba85de9e">More...</a><br /></td></tr>
<tr class="separator:a025a1eb3a6fcfd673edc15b7ba85de9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a73339c4b21bba9c3fa975f7a6c4220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a1a73339c4b21bba9c3fa975f7a6c4220">IsNaN</a> () const</td></tr>
<tr class="memdesc:a1a73339c4b21bba9c3fa975f7a6c4220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any of the elements in this spatial inertia is NaN and <code>false</code> otherwise.  <a href="#a1a73339c4b21bba9c3fa975f7a6c4220">More...</a><br /></td></tr>
<tr class="separator:a1a73339c4b21bba9c3fa975f7a6c4220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679852e6738fbcf5751ca37c51d2f084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a679852e6738fbcf5751ca37c51d2f084">IsPhysicallyValid</a> () const</td></tr>
<tr class="memdesc:a679852e6738fbcf5751ca37c51d2f084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a number of checks to verify that this is a physically valid spatial inertia.  <a href="#a679852e6738fbcf5751ca37c51d2f084">More...</a><br /></td></tr>
<tr class="separator:a679852e6738fbcf5751ca37c51d2f084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413ff91e8caf0498a96e5b1e06da9cd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a413ff91e8caf0498a96e5b1e06da9cd1">CopyToFullMatrix6</a> () const</td></tr>
<tr class="memdesc:a413ff91e8caf0498a96e5b1e06da9cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy to a full 6x6 matrix representation.  <a href="#a413ff91e8caf0498a96e5b1e06da9cd1">More...</a><br /></td></tr>
<tr class="separator:a413ff91e8caf0498a96e5b1e06da9cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b2415a4b0787515507518d9c0dd4e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a09b2415a4b0787515507518d9c0dd4e5">SetNaN</a> ()</td></tr>
<tr class="memdesc:a09b2415a4b0787515507518d9c0dd4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> spatial inertia to have NaN entries.  <a href="#a09b2415a4b0787515507518d9c0dd4e5">More...</a><br /></td></tr>
<tr class="separator:a09b2415a4b0787515507518d9c0dd4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7124bb702e0614d7b4874c09e4b0c649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a7124bb702e0614d7b4874c09e4b0c649">operator+=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;M_BP_E)</td></tr>
<tr class="memdesc:a7124bb702e0614d7b4874c09e4b0c649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds in a spatial inertia to <code>this</code> spatial inertia.  <a href="#a7124bb702e0614d7b4874c09e4b0c649">More...</a><br /></td></tr>
<tr class="separator:a7124bb702e0614d7b4874c09e4b0c649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc865a1da3d8d740ee1e7534e467d57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a6cc865a1da3d8d740ee1e7534e467d57">ReExpressInPlace</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_AE)</td></tr>
<tr class="memdesc:a6cc865a1da3d8d740ee1e7534e467d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, taken about a point P and expressed in frame E, this method computes the same inertia re-expressed in another frame A.  <a href="#a6cc865a1da3d8d740ee1e7534e467d57">More...</a><br /></td></tr>
<tr class="separator:a6cc865a1da3d8d740ee1e7534e467d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70df4e7d875f27cf5f12d391f436d688"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a70df4e7d875f27cf5f12d391f436d688">DRAKE_DEPRECATED</a> (&quot;Use <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a6cc865a1da3d8d740ee1e7534e467d57">SpatialInertia::ReExpressInPlace</a>(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February 5, 2019.&quot;) SpatialInertia &amp;<a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a6cc865a1da3d8d740ee1e7534e467d57">ReExpressInPlace</a>(const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R_AE)</td></tr>
<tr class="separator:a70df4e7d875f27cf5f12d391f436d688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87068d58ff4a71b1d3d9795e9fed4aa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a87068d58ff4a71b1d3d9795e9fed4aa6">ReExpress</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_AE) const</td></tr>
<tr class="memdesc:a87068d58ff4a71b1d3d9795e9fed4aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, taken about a point P and expressed in frame E, this method computes the same inertia re-expressed in another frame A.  <a href="#a87068d58ff4a71b1d3d9795e9fed4aa6">More...</a><br /></td></tr>
<tr class="separator:a87068d58ff4a71b1d3d9795e9fed4aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a3166ee48597a46f3d32b13a323945"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a87a3166ee48597a46f3d32b13a323945">DRAKE_DEPRECATED</a> (&quot;Use SpatialInertia:ReExpress(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February 5, 2019.&quot;) SpatialInertia <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a87068d58ff4a71b1d3d9795e9fed4aa6">ReExpress</a>(const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R_AE) const</td></tr>
<tr class="separator:a87a3166ee48597a46f3d32b13a323945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8c5e6a454900028bca003bd5cc9539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#afd8c5e6a454900028bca003bd5cc9539">ShiftInPlace</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PQ_E)</td></tr>
<tr class="memdesc:afd8c5e6a454900028bca003bd5cc9539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, computed about point P, and expressed in frame E, this method uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the same spatial inertia about a new point Q.  <a href="#afd8c5e6a454900028bca003bd5cc9539">More...</a><br /></td></tr>
<tr class="separator:afd8c5e6a454900028bca003bd5cc9539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eb83927e03cc49eb573ea200767cee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#aa0eb83927e03cc49eb573ea200767cee">Shift</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PQ_E) const</td></tr>
<tr class="memdesc:aa0eb83927e03cc49eb573ea200767cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, computed about point P, and expressed in frame E, this method uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the same spatial inertia about a new point Q.  <a href="#aa0eb83927e03cc49eb573ea200767cee">More...</a><br /></td></tr>
<tr class="separator:aa0eb83927e03cc49eb573ea200767cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e11845963568353bcb1de415be650e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html">SpatialForce</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a09e11845963568353bcb1de415be650e">operator*</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;A_WB_E) const</td></tr>
<tr class="memdesc:a09e11845963568353bcb1de415be650e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> spatial inertia <code>M_Bo_E</code> of a body B about its frame origin <code>Bo</code> by the spatial acceleration of the body frame B in a frame W.  <a href="#a09e11845963568353bcb1de415be650e">More...</a><br /></td></tr>
<tr class="separator:a09e11845963568353bcb1de415be650e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40603e75821ce46c958547a2fc543045"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_momentum.html">SpatialMomentum</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a40603e75821ce46c958547a2fc543045">operator*</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;V_WBp_E) const</td></tr>
<tr class="memdesc:a40603e75821ce46c958547a2fc543045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> spatial inertia <code>M_BP_E</code> of a body B about a point P by the spatial velocity <code>V_WBp</code>, in a frame W, of the body frame B shifted to point P.  <a href="#a40603e75821ce46c958547a2fc543045">More...</a><br /></td></tr>
<tr class="separator:a40603e75821ce46c958547a2fc543045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a8f02d78a11a4fd918699c75b48573520"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a8f02d78a11a4fd918699c75b48573520">SpatialInertia</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;)=default</td></tr>
<tr class="separator:a8f02d78a11a4fd918699c75b48573520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43ccc9d77b74b64c25cfcaf3deeaf0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#aa43ccc9d77b74b64c25cfcaf3deeaf0b">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;)=default</td></tr>
<tr class="separator:aa43ccc9d77b74b64c25cfcaf3deeaf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423681189f9dd1726b750876f67dafe9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a423681189f9dd1726b750876f67dafe9">SpatialInertia</a> (<a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a423681189f9dd1726b750876f67dafe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d612851b1578071428ec79f7da1047a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a2d612851b1578071428ec79f7da1047a">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a2d612851b1578071428ec79f7da1047a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3c36e3056b0d3fcc88d8c972df267a0e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a3c36e3056b0d3fcc88d8c972df267a0e">MakeFromCentralInertia</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PScm_E, const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_SScm_E)</td></tr>
<tr class="memdesc:a3c36e3056b0d3fcc88d8c972df267a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a physical body or composite body S about a point P from a given mass, center of mass, and central rotational inertia.  <a href="#a3c36e3056b0d3fcc88d8c972df267a0e">More...</a><br /></td></tr>
<tr class="separator:a3c36e3056b0d3fcc88d8c972df267a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a478f065fcb2da44767e1be0e9c27a56f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a478f065fcb2da44767e1be0e9c27a56f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a478f065fcb2da44767e1be0e9c27a56f">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:a478f065fcb2da44767e1be0e9c27a56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion operator to write <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia. ">SpatialInertia</a> objects into a <code>std::ostream</code>.  <a href="#a478f065fcb2da44767e1be0e9c27a56f">More...</a><br /></td></tr>
<tr class="separator:a478f065fcb2da44767e1be0e9c27a56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::SpatialInertia&lt; T &gt;</h3>

<p>This class represents the physical concept of a <em>Spatial Inertia</em>. </p>
<p>A spatial inertia (or spatial mass matrix) encapsulates the mass, center of mass, and rotational inertia of the mass distribution of a body or composite body S, where with "composite body" we mean a collection of bodies welded together containing at least one body (throughout this documentation "body" is many times used instead of "composite body" but the same concepts apply to a collection of bodies as well.) A spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive semi-definite. It logically consists of <code>3x3</code> sub-matrices arranged like so, [Jain 2010]: </p><pre>
             Spatial mass matrix
          ------------ ------------
       0 |            |            |
       1 |    I_SP    | m p_PScm×  |
       2 |            |            |
          ------------ ------------
       3 |            |            |
       4 | -m p_PScm× |     m Id   |
       5 |            |            |
          ------------ ------------
               Symbol: M
</pre><p> where, with the monogram notation described in <a class="el" href="group__multibody__spatial__inertia.html">Spatial Mass Matrix (Spatial Inertia)</a>, <code>I_SP</code> is the rotational inertia of body or composite body S computed about a point P, m is the mass of this composite body, <code>p_PScm</code> is the position vector from point P to the center of mass <code>Scm</code> of the composite body S with <code>p_PScm×</code> denoting its skew-symmetric cross product matrix (defined such that <code>a× b = a.cross(b)</code>), and <code>Id</code> is the identity matrix in ℝ³ˣ³. See Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown above is chosen to be consistent with our logical arrangement for spatial vectors as documented in <a class="el" href="group__multibody__spatial__algebra.html">Spatial Algebra</a> for which the rotational component comes first followed by the translational component.</p>
<p>In typeset material we use the symbol \( [M^{S/P}]_E \) to represent the spatial inertia of a body or composite body S about point P, expressed in frame E. For this inertia, the monogram notation reads <code>M_SP_E</code>. If the point P is fixed to a body B, we write that point as \( B_P \) which appears in code and comments as <code>Bp</code>. So if the body or composite body is B and the about point is <code>Bp</code>, the monogram notation reads <code>M_BBp_E</code>, which can be abbreviated to <code>M_Bp_E</code> since the about point <code>Bp</code> also identifies the body. Common cases are that the about point is the origin <code>Bo</code> of the body, or it's the center of mass <code>Bcm</code> for which the rotational inertia in monogram notation would read as <code>I_Bo_E</code> and <code>I_Bcm_E</code>, respectively. Given <code>M_BP_E</code> ( \([M^{B/P}]_E\)), the rotational inertia of this spatial inertia is <code>I_BP_E</code> ( \([I^{B/P}]_E\)) and the position vector of the center of mass measured from point P and expressed in E is <code>p_PBcm_E</code> ( \([^Pp^{B_{cm}}]_E\)).</p>
<dl class="section note"><dt>Note</dt><dd>This class does not implement any mechanism to track the frame E in which a spatial inertia is expressed or about what point is computed. Methods and operators on this class have no means to determine frame consistency through operations. It is therefore the responsibility of users of this class to keep track of frames in which operations are performed. We suggest doing that using disciplined notation, as described above.</dd>
<dd>
Several methods in this class throw a std::exception for invalid rotational inertia operations in debug releases only. This provides speed in a release build while facilitating debugging in debug builds. In addition, these validity tests are only performed for scalar types for which <a class="el" href="structdrake_1_1scalar__predicate.html#ab6fdcd06e06c892b3492eb6ea8f15be2" title="Whether type is bool. ">drake::scalar_predicate&lt;T&gt;::is_bool</a> is <code>true</code>. For instance, validity checks are not performed when T is <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">symbolic::Expression</a>.</dd></dl>
<ul>
<li>[Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis and algorithms. Springer Science &amp; Business Media.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The underlying scalar type. Must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar.</td></tr>
  </table>
  </dd>
</dl>
<p>Instantiated templates for the following kinds of T's are provided:</p>
<ul>
<li>double</li>
<li>AutoDiffXd</li>
<li><a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">symbolic::Expression</a></li>
</ul>
<p>They are already available to link against in the containing library. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8f02d78a11a4fd918699c75b48573520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f02d78a11a4fd918699c75b48573520">&#9670;&nbsp;</a></span>SpatialInertia() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a423681189f9dd1726b750876f67dafe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423681189f9dd1726b750876f67dafe9">&#9670;&nbsp;</a></span>SpatialInertia() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a70f239bc8c7a515ee38b9e26aad808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a70f239bc8c7a515ee38b9e26aad808">&#9670;&nbsp;</a></span>SpatialInertia() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia. ">SpatialInertia</a> constructor initializes mass, center of mass and rotational inertia to invalid NaN's for a quick detection of uninitialized values. </p>

</div>
</div>
<a id="a28e94087f9349bc468ad0d628d901959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e94087f9349bc468ad0d628d901959">&#9670;&nbsp;</a></span>SpatialInertia() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PScm_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>G_SP_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a spatial inertia for a physical body or composite body S about a point P from a given mass, center of mass and rotational inertia. </p>
<p>The center of mass is specified by the position vector <code>p_PScm_E</code> from point P to the center of mass point <code>Scm</code>, expressed in a frame E. The rotational inertia is provided as the <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html" title="This class is used to represent rotational inertias for unit mass bodies. ">UnitInertia</a> <code>G_SP_E</code> of the body or composite body S computed about point P and expressed in frame E.</p>
<dl class="section note"><dt>Note</dt><dd>The third argument of this constructor is unusual in that it is an <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html" title="This class is used to represent rotational inertias for unit mass bodies. ">UnitInertia</a> (not a traditional <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class helps describe the mass distribution (inertia properties) of a body or composite body abou...">RotationalInertia</a>) and its inertia is about the arbitrary point P (not Scm &ndash; S's center of mass). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a3c36e3056b0d3fcc88d8c972df267a0e" title="Creates a spatial inertia for a physical body or composite body S about a point P from a given mass...">MakeFromCentralInertia</a> a factory method with traditional utility.</dd></dl>
<p>This constructor checks for the physical validity of the resulting SpatialInertia with <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a679852e6738fbcf5751ca37c51d2f084" title="Performs a number of checks to verify that this is a physically valid spatial inertia. ">IsPhysicallyValid()</a> and throws a std::runtime_error exception in the event the provided input parameters lead to non-physically viable spatial inertia.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>The mass of the body or composite body S. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_PScm_E</td><td>The position vector from point P to the center of mass of body or composite body S expressed in frame E. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">G_SP_E</td><td><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html" title="This class is used to represent rotational inertias for unit mass bodies. ">UnitInertia</a> of the body or composite body S computed about origin point P and expressed in frame E. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3a1c2e2b7b334839c460e022d4686f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1c2e2b7b334839c460e022d4686f54">&#9670;&nbsp;</a></span>CalcComMoment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; CalcComMoment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the center of mass moment vector <code>mass * p_PScm_E</code> given the position vector <code>p_PScm_E</code> from the <em>about point</em> P to the center of mass <code>Scm</code> of the body or composite body S, expressed in frame E. </p>
<p>See the documentation of this class for details. </p>

</div>
</div>
<a id="a025a1eb3a6fcfd673edc15b7ba85de9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025a1eb3a6fcfd673edc15b7ba85de9e">&#9670;&nbsp;</a></span>CalcRotationalInertia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; CalcRotationalInertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the rotational inertia <code>I_SP_E = mass * G_SP_E</code> of this spatial inertia, computed about point P and expressed in frame E. </p>
<p>See the documentation of this class for details. </p>

</div>
</div>
<a id="a751136a22e2d0980679dd41429d54c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751136a22e2d0980679dd41429d54c62">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;Scalar&gt; cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new SpatialInertia object templated on <code>Scalar</code> initialized from the value of <code>this</code> spatial inertia. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type on which the new spatial inertia will be templated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia. ">SpatialInertia</a>&lt;From&gt;::cast&lt;To&gt;()</code> creates a new <code><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia. ">SpatialInertia</a>&lt;To&gt;</code> from a <code><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia. ">SpatialInertia</a>&lt;From&gt;</code> but only if type <code>To</code> is constructible from type <code>From</code>. This cast method works in accordance with <a class="el" href="namespace_eigen.html">Eigen</a>'s cast method for <a class="el" href="namespace_eigen.html">Eigen</a>'s objects that underlie this SpatialInertia. For example, <a class="el" href="namespace_eigen.html">Eigen</a> currently allows cast from type double to AutoDiffXd, but not vice-versa. </dd></dl>

</div>
</div>
<a id="a413ff91e8caf0498a96e5b1e06da9cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413ff91e8caf0498a96e5b1e06da9cd1">&#9670;&nbsp;</a></span>CopyToFullMatrix6()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt;T&gt; CopyToFullMatrix6 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy to a full 6x6 matrix representation. </p>

</div>
</div>
<a id="a70df4e7d875f27cf5f12d391f436d688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70df4e7d875f27cf5f12d391f436d688">&#9670;&nbsp;</a></span>DRAKE_DEPRECATED() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DRAKE_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;Use <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;::<a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a6cc865a1da3d8d740ee1e7534e467d57">ReExpressInPlace</a>(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February&#160;</td>
          <td class="paramname"><em>5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2019.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87a3166ee48597a46f3d32b13a323945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a3166ee48597a46f3d32b13a323945">&#9670;&nbsp;</a></span>DRAKE_DEPRECATED() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DRAKE_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;Use <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;:<a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a87068d58ff4a71b1d3d9795e9fed4aa6">ReExpress</a>(<a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp;). &quot; &quot;Code will be deleted after February&#160;</td>
          <td class="paramname"><em>5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2019.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d857a6e2165c421949804eb2afbe7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d857a6e2165c421949804eb2afbe7c7">&#9670;&nbsp;</a></span>get_com()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;&amp; get_com </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a constant reference to the position vector <code>p_PScm_E</code> from the <em>about point</em> P to the center of mass <code>Scm</code> of the body or composite body S, expressed in frame E. </p>
<p>See the documentation of this class for details. </p>

</div>
</div>
<a id="a1664b38f6c4fad624a7ab777c9642a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1664b38f6c4fad624a7ab777c9642a7e">&#9670;&nbsp;</a></span>get_mass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; get_mass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a constant reference to the mass of this spatial inertia. </p>

</div>
</div>
<a id="aa7fbc3778a7090443b7b5102861ebe9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fbc3778a7090443b7b5102861ebe9a">&#9670;&nbsp;</a></span>get_unit_inertia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt;&amp; get_unit_inertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a constant reference to the unit inertia <code>G_SP_E</code> of this spatial inertia, computed about point P and expressed in frame E. </p>
<p>See the documentation of this class for details. </p>

</div>
</div>
<a id="a1a73339c4b21bba9c3fa975f7a6c4220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a73339c4b21bba9c3fa975f7a6c4220">&#9670;&nbsp;</a></span>IsNaN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if any of the elements in this spatial inertia is NaN and <code>false</code> otherwise. </p>

</div>
</div>
<a id="a679852e6738fbcf5751ca37c51d2f084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679852e6738fbcf5751ca37c51d2f084">&#9670;&nbsp;</a></span>IsPhysicallyValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsPhysicallyValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a number of checks to verify that this is a physically valid spatial inertia. </p>
<p>The checks performed are:</p>
<ul>
<li>No NaN entries.</li>
<li>Non-negative mass.</li>
<li>Non-negative principal moments about the center of mass.</li>
<li>Principal moments about the center of mass must satisfy the triangle inequality:<ul>
<li><code>Ixx + Iyy &gt;= Izz</code></li>
<li><code>Ixx + Izz &gt;= Iyy</code></li>
<li><code>Iyy + Izz &gt;= Ixx</code></li>
</ul>
</li>
</ul>
<p>These are the tests performed by <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">RotationalInertia::CouldBePhysicallyValid()</a> which become a sufficient condition when performed on a rotational inertia about a body's center of mass. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">RotationalInertia::CouldBePhysicallyValid()</a>. </dd></dl>

</div>
</div>
<a id="a3c36e3056b0d3fcc88d8c972df267a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c36e3056b0d3fcc88d8c972df267a0e">&#9670;&nbsp;</a></span>MakeFromCentralInertia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> MakeFromCentralInertia </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PScm_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_SScm_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a physical body or composite body S about a point P from a given mass, center of mass, and central rotational inertia. </p>
<p>For example, this method creates a body's <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia. ">SpatialInertia</a> about its body origin Bo from the body's mass, position vector from Bo to the body's center of mass, and rotational inertia about the body's center of mass.</p>
<p>This method checks for the physical validity of the resulting SpatialInertia with <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a679852e6738fbcf5751ca37c51d2f084" title="Performs a number of checks to verify that this is a physically valid spatial inertia. ">IsPhysicallyValid()</a> and throws a std::runtime_error exception in the event the provided input parameters lead to a non-physically viable spatial inertia.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>The mass of the body or composite body S. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_PScm_E</td><td>The position vector from point P to point <code>Scm</code> (S's center of mass), expressed in a frame E. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I_SScm_E</td><td>S's <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class helps describe the mass distribution (inertia properties) of a body or composite body abou...">RotationalInertia</a> about Scm, expressed in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_SP_E</td><td>S's spatial inertia about point P, expressed in frame E. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09e11845963568353bcb1de415be650e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e11845963568353bcb1de415be650e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html">SpatialForce</a>&lt;T&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_WB_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> spatial inertia <code>M_Bo_E</code> of a body B about its frame origin <code>Bo</code> by the spatial acceleration of the body frame B in a frame W. </p>
<p>Mathematically: </p><pre>
  F_Bo_E = M_Bo_E * A_WB_E
</pre><p> or, in terms of its rotational and translational components (see this class's documentation for the block form of a rotational inertia): </p><pre>
  t_Bo = I_Bo * alpha_WB + m * p_BoBcm x a_WBo
  f_Bo = -m * p_BoBcm x alpha_WB + m * a_WBo
</pre><p> where <code>alpha_WB</code> and <code>a_WBo</code> are the rotational and translational components of the spatial acceleration <code>A_WB</code>, respectively.</p>
<dl class="section note"><dt>Note</dt><dd>The term <code>F_Bo_E</code> computed by this operator appears in the equations of motion for a rigid body which, when written about the origin <code>Bo</code> of the body frame B (which does not necessarily need to coincide with the body's center of mass), read as: <pre>
  Ftot_BBo = M_Bo_W * A_WB + b_Bo
</pre> where <code>Ftot_BBo</code> is the total spatial force applied on body B at at <code>Bo</code> that corresponds to the body spatial acceleration <code>A_WB</code> and <code>b_Bo</code> contains the velocity dependent gyroscopic terms (see Eq. 2.26, p. 27, in A. Jain's book). </dd></dl>

</div>
</div>
<a id="a40603e75821ce46c958547a2fc543045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40603e75821ce46c958547a2fc543045">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_momentum.html">SpatialMomentum</a>&lt;T&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_WBp_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> spatial inertia <code>M_BP_E</code> of a body B about a point P by the spatial velocity <code>V_WBp</code>, in a frame W, of the body frame B shifted to point P. </p>
<p>Mathematically: </p><pre>
  L_WBp_E = M_BP_E * V_WBp_E
</pre><p> or, in terms of its rotational and translational components (see this class's documentation for the block form of a rotational inertia): </p><pre>
  h_WB  = I_Bp * w_WB + m * p_BoBcm x v_WP
  l_WBp = -m * p_BoBcm x w_WB + m * v_WP
</pre><p> where <code>w_WB</code> and <code>v_WP</code> are the rotational and translational components of the spatial velocity <code>V_WBp</code>, respectively and, <code>h_WB</code> and <code>l_WBp</code> are the angular and linear components of the spatial momentum <code>L_WBp</code>, respectively.</p>
<dl class="section note"><dt>Note</dt><dd>It is possible to show that <code>M_BP_E.Shift(p_PQ_E) * V_WBp_E.Shift(p_PQ_E)</code> exactly equals <code>L_WBp_E.Shift(p_PQ_E)</code>. </dd></dl>

</div>
</div>
<a id="a7124bb702e0614d7b4874c09e4b0c649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7124bb702e0614d7b4874c09e4b0c649">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_BP_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds in a spatial inertia to <code>this</code> spatial inertia. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M_BP_E</td><td>A spatial inertia of some body B to be added to <code>this</code> spatial inertia. It must be defined about the same point P as <code>this</code> inertia, and expressed in the same frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> spatial inertia, which has been updated to include the given spatial inertia <code>M_BP_E</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operation aborts if the mass of the resulting spatial inertia is zero since in that case the position vector from the about point to the center of mass is not well defined.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation is only valid if both spatial inertias are computed about the same point P and expressed in the same frame E. Considering <code>this</code> spatial inertia to be <code>M_SP_E</code> for some body or composite body S, about some point P, the supplied spatial inertia <code>M_BP_E</code> must be for some other body or composite body B about the <em>same</em> point P; B's inertia is then included in S. </dd></dl>

</div>
</div>
<a id="a2d612851b1578071428ec79f7da1047a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d612851b1578071428ec79f7da1047a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa43ccc9d77b74b64c25cfcaf3deeaf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43ccc9d77b74b64c25cfcaf3deeaf0b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87068d58ff4a71b1d3d9795e9fed4aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87068d58ff4a71b1d3d9795e9fed4aa6">&#9670;&nbsp;</a></span>ReExpress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> ReExpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_AE</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, taken about a point P and expressed in frame E, this method computes the same inertia re-expressed in another frame A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_AE</td><td>RotationMatrix relating frames A and E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_SP_A</td><td>The same spatial inertia of S about P but now re-expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a6cc865a1da3d8d740ee1e7534e467d57" title="Given this spatial inertia M_SP_E for some body or composite body S, taken about a point P and expres...">ReExpressInPlace()</a> for details. </dd></dl>

</div>
</div>
<a id="a6cc865a1da3d8d740ee1e7534e467d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc865a1da3d8d740ee1e7534e467d57">&#9670;&nbsp;</a></span>ReExpressInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&amp; ReExpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_AE</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, taken about a point P and expressed in frame E, this method computes the same inertia re-expressed in another frame A. </p>
<p>This operation is performed in-place modifying the original object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_AE</td><td>Rotation matrix from frame E to frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia about the same point P but now re-expressed in frame A, that is, <code>M_SP_A</code>. </dd></dl>

</div>
</div>
<a id="a09b2415a4b0787515507518d9c0dd4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b2415a4b0787515507518d9c0dd4e5">&#9670;&nbsp;</a></span>SetNaN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>this</code> spatial inertia to have NaN entries. </p>
<p>Typically used for quick detection of uninitialized values. </p>

</div>
</div>
<a id="aa0eb83927e03cc49eb573ea200767cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0eb83927e03cc49eb573ea200767cee">&#9670;&nbsp;</a></span>Shift()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> Shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PQ_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, computed about point P, and expressed in frame E, this method uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the same spatial inertia about a new point Q. </p>
<p>The result still is expressed in frame E. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#afd8c5e6a454900028bca003bd5cc9539" title="Given this spatial inertia M_SP_E for some body or composite body S, computed about point P...">ShiftInPlace()</a> for more details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_PQ_E</td><td>Vector from the original about point P to the new about point Q, expressed in the same frame E <code>this</code> spatial inertia is expressed in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_SQ_E</td><td>This same spatial inertia for body or composite body S but computed about about a new point Q. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd8c5e6a454900028bca003bd5cc9539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8c5e6a454900028bca003bd5cc9539">&#9670;&nbsp;</a></span>ShiftInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&amp; ShiftInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PQ_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, computed about point P, and expressed in frame E, this method uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the same spatial inertia about a new point Q. </p>
<p>The result still is expressed in frame E. This operation is performed in-place modifying the original object. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#aa0eb83927e03cc49eb573ea200767cee" title="Given this spatial inertia M_SP_E for some body or composite body S, computed about point P...">Shift()</a> which does not modify this object.</dd></dl>
<p>For details see Section 2.1.2, p. 20 of [Jain 2010].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_PQ_E</td><td>Vector from the original about point P to the new about point Q, expressed in the same frame E <code>this</code> spatial inertia is expressed in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> spatial inertia for body or composite body S but now computed about about a new point Q. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a478f065fcb2da44767e1be0e9c27a56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478f065fcb2da44767e1be0e9c27a56f">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insertion operator to write <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia. ">SpatialInertia</a> objects into a <code>std::ostream</code>. </p>
<p>Especially useful for debugging. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/multibody_tree/<a class="el" href="spatial__inertia_8h.html">spatial_inertia.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
