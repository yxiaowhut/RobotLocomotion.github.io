<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: QueryObject&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1geometry_1_1_query_object.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdrake_1_1geometry_1_1_query_object-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">QueryObject&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The QueryObject serves as a mechanism to perform geometry queries on the world's geometry.  
 <a href="classdrake_1_1geometry_1_1_query_object.html#details">More...</a></p>

<p><code>#include &lt;drake/geometry/scene_graph_inspector.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3ead3718ecc338ebf8ffdd60f8206ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#ab3ead3718ecc338ebf8ffdd60f8206ed">QueryObject</a> ()=default</td></tr>
<tr class="memdesc:ab3ead3718ecc338ebf8ffdd60f8206ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a default <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry. ">QueryObject</a> (all pointers are null).  <a href="#ab3ead3718ecc338ebf8ffdd60f8206ed">More...</a><br /></td></tr>
<tr class="separator:ab3ead3718ecc338ebf8ffdd60f8206ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd120e4e5cad6f052fd4a17cce5c984"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html">SceneGraphInspector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a3bd120e4e5cad6f052fd4a17cce5c984">inspector</a> () const</td></tr>
<tr class="memdesc:a3bd120e4e5cad6f052fd4a17cce5c984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an inspector for the topological structure of the underlying scene graph data (see <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">SceneGraphInspector</a> for details).  <a href="#a3bd120e4e5cad6f052fd4a17cce5c984">More...</a><br /></td></tr>
<tr class="separator:a3bd120e4e5cad6f052fd4a17cce5c984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Collision Queries</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These queries detect <em>collisions</em> between geometry.</p>
<p>Two geometries collide if they overlap each other and are not explicitly excluded through <a class="el" href="group__collision__filter__concepts.html">collision filtering</a>. These algorithms find those colliding cases, characterize them, and report the essential characteristics of that collision. </p>
</div></td></tr>
<tr class="memitem:a9ae8651607d21a9fb37348c83e6d65c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">PenetrationAsPointPair</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a9ae8651607d21a9fb37348c83e6d65c4">ComputePointPairPenetration</a> () const</td></tr>
<tr class="memdesc:a9ae8651607d21a9fb37348c83e6d65c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the penetrations across all pairs of geometries in the world.  <a href="#a9ae8651607d21a9fb37348c83e6d65c4">More...</a><br /></td></tr>
<tr class="separator:a9ae8651607d21a9fb37348c83e6d65c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Signed Distance Queries</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="signed_distance_query"></a></p>
<p>These queries provide the signed distance between two objects. Each query has a specific definition of the signed distance being positive, negative, or zero associated with some notions of being outside, inside, or on the boundary.</p>
<p>These queries provide bookkeeping data like geometry id(s) of the geometries involved and the important locations on the boundaries of these geometries.</p>
<p>The signed distance function is a continuous function. Its partial derivatives are continuous almost everywhere. </p>
</div></td></tr>
<tr class="memitem:aba336c0f5f4393b05034a362aff704ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_pair.html">SignedDistancePair</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#aba336c0f5f4393b05034a362aff704ca">ComputeSignedDistancePairwiseClosestPoints</a> () const</td></tr>
<tr class="memdesc:aba336c0f5f4393b05034a362aff704ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the signed distance together with the nearest points across all pairs of geometries in the world.  <a href="#aba336c0f5f4393b05034a362aff704ca">More...</a><br /></td></tr>
<tr class="separator:aba336c0f5f4393b05034a362aff704ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9db492cf1799539fb61a004076e230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_to_point.html">SignedDistanceToPoint</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#aad9db492cf1799539fb61a004076e230">ComputeSignedDistanceToPoint</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;p_WQ, const <a class="el" href="classdouble.html">double</a> <a class="el" href="proximity__engine_8cc.html#a1d82d181e6f77a3479faa6152c83b438">threshold</a>=std::numeric_limits&lt; <a class="el" href="classdouble.html">double</a> &gt;::infinity()) const</td></tr>
<tr class="memdesc:aad9db492cf1799539fb61a004076e230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the signed distances and gradients to a query point from each geometry in the scene.  <a href="#aad9db492cf1799539fb61a004076e230">More...</a><br /></td></tr>
<tr class="separator:aad9db492cf1799539fb61a004076e230"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a09e32deb354fd5ca0cc04c6f6110bcb7"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a09e32deb354fd5ca0cc04c6f6110bcb7">SceneGraph&lt; T &gt;</a></td></tr>
<tr class="separator:a09e32deb354fd5ca0cc04c6f6110bcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7b762702efa3b6adc8d5aed4d9dbcb"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#abd7b762702efa3b6adc8d5aed4d9dbcb">QueryObjectTester</a></td></tr>
<tr class="separator:abd7b762702efa3b6adc8d5aed4d9dbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::geometry::QueryObject&lt; T &gt;</h3>

<p>The QueryObject serves as a mechanism to perform geometry queries on the world's geometry. </p>
<p>The <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram...">SceneGraph</a> has an abstract-valued port that contains a QueryObject (i.e., a QueryObject-valued output port).</p>
<p>To perform geometry queries on <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram...">SceneGraph</a>:</p><ul>
<li>a LeafSystem must have a QueryObject-valued input port and connect it to the corresponding query output port on <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram...">SceneGraph</a>,</li>
<li>the querying LeafSystem can evaluate the input port, retrieving a <code>const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry. ">QueryObject</a>&amp;</code> in return, and, finally,</li>
<li>invoke the appropriate method on the QueryObject.</li>
</ul>
<p>The const reference returned by the input port is considered "live" - it is linked to the context, system, and cache (making full use of all of those mechanisms). This const reference should <em>never</em> be persisted; doing so can lead to erroneous query results. It is simpler and more advisable to acquire it for evaluation in a limited scope (e.g., CalcTimeDerivatives()) and then discard it. If a QueryObject is needed for many separate functions in a LeafSystem, each should re-evaluate the input port. The underlying caching mechanism should make the cost of this negligible.</p>
<p>In addition to not persisting the reference from the output port, the QueryObject shouldn't be copied. Strictly speaking, it is an allowed operation, but the result is not live, and any geometry query performed on the copy will throw an exception.</p>
<p>A QueryObject <em>cannot</em> be converted to a different scalar type. A QueryObject of scalar type S can only be acquired from the output port of a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram...">SceneGraph</a> of type S evaluated on a corresponding <a class="el" href="classdrake_1_1geometry_1_1_geometry_context.html" title="The custom leaf context type for SceneGraph. ">GeometryContext</a>, also of type S.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type. Must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar.</td></tr>
  </table>
  </dd>
</dl>
<p>Instantiated templates for the following kinds of T's are provided:</p>
<ul>
<li>double</li>
<li>AutoDiffXd</li>
</ul>
<p>They are already available to link against in the containing library. No other values for T are currently supported. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab3ead3718ecc338ebf8ffdd60f8206ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ead3718ecc338ebf8ffdd60f8206ed">&#9670;&nbsp;</a></span>QueryObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a default <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry. ">QueryObject</a> (all pointers are null). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9ae8651607d21a9fb37348c83e6d65c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae8651607d21a9fb37348c83e6d65c4">&#9670;&nbsp;</a></span>ComputePointPairPenetration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">PenetrationAsPointPair</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; ComputePointPairPenetration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the penetrations across all pairs of geometries in the world. </p>
<p>Only reports results for <em>penetrating</em> geometries; if two geometries are separated, there will be no result for that pair. Pairs of <em>anchored</em> geometry are also not reported. The penetration between two geometries is characterized as a point pair (see <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html" title="A characterization of the intersection of two penetrating geometries. ">PenetrationAsPointPair</a>).</p>
<p>For two penetrating geometries g₁ and g₂, it is guaranteed that they will map to <code>id_A</code> and <code>id_B</code> in a fixed, repeatable manner.</p>
<p>This method is affected by collision filtering; element pairs that have been filtered will not produce contacts, even if their collision geometry is penetrating.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector populated with all detected penetrations characterized as point pairs. </dd></dl>

</div>
</div>
<a id="aba336c0f5f4393b05034a362aff704ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba336c0f5f4393b05034a362aff704ca">&#9670;&nbsp;</a></span>ComputeSignedDistancePairwiseClosestPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_pair.html">SignedDistancePair</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; ComputeSignedDistancePairwiseClosestPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the signed distance together with the nearest points across all pairs of geometries in the world. </p>
<p>Reports both the separating geometries and penetrating geometries.</p>
<p>This query provides φ(A, B), the signed distance between two objects A and B.</p>
<p>If the objects do not overlap (i.e., A ⋂ B = ∅), φ &gt; 0 and represents the minimal distance between the two objects. More formally: φ = min(|Aₚ - Bₚ|) ∀ Aₚ ∈ A and Bₚ ∈ B. </p><dl class="section note"><dt>Note</dt><dd>The pair (Aₚ, Bₚ) is a "witness" of the distance. The pair need not be unique (think of two parallel planes).</dd></dl>
<p>If the objects touch or overlap (i.e., A ⋂ B ≠ ∅), φ ≤ 0 and can be interpreted as the negative penetration depth. It is the smallest length of the vector v, such that by shifting one object along that vector relative to the other, the two objects will no longer be overlapping. More formally, φ(A, B) = -min |v|. s.t (Tᵥ · A) ⋂ B = ∅ where Tᵥ is a rigid transformation that displaces A by the vector v, namely Tᵥ · A = {u + v | ∀ u ∈ A}. By implication, there exist points Aₚ and Bₚ on the surfaces of objects A and B, respectively, such that Aₚ + v = Bₚ, Aₚ ∈ A ∩ B, Bₚ ∈ A ∩ B. These points are the witnesses to the penetration.</p>
<p>This method is affected by collision filtering; geometry pairs that have been filtered will not produce signed distance query results.</p>
<p>Notice that this is an O(N²) operation, where N is the number of geometries remaining in the world after applying collision filter. We report the distance between dynamic objects, and between dynamic and anchored objects. We DO NOT report the distance between two anchored objects. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">near_pairs</td><td>The signed distance for all unfiltered geometry pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad9db492cf1799539fb61a004076e230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9db492cf1799539fb61a004076e230">&#9670;&nbsp;</a></span>ComputeSignedDistanceToPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_to_point.html">SignedDistanceToPoint</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; ComputeSignedDistanceToPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_WQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>std::numeric_limits&lt;<a class="el" href="classdouble.html">double</a>&gt;::infinity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the signed distances and gradients to a query point from each geometry in the scene. </p>
<dl class="section warning"><dt>Warning</dt><dd>Currently supports spheres only. Silently ignores other kinds of geometries, which will be added later.</dd></dl>
<p>This query provides φᵢ(p), φᵢ:ℝ³→ℝ, the signed distance to the position p of a query point from geometry Gᵢ in the scene. It returns an array of the signed distances from all geometries.</p>
<p>Optionally you can specify a threshold distance that will filter out any object beyond the threshold. By default, we report distances from the query point to every object.</p>
<p>This query also provides the gradient vector ∇φᵢ(p) of the signed distance function from geometry Gᵢ. Note that, in general, if p is outside Gᵢ, then ∇φᵢ(p) equals the unit vector in the direction from the nearest point Nᵢ on Gᵢ's surface to p. If p is inside Gᵢ, then ∇φᵢ(p) is in the direction from p to Nᵢ. This observation is written formally as:</p>
<p>∇φᵢ(p) = (p - Nᵢ)/|p - Nᵢ| if p is outside Gᵢ</p>
<p>∇φᵢ(p) = (Nᵢ - p)/|Nᵢ - p| if p is inside Gᵢ</p>
<p>Note that ∇φᵢ(p) is also defined on Gᵢ's surface, but we cannot use the above formula.</p>
<dl class="section note"><dt>Note</dt><dd>For a sphere, the signed distance function φᵢ(p) has undefined gradient vector at the center of the sphere&ndash;every point on the sphere's surface has the same distance to the center. In this case, we will assign an arbitrary vector (1,0,0) as its gradient vector.</dd>
<dd>
The signed distance function is a continuous function with respect to the position of the query point, but its gradient vector field may not be continuous. Specifically at a position on the medial axis, its gradient vector field is not continuous.</dd>
<dd>
For a convex object, outside the object at positive distance from the boundary, the signed distance function is smooth (having continuous first-order partial derivatives).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_WQ</td><td>Position of a query point Q in world frame W. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>We ignore any object beyond this distance. By default, it is infinity, so we report distances from the query point to every object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">signed_distances</td><td>A vector populated with per-object signed distance values (and supporting data). See <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_to_point.html" title="The data for reporting the signed distance from a query point to a geometry. ">SignedDistanceToPoint</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bd120e4e5cad6f052fd4a17cce5c984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd120e4e5cad6f052fd4a17cce5c984">&#9670;&nbsp;</a></span>inspector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html">SceneGraphInspector</a>&lt;T&gt;&amp; inspector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides an inspector for the topological structure of the underlying scene graph data (see <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">SceneGraphInspector</a> for details). </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="abd7b762702efa3b6adc8d5aed4d9dbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7b762702efa3b6adc8d5aed4d9dbcb">&#9670;&nbsp;</a></span>QueryObjectTester</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class QueryObjectTester</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09e32deb354fd5ca0cc04c6f6110bcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e32deb354fd5ca0cc04c6f6110bcb7">&#9670;&nbsp;</a></span>SceneGraph< T ></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">SceneGraph</a>&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/geometry/<a class="el" href="query__object_8h.html">query_object.h</a></li>
<li>drake/geometry/<a class="el" href="query__object_8cc.html">query_object.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
