<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: ScalarInitialValueProblem&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1systems_1_1_scalar_initial_value_problem.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1systems_1_1_scalar_initial_value_problem-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ScalarInitialValueProblem&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A thin wrapper of the <a class="el" href="classdrake_1_1systems_1_1_initial_value_problem.html" title="A general initial value problem (or IVP) representation class, that allows evaluating the ùê±(t; ùê§)...">InitialValueProblem</a> class to provide a simple interface when solving scalar initial value problems i.e.  
 <a href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#details">More...</a></p>

<p><code>#include &lt;drake/systems/analysis/scalar_initial_value_problem.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_specified_values.html">SpecifiedValues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of values i.e.  <a href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_specified_values.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aee8bbba8701284c5d5dab38d8f37e800"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#aee8bbba8701284c5d5dab38d8f37e800">ScalarODEFunction</a> = std::function&lt; T(const T &amp;t, const T &amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;k)&gt;</td></tr>
<tr class="memdesc:aee8bbba8701284c5d5dab38d8f37e800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar ODE dx/dt = f(t, x; ùê§) function type.  <a href="#aee8bbba8701284c5d5dab38d8f37e800">More...</a><br /></td></tr>
<tr class="separator:aee8bbba8701284c5d5dab38d8f37e800"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2a3b20c0aedfa12e01b2287c4fbf070f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a2a3b20c0aedfa12e01b2287c4fbf070f">ScalarInitialValueProblem</a> (const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#aee8bbba8701284c5d5dab38d8f37e800">ScalarODEFunction</a> &amp;scalar_ode_function, const <a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_specified_values.html">SpecifiedValues</a> &amp;default_values)</td></tr>
<tr class="memdesc:a2a3b20c0aedfa12e01b2287c4fbf070f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an scalar IVP described by the given <code>scalar_ode_function</code>, using given <code>default_values.t0</code> and <code>default_values.x0</code> as initial conditions, and parameterized with <code>default_values.k</code> by default.  <a href="#a2a3b20c0aedfa12e01b2287c4fbf070f">More...</a><br /></td></tr>
<tr class="separator:a2a3b20c0aedfa12e01b2287c4fbf070f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26588cf65db698bb238499812d4b068a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a26588cf65db698bb238499812d4b068a">Solve</a> (const T &amp;tf, const <a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_specified_values.html">SpecifiedValues</a> &amp;values={}) const</td></tr>
<tr class="memdesc:a26588cf65db698bb238499812d4b068a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the IVP for time <code>tf</code>, using the initial time t‚ÇÄ, initial state x‚ÇÄ and parameter vector ùê§ present in <code>values</code>, falling back to the ones given on construction if not given.  <a href="#a26588cf65db698bb238499812d4b068a">More...</a><br /></td></tr>
<tr class="separator:a26588cf65db698bb238499812d4b068a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0f3e151719ecbe2f194e4b7847f2dc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_scalar_dense_output.html">ScalarDenseOutput</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#aea0f3e151719ecbe2f194e4b7847f2dc">DenseSolve</a> (const T &amp;tf, const <a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_specified_values.html">SpecifiedValues</a> &amp;values={}) const</td></tr>
<tr class="memdesc:aea0f3e151719ecbe2f194e4b7847f2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves and yields an approximation of the IVP solution x(t; ùê§) for the closed time interval between the initial time t‚ÇÄ and the given final time <code>tf</code>, using initial state x‚ÇÄ and parameter vector ùê§ present in <code>values</code> (falling back to the ones given on construction if not given).  <a href="#aea0f3e151719ecbe2f194e4b7847f2dc">More...</a><br /></td></tr>
<tr class="separator:aea0f3e151719ecbe2f194e4b7847f2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf92f89ed3fb6ea7acde795d33645a3c"><td class="memTemplParams" colspan="2">template&lt;typename Integrator , typename... Args&gt; </td></tr>
<tr class="memitem:aaf92f89ed3fb6ea7acde795d33645a3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_integrator.html">Integrator</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#aaf92f89ed3fb6ea7acde795d33645a3c">reset_integrator</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aaf92f89ed3fb6ea7acde795d33645a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the internal integrator instance by in-place construction of the given integrator type.  <a href="#aaf92f89ed3fb6ea7acde795d33645a3c">More...</a><br /></td></tr>
<tr class="separator:aaf92f89ed3fb6ea7acde795d33645a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05560d5b1fa368e1db5be08f2d78e0b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a05560d5b1fa368e1db5be08f2d78e0b5">get_integrator</a> () const</td></tr>
<tr class="memdesc:a05560d5b1fa368e1db5be08f2d78e0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the internal integrator instance.  <a href="#a05560d5b1fa368e1db5be08f2d78e0b5">More...</a><br /></td></tr>
<tr class="separator:a05560d5b1fa368e1db5be08f2d78e0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20cb332535cfc631ae1547189f4607c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#aa20cb332535cfc631ae1547189f4607c">get_mutable_integrator</a> ()</td></tr>
<tr class="memdesc:aa20cb332535cfc631ae1547189f4607c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the internal mutable integrator instance.  <a href="#aa20cb332535cfc631ae1547189f4607c">More...</a><br /></td></tr>
<tr class="separator:aa20cb332535cfc631ae1547189f4607c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a9e14d71a4415b5bbeb479c4b42712615"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a9e14d71a4415b5bbeb479c4b42712615">ScalarInitialValueProblem</a> (const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> &amp;)=delete</td></tr>
<tr class="separator:a9e14d71a4415b5bbeb479c4b42712615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af271bb5896ff93bf00fb74143035279e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#af271bb5896ff93bf00fb74143035279e">operator=</a> (const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> &amp;)=delete</td></tr>
<tr class="separator:af271bb5896ff93bf00fb74143035279e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3039082d5cf5d9b4884c666c2e0dd033"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a3039082d5cf5d9b4884c666c2e0dd033">ScalarInitialValueProblem</a> (<a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3039082d5cf5d9b4884c666c2e0dd033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87db2601a897d3578d48ef507b455b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#af87db2601a897d3578d48ef507b455b3">operator=</a> (<a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:af87db2601a897d3578d48ef507b455b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::systems::ScalarInitialValueProblem&lt; T &gt;</h3>

<p>A thin wrapper of the <a class="el" href="classdrake_1_1systems_1_1_initial_value_problem.html" title="A general initial value problem (or IVP) representation class, that allows evaluating the ùê±(t; ùê§)...">InitialValueProblem</a> class to provide a simple interface when solving scalar initial value problems i.e. </p>
<p>when evaluating the x(t; ùê§) solution function to the given ODE dx/dt = f(t, x; ùê§), where f : t ‚®Ø x ‚Üí ‚Ñù , t ‚àà ‚Ñù, x ‚àà ‚Ñù, ùê§ ‚àà ‚Ñù·µê, along with an initial condition x(t‚ÇÄ; ùê§) = x‚ÇÄ. The parameter vector ùê§ allows for generic IVP definitions, which can later be solved for any instance of said vector.</p>
<p>Note the distinction from general initial value problems where f : t ‚®Ø ùê± ‚Üí ‚Ñù‚Åø and ùê± ‚àà ‚Ñù‚Åø, addressed by the class being wrapped. While every scalar initial value problem could be written in vector form, this wrapper keeps both problem definition and solution in their scalar form with almost zero overhead, leading to clearer code if applicable. Moreover, this scalar form facilitates single-dimensional quadrature using methods for solving initial value problems.</p>
<p>See <a class="el" href="classdrake_1_1systems_1_1_initial_value_problem.html" title="A general initial value problem (or IVP) representation class, that allows evaluating the ùê±(t; ùê§)...">InitialValueProblem</a> class documentation for information on caching support and dense output usage for improved efficiency in scalar IVP solving.</p>
<p>For further insight into its use, consider the following examples of scalar IVPs:</p>
<ul>
<li>The population growth of an hypothetical bacteria colony is described by dN/dt = r * N. The colony has N‚ÇÄ subjects at time t‚ÇÄ. In this context, x ‚âú N, x‚ÇÄ ‚âú N‚ÇÄ, ùê§ ‚âú [r], dx/dt = f(t, x; ùê§) = ùê§‚ÇÅ * x.</li>
<li>The charge Q stored in the capacitor of a (potentially equivalent) series RC circuit driven by a time varying voltage source E(t) can be described by dQ/dt = (E(t) - Q / Cs) / Rs, where Rs refers to the resistor's resistance and Cs refers to the capacitor's capacitance. In this context, and assuming an initial stored charge Q‚ÇÄ at time t‚ÇÄ, x ‚âú Q, ùê§ ‚âú [Rs, Cs], x‚ÇÄ ‚âú Q‚ÇÄ, dx/dt = f(t, x; ùê§) = (E(t) - x / ùê§‚ÇÇ) / ùê§‚ÇÅ.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The ‚Ñù domain scalar type, which must be a valid <a class="el" href="namespace_eigen.html">Eigen</a> scalar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Instantiated templates for the following scalar types <code>T</code> are provided:</dd></dl>
<ul>
<li>double </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aee8bbba8701284c5d5dab38d8f37e800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8bbba8701284c5d5dab38d8f37e800">&#9670;&nbsp;</a></span>ScalarODEFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#aee8bbba8701284c5d5dab38d8f37e800">ScalarODEFunction</a> =  std::function&lt;T(const T&amp; t, const T&amp; <a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&amp; k)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scalar ODE dx/dt = f(t, x; ùê§) function type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The independent variable t ‚àà ‚Ñù . </td></tr>
    <tr><td class="paramname">x</td><td>The dependent variable x ‚àà ‚Ñù . </td></tr>
    <tr><td class="paramname">k</td><td>The parameter vector ùê§ ‚àà ‚Ñù·µê. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative dx/dt ‚àà ‚Ñù. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9e14d71a4415b5bbeb479c4b42712615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e14d71a4415b5bbeb479c4b42712615">&#9670;&nbsp;</a></span>ScalarInitialValueProblem() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3039082d5cf5d9b4884c666c2e0dd033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3039082d5cf5d9b4884c666c2e0dd033">&#9670;&nbsp;</a></span>ScalarInitialValueProblem() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a3b20c0aedfa12e01b2287c4fbf070f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3b20c0aedfa12e01b2287c4fbf070f">&#9670;&nbsp;</a></span>ScalarInitialValueProblem() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#aee8bbba8701284c5d5dab38d8f37e800">ScalarODEFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar_ode_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_specified_values.html">SpecifiedValues</a> &amp;&#160;</td>
          <td class="paramname"><em>default_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an scalar IVP described by the given <code>scalar_ode_function</code>, using given <code>default_values.t0</code> and <code>default_values.x0</code> as initial conditions, and parameterized with <code>default_values.k</code> by default. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar_ode_function</td><td>The ODE function f(t, x; ùê§) that describes the state evolution over time. </td></tr>
    <tr><td class="paramname">default_values</td><td>The values specified by default for this IVP, i.e. default initial time t‚ÇÄ ‚àà ‚Ñù and state x‚ÇÄ ‚àà ‚Ñù, and default parameter vector ùê§ ‚àà ‚Ñù·µê. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>An initial time <code>default_values.t0</code> is provided. </dd>
<dd>
An initial state <code>default_values.x0</code> is provided. </dd>
<dd>
An parameter vector <code>default_values.k</code> is provided. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if preconditions are not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aea0f3e151719ecbe2f194e4b7847f2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0f3e151719ecbe2f194e4b7847f2dc">&#9670;&nbsp;</a></span>DenseSolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_scalar_dense_output.html">ScalarDenseOutput</a>&lt;T&gt; &gt; DenseSolve </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_specified_values.html">SpecifiedValues</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves and yields an approximation of the IVP solution x(t; ùê§) for the closed time interval between the initial time t‚ÇÄ and the given final time <code>tf</code>, using initial state x‚ÇÄ and parameter vector ùê§ present in <code>values</code> (falling back to the ones given on construction if not given). </p>
<p>To this end, the wrapped <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html" title="An abstract class for an integrator for ODEs and DAEs as represented by a Drake System. ">IntegratorBase</a> instance solves this scalar IVP, advancing time and state from t‚ÇÄ and x‚ÇÄ = x(t‚ÇÄ) to <code>tf</code> and x(<code>tf</code>), creating a scalar dense output over that [t‚ÇÄ, <code>tf</code>] interval along the way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tf</td><td>The IVP will be solved up to this time. Usually, t‚ÇÄ &lt; <code>tf</code> as an empty dense output would result if t‚ÇÄ = <code>tf</code>. </td></tr>
    <tr><td class="paramname">values</td><td>IVP initial conditions and parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dense approximation to x(t; ùê§) with x(t‚ÇÄ; ùê§) = x‚ÇÄ, defined for t‚ÇÄ ‚â§ t ‚â§ tf. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The larger the given <code>tf</code> value is, the larger the approximated interval will be. See documentation of the specific dense output technique in use for reference on performance impact as this interval grows. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>tf</code> must be larger than or equal to the specified initial time t‚ÇÄ (either given or default). </dd>
<dd>
If given, the dimension of the initial state vector <code>values.x0</code> must match that of the default initial state vector in the default specified values given on construction. </dd>
<dd>
If given, the dimension of the parameter vector <code>values.k</code> must match that of the parameter vector in the default specified values given on construction. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if any of the preconditions is not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05560d5b1fa368e1db5be08f2d78e0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05560d5b1fa368e1db5be08f2d78e0b5">&#9670;&nbsp;</a></span>get_integrator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt;T&gt;* get_integrator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to the internal integrator instance. </p>

</div>
</div>
<a id="aa20cb332535cfc631ae1547189f4607c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20cb332535cfc631ae1547189f4607c">&#9670;&nbsp;</a></span>get_mutable_integrator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt;T&gt;* get_mutable_integrator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to the internal mutable integrator instance. </p>

</div>
</div>
<a id="af271bb5896ff93bf00fb74143035279e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af271bb5896ff93bf00fb74143035279e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af87db2601a897d3578d48ef507b455b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87db2601a897d3578d48ef507b455b3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf92f89ed3fb6ea7acde795d33645a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf92f89ed3fb6ea7acde795d33645a3c">&#9670;&nbsp;</a></span>reset_integrator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_integrator.html">Integrator</a>* reset_integrator </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the internal integrator instance by in-place construction of the given integrator type. </p>
<p>A usage example is shown below. </p><div class="fragment"><div class="line">scalar_ivp.reset_integrator&lt;RungeKutta2Integrator&lt;T&gt;&gt;(max_step);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The integrator type-specific arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new integrator instance. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classdrake_1_1systems_1_1_integrator.html" title="An integrator for a continuous vector input. ">Integrator</a></td><td>The integrator type, which must be an <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html" title="An abstract class for an integrator for ODEs and DAEs as represented by a Drake System. ">IntegratorBase</a> subclass. </td></tr>
    <tr><td class="paramname">Args</td><td>The integrator specific argument types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation invalidates pointers returned by <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a05560d5b1fa368e1db5be08f2d78e0b5" title="Gets a pointer to the internal integrator instance. ">ScalarInitialValueProblem::get_integrator()</a> and <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#aa20cb332535cfc631ae1547189f4607c" title="Gets a pointer to the internal mutable integrator instance. ">ScalarInitialValueProblem::get_mutable_integrator()</a>. </dd></dl>

</div>
</div>
<a id="a26588cf65db698bb238499812d4b068a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26588cf65db698bb238499812d4b068a">&#9670;&nbsp;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Solve </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_specified_values.html">SpecifiedValues</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the IVP for time <code>tf</code>, using the initial time t‚ÇÄ, initial state x‚ÇÄ and parameter vector ùê§ present in <code>values</code>, falling back to the ones given on construction if not given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tf</td><td>The IVP will be solved for this time. </td></tr>
    <tr><td class="paramname">values</td><td>IVP initial conditions and parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The IVP solution x(<code>tf</code>; ùê§) for x(t‚ÇÄ; ùê§) = x‚ÇÄ. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>tf</code> must be larger than or equal to the specified initial time t‚ÇÄ (either given or default). </dd>
<dd>
If given, the dimension of the parameter vector <code>values.k</code> must match that of the parameter vector in the default specified values given on construction. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if any of the preconditions is not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/systems/analysis/<a class="el" href="scalar__initial__value__problem_8h.html">scalar_initial_value_problem.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1systems.html">systems</a></li><li class="navelem"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
