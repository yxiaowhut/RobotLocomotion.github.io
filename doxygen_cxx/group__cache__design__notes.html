<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: System Cache Design and Implementation Notes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__cache__design__notes.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">System Cache Design and Implementation Notes<div class="ingroups"><a class="el" href="group__technical__notes.html">Technical Notes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<center> "There are only two hard things in computer science:<br />
 <b>cache invalidation</b>, and naming things."<br />
 &ndash; Phil Karlton </center> <h2>Background</h2>
<p>Drake <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> objects are used to specify the computational <em>structure</em> of a model to be studied. The actual <em>values</em> during computation are stored in a separate <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> object. The Context contains <em>source</em> values (time, parameters, states, input ports, accuracy) and <em>computed</em> values (e.g. derivatives, output ports) that depend on some or all of the source values. We call the particular dependencies of a computed value its <em>prerequisites</em>. The caching system described here manages computed values so that</p>
<ul>
<li>they are recomputed <em>only if</em> a prerequisite has changed,</li>
<li>they are marked out of date <em>whenever</em> a prerequisite changes, and</li>
<li><em>every</em> access to a computed value first ensures that it is up to date.</li>
</ul>
<p>Accessing computed values is a critical, inner-loop activity during simulation (many times per step) so the implementation is designed to provide validity-checked access at minimal computational cost. Marking computations out of date as prerequisites change is also frequent (at least once per step), and potentially expensive, so must be efficient; the implementation goes to great lengths to minimize the cost of that operation.</p>
<p><a class="anchor" id="cache_design_goals"></a></p><h2>Design Constraints and Goals</h2>
<p>Caching is entirely about performance. Hence, other than correctness, the performance goals listed above are the primary architectural constraints. Other goals also influenced the design. Here are the main goals in roughly descending order of importance.</p>
<ol type="1">
<li>Must be correct (same result with caching on or off).</li>
<li>Must be fast.</li>
<li>Must preserve independence of <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> and <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> objects (e.g., no cross-pointers).</li>
<li>Should provide a simple conceptual model and API for users.</li>
<li>Should treat all value sources and dependencies in Drake uniformly.</li>
<li>Should be backwards compatible with the existing API.</li>
</ol>
<p>In service of correctness and speed we need instrumentation for debugging and performance measurement. For example, it should be possible to disable caching to verify that the results don't change.</p>
<p><b>Not a goal</b> for the initial implementation: automatic determination or validation of dependency lists. Instead we rely on a conservative default (depends on everything), and the ability to disable caching during testing. Several follow-ons are possible to improve this:</p>
<ul>
<li>Runtime validation that computations only request sub-computations for which they hold tickets (probably affordable only in Debug), and</li>
<li>Use of symbolic expressions to calculate dependency lists automatically.</li>
</ul>
<p><a class="anchor" id="cache_design_architecture"></a></p><h2>Architecture</h2>
<p>This is the basic architecture Drake uses to address the above design goals.</p>
<p>Every declared source and computed value is assigned a small-integer DependencyTicket ("ticket") by the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> (unique within a subsystem). The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> contains corresponding <a class="el" href="classdrake_1_1systems_1_1_dependency_tracker.html" title="Manages value interdependencies for a particular value or set of values in a Context. ">DependencyTracker</a> ("tracker") objects that manage that value's downstream dependents and upstream prerequisites; these can be accessed efficiently using the ticket. Cached computations are declared and accessed through System-owned <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> objects; their values are stored in Context-owned <a class="el" href="classdrake_1_1systems_1_1_cache_entry_value.html" title="This is the representation in the Context for the value of one of a System&#39;s CacheEntry objects...">CacheEntryValue</a> objects whose validity with respect to source values is tracked via their associated dependency trackers. Computed values may in turn serve as source values for further computations. A change to a source value invalidates any computed values that depend on it, recursively. Such changes are initiated via Context methods that send "out of date" notifications to all downstream dependency trackers, which set the "out of date" flag on cache entry values.</p>
<p>Any value contained in a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> may be exported via an output port that exposes that value to downstream Systems; inter-subsystem dependencies are tracked using the same mechanism as intra-subsystem dependencies. The current implementation assigns a cache entry to each output port and requires copying Context values to that cache entry in order to expose them. This may be improved later to allow values to be exposed directly without the intermediate cache entry, but the semantics will be unchanged.</p>
<p>From a user perspective:</p>
<ul>
<li><a class="el" href="classdrake_1_1systems_1_1_cache.html" title="Stores all the CacheEntryValue objects owned by a particular Context, organized to allow fast access ...">Cache</a> entries of arbitrary type are allocated to hold the results of all significant computations, including built-ins like derivatives, energy, and output ports as well as user-defined internal computations. Prerequisites for these computations are explicitly noted at the time they are declared; the default for user-defined cache entries is that they are dependent on all sources.</li>
<li>Computation is initiated when a result is requested via an "Eval" method, if the result is not already up to date with respect to its prerequisites, which are recursively obtained using their Eval methods.</li>
<li>Cached results are automatically marked out of date when any of their prerequisites may have changed.</li>
</ul>
<p>Figure 1 below illustrates the computational structure of a Drake <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>, paired with its <a class="el" href="classdrake_1_1systems_1_1_leaf_context.html" title="LeafContext contains all prerequisite data necessary to uniquely determine the results of computation...">LeafContext</a>. A Drake <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> interconnects subsystems like these by connecting output ports of subsystems to input ports of other subsystems, and aggregates results such as derivative calculations. When referring to individual Systems within a diagram, we use the terms "subsystem" and "subcontext".</p>
<div class="image">
<img src="system_context_cache.png" alt="system_context_cache.png"/>
<div class="caption">
Figure 1: Computational structure of a Drake System.</div></div>
<p> In Figure 1 above, values are shown in gray like the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> to emphasize that they are actually being stored in the Context. The <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> can declare the structure (colored borders), but does not contain the actual values. There can also be values in the Context of which the System is unaware, including the Fixed Input values as shown, and additional cached computations. Computed values depend on source values, but are shown rounded on one side to emphasize that they then become sources to downstream computations. The arrows as drawn should be considered "is-prerequisite-of" edges; drawn in the reverse direction they could be labeled "depends-on" edges.</p>
<p><a class="anchor" id="cache_design_value_sources"></a></p><h2>Value sources</h2>
<p>When a cache entry is allocated, a list of prerequisite value sources is provided by listing the dependency tickets for those sources. Only <em>intra</em>-System dependencies are permitted; <em>inter</em>-System dependencies are expressed by listing an input port as a prerequisite. There are six kinds of value sources within a <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>'s <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> that can serve as prerequisites for cached results within that Context:</p>
<ol type="1">
<li>Time</li>
<li>Input ports</li>
<li>Parameters (numerical and abstract)</li>
<li>State (including continuous, discrete, and abstract variables)</li>
<li>Other cache entries</li>
<li>Accuracy</li>
</ol>
<p>In addition, we support "fixed" input ports whose values are provided locally; each such value is a value source, but is restricted to its corresponding input port. Fixed values are semantically like additional Parameters.</p>
<p>The Accuracy setting serves as a prerequisite for cached computations that are computed approximately, to make sure they get recomputed if accuracy requirements change. That is a technical detail not of interest to most users. Its dependencies are handled similarly to time dependencies.</p>
<p>Each value source has a unique DependencyTicket that is used to locate its <a class="el" href="classdrake_1_1systems_1_1_dependency_tracker.html" title="Manages value interdependencies for a particular value or set of values in a Context. ">DependencyTracker</a> in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. Further granularity is provided for individual value sources from the above categories. For example, configuration variables q and velocity variables v have separate tickets. The ticket is used to designate that source as a prerequisite for a cache entry. Tickets are assigned during System construction, whenever a component is specified that can serve as a value source. Each value source's DependencyTracker maintains a list of its dependents (called "subscribers") so that it can perform "out of date" notifications at run time, and is registered with its prerequisites so that it can be properly notified when it may be invalid.</p>
<p><a class="anchor" id="cache_design_output_ports"></a></p><h2>Output ports</h2>
<p>An Output Port for a <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> is a "window" onto one of the value sources within that System's <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>; that is the only way in which internal values of a System are exported to other Systems in a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a>. That value source may be</p>
<ul>
<li>a cache entry allocated specifically for the output port, or</li>
<li>a pre-existing source like a state subgroup or a cached value that has other uses (not implemented yet), or</li>
<li>an output port of a contained subsystem that has been exported.</li>
</ul>
<p>An output port is a subscriber to its source, and a prerequisite to the downstream input ports that it drives.</p>
<p>Every output port has an associated dependency ticket and tracker. If there is a cache entry associated with the output port, it has its own ticket and tracker to which the output port's tracker subscribes. A <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> output port that is exported from a contained subsystem still has its own tracker and subscribes to the source output port's tracker.</p>
<p><a class="anchor" id="cache_design_input_ports"></a></p><h2>Input ports</h2>
<p>The value source for a subsystem input port is either</p>
<ul>
<li>an output port of a peer subsystem, or</li>
<li>an input port of its parent <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a>, or</li>
<li>a locally-stored value.</li>
</ul>
<p>When an input port's value comes from a locally-stored value, we call it a <em>fixed</em> input port. Note that the fixed value is stored as a source value in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. There is no corresponding entry in the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> since providing values for input ports is done exclusively via the Context (see Figure 1 above).</p>
<p>Fixed input ports are treated identically to <a class="el" href="classdrake_1_1systems_1_1_parameters.html" title="Parameters is a container for variables that parameterize a System so that it can represent a family ...">Parameters</a> &ndash; they may have numerical or abstract value types; they may be changed with downstream invalidation handled automatically; and their values do not change during a time-advancing simulation. The values for fixed input ports are represented by <a class="el" href="classdrake_1_1systems_1_1_fixed_input_port_value.html" title="A FixedInputPortValue encapsulates a vector or abstract value for use as an internal value source for...">FixedInputPortValue</a> objects, which have their own ticket and tracker to which the corresponding input port subscribes.</p>
<p>Every input port has an associated dependency ticket and tracker. The tracker is automatically subscribed to the input port's source's tracker.</p>
<p><a class="anchor" id="cache_design_known_computations"></a></p><h2>Known computations</h2>
<p>Certain computations are defined by the system framework so are automatically assigned cache entries in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. Currently those are:</p>
<ul>
<li>Leaf output ports</li>
<li>Time derivatives</li>
<li>Power and energy (scalars)</li>
</ul>
<p>Output ports that have their own Calc() methods are also automatically assigned cache entries. Currently that applies to every leaf output port, but not to diagram output ports.</p>
<p><a class="anchor" id="cache_design_declaring"></a></p><h2>Declaring a cache entry</h2>
<p>The API for declaring a cache entry is similar to the existing output port API. A cache entry is defined by an Allocator() method returning an <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html" title="A fully type-erased container class. ">AbstractValue</a>, and a Calculator() method that takes a const (sub)<a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> and an <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html" title="A fully type-erased container class. ">AbstractValue</a> object of the type returned by the Allocator, and computes the correct value given the Context, and a list of prerequisites for the Calculator() function, which are DependencyTickets for value sources in the same subcontext.</p>
<p>In the absence of explicit prerequisites, a cache entry is implicitly presumed to be dependent on all possible values sources, so will be marked "out of date" whenever accuracy, time, any input port, parameter, or state variable may have a changed value. However, no implicit dependency on other cache entries is assumed.</p>
<p>A typical declaration looks like this (in the constructor for a <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>): </p><div class="fragment"><div class="line"><span class="keyword">const</span> CacheEntry&amp; pe_cache_entry =</div><div class="line">    DeclareCacheEntry(<span class="stringliteral">&quot;potential energy&quot;</span>, 0.0,</div><div class="line">                      &amp;MySystem::CalcPotentialEnergy,</div><div class="line">                      {all_parameters_ticket(), q_ticket()});</div></div><!-- fragment --><p>That is a templatized "sugar" method where the allocator has been specified to simply copy the given default value. The usual variants are available, as for output port declarations. See <a class="el" href="classdrake_1_1systems_1_1_system_base.html#DeclareCacheEntry_documentation">Declare cache entries</a> in <a class="el" href="classdrake_1_1systems_1_1_system_base.html" title="Provides non-templatized functionality shared by the templatized System classes. ">SystemBase</a> for the full collection of variants.</p>
<p>If no dependencies are listed in a cache entry declaration, the default is <code>{all_sources_ticket()}</code>. A cache entry that is truly independent of all sources must explicitly say so by specifying <code>{nothing_ticket()}</code>. The available tickets are defined in the <a class="el" href="classdrake_1_1systems_1_1_system_base.html" title="Provides non-templatized functionality shared by the templatized System classes. ">SystemBase</a> class; see <a class="el" href="classdrake_1_1systems_1_1_system_base.html#DependencyTicket_documentation">Dependency tickets</a> there. Once declared, the new <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> object's CacheIndex and DependencyTicket can be obtained from the entry if needed.</p>
<p><a class="anchor" id="predefined_dependency_tickets"></a></p><h2>Predefined dependency tickets</h2>
<p>The following dependency tickets are always available and are used to select particular built-in dependency trackers. During <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> construction, an API user can obtain the ticket number as the return value of methods like <code>time_ticket()</code> that are provided by <a class="el" href="classdrake_1_1systems_1_1_system_base.html" title="Provides non-templatized functionality shared by the templatized System classes. ">SystemBase</a>. Add <code>_ticket()</code> to the names in the first column of the table below to obtain the name of the method to use in a prerequisite list as shown in the previous section. Ticket methods followed by <code>(i)</code> in the table below are assigned as the indicated resource is allocated; they do not have pre-assigned ticket numbers.</p>
<table class="doxtable">
<tr>
<th align="left">Ticket name </th><th align="center">Abbr</th><th align="left">Prerequisite indicated </th><th align="left">Subscribes to  </th></tr>
<tr>
<td align="left">nothing </td><td align="center"></td><td align="left">has no prerequisite </td><td align="left">‚Äî </td></tr>
<tr>
<td align="left">time </td><td align="center">t </td><td align="left">simulated time </td><td align="left">‚Äî </td></tr>
<tr>
<td align="left">accuracy </td><td align="center">a </td><td align="left">accuracy setting </td><td align="left">‚Äî </td></tr>
<tr>
<td align="left">q </td><td align="center"></td><td align="left">continuous configuration </td><td align="left">‚Äî ¬π </td></tr>
<tr>
<td align="left">v </td><td align="center"></td><td align="left">continuous velocity </td><td align="left">‚Äî ¬π </td></tr>
<tr>
<td align="left">z </td><td align="center"></td><td align="left">misc. continuous state </td><td align="left">‚Äî ¬π </td></tr>
<tr>
<td align="left">xc </td><td align="center"></td><td align="left">any continuous state </td><td align="left">q v z </td></tr>
<tr>
<td align="left">xd </td><td align="center"></td><td align="left">any discrete state </td><td align="left">xd·µ¢ ‚àÄi ¬π ¬≤ </td></tr>
<tr>
<td align="left">xa </td><td align="center"></td><td align="left">any abstract state </td><td align="left">xa‚±º ‚àÄj ¬π ¬≤ </td></tr>
<tr>
<td align="left">all_state </td><td align="center">x </td><td align="left">any state variable </td><td align="left">xc xd xa </td></tr>
<tr>
<td align="left">pn </td><td align="center"></td><td align="left">any numeric parameter </td><td align="left">pn·µ¢ ‚àÄi ¬π ¬≤ </td></tr>
<tr>
<td align="left">pa </td><td align="center"></td><td align="left">any abstract parameter </td><td align="left">pa·µ¢ ‚àÄi ¬π ¬≤ </td></tr>
<tr>
<td align="left">all_parameters </td><td align="center">p </td><td align="left">any parameter p </td><td align="left">pn pa </td></tr>
<tr>
<td align="left">all_input_ports </td><td align="center">u </td><td align="left">any input port u </td><td align="left">u·µ¢ ‚àÄi </td></tr>
<tr>
<td align="left">all_sources </td><td align="center"></td><td align="left">any change to Context </td><td align="left">t, a, x, p, u </td></tr>
<tr>
<td align="left">configuration </td><td align="center"></td><td align="left">may affect pose or PE </td><td align="left">q, a, p, xd, xa ¬≥ </td></tr>
<tr>
<td align="left">kinematics </td><td align="center"></td><td align="left">may affect pose/motion </td><td align="left">configuration, v ¬≥ </td></tr>
<tr>
<td align="left">xcdot </td><td align="center"></td><td align="left">d/dt xc cached value </td><td align="left">all_sources ¬π </td></tr>
<tr>
<td align="left">pe </td><td align="center"></td><td align="left">potential energy </td><td align="left">all_sources ¬π </td></tr>
<tr>
<td align="left">ke </td><td align="center"></td><td align="left">kinetic energy </td><td align="left">all_sources ¬π </td></tr>
<tr>
<td align="left">pc </td><td align="center"></td><td align="left">conservative power </td><td align="left">all_sources ¬π </td></tr>
<tr>
<td align="left">pnc </td><td align="center"></td><td align="left">non-conservative power </td><td align="left">all_sources ¬π </td></tr>
<tr>
<td align="left">numeric_parameter(i) </td><td align="center">pn·µ¢ </td><td align="left">one numeric parameter </td><td align="left">‚Äî ¬≤ </td></tr>
<tr>
<td align="left">abstract_parameter(i)</td><td align="center">pa·µ¢ </td><td align="left">one abstract parameter </td><td align="left">‚Äî ¬≤ </td></tr>
<tr>
<td align="left">discrete_state(i) </td><td align="center">xd·µ¢ </td><td align="left">one discrete state group </td><td align="left">‚Äî ¬≤ </td></tr>
<tr>
<td align="left">abstract_state(i) </td><td align="center">xa·µ¢ </td><td align="left">one abstract state </td><td align="left">‚Äî ¬≤ </td></tr>
<tr>
<td align="left">input_port(i) </td><td align="center">u·µ¢ </td><td align="left">one input port </td><td align="left">peer, parent, or self ‚Å¥ </td></tr>
<tr>
<td align="left">cache_entry(i) </td><td align="center">c·µ¢ </td><td align="left">one cache entry </td><td align="left">explicit prerequisites </td></tr>
</table>
<p><em>Notes</em></p>
<ol type="1">
<li>Diagram has additional subscriptions for this tracker. See the diagram-specific table in the <a class="el" href="group__cache__design__notes.html#caching_implementation_for_diagrams">Diagram-specific implementation</a> section below.</li>
<li>There are no Diagram-level trackers for individual discrete/abstract variables and numeric/abstract parameters.</li>
<li>Until issue <a href="https://github.com/RobotLocomotion/drake/issues/9171">#9171</a> is resolved we don't know which non-continuous variables or which parameters may affect kinematics, so we have to depend on all of them.</li>
<li>Input ports are dependent on the source that provides their values. That may be the output port of a peer subsystem, the input port of the parent diagram, or a locally-stored fixed input port value.</li>
</ol>
<p>Fixed input port values and output ports also have associated trackers. There are methods for obtaining their tickets also but they are for internal use. Only input ports may subscribe to those trackers, and that is handled by the framework when the source for an input port is established.</p>
<p><a class="anchor" id="cache_handling_composite_trackers"></a></p><h3>Handling of composite trackers</h3>
<p>In the above table, entries that don't subscribe to anything ("‚Äî") are primary source objects. For example, q is an independent state variable so its tracker doesn't depend on anything else. Trackers like xc are composites, meaning they are shorthand for a group of independent objects. xc is a tracker that subscribes to the trackers for q, v, and z. Similarly xd stands for <em>all</em> discrete state variables, and subscribes to each of the individual discrete state trackers. That way if a q is modified, xc gets notified automatically. Similarly a change to a single discrete state variable notifies xd. Once those subscriptions are set up, no additional code is required in Drake to propagate the notifications. Let's call this the "up" direction, where a low-level entity notifies its "parent" composite entity.</p>
<p>More subtly, we also have to issue notifications in the "down" direction. That's because the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> provides methods like SetContinuousState() and get_mutable_state() which effectively change a group of source objects. That <em>could</em> be handled with more subscriptions, at the cost of introducing cycles into the dependency DAG (the "change event" would serve to break those cycles during notification sweeps). Instead, since we always know the constituents at the time a high-level modification request is made, we simply have bespoke code that notifies the lowest-level constituents, then depend on the "up" direction subscriptions to get the composite trackers notified. See the <a class="el" href="classdrake_1_1systems_1_1_context_base.html#context_base_change_notification_methods">notifications methods</a> in <a class="el" href="classdrake_1_1systems_1_1_context_base.html" title="Provides non-templatized Context functionality shared by the templatized derived classes. ">ContextBase</a>.</p>
<p>There are additional considerations for <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> notifications; those are discussed in the next section.</p>
<p><a class="anchor" id="caching_implementation_for_diagrams"></a></p><h2>Diagram-specific implementation</h2>
<p>Diagrams have some implementation details that don't apply to leaf systems. Diagrams do not have their own state variables and parameters. Instead, their states and parameters are references to their child subsystems' corresponding states and parameters. This applies individually to each state and parameter category. <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> contexts do have trackers for their composite state and parameters, and we must subscribe those to the corresponding child subsystem trackers to ensure notifications propagate upward. Using capital letters to denote the Diagram composite trackers we have:</p>
<ul>
<li>Q = { q‚Çõ : s ‚àà ùïä}</li>
<li>V = { v‚Çõ : s ‚àà ùïä}</li>
<li>Z = { z‚Çõ : s ‚àà ùïä}</li>
<li>Xd = {xd‚Çõ : s ‚àà ùïä}</li>
<li>Xa = {xa‚Çõ : s ‚àà ùïä}</li>
<li>Pn = {pn‚Çõ : s ‚àà ùïä}</li>
<li>Pa = {pa‚Çõ : s ‚àà ùïä}</li>
</ul>
<p>where ùïä is the set of immediate child subsystems of a Diagram. Note that the higher-level built-in trackers (all_state, all_parameters, configuration, etc.) do not require special treatment. They simply subscribe to some or all of the diagram source trackers listed above. They may also subscribe to time, accuracy, and diagram-level input ports, none of which have dependencies on child subsystems.</p>
<p>In addition to composite sources, Diagrams have a limited set of built-in computations that are composites of their children's corresponding computations. These are</p>
<ul>
<li>xcdot: composite time derivatives</li>
<li>pe: summed potential energy</li>
<li>ke: summed kinetic energy</li>
<li>pc: summed conservative power</li>
<li>pnc: summed non-conservative power</li>
</ul>
<p>Each of these has a cache entry and an associated Calc() method that sets the cache value by visiting the children to Eval() the corresponding quantities, which are then combined to produce the composite quantity. xcdot is just a container for the collected child quantities so just needs to ensure these are up to date. Energy and power are scalars formed by summing the corresponding scalar quantities from each child subsystem. To ensure that the diagram cache entries are updated appropriately, they subscribe to the corresponding child cache entries' dependency trackers. That way if a leaf quantity gets notified of a leaf context change, any composite diagram quantity that needs that leaf quantity is automatically notified also.</p>
<p>Modifications to state variables and parameters are always initiated through one of the mutable methods of the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> class, but not necessarily at the root <a class="el" href="classdrake_1_1systems_1_1_diagram_context.html" title="The DiagramContext is a container for all of the data necessary to uniquely determine the computation...">DiagramContext</a> of a Context tree. Wherever a modification is initiated, we must propagate that change in both directions: down to the child subsystems, and up to the parent diagram. If someone changes the root diagram Q, that is a change to each of its constituents q‚Çõ, so we need to notify "down" to the trackers for each of those, to make sure that subsystem s computations that depend on q‚Çõ will be properly marked "out of date". In the "up" direction, a user who has access to one of the child subcontexts may initiate a change to a q‚Çõ; that should be propagated to the diagram Q since some part of it has changed.</p>
<p>We implement the two directions asymmetrically. The "up" direction is implemented simply by subscribing every diagram-level tracker to each of its constituent object's trackers. That way any change to a constituent notifies its parent via the usual subscriber notification code. Other than the code to set up the subscriptions properly, there is no explicit code needed to handle the "up" notifications. See <code>DiagramContext::SubscribeDiagramCompositeTrackersToChildrens()</code> for the code that sets up these subscriptions. The following table shows the Diagram-specific notifications and subscriptions:</p>
<table class="doxtable">
<tr>
<th align="left"><a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> tracker </th><th align="left">Notifications sent ("down") </th><th align="left">Subscribes to ("up")  </th></tr>
<tr>
<td align="left">time </td><td align="left">subsystem time </td><td align="left">‚Äî ¬π </td></tr>
<tr>
<td align="left">accuracy </td><td align="left">subsystem accuracy </td><td align="left">‚Äî ¬π </td></tr>
<tr>
<td align="left">q </td><td align="left">subsystem q </td><td align="left">subsystem q </td></tr>
<tr>
<td align="left">v </td><td align="left">subsystem v </td><td align="left">subsystem v </td></tr>
<tr>
<td align="left">z </td><td align="left">subsystem z </td><td align="left">subsystem z </td></tr>
<tr>
<td align="left">xd </td><td align="left">subsystem xd </td><td align="left">subsystem xd </td></tr>
<tr>
<td align="left">xa </td><td align="left">subsystem xa </td><td align="left">subsystem xa </td></tr>
<tr>
<td align="left">pn </td><td align="left">subsystem pn </td><td align="left">subsystem pn </td></tr>
<tr>
<td align="left">pa </td><td align="left">subsystem pa </td><td align="left">subsystem pa </td></tr>
<tr>
<td align="left">xcdot </td><td align="left">‚Äî </td><td align="left">subsystem xcdot </td></tr>
<tr>
<td align="left">pe </td><td align="left">‚Äî </td><td align="left">subsystem pe </td></tr>
<tr>
<td align="left">ke </td><td align="left">‚Äî </td><td align="left">subsystem ke </td></tr>
<tr>
<td align="left">pc </td><td align="left">‚Äî </td><td align="left">subsystem pc </td></tr>
<tr>
<td align="left">pnc </td><td align="left">‚Äî </td><td align="left">subsystem pnc </td></tr>
</table>
<p><em>Notes</em></p>
<ol type="1">
<li>Time and accuracy can be set only in the root <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> so can only propagate downward.</li>
</ol>
<p>The "down" direction <em>could</em> have been handled via subscriptions also, at the cost of introducing cycles into the dependency DAG (the "change event" would serve to break those cycles during notification sweeps). Instead, the "down" direction is implemented via bespoke code for the <a class="el" href="classdrake_1_1systems_1_1_context.html#context_value_change_methods">Context modification methods</a> that recursively visits each subcontext and executes the same modification and out of date notifications there. That is similar to the treatment of local composite trackers as discussed in <a class="el" href="group__cache__design__notes.html#cache_handling_composite_trackers">Handling of composite trackers</a> above.</p>
<p>Note that a lower-level subcontext may also have fixed input port values, and that a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> is completely unaware of any subsystem input ports whose values have been fixed locally. When a subcontext fixed input port value changes, all downstream computations are properly notified. For example, a subcontext time derivative cache entry might depend on the fixed input port. As long as the composite Diagram time derivatives cache entry has subscribed to its subsystems' time derivative cache entries, that change will also mark the Diagram time derivative out of date.</p>
<p><a class="anchor" id="cache_design_implementation"></a></p><h2>Implementation</h2>
<p>The logical cache entry object is split into two pieces to reflect the const and mutable aspects. Given a CacheIndex, either piece may be obtained very efficiently. The <code>const</code> part is a <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> owned by the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>, and consists of:</p>
<ul>
<li>The Allocator() and Calculator() methods,</li>
<li>a list of the Calculator's prerequisites, and</li>
<li>the assigned dependency ticket for this cache entry.</li>
</ul>
<p>The mutable part is a <a class="el" href="classdrake_1_1systems_1_1_cache_entry_value.html" title="This is the representation in the Context for the value of one of a System&#39;s CacheEntry objects...">CacheEntryValue</a> and associated <a class="el" href="classdrake_1_1systems_1_1_dependency_tracker.html" title="Manages value interdependencies for a particular value or set of values in a Context. ">DependencyTracker</a>, both owned by the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. The <a class="el" href="classdrake_1_1systems_1_1_cache_entry_value.html" title="This is the representation in the Context for the value of one of a System&#39;s CacheEntry objects...">CacheEntryValue</a> is designed to optimize access efficiency. It contains:</p>
<ul>
<li>an <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html" title="A fully type-erased container class. ">AbstractValue</a> (obtained by invoking the Allocator()), and</li>
<li>a flag indicating whether the value is out of date with respect to its prerequisites, and</li>
<li>a serial number that is incremented whenever the contained value changes, and</li>
<li>the index to its <a class="el" href="classdrake_1_1systems_1_1_dependency_tracker.html" title="Manages value interdependencies for a particular value or set of values in a Context. ">DependencyTracker</a> (i.e. the ticket).</li>
</ul>
<p>When a prerequisite of a cache entry value changes, the associated <a class="el" href="classdrake_1_1systems_1_1_dependency_tracker.html" title="Manages value interdependencies for a particular value or set of values in a Context. ">DependencyTracker</a> sets its <a class="el" href="classdrake_1_1systems_1_1_cache_entry_value.html" title="This is the representation in the Context for the value of one of a System&#39;s CacheEntry objects...">CacheEntryValue</a>'s "out of date" boolean <code>true</code>. When a new value is computed and assigned the "out of date" boolean is cleared to <code>false</code> by the code that performed the assignment. For debugging and performance analysis, there is also a flag indicating whether caching has been disabled for this entry, in which case the value is considered in need of recomputation every time it is accessed. The out of date flag operates even when caching is disabled but is ignored in that case by Eval() methods. The sense of these flags is chosen so that only a single check that an int is zero is required to know that a value may be returned without computation.</p>
<p>To summarize, the Eval() method for a <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> operates as follows:</p>
<ol type="1">
<li>The <a class="el" href="classdrake_1_1systems_1_1_cache_entry_value.html" title="This is the representation in the Context for the value of one of a System&#39;s CacheEntry objects...">CacheEntryValue</a> is obtained using an array index into the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>'s cache.</li>
<li>If the value is out of date (or caching is disabled), call the Calc() method to bring it up to date, and clear the "out of date" boolean to false.</li>
<li>Return a reference to the cache entry's <a class="el" href="classdrake_1_1systems_1_1_abstract_value.html" title="A fully type-erased container class. ">AbstractValue</a>.</li>
<li>Downcast to the specified concrete type.</li>
</ol>
<p>The <a class="el" href="classdrake_1_1systems_1_1_dependency_tracker.html" title="Manages value interdependencies for a particular value or set of values in a Context. ">DependencyTracker</a> is designed to optimize invalidation efficiency. It contains:</p>
<ul>
<li>Pointers to the prerequisite DependencyTrackers to which it has subscribed,</li>
<li>pointers to downstream subscribers that have registered as dependents of this cache entry,</li>
<li>a pointer back to the <a class="el" href="classdrake_1_1systems_1_1_cache_entry_value.html" title="This is the representation in the Context for the value of one of a System&#39;s CacheEntry objects...">CacheEntryValue</a> for efficient invalidation, and</li>
<li>bookkeeping and statistics-gathering members.</li>
</ul>
<p>A prerequisite change to a particular value source works like this:</p>
<ol type="1">
<li>A "set" method or method providing mutable access to a source is invoked on a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.</li>
<li>A unique "change event" number N is assigned.</li>
<li>The ticket associated with the source is used to find its <a class="el" href="classdrake_1_1systems_1_1_dependency_tracker.html" title="Manages value interdependencies for a particular value or set of values in a Context. ">DependencyTracker</a> (just an array index operation).</li>
<li>The tracker's notification method is invoked, providing the change event number N.</li>
<li>The tracker records N, and then notifies all trackers on its "subscribers" list that change event N is occurring.</li>
<li>A notified tracker first checks its recorded change event number. If it is already set to N then no further action is taken. Otherwise, it records N, marks the associated cache entry (if any) out of date, and recursively notifies all trackers on its "subscribers" list.</li>
</ol>
<p>For efficiency, changes to multiple value sources can be grouped into the same change event. Also, <a class="el" href="classdrake_1_1systems_1_1_dependency_tracker.html" title="Manages value interdependencies for a particular value or set of values in a Context. ">DependencyTracker</a> subscriber lists and cache entry references are just direct pointers (internal to the overall diagram <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>) so no lookups are required. This is very fast but makes cloning a Context more difficult because the pointers must be fixed up to point to corresponding entities in the clone.</p>
<p>(Note that the "down" direction for <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> notifications (as described above) currently uses bespoke recursive code to notify all the subsystems. It would likely be faster to use the subscription mechanism there also.)</p>
<p><a class="anchor" id="cache_design_loose_ends"></a></p><h2>Notes &amp; Loose Ends</h2>
<h3>No cross pointers</h3>
<p>It is important to emphasize that a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> <em>never</em> contains pointers to a particular <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>. Thus the allocator and calculator functors for a cache entry reside in the (sub)System, not in the (sub)Context. That implies that you cannot evaluate a cache entry without both a System and a Context. It also means you can use the same Context with different Systems, and that a Context could be serialized then deserialized to use later, provided that a compatible System is available.</p>
<h3>System vs Context</h3>
<p>Drake's <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> framework provides a careful separation between the persistent structure of a System and its ephemeral values (<a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>). The structure is represented in const objects derived from <a class="el" href="classdrake_1_1systems_1_1_system_base.html" title="Provides non-templatized functionality shared by the templatized System classes. ">SystemBase</a>, while the values are represented in mutable objects derived from <a class="el" href="classdrake_1_1systems_1_1_context_base.html" title="Provides non-templatized Context functionality shared by the templatized derived classes. ">ContextBase</a>. Generally that means that what are logically single objects are split into two separate classes. Since users are intended to interact primarily with System objects, we use the logical names for the System half of the object, and more obscure names for the Context half that stores the runtime values. Here are some examples:</p>
<table class="doxtable">
<tr>
<th align="left">Logical object </th><th align="left">System-side class </th><th align="left">Context-side class  </th></tr>
<tr>
<td align="left">System </td><td align="left"><a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> </td><td align="left"><a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> </td></tr>
<tr>
<td align="left">Output port </td><td align="left"><a class="el" href="classdrake_1_1systems_1_1_output_port.html" title="An OutputPort belongs to a System and represents the properties of one of that System&#39;s output ports...">OutputPort</a> </td><td align="left">(cache entry) </td></tr>
<tr>
<td align="left">Input port </td><td align="left"><a class="el" href="classdrake_1_1systems_1_1_input_port.html" title="This extends InputPortBase with some scalar type-dependent methods. ">InputPort</a> </td><td align="left"><a class="el" href="classdrake_1_1systems_1_1_fixed_input_port_value.html" title="A FixedInputPortValue encapsulates a vector or abstract value for use as an internal value source for...">FixedInputPortValue</a> </td></tr>
<tr>
<td align="left">Cache entry </td><td align="left"><a class="el" href="classdrake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> </td><td align="left"><a class="el" href="classdrake_1_1systems_1_1_cache_entry_value.html" title="This is the representation in the Context for the value of one of a System&#39;s CacheEntry objects...">CacheEntryValue</a> </td></tr>
<tr>
<td align="left">Dependency tracker </td><td align="left">(ticket only) </td><td align="left"><a class="el" href="classdrake_1_1systems_1_1_dependency_tracker.html" title="Manages value interdependencies for a particular value or set of values in a Context. ">DependencyTracker</a> </td></tr>
</table>
<p>The System-side objects are used for declaring the computational structure of a <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a>; the Context-side objects are used to maintain correct current values. For example, the necessary allocation and calculation methods for a cache entry are stored in the System-side <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> object in the System, while the result of executing those methods is stored in the corresponding <a class="el" href="classdrake_1_1systems_1_1_cache_entry_value.html" title="This is the representation in the Context for the value of one of a System&#39;s CacheEntry objects...">CacheEntryValue</a> object in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.</p>
<h3>Output Port cache entries</h3>
<p>Each port and each cache entry is assigned a unique <a class="el" href="classdrake_1_1systems_1_1_dependency_tracker.html" title="Manages value interdependencies for a particular value or set of values in a Context. ">DependencyTracker</a> object. Output ports generally also have their own cache entries for storing their values; that results in two DependencyTrackers &ndash; the output port DependencyTracker lists its cache entry's DependencyTracker as a prerequisite. (TODO: In the initial implementation there will always be a cache entry assigned for leaf output ports, but this design is intended to allow output ports to forward from other sources without making unnecessary copies &ndash; an output port DependencyTracker is still needed in those cases even though there won't be an associated cache entry.)</p>
<p>The <code>Calc()</code> function and list of prerequisite supplied to the <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#DeclareLeafOutputPort_documentation">declare output ports APIs</a> are used directly to construct the output port's cache entry.</p>
<h3>Declaring dependencies for built-in computations</h3>
<p>The built-in computations like time derivatives, energy, and power are associated with bespoke "Calc" methods which need to have known dependency lists. Rather than add these with yet more <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input...">System</a> methods, we should consider changing the API to define them analogously to the <a class="el" href="classdrake_1_1systems_1_1_output_port.html" title="An OutputPort belongs to a System and represents the properties of one of that System&#39;s output ports...">OutputPort</a> and <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> declarations which accept Allocator() and Calculator() functors and a dependency list for the Calculator(). Currently they are just defaulting to "depends on everything".</p>
<p>See Drake issue <a href="https://github.com/RobotLocomotion/drake/issues/9205">#9205</a> on GitHub for a checklist of caching loose ends. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
