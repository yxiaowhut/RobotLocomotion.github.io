<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: MathematicalProgram Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdrake_1_1solvers_1_1_mathematical_program.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classdrake_1_1solvers_1_1_mathematical_program-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MathematicalProgram Class Reference<div class="ingroups"><a class="el" href="group__solvers.html">Formulating and Solving Optimization Problems</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> stores the decision variables, the constraints and costs of an optimization problem.  
 <a href="classdrake_1_1solvers_1_1_mathematical_program.html#details">More...</a></p>

<p><code>#include &lt;drake/solvers/mathematical_program.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_mathematical_program_1_1_solver_data.html">SolverData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a407fb21fc13a5122994e71a05a6a0818"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> { <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">kSos</a>, 
<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a28b23c4ed46cc23775486c764a920e29">kSdsos</a>, 
<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a26e1dbaa56329cec4d3ba803424aed81">kDsos</a>
 }<tr class="memdesc:a407fb21fc13a5122994e71a05a6a0818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of non-negative polynomial that can be found through conic optimization.  <a href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a407fb21fc13a5122994e71a05a6a0818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed05d048d1ac7b1d4960e328c20d02f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aaed05d048d1ac7b1d4960e328c20d02f">VarType</a> = <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">symbolic::Variable::Type</a></td></tr>
<tr class="separator:aaed05d048d1ac7b1d4960e328c20d02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac577d0f44c9c07256230cf2642ec6822"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> ()</td></tr>
<tr class="separator:ac577d0f44c9c07256230cf2642ec6822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d19f450570339ad19df40415cb3592"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a65d19f450570339ad19df40415cb3592">~MathematicalProgram</a> ()</td></tr>
<tr class="separator:a65d19f450570339ad19df40415cb3592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf8eca4db252695b1950209857df07a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8bf8eca4db252695b1950209857df07a">Clone</a> () const</td></tr>
<tr class="memdesc:a8bf8eca4db252695b1950209857df07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones an optimization program.  <a href="#a8bf8eca4db252695b1950209857df07a">More...</a><br /></td></tr>
<tr class="separator:a8bf8eca4db252695b1950209857df07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53949966a66a6f53ba90596fc5a439ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a53949966a66a6f53ba90596fc5a439ef">NewContinuousVariables</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>=&quot;x&quot;)</td></tr>
<tr class="memdesc:a53949966a66a6f53ba90596fc5a439ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds continuous variables, appending them to an internal vector of any existing vars.  <a href="#a53949966a66a6f53ba90596fc5a439ef">More...</a><br /></td></tr>
<tr class="separator:a53949966a66a6f53ba90596fc5a439ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd612c938a2bb1887476dadf65dd0a5"><td class="memTemplParams" colspan="2">template&lt;int Rows = Eigen::Dynamic, int Cols = Eigen::Dynamic&gt; </td></tr>
<tr class="memitem:a2cd612c938a2bb1887476dadf65dd0a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a2cd612c938a2bb1887476dadf65dd0a5">NewContinuousVariables</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>=&quot;X&quot;)</td></tr>
<tr class="memdesc:a2cd612c938a2bb1887476dadf65dd0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds continuous variables, appending them to an internal vector of any existing vars.  <a href="#a2cd612c938a2bb1887476dadf65dd0a5">More...</a><br /></td></tr>
<tr class="separator:a2cd612c938a2bb1887476dadf65dd0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f22188fff7a464ac091b8fea727a89d"><td class="memTemplParams" colspan="2">template&lt;int Rows, int Cols = 1&gt; </td></tr>
<tr class="memitem:a8f22188fff7a464ac091b8fea727a89d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8f22188fff7a464ac091b8fea727a89d">NewContinuousVariables</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>=&quot;X&quot;)</td></tr>
<tr class="memdesc:a8f22188fff7a464ac091b8fea727a89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds continuous variables, appending them to an internal vector of any existing vars.  <a href="#a8f22188fff7a464ac091b8fea727a89d">More...</a><br /></td></tr>
<tr class="separator:a8f22188fff7a464ac091b8fea727a89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e5827a62c6aadac95e0a053cf3fe08"><td class="memTemplParams" colspan="2">template&lt;int Rows = Eigen::Dynamic, int Cols = Eigen::Dynamic&gt; </td></tr>
<tr class="memitem:ae4e5827a62c6aadac95e0a053cf3fe08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae4e5827a62c6aadac95e0a053cf3fe08">NewBinaryVariables</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>)</td></tr>
<tr class="memdesc:ae4e5827a62c6aadac95e0a053cf3fe08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds binary variables, appending them to an internal vector of any existing vars.  <a href="#ae4e5827a62c6aadac95e0a053cf3fe08">More...</a><br /></td></tr>
<tr class="separator:ae4e5827a62c6aadac95e0a053cf3fe08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b5acd86b0429f7cd22b04355f1f774"><td class="memTemplParams" colspan="2">template&lt;int Rows, int Cols = 1&gt; </td></tr>
<tr class="memitem:a07b5acd86b0429f7cd22b04355f1f774"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a07b5acd86b0429f7cd22b04355f1f774">NewBinaryVariables</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>=&quot;b&quot;)</td></tr>
<tr class="memdesc:a07b5acd86b0429f7cd22b04355f1f774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a matrix of binary variables into the optimization program.  <a href="#a07b5acd86b0429f7cd22b04355f1f774">More...</a><br /></td></tr>
<tr class="separator:a07b5acd86b0429f7cd22b04355f1f774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30759ec657805673fd0ce5e9edc166a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a30759ec657805673fd0ce5e9edc166a2">NewBinaryVariables</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>=&quot;b&quot;)</td></tr>
<tr class="memdesc:a30759ec657805673fd0ce5e9edc166a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds binary variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="#a30759ec657805673fd0ce5e9edc166a2">More...</a><br /></td></tr>
<tr class="separator:a30759ec657805673fd0ce5e9edc166a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f718351922bc149cb6e7fa6d82288a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8f718351922bc149cb6e7fa6d82288a5">NewSymmetricContinuousVariables</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>=&quot;Symmetric&quot;)</td></tr>
<tr class="memdesc:a8f718351922bc149cb6e7fa6d82288a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a runtime sized symmetric matrix as decision variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="#a8f718351922bc149cb6e7fa6d82288a5">More...</a><br /></td></tr>
<tr class="separator:a8f718351922bc149cb6e7fa6d82288a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a84a217cea56358191de7d25c142c0"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:af9a84a217cea56358191de7d25c142c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; rows, rows &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af9a84a217cea56358191de7d25c142c0">NewSymmetricContinuousVariables</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>=&quot;Symmetric&quot;)</td></tr>
<tr class="memdesc:af9a84a217cea56358191de7d25c142c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a static sized symmetric matrix as decision variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="#af9a84a217cea56358191de7d25c142c0">More...</a><br /></td></tr>
<tr class="separator:af9a84a217cea56358191de7d25c142c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2754b7d6e748804b771b513e0df552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a2b2754b7d6e748804b771b513e0df552">AddDecisionVariables</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a24b7242d08574fad6a8b10cfc8e54bca">decision_variables</a>)</td></tr>
<tr class="memdesc:a2b2754b7d6e748804b771b513e0df552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends new variables to the end of the existing variables.  <a href="#a2b2754b7d6e748804b771b513e0df552">More...</a><br /></td></tr>
<tr class="separator:a2b2754b7d6e748804b771b513e0df552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a71c1f6466e5dedbd2cd73372dfcd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae6a71c1f6466e5dedbd2cd73372dfcd5">NewFreePolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac236784fdf749e0e3b7921f1d75de1ff">indeterminates</a>, <a class="el" href="classint.html">int</a> degree, const std::string &amp;coeff_name=&quot;a&quot;)</td></tr>
<tr class="memdesc:ae6a71c1f6466e5dedbd2cd73372dfcd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a free polynomial in a monomial basis over <code>indeterminates</code> of a given <code>degree</code>.  <a href="#ae6a71c1f6466e5dedbd2cd73372dfcd5">More...</a><br /></td></tr>
<tr class="separator:ae6a71c1f6466e5dedbd2cd73372dfcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5404758e930bc3fc23b26635092458da"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a5404758e930bc3fc23b26635092458da">NewNonnegativePolynomial</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;monomial_basis, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> <a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>)</td></tr>
<tr class="memdesc:a5404758e930bc3fc23b26635092458da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of nonnegative polynomial p = mᵀQm and the coefficient matrix Q, where m is <code>monomial_basis</code>.  <a href="#a5404758e930bc3fc23b26635092458da">More...</a><br /></td></tr>
<tr class="separator:a5404758e930bc3fc23b26635092458da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e1be270437666161b6c427209a7267"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af0e1be270437666161b6c427209a7267">NewNonnegativePolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac236784fdf749e0e3b7921f1d75de1ff">indeterminates</a>, <a class="el" href="classint.html">int</a> degree, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> <a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>)</td></tr>
<tr class="memdesc:af0e1be270437666161b6c427209a7267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of nonnegative polynomial p = mᵀQm and the coefficient matrix Q, where m is the monomial basis, containing all monomials of <code>indeterminates</code> of total order up to <code>degree</code> / 2, hence the polynomial p contains all the monomials of total order up to <code>degree</code>, as p is quadratic in m.  <a href="#af0e1be270437666161b6c427209a7267">More...</a><br /></td></tr>
<tr class="separator:af0e1be270437666161b6c427209a7267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790ff49f1d271fed2a533347c4686bf9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a790ff49f1d271fed2a533347c4686bf9">NewSosPolynomial</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;monomial_basis)</td></tr>
<tr class="memdesc:a790ff49f1d271fed2a533347c4686bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of a SOS polynomial p = mᵀQm and the coefficient matrix Q, where m is the <code>monomial</code> basis.  <a href="#a790ff49f1d271fed2a533347c4686bf9">More...</a><br /></td></tr>
<tr class="separator:a790ff49f1d271fed2a533347c4686bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559577e6f188c292f246a3866528d1e6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a559577e6f188c292f246a3866528d1e6">NewSosPolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac236784fdf749e0e3b7921f1d75de1ff">indeterminates</a>, <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="memdesc:a559577e6f188c292f246a3866528d1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of a SOS polynomial p = m(x)ᵀQm(x) of degree <code>degree</code> and the coefficient matrix Q that should be PSD, where m(x) is the result of calling <code>MonomialBasis(indeterminates, degree/2)</code>.  <a href="#a559577e6f188c292f246a3866528d1e6">More...</a><br /></td></tr>
<tr class="separator:a559577e6f188c292f246a3866528d1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0228101da15efa318a6e51349d3ff0a4"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a0228101da15efa318a6e51349d3ff0a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt; rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0228101da15efa318a6e51349d3ff0a4">NewIndeterminates</a> (const std::array&lt; std::string, rows *cols &gt; &amp;<a class="el" href="translator__test_8cc.html#a9c4192866025823ecd5592526c757c0b">names</a>)</td></tr>
<tr class="memdesc:a0228101da15efa318a6e51349d3ff0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates, appending them to an internal vector of any existing indeterminates.  <a href="#a0228101da15efa318a6e51349d3ff0a4">More...</a><br /></td></tr>
<tr class="separator:a0228101da15efa318a6e51349d3ff0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae23f7c130166d82b578205015aed630"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:aae23f7c130166d82b578205015aed630"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt; rows &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aae23f7c130166d82b578205015aed630">NewIndeterminates</a> (const std::array&lt; std::string, rows &gt; &amp;<a class="el" href="translator__test_8cc.html#a9c4192866025823ecd5592526c757c0b">names</a>)</td></tr>
<tr class="memdesc:aae23f7c130166d82b578205015aed630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates, appending them to an internal vector of any existing indeterminates.  <a href="#aae23f7c130166d82b578205015aed630">More...</a><br /></td></tr>
<tr class="separator:aae23f7c130166d82b578205015aed630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c82857db425d76e1e49d69560f989d"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a84c82857db425d76e1e49d69560f989d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt; rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a84c82857db425d76e1e49d69560f989d">NewIndeterminates</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>=&quot;X&quot;)</td></tr>
<tr class="memdesc:a84c82857db425d76e1e49d69560f989d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates, appending them to an internal vector of any existing indeterminates.  <a href="#a84c82857db425d76e1e49d69560f989d">More...</a><br /></td></tr>
<tr class="separator:a84c82857db425d76e1e49d69560f989d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d51c28aae22e905563f6b00f3c65a7"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a26d51c28aae22e905563f6b00f3c65a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt; rows &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a26d51c28aae22e905563f6b00f3c65a7">NewIndeterminates</a> (const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>=&quot;x&quot;)</td></tr>
<tr class="memdesc:a26d51c28aae22e905563f6b00f3c65a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates to the program.  <a href="#a26d51c28aae22e905563f6b00f3c65a7">More...</a><br /></td></tr>
<tr class="separator:a26d51c28aae22e905563f6b00f3c65a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd679ea34528e50d76d23f79fcd294f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0fd679ea34528e50d76d23f79fcd294f">NewIndeterminates</a> (<a class="el" href="classint.html">int</a> rows, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; std::string &gt; &amp;<a class="el" href="translator__test_8cc.html#a9c4192866025823ecd5592526c757c0b">names</a>)</td></tr>
<tr class="memdesc:a0fd679ea34528e50d76d23f79fcd294f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="#a0fd679ea34528e50d76d23f79fcd294f">More...</a><br /></td></tr>
<tr class="separator:a0fd679ea34528e50d76d23f79fcd294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ec9c4fc4ae8f5d8ff8382b227dd82f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae4ec9c4fc4ae8f5d8ff8382b227dd82f">NewIndeterminates</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>=&quot;x&quot;)</td></tr>
<tr class="memdesc:ae4ec9c4fc4ae8f5d8ff8382b227dd82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, with default name "x".  <a href="#ae4ec9c4fc4ae8f5d8ff8382b227dd82f">More...</a><br /></td></tr>
<tr class="separator:ae4ec9c4fc4ae8f5d8ff8382b227dd82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12431081348a404711db4d3bb25c8a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a12431081348a404711db4d3bb25c8a76">NewIndeterminates</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; std::string &gt; &amp;<a class="el" href="translator__test_8cc.html#a9c4192866025823ecd5592526c757c0b">names</a>)</td></tr>
<tr class="memdesc:a12431081348a404711db4d3bb25c8a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates, appending them to an internal vector of any existing vars.  <a href="#a12431081348a404711db4d3bb25c8a76">More...</a><br /></td></tr>
<tr class="separator:a12431081348a404711db4d3bb25c8a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e4fa58845ca19073b0c532431ac141"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ad7e4fa58845ca19073b0c532431ac141">NewIndeterminates</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;<a class="el" href="geometry__base__test_8cc.html#a9b45b3e13bd9167aab02e17e08916231">name</a>=&quot;X&quot;)</td></tr>
<tr class="memdesc:ad7e4fa58845ca19073b0c532431ac141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, with default name "X".  <a href="#ad7e4fa58845ca19073b0c532431ac141">More...</a><br /></td></tr>
<tr class="separator:ad7e4fa58845ca19073b0c532431ac141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c7fda7a953076c526e686a24fc1c3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a46c7fda7a953076c526e686a24fc1c3b">AddIndeterminates</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> &gt; &amp;new_indeterminates)</td></tr>
<tr class="memdesc:a46c7fda7a953076c526e686a24fc1c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates.  <a href="#a46c7fda7a953076c526e686a24fc1c3b">More...</a><br /></td></tr>
<tr class="separator:a46c7fda7a953076c526e686a24fc1c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4724865fbef538d6b26a1d1934f93166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4724865fbef538d6b26a1d1934f93166">AddVisualizationCallback</a> (const <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html#a84c15b60ba647eabef0aaa2d5dd3943e">VisualizationCallback::CallbackFunction</a> &amp;callback, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a4724865fbef538d6b26a1d1934f93166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback method to visualize intermediate results of the optimization.  <a href="#a4724865fbef538d6b26a1d1934f93166">More...</a><br /></td></tr>
<tr class="separator:a4724865fbef538d6b26a1d1934f93166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2cc4c49122282ae0b2fe0511e86817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8d2cc4c49122282ae0b2fe0511e86817">AddVisualizationCallback</a> (const <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html#a84c15b60ba647eabef0aaa2d5dd3943e">VisualizationCallback::CallbackFunction</a> &amp;callback, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a8d2cc4c49122282ae0b2fe0511e86817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback method to visualize intermediate results of the optimization.  <a href="#a8d2cc4c49122282ae0b2fe0511e86817">More...</a><br /></td></tr>
<tr class="separator:a8d2cc4c49122282ae0b2fe0511e86817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efea1b480be940fe05070939b7954ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4efea1b480be940fe05070939b7954ac">AddCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a4efea1b480be940fe05070939b7954ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic cost to the optimization program.  <a href="#a4efea1b480be940fe05070939b7954ac">More...</a><br /></td></tr>
<tr class="separator:a4efea1b480be940fe05070939b7954ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e141e79d84c40fbc83ea8e3aab7823"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a60e141e79d84c40fbc83ea8e3aab7823"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a60e141e79d84c40fbc83ea8e3aab7823">AddCost</a> (const std::shared_ptr&lt; C &gt; &amp;obj, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a60e141e79d84c40fbc83ea8e3aab7823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost type to the optimization program.  <a href="#a60e141e79d84c40fbc83ea8e3aab7823">More...</a><br /></td></tr>
<tr class="separator:a60e141e79d84c40fbc83ea8e3aab7823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f0ccf74cf7be71ca7bc12d81051cad"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a24f0ccf74cf7be71ca7bc12d81051cad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a24f0ccf74cf7be71ca7bc12d81051cad">AddCost</a> (const std::shared_ptr&lt; C &gt; &amp;obj, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a24f0ccf74cf7be71ca7bc12d81051cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic cost to the optimization program.  <a href="#a24f0ccf74cf7be71ca7bc12d81051cad">More...</a><br /></td></tr>
<tr class="separator:a24f0ccf74cf7be71ca7bc12d81051cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dd64529a087eec92208ac063f984fa"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ac3dd64529a087eec92208ac063f984fa"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1solvers_1_1detail_1_1is__cost__functor__candidate.html">detail::is_cost_functor_candidate</a>&lt; <a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac3dd64529a087eec92208ac063f984fa">AddCost</a> (<a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &amp;&amp;f, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:ac3dd64529a087eec92208ac063f984fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost to the optimization program on a list of variables.  <a href="#ac3dd64529a087eec92208ac063f984fa">More...</a><br /></td></tr>
<tr class="separator:ac3dd64529a087eec92208ac063f984fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b84fed8288d7fd99ecde678c14bc04"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a36b84fed8288d7fd99ecde678c14bc04"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1solvers_1_1detail_1_1is__cost__functor__candidate.html">detail::is_cost_functor_candidate</a>&lt; <a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a36b84fed8288d7fd99ecde678c14bc04">AddCost</a> (<a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &amp;&amp;f, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a36b84fed8288d7fd99ecde678c14bc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost to the optimization program on an Eigen::Vector containing decision variables.  <a href="#a36b84fed8288d7fd99ecde678c14bc04">More...</a><br /></td></tr>
<tr class="separator:a36b84fed8288d7fd99ecde678c14bc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6efe825a3e8d2532cb52196c31560d"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Vars &gt; </td></tr>
<tr class="memitem:a4f6efe825a3e8d2532cb52196c31560d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1solvers_1_1detail_1_1assert__if__is__constraint.html">detail::assert_if_is_constraint</a>&lt; <a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4f6efe825a3e8d2532cb52196c31560d">AddCost</a> (<a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &amp;&amp;, Vars &amp;&amp;)</td></tr>
<tr class="memdesc:a4f6efe825a3e8d2532cb52196c31560d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically assert if a user inadvertently passes a binding-compatible <a class="el" href="classdrake_1_1solvers_1_1_constraint.html" title="A constraint is a function + lower and upper bounds. ">Constraint</a>.  <a href="#a4f6efe825a3e8d2532cb52196c31560d">More...</a><br /></td></tr>
<tr class="separator:a4f6efe825a3e8d2532cb52196c31560d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9361760e08efc82cecdb7d73abdaf08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af9361760e08efc82cecdb7d73abdaf08">AddCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:af9361760e08efc82cecdb7d73abdaf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form c'*x.  <a href="#af9361760e08efc82cecdb7d73abdaf08">More...</a><br /></td></tr>
<tr class="separator:af9361760e08efc82cecdb7d73abdaf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8dae8551794a05aadea978f2ae5ae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8a8dae8551794a05aadea978f2ae5ae3">AddLinearCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a8a8dae8551794a05aadea978f2ae5ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost term of the form a'*x + b.  <a href="#a8a8dae8551794a05aadea978f2ae5ae3">More...</a><br /></td></tr>
<tr class="separator:a8a8dae8551794a05aadea978f2ae5ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d909ab79bbc45767206daaa8d145c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ab5d909ab79bbc45767206daaa8d145c8">AddLinearCost</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;a, <a class="el" href="classdouble.html">double</a> b, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:ab5d909ab79bbc45767206daaa8d145c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost term of the form a'*x + b.  <a href="#ab5d909ab79bbc45767206daaa8d145c8">More...</a><br /></td></tr>
<tr class="separator:ab5d909ab79bbc45767206daaa8d145c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc63e8400b182a07b2b9372a4418114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3bc63e8400b182a07b2b9372a4418114">AddLinearCost</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;a, <a class="el" href="classdouble.html">double</a> b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a3bc63e8400b182a07b2b9372a4418114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost term of the form a'*x + b.  <a href="#a3bc63e8400b182a07b2b9372a4418114">More...</a><br /></td></tr>
<tr class="separator:a3bc63e8400b182a07b2b9372a4418114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06dbd6c1bf0971fc28366df95ee1bca2"><td class="memTemplParams" colspan="2">template&lt;typename VarType &gt; </td></tr>
<tr class="memitem:a06dbd6c1bf0971fc28366df95ee1bca2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a06dbd6c1bf0971fc28366df95ee1bca2">AddLinearCost</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;a, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">VarType</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a06dbd6c1bf0971fc28366df95ee1bca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost term of the form a'*x.  <a href="#a06dbd6c1bf0971fc28366df95ee1bca2">More...</a><br /></td></tr>
<tr class="separator:a06dbd6c1bf0971fc28366df95ee1bca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413bc850a691a89ffd076b6bfbd6ffea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a413bc850a691a89ffd076b6bfbd6ffea">AddCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a413bc850a691a89ffd076b6bfbd6ffea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form 0.5*x'*Q*x + b'x.  <a href="#a413bc850a691a89ffd076b6bfbd6ffea">More...</a><br /></td></tr>
<tr class="separator:a413bc850a691a89ffd076b6bfbd6ffea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a78776183f17d6ec22b4e3a9d27cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ab9a78776183f17d6ec22b4e3a9d27cdb">AddQuadraticCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab9a78776183f17d6ec22b4e3a9d27cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a quadratic cost term of the form 0.5*x'*Q*x + b'*x + c.  <a href="#ab9a78776183f17d6ec22b4e3a9d27cdb">More...</a><br /></td></tr>
<tr class="separator:ab9a78776183f17d6ec22b4e3a9d27cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae7eae6436a037740a2b8b7ba31f123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1ae7eae6436a037740a2b8b7ba31f123">AddQuadraticErrorCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_desired, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a1ae7eae6436a037740a2b8b7ba31f123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired).  <a href="#a1ae7eae6436a037740a2b8b7ba31f123">More...</a><br /></td></tr>
<tr class="separator:a1ae7eae6436a037740a2b8b7ba31f123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b19f7bda6ac7551c6d0213b40527bf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3b19f7bda6ac7551c6d0213b40527bf5">AddQuadraticErrorCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_desired, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a3b19f7bda6ac7551c6d0213b40527bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired).  <a href="#a3b19f7bda6ac7551c6d0213b40527bf5">More...</a><br /></td></tr>
<tr class="separator:a3b19f7bda6ac7551c6d0213b40527bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a915ebc93c14da19b845df70e95bf6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a2a915ebc93c14da19b845df70e95bf6c">AddL2NormCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a2a915ebc93c14da19b845df70e95bf6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form | Ax - b |^2.  <a href="#a2a915ebc93c14da19b845df70e95bf6c">More...</a><br /></td></tr>
<tr class="separator:a2a915ebc93c14da19b845df70e95bf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12e1f27eb841aef6de75e3e7e5a96fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae12e1f27eb841aef6de75e3e7e5a96fe">AddL2NormCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:ae12e1f27eb841aef6de75e3e7e5a96fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form | Ax - b |^2.  <a href="#ae12e1f27eb841aef6de75e3e7e5a96fe">More...</a><br /></td></tr>
<tr class="separator:ae12e1f27eb841aef6de75e3e7e5a96fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9708627dc1a8b2def71c1524006092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aae9708627dc1a8b2def71c1524006092">AddQuadraticCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:aae9708627dc1a8b2def71c1524006092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form 0.5*x'*Q*x + b'x.  <a href="#aae9708627dc1a8b2def71c1524006092">More...</a><br /></td></tr>
<tr class="separator:aae9708627dc1a8b2def71c1524006092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc7aa67cc26a874779ec034ab47d679"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a6cc7aa67cc26a874779ec034ab47d679">AddQuadraticCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, <a class="el" href="classdouble.html">double</a> c, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a6cc7aa67cc26a874779ec034ab47d679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form 0.5*x'*Q*x + b'x + c Applied to subset of the variables.  <a href="#a6cc7aa67cc26a874779ec034ab47d679">More...</a><br /></td></tr>
<tr class="separator:a6cc7aa67cc26a874779ec034ab47d679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b50b2f95a7c6c064f65d5a54449be06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a2b50b2f95a7c6c064f65d5a54449be06">AddQuadraticCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a2b50b2f95a7c6c064f65d5a54449be06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form 0.5*x'*Q*x + b'x Applied to subset of the variables.  <a href="#a2b50b2f95a7c6c064f65d5a54449be06">More...</a><br /></td></tr>
<tr class="separator:a2b50b2f95a7c6c064f65d5a54449be06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaac50719294dcb0ddad7ccb1df3ae03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_polynomial_cost.html">PolynomialCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#acaac50719294dcb0ddad7ccb1df3ae03">AddPolynomialCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acaac50719294dcb0ddad7ccb1df3ae03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term in the polynomial form.  <a href="#acaac50719294dcb0ddad7ccb1df3ae03">More...</a><br /></td></tr>
<tr class="separator:acaac50719294dcb0ddad7ccb1df3ae03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeaa05fb1b97a02f8d14c393bebe68bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#adeaa05fb1b97a02f8d14c393bebe68bf">AddCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:adeaa05fb1b97a02f8d14c393bebe68bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost in the symbolic form.  <a href="#adeaa05fb1b97a02f8d14c393bebe68bf">More...</a><br /></td></tr>
<tr class="separator:adeaa05fb1b97a02f8d14c393bebe68bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05fa6863859ca8be0153e10c29def11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af05fa6863859ca8be0153e10c29def11">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:af05fa6863859ca8be0153e10c29def11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic constraint to the program.  <a href="#af05fa6863859ca8be0153e10c29def11">More...</a><br /></td></tr>
<tr class="separator:af05fa6863859ca8be0153e10c29def11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94e40b82b4d9d62a702cf6636493416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ab94e40b82b4d9d62a702cf6636493416">AddConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, <a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub)</td></tr>
<tr class="memdesc:ab94e40b82b4d9d62a702cf6636493416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of constraint lb &lt;= e &lt;= ub where <code>e</code> is a symbolic expression.  <a href="#ab94e40b82b4d9d62a702cf6636493416">More...</a><br /></td></tr>
<tr class="separator:ab94e40b82b4d9d62a702cf6636493416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412ef43fcfe9a34e19b1054d8750836b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a412ef43fcfe9a34e19b1054d8750836b">AddConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;v, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub)</td></tr>
<tr class="separator:a412ef43fcfe9a34e19b1054d8750836b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d9bfe34ef20a9f343e518fccc40bd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae8d9bfe34ef20a9f343e518fccc40bd6">AddConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ae8d9bfe34ef20a9f343e518fccc40bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constraint represented by a symbolic formula to the program.  <a href="#ae8d9bfe34ef20a9f343e518fccc40bd6">More...</a><br /></td></tr>
<tr class="separator:ae8d9bfe34ef20a9f343e518fccc40bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801d3b07132b5d3ae66a3bf96b80a74e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a801d3b07132b5d3ae66a3bf96b80a74e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; Derived, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a801d3b07132b5d3ae66a3bf96b80a74e">AddConstraint</a> (const Eigen::ArrayBase&lt; Derived &gt; &amp;formulas)</td></tr>
<tr class="separator:a801d3b07132b5d3ae66a3bf96b80a74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c28156f900997a8fb1b0079e30fce6d"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a0c28156f900997a8fb1b0079e30fce6d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0c28156f900997a8fb1b0079e30fce6d">AddConstraint</a> (std::shared_ptr&lt; C &gt; con, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a0c28156f900997a8fb1b0079e30fce6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic constraint to the program.  <a href="#a0c28156f900997a8fb1b0079e30fce6d">More...</a><br /></td></tr>
<tr class="separator:a0c28156f900997a8fb1b0079e30fce6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d26f3d31c9cfba7144b9a0d96aebdd0"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a8d26f3d31c9cfba7144b9a0d96aebdd0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8d26f3d31c9cfba7144b9a0d96aebdd0">AddConstraint</a> (std::shared_ptr&lt; C &gt; con, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a8d26f3d31c9cfba7144b9a0d96aebdd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic constraint to the program.  <a href="#a8d26f3d31c9cfba7144b9a0d96aebdd0">More...</a><br /></td></tr>
<tr class="separator:a8d26f3d31c9cfba7144b9a0d96aebdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb35904c3fd69181dba1a7f185662473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#adb35904c3fd69181dba1a7f185662473">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:adb35904c3fd69181dba1a7f185662473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#adb35904c3fd69181dba1a7f185662473">More...</a><br /></td></tr>
<tr class="separator:adb35904c3fd69181dba1a7f185662473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d60c0944a1bf43c50dd26b6dbbc3c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7d60c0944a1bf43c50dd26b6dbbc3c1b">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a7d60c0944a1bf43c50dd26b6dbbc3c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#a7d60c0944a1bf43c50dd26b6dbbc3c1b">More...</a><br /></td></tr>
<tr class="separator:a7d60c0944a1bf43c50dd26b6dbbc3c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78a44ed429e0dea8964470adbb46218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae78a44ed429e0dea8964470adbb46218">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:ae78a44ed429e0dea8964470adbb46218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#ae78a44ed429e0dea8964470adbb46218">More...</a><br /></td></tr>
<tr class="separator:ae78a44ed429e0dea8964470adbb46218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3340539f7b90d2f7d6987eea1a7242"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aea3340539f7b90d2f7d6987eea1a7242">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;a, <a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:aea3340539f7b90d2f7d6987eea1a7242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear constraint referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#aea3340539f7b90d2f7d6987eea1a7242">More...</a><br /></td></tr>
<tr class="separator:aea3340539f7b90d2f7d6987eea1a7242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2358db7c4dc6aa23411618b1d21d9a07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a2358db7c4dc6aa23411618b1d21d9a07">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;a, <a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a2358db7c4dc6aa23411618b1d21d9a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear constraint referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#a2358db7c4dc6aa23411618b1d21d9a07">More...</a><br /></td></tr>
<tr class="separator:a2358db7c4dc6aa23411618b1d21d9a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11440aef6df9ddedfd6675ce56fe6e16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a11440aef6df9ddedfd6675ce56fe6e16">AddLinearConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, <a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub)</td></tr>
<tr class="memdesc:a11440aef6df9ddedfd6675ce56fe6e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear constraint lb &lt;= e &lt;= ub where <code>e</code> is a symbolic expression.  <a href="#a11440aef6df9ddedfd6675ce56fe6e16">More...</a><br /></td></tr>
<tr class="separator:a11440aef6df9ddedfd6675ce56fe6e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2519f91e26b48c81fbae688cf774b41d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a2519f91e26b48c81fbae688cf774b41d">AddLinearConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;v, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub)</td></tr>
<tr class="memdesc:a2519f91e26b48c81fbae688cf774b41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints represented by symbolic expressions to the program.  <a href="#a2519f91e26b48c81fbae688cf774b41d">More...</a><br /></td></tr>
<tr class="separator:a2519f91e26b48c81fbae688cf774b41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecde2056d0658ea4dac1c0e632ad353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1ecde2056d0658ea4dac1c0e632ad353">AddLinearConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a1ecde2056d0658ea4dac1c0e632ad353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a linear constraint represented by a symbolic formula to the program.  <a href="#a1ecde2056d0658ea4dac1c0e632ad353">More...</a><br /></td></tr>
<tr class="separator:a1ecde2056d0658ea4dac1c0e632ad353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62eade914da1066e0f1cf0c53dc3a3d7"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a62eade914da1066e0f1cf0c53dc3a3d7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; Derived, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a62eade914da1066e0f1cf0c53dc3a3d7">AddLinearConstraint</a> (const Eigen::ArrayBase&lt; Derived &gt; &amp;formulas)</td></tr>
<tr class="memdesc:a62eade914da1066e0f1cf0c53dc3a3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a linear constraint represented by an Eigen::Array&lt;symbolic::Formula&gt; to the program.  <a href="#a62eade914da1066e0f1cf0c53dc3a3d7">More...</a><br /></td></tr>
<tr class="separator:a62eade914da1066e0f1cf0c53dc3a3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9673db3dce831cddef02eb3345a5f809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a9673db3dce831cddef02eb3345a5f809">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a9673db3dce831cddef02eb3345a5f809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear equality constraints referencing potentially a subset of the decision variables.  <a href="#a9673db3dce831cddef02eb3345a5f809">More...</a><br /></td></tr>
<tr class="separator:a9673db3dce831cddef02eb3345a5f809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce9200575be00912b9f62ee4ea53599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#adce9200575be00912b9f62ee4ea53599">AddLinearEqualityConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, <a class="el" href="classdouble.html">double</a> b)</td></tr>
<tr class="memdesc:adce9200575be00912b9f62ee4ea53599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear constraint e = b where <code>e</code> is a symbolic expression.  <a href="#adce9200575be00912b9f62ee4ea53599">More...</a><br /></td></tr>
<tr class="separator:adce9200575be00912b9f62ee4ea53599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f626f98cede0db08541462de301bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a51f626f98cede0db08541462de301bf9">AddLinearEqualityConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a51f626f98cede0db08541462de301bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear equality constraint represented by a symbolic formula to the program.  <a href="#a51f626f98cede0db08541462de301bf9">More...</a><br /></td></tr>
<tr class="separator:a51f626f98cede0db08541462de301bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352b1445c6c1cd2f70770a7da4b7e498"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedB &gt; </td></tr>
<tr class="memitem:a352b1445c6c1cd2f70770a7da4b7e498"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector__expression__double__pair.html">is_eigen_vector_expression_double_pair</a>&lt; DerivedV, DerivedB &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a352b1445c6c1cd2f70770a7da4b7e498">AddLinearEqualityConstraint</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;v, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a352b1445c6c1cd2f70770a7da4b7e498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear equality constraints \( v = b \), where <code>v(i)</code> is a symbolic linear expression.  <a href="#a352b1445c6c1cd2f70770a7da4b7e498">More...</a><br /></td></tr>
<tr class="separator:a352b1445c6c1cd2f70770a7da4b7e498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e634ab834b9139a429d17667256b1d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedB &gt; </td></tr>
<tr class="memitem:a13e634ab834b9139a429d17667256b1d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__nonvector__expression__double__pair.html">is_eigen_nonvector_expression_double_pair</a>&lt; DerivedV, DerivedB &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a13e634ab834b9139a429d17667256b1d">AddLinearEqualityConstraint</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, <a class="el" href="classbool.html">bool</a> lower_triangle=false)</td></tr>
<tr class="memdesc:a13e634ab834b9139a429d17667256b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear equality constraint for a matrix of linear expression <code>V</code>, such that V(i, j) = B(i, j).  <a href="#a13e634ab834b9139a429d17667256b1d">More...</a><br /></td></tr>
<tr class="separator:a13e634ab834b9139a429d17667256b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aec5ef573ea5fb0667475c7e5a1914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa4aec5ef573ea5fb0667475c7e5a1914">AddLinearEqualityConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Aeq, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;beq, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:aa4aec5ef573ea5fb0667475c7e5a1914"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddLinearEqualityConstraint.  <a href="#aa4aec5ef573ea5fb0667475c7e5a1914">More...</a><br /></td></tr>
<tr class="separator:aa4aec5ef573ea5fb0667475c7e5a1914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cd4f274bef65432200b7af16fd9547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae7cd4f274bef65432200b7af16fd9547">AddLinearEqualityConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Aeq, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;beq, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:ae7cd4f274bef65432200b7af16fd9547"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddLinearEqualityConstraint.  <a href="#ae7cd4f274bef65432200b7af16fd9547">More...</a><br /></td></tr>
<tr class="separator:ae7cd4f274bef65432200b7af16fd9547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba470b9c71439a795a0d647d171f71b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#adba470b9c71439a795a0d647d171f71b">AddLinearEqualityConstraint</a> (const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;a, <a class="el" href="classdouble.html">double</a> beq, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:adba470b9c71439a795a0d647d171f71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear equality constraint referencing potentially a subset of decision variables.  <a href="#adba470b9c71439a795a0d647d171f71b">More...</a><br /></td></tr>
<tr class="separator:adba470b9c71439a795a0d647d171f71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca8d2a20e1ba47d1c658613569eb447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7ca8d2a20e1ba47d1c658613569eb447">AddLinearEqualityConstraint</a> (const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;a, <a class="el" href="classdouble.html">double</a> beq, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a7ca8d2a20e1ba47d1c658613569eb447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear equality constraint referencing potentially a subset of decision variables.  <a href="#a7ca8d2a20e1ba47d1c658613569eb447">More...</a><br /></td></tr>
<tr class="separator:a7ca8d2a20e1ba47d1c658613569eb447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e23aa9a8116a05e5ef8c9dd6d7fa5e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3e23aa9a8116a05e5ef8c9dd6d7fa5e3">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a3e23aa9a8116a05e5ef8c9dd6d7fa5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds bounding box constraints referencing potentially a subest of the decision variables.  <a href="#a3e23aa9a8116a05e5ef8c9dd6d7fa5e3">More...</a><br /></td></tr>
<tr class="separator:a3e23aa9a8116a05e5ef8c9dd6d7fa5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4d1c9278bc20bf599b1e74178f51c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1b4d1c9278bc20bf599b1e74178f51c8">AddBoundingBoxConstraint</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a1b4d1c9278bc20bf599b1e74178f51c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddBoundingBoxConstraint.  <a href="#a1b4d1c9278bc20bf599b1e74178f51c8">More...</a><br /></td></tr>
<tr class="separator:a1b4d1c9278bc20bf599b1e74178f51c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad39fd8296f6a779756b2afd9782b95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#acad39fd8296f6a779756b2afd9782b95">AddBoundingBoxConstraint</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:acad39fd8296f6a779756b2afd9782b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds bounding box constraints referencing potentially a subset of the decision variables.  <a href="#acad39fd8296f6a779756b2afd9782b95">More...</a><br /></td></tr>
<tr class="separator:acad39fd8296f6a779756b2afd9782b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c41563c9fea14a00330000b42a682fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a5c41563c9fea14a00330000b42a682fc">AddBoundingBoxConstraint</a> (<a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a5c41563c9fea14a00330000b42a682fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds bounds for a single variable.  <a href="#a5c41563c9fea14a00330000b42a682fc">More...</a><br /></td></tr>
<tr class="separator:a5c41563c9fea14a00330000b42a682fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8c7c4993cbaa6cc2ca30874be835d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a5e8c7c4993cbaa6cc2ca30874be835d7">AddBoundingBoxConstraint</a> (<a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a5e8c7c4993cbaa6cc2ca30874be835d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the same scalar lower and upper bound to every variable in the list.  <a href="#a5e8c7c4993cbaa6cc2ca30874be835d7">More...</a><br /></td></tr>
<tr class="separator:a5e8c7c4993cbaa6cc2ca30874be835d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368eb40bf59115cde7610cda3112d3f9"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a368eb40bf59115cde7610cda3112d3f9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;Derived::ColsAtCompileTime==1, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a368eb40bf59115cde7610cda3112d3f9">AddBoundingBoxConstraint</a> (<a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const Eigen::MatrixBase&lt; Derived &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a368eb40bf59115cde7610cda3112d3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the same scalar lower and upper bound to every variable in <code>vars</code>.  <a href="#a368eb40bf59115cde7610cda3112d3f9">More...</a><br /></td></tr>
<tr class="separator:a368eb40bf59115cde7610cda3112d3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cc6bbf63a154236317beff5382c04d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a68cc6bbf63a154236317beff5382c04d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp;Derived::ColsAtCompileTime !=1, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a68cc6bbf63a154236317beff5382c04d">AddBoundingBoxConstraint</a> (<a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const Eigen::MatrixBase&lt; Derived &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a68cc6bbf63a154236317beff5382c04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the same scalar lower and upper bound to every variable in <code>vars</code>.  <a href="#a68cc6bbf63a154236317beff5382c04d">More...</a><br /></td></tr>
<tr class="separator:a68cc6bbf63a154236317beff5382c04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008804cb1833a8496b6131daf8ace573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a008804cb1833a8496b6131daf8ace573">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a008804cb1833a8496b6131daf8ace573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint referencing potentially a subset of the decision variables.  <a href="#a008804cb1833a8496b6131daf8ace573">More...</a><br /></td></tr>
<tr class="separator:a008804cb1833a8496b6131daf8ace573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f5fbc13ef9deda258e09952942dee8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a37f5fbc13ef9deda258e09952942dee8">AddLorentzConeConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:a37f5fbc13ef9deda258e09952942dee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint referencing potentially a subset of the decision variables.  <a href="#a37f5fbc13ef9deda258e09952942dee8">More...</a><br /></td></tr>
<tr class="separator:a37f5fbc13ef9deda258e09952942dee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e7cbefcdcdf2e9d339100f522c3c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a13e7cbefcdcdf2e9d339100f522c3c10">AddLorentzConeConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;linear_expression, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;quadratic_expression, <a class="el" href="classdouble.html">double</a> tol=0)</td></tr>
<tr class="memdesc:a13e7cbefcdcdf2e9d339100f522c3c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint on the linear expression v1 and quadratic expression v2, such that v1 &gt;= sqrt(v2)  <a href="#a13e7cbefcdcdf2e9d339100f522c3c10">More...</a><br /></td></tr>
<tr class="separator:a13e7cbefcdcdf2e9d339100f522c3c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579bccc0dc41e5b6bf662c9aeb994fc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a579bccc0dc41e5b6bf662c9aeb994fc4">AddLorentzConeConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a579bccc0dc41e5b6bf662c9aeb994fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#a579bccc0dc41e5b6bf662c9aeb994fc4">More...</a><br /></td></tr>
<tr class="separator:a579bccc0dc41e5b6bf662c9aeb994fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d9c1941285be6b2b6e51c1e0941654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a80d9c1941285be6b2b6e51c1e0941654">AddLorentzConeConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a80d9c1941285be6b2b6e51c1e0941654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#a80d9c1941285be6b2b6e51c1e0941654">More...</a><br /></td></tr>
<tr class="separator:a80d9c1941285be6b2b6e51c1e0941654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c56319ef4614b8952aa1c4a05805783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0c56319ef4614b8952aa1c4a05805783">AddLorentzConeConstraint</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a0c56319ef4614b8952aa1c4a05805783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imposes that a vector \( x\in\mathbb{R}^m \) lies in Lorentz cone.  <a href="#a0c56319ef4614b8952aa1c4a05805783">More...</a><br /></td></tr>
<tr class="separator:a0c56319ef4614b8952aa1c4a05805783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8ae8ccec0fb23009ff8a010e5ad519"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a9a8ae8ccec0fb23009ff8a010e5ad519"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a9a8ae8ccec0fb23009ff8a010e5ad519">AddLorentzConeConstraint</a> (const Eigen::MatrixBase&lt; <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; rows &gt;&gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a9a8ae8ccec0fb23009ff8a010e5ad519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imposes that a vector \( x\in\mathbb{R}^m \) lies in Lorentz cone.  <a href="#a9a8ae8ccec0fb23009ff8a010e5ad519">More...</a><br /></td></tr>
<tr class="separator:a9a8ae8ccec0fb23009ff8a010e5ad519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a80e477decc42724b9e814d70cc339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a63a80e477decc42724b9e814d70cc339">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a63a80e477decc42724b9e814d70cc339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables.  <a href="#a63a80e477decc42724b9e814d70cc339">More...</a><br /></td></tr>
<tr class="separator:a63a80e477decc42724b9e814d70cc339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ceaba09e755defc9a689829a1ceb84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a52ceaba09e755defc9a689829a1ceb84">AddRotatedLorentzConeConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;linear_expression1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;linear_expression2, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;quadratic_expression, <a class="el" href="classdouble.html">double</a> tol=0)</td></tr>
<tr class="memdesc:a52ceaba09e755defc9a689829a1ceb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds rotated Lorentz cone constraint on the linear expression v1, v2 and quadratic expression u, such that v1 * v2 &gt;= u, v1 &gt;= 0, v2 &gt;= 0.  <a href="#a52ceaba09e755defc9a689829a1ceb84">More...</a><br /></td></tr>
<tr class="separator:a52ceaba09e755defc9a689829a1ceb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8888193e1130288e45be9edd3f47a7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af8888193e1130288e45be9edd3f47a7e">AddRotatedLorentzConeConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:af8888193e1130288e45be9edd3f47a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constraint that a symbolic expression.  <a href="#af8888193e1130288e45be9edd3f47a7e">More...</a><br /></td></tr>
<tr class="separator:af8888193e1130288e45be9edd3f47a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad038198c145926f0e63faf04b254c7a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ad038198c145926f0e63faf04b254c7a3">AddRotatedLorentzConeConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:ad038198c145926f0e63faf04b254c7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables, The linear expression \( z=Ax+b \) is in rotated Lorentz cone.  <a href="#ad038198c145926f0e63faf04b254c7a3">More...</a><br /></td></tr>
<tr class="separator:ad038198c145926f0e63faf04b254c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbaf2d641fd2fffcb7c7a3c68f0929be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#acbaf2d641fd2fffcb7c7a3c68f0929be">AddRotatedLorentzConeConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:acbaf2d641fd2fffcb7c7a3c68f0929be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables, The linear expression \( z=Ax+b \) is in rotated Lorentz cone.  <a href="#acbaf2d641fd2fffcb7c7a3c68f0929be">More...</a><br /></td></tr>
<tr class="separator:acbaf2d641fd2fffcb7c7a3c68f0929be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0b88b023b5603a6534662bf98af309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1c0b88b023b5603a6534662bf98af309">AddRotatedLorentzConeConstraint</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a1c0b88b023b5603a6534662bf98af309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose that a vector \( x\in\mathbb{R}^m \) is in rotated Lorentz cone.  <a href="#a1c0b88b023b5603a6534662bf98af309">More...</a><br /></td></tr>
<tr class="separator:a1c0b88b023b5603a6534662bf98af309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a5ef4b6da552936dabb22caae98f4b"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:af5a5ef4b6da552936dabb22caae98f4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af5a5ef4b6da552936dabb22caae98f4b">AddRotatedLorentzConeConstraint</a> (const Eigen::MatrixBase&lt; <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; rows &gt;&gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:af5a5ef4b6da552936dabb22caae98f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose that a vector \( x\in\mathbb{R}^m \) is in rotated Lorentz cone.  <a href="#af5a5ef4b6da552936dabb22caae98f4b">More...</a><br /></td></tr>
<tr class="separator:af5a5ef4b6da552936dabb22caae98f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dd1bb48c3631c7a2e0a70e50022c1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a69dd1bb48c3631c7a2e0a70e50022c1a">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a69dd1bb48c3631c7a2e0a70e50022c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear complementarity constraints referencing a subset of the decision variables.  <a href="#a69dd1bb48c3631c7a2e0a70e50022c1a">More...</a><br /></td></tr>
<tr class="separator:a69dd1bb48c3631c7a2e0a70e50022c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb8281bc9e90a665dab64afa9749542"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aefb8281bc9e90a665dab64afa9749542">AddLinearComplementarityConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;M, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;q, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:aefb8281bc9e90a665dab64afa9749542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear complementarity constraints referencing a subset of the decision variables.  <a href="#aefb8281bc9e90a665dab64afa9749542">More...</a><br /></td></tr>
<tr class="separator:aefb8281bc9e90a665dab64afa9749542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad946ddf713f3d8f248c417cf9b728ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ad946ddf713f3d8f248c417cf9b728ec8">AddLinearComplementarityConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;M, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;q, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:ad946ddf713f3d8f248c417cf9b728ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear complementarity constraints referencing a subset of the decision variables.  <a href="#ad946ddf713f3d8f248c417cf9b728ec8">More...</a><br /></td></tr>
<tr class="separator:ad946ddf713f3d8f248c417cf9b728ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f25487f506aa0756bc7aeda562822d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4f25487f506aa0756bc7aeda562822d5">AddPolynomialConstraint</a> (const <a class="el" href="polynomial_8h.html#a00cbebcd97766579bb36e35abcf44acf">VectorXPoly</a> &amp;polynomials, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="class_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">Polynomiald::VarType</a> &gt; &amp;poly_vars, const Eigen::VectorXd &amp;lb, const Eigen::VectorXd &amp;ub, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a4f25487f506aa0756bc7aeda562822d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a polynomial constraint to the program referencing a subset of the decision variables (defined in the vars parameter).  <a href="#a4f25487f506aa0756bc7aeda562822d5">More...</a><br /></td></tr>
<tr class="separator:a4f25487f506aa0756bc7aeda562822d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac119a5e6eb9a5cbb3135d2bc2d022d59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac119a5e6eb9a5cbb3135d2bc2d022d59">AddPolynomialConstraint</a> (const <a class="el" href="polynomial_8h.html#a00cbebcd97766579bb36e35abcf44acf">VectorXPoly</a> &amp;polynomials, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="class_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">Polynomiald::VarType</a> &gt; &amp;poly_vars, const Eigen::VectorXd &amp;lb, const Eigen::VectorXd &amp;ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:ac119a5e6eb9a5cbb3135d2bc2d022d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a polynomial constraint to the program referencing a subset of the decision variables (defined in the vars parameter).  <a href="#ac119a5e6eb9a5cbb3135d2bc2d022d59">More...</a><br /></td></tr>
<tr class="separator:ac119a5e6eb9a5cbb3135d2bc2d022d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaff79975646e0a4381f073a47c9974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7eaff79975646e0a4381f073a47c9974">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a7eaff79975646e0a4381f073a47c9974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a positive semidefinite constraint on a symmetric matrix.  <a href="#a7eaff79975646e0a4381f073a47c9974">More...</a><br /></td></tr>
<tr class="separator:a7eaff79975646e0a4381f073a47c9974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c66d4086096ed5206e2168d8a6fe3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a46c66d4086096ed5206e2168d8a6fe3f">AddConstraint</a> (std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; con, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;symmetric_matrix_var)</td></tr>
<tr class="memdesc:a46c66d4086096ed5206e2168d8a6fe3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a positive semidefinite constraint on a symmetric matrix.  <a href="#a46c66d4086096ed5206e2168d8a6fe3f">More...</a><br /></td></tr>
<tr class="separator:a46c66d4086096ed5206e2168d8a6fe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eede327356f097ffbe492929b4effb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1eede327356f097ffbe492929b4effb7">AddPositiveSemidefiniteConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;symmetric_matrix_var)</td></tr>
<tr class="memdesc:a1eede327356f097ffbe492929b4effb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a positive semidefinite constraint on a symmetric matrix.  <a href="#a1eede327356f097ffbe492929b4effb7">More...</a><br /></td></tr>
<tr class="separator:a1eede327356f097ffbe492929b4effb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97e94e833feb1d3570a61226b1e4a19"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aa97e94e833feb1d3570a61226b1e4a19"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa97e94e833feb1d3570a61226b1e4a19">AddPositiveSemidefiniteConstraint</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;e)</td></tr>
<tr class="memdesc:aa97e94e833feb1d3570a61226b1e4a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a positive semidefinite constraint on a symmetric matrix of symbolic expressions <code>e</code>.  <a href="#aa97e94e833feb1d3570a61226b1e4a19">More...</a><br /></td></tr>
<tr class="separator:aa97e94e833feb1d3570a61226b1e4a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b781bb7ad3b694a9d9fcbf636235469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8b781bb7ad3b694a9d9fcbf636235469">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a8b781bb7ad3b694a9d9fcbf636235469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear matrix inequality constraint to the program.  <a href="#a8b781bb7ad3b694a9d9fcbf636235469">More...</a><br /></td></tr>
<tr class="separator:a8b781bb7ad3b694a9d9fcbf636235469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cca1ac259f166dc97725ed23b7e5739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3cca1ac259f166dc97725ed23b7e5739">AddLinearMatrixInequalityConstraint</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Ref&lt; const Eigen::MatrixXd &gt;&gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a>, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a3cca1ac259f166dc97725ed23b7e5739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear matrix inequality constraint to the program.  <a href="#a3cca1ac259f166dc97725ed23b7e5739">More...</a><br /></td></tr>
<tr class="separator:a3cca1ac259f166dc97725ed23b7e5739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b15080aade12f067877a6e84006c8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a11b15080aade12f067877a6e84006c8d">AddLinearMatrixInequalityConstraint</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Ref&lt; const Eigen::MatrixXd &gt;&gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>)</td></tr>
<tr class="memdesc:a11b15080aade12f067877a6e84006c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear matrix inequality constraint to the program.  <a href="#a11b15080aade12f067877a6e84006c8d">More...</a><br /></td></tr>
<tr class="separator:a11b15080aade12f067877a6e84006c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589dbafbe9df2c711789428c7964b838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a589dbafbe9df2c711789428c7964b838">AddPositiveDiagonallyDominantMatrixConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;X)</td></tr>
<tr class="memdesc:a589dbafbe9df2c711789428c7964b838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint that a symmetric matrix is diagonally dominant with non-negative diagonal entries.  <a href="#a589dbafbe9df2c711789428c7964b838">More...</a><br /></td></tr>
<tr class="separator:a589dbafbe9df2c711789428c7964b838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d190e8e690c020760bb1eb14405759"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ad1d190e8e690c020760bb1eb14405759">AddSosConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;p, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;monomial_basis)</td></tr>
<tr class="memdesc:ad1d190e8e690c020760bb1eb14405759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints that a given polynomial <code>p</code> is a sums-of-squares (SOS), that is, <code>p</code> can be decomposed into <code>mᵀQm</code>, where m is the <code>monomial_basis</code>.  <a href="#ad1d190e8e690c020760bb1eb14405759">More...</a><br /></td></tr>
<tr class="separator:ad1d190e8e690c020760bb1eb14405759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e6a59cb48bb8b82a39f44f0eb5fae5"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a69e6a59cb48bb8b82a39f44f0eb5fae5">AddSosConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;p)</td></tr>
<tr class="memdesc:a69e6a59cb48bb8b82a39f44f0eb5fae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints that a given polynomial <code>p</code> is a sums-of-squares (SOS), that is, <code>p</code> can be decomposed into <code>mᵀQm</code>, where m is the monomial basis of all indeterminates in the program with degree equal to half the TotalDegree of <code>p</code>.  <a href="#a69e6a59cb48bb8b82a39f44f0eb5fae5">More...</a><br /></td></tr>
<tr class="separator:a69e6a59cb48bb8b82a39f44f0eb5fae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e00f880b6d61bbc722f04ee19dc7ece"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a6e00f880b6d61bbc722f04ee19dc7ece">AddSosConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;monomial_basis)</td></tr>
<tr class="memdesc:a6e00f880b6d61bbc722f04ee19dc7ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints that a given symbolic expression <code>e</code> is a sums-of-squares (SOS), that is, <code>p</code> can be decomposed into <code>mᵀQm</code>, where m is the <code>monomial_basis</code>.  <a href="#a6e00f880b6d61bbc722f04ee19dc7ece">More...</a><br /></td></tr>
<tr class="separator:a6e00f880b6d61bbc722f04ee19dc7ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1126da802ae20d4c6556cf5a1258c1cb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1126da802ae20d4c6556cf5a1258c1cb">AddSosConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a1126da802ae20d4c6556cf5a1258c1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints that a given symbolic expression <code>e</code> is a sums-of-squares (SOS), that is, <code>e</code> can be decomposed into <code>mTQm</code>.  <a href="#a1126da802ae20d4c6556cf5a1258c1cb">More...</a><br /></td></tr>
<tr class="separator:a1126da802ae20d4c6556cf5a1258c1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44e07a559ca22d055de33fa1154c095"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa44e07a559ca22d055de33fa1154c095">GetInitialGuess</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7647680c7f56fdae6dc324db6aed1e45">decision_variable</a>) const</td></tr>
<tr class="memdesc:aa44e07a559ca22d055de33fa1154c095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initial guess for a single variable.  <a href="#aa44e07a559ca22d055de33fa1154c095">More...</a><br /></td></tr>
<tr class="separator:aa44e07a559ca22d055de33fa1154c095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f923497a86e90898843b496cc3f4e5"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a14f923497a86e90898843b496cc3f4e5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a14f923497a86e90898843b496cc3f4e5">GetInitialGuess</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;decision_variable_mat) const</td></tr>
<tr class="memdesc:a14f923497a86e90898843b496cc3f4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initial guess for some variables.  <a href="#a14f923497a86e90898843b496cc3f4e5">More...</a><br /></td></tr>
<tr class="separator:a14f923497a86e90898843b496cc3f4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48cb6d2263ccf09e38932dcd27f769f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae48cb6d2263ccf09e38932dcd27f769f">SetInitialGuess</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7647680c7f56fdae6dc324db6aed1e45">decision_variable</a>, <a class="el" href="classdouble.html">double</a> variable_guess_value)</td></tr>
<tr class="memdesc:ae48cb6d2263ccf09e38932dcd27f769f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the initial guess for a single variable <code>decision_variable</code>.  <a href="#ae48cb6d2263ccf09e38932dcd27f769f">More...</a><br /></td></tr>
<tr class="separator:ae48cb6d2263ccf09e38932dcd27f769f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eca61aa09da31d13c9d476cf1b6b760"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a6eca61aa09da31d13c9d476cf1b6b760"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a6eca61aa09da31d13c9d476cf1b6b760">SetInitialGuess</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;decision_variable_mat, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;x0)</td></tr>
<tr class="memdesc:a6eca61aa09da31d13c9d476cf1b6b760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the initial guess for the decision variables stored in <code>decision_variable_mat</code> to be <code>x0</code>.  <a href="#a6eca61aa09da31d13c9d476cf1b6b760">More...</a><br /></td></tr>
<tr class="separator:a6eca61aa09da31d13c9d476cf1b6b760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35679ed5aabea90fcf4ff3b337b44f5"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ae35679ed5aabea90fcf4ff3b337b44f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae35679ed5aabea90fcf4ff3b337b44f5">SetInitialGuessForAllVariables</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;x0)</td></tr>
<tr class="memdesc:ae35679ed5aabea90fcf4ff3b337b44f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initial guess for ALL decision variables.  <a href="#ae35679ed5aabea90fcf4ff3b337b44f5">More...</a><br /></td></tr>
<tr class="separator:ae35679ed5aabea90fcf4ff3b337b44f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20c365943aa8acb50dfd6b99b7e5194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae20c365943aa8acb50dfd6b99b7e5194">Solve</a> ()</td></tr>
<tr class="memdesc:ae20c365943aa8acb50dfd6b99b7e5194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="#ae20c365943aa8acb50dfd6b99b7e5194">More...</a><br /></td></tr>
<tr class="separator:ae20c365943aa8acb50dfd6b99b7e5194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b055ec02e32a70bd184a3f17f57734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a58b055ec02e32a70bd184a3f17f57734">PrintSolution</a> ()</td></tr>
<tr class="separator:a58b055ec02e32a70bd184a3f17f57734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b58f1d09a3aec5918813ba163c1098"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a77b58f1d09a3aec5918813ba163c1098">SetSolverOption</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id, const std::string &amp;solver_option, <a class="el" href="classdouble.html">double</a> option_value)</td></tr>
<tr class="separator:a77b58f1d09a3aec5918813ba163c1098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aafa15b34bc04d8a3449f39787bc76e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3aafa15b34bc04d8a3449f39787bc76e">SetSolverOption</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id, const std::string &amp;solver_option, <a class="el" href="classint.html">int</a> option_value)</td></tr>
<tr class="separator:a3aafa15b34bc04d8a3449f39787bc76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b38acbaeb959344b7ef04e84f4c40c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a00b38acbaeb959344b7ef04e84f4c40c">SetSolverOption</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id, const std::string &amp;solver_option, const std::string &amp;option_value)</td></tr>
<tr class="separator:a00b38acbaeb959344b7ef04e84f4c40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4737cb6ed52094f3d292e0ed4ca187da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4737cb6ed52094f3d292e0ed4ca187da">solver_options</a> () const</td></tr>
<tr class="memdesc:a4737cb6ed52094f3d292e0ed4ca187da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solver options stored inside <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="#a4737cb6ed52094f3d292e0ed4ca187da">More...</a><br /></td></tr>
<tr class="separator:a4737cb6ed52094f3d292e0ed4ca187da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abf83f965123608bf855d5eef56806f"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; std::string, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7abf83f965123608bf855d5eef56806f">GetSolverOptionsDouble</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id) const</td></tr>
<tr class="separator:a7abf83f965123608bf855d5eef56806f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53e7b6bf2db39795a28138edda49638"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; std::string, <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa53e7b6bf2db39795a28138edda49638">GetSolverOptionsInt</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id) const</td></tr>
<tr class="separator:aa53e7b6bf2db39795a28138edda49638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac296d646cdfb000b49df738e9da24159"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; std::string, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac296d646cdfb000b49df738e9da24159">GetSolverOptionsStr</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id) const</td></tr>
<tr class="separator:ac296d646cdfb000b49df738e9da24159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cf76d7a3bab899a9454a9cd6d19264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a54cf76d7a3bab899a9454a9cd6d19264">GetSolverId</a> () const</td></tr>
<tr class="memdesc:a54cf76d7a3bab899a9454a9cd6d19264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of the solver that was used to solve this program.  <a href="#a54cf76d7a3bab899a9454a9cd6d19264">More...</a><br /></td></tr>
<tr class="separator:a54cf76d7a3bab899a9454a9cd6d19264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c1b4cd100b3f6f6b6a22d8e924df4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a57c1b4cd100b3f6f6b6a22d8e924df4e">GetOptimalCost</a> () const</td></tr>
<tr class="memdesc:a57c1b4cd100b3f6f6b6a22d8e924df4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for optimal cost at the solution.  <a href="#a57c1b4cd100b3f6f6b6a22d8e924df4e">More...</a><br /></td></tr>
<tr class="separator:a57c1b4cd100b3f6f6b6a22d8e924df4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f32040318cf7c8e905b0b800be60bac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a5f32040318cf7c8e905b0b800be60bac">GetLowerBoundCost</a> () const</td></tr>
<tr class="memdesc:a5f32040318cf7c8e905b0b800be60bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for lower bound on optimal cost.  <a href="#a5f32040318cf7c8e905b0b800be60bac">More...</a><br /></td></tr>
<tr class="separator:a5f32040318cf7c8e905b0b800be60bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744f8ed184bc9260b5970f7b8e12812a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a744f8ed184bc9260b5970f7b8e12812a">visualization_callbacks</a> () const</td></tr>
<tr class="memdesc:a744f8ed184bc9260b5970f7b8e12812a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all callbacks.  <a href="#a744f8ed184bc9260b5970f7b8e12812a">More...</a><br /></td></tr>
<tr class="separator:a744f8ed184bc9260b5970f7b8e12812a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76eeecc02d2b6d3f2c11b407e70baf86"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a76eeecc02d2b6d3f2c11b407e70baf86">generic_costs</a> () const</td></tr>
<tr class="memdesc:a76eeecc02d2b6d3f2c11b407e70baf86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all generic costs.  <a href="#a76eeecc02d2b6d3f2c11b407e70baf86">More...</a><br /></td></tr>
<tr class="separator:a76eeecc02d2b6d3f2c11b407e70baf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a221ef50ba7ccdff7222a5a0fb38b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a63a221ef50ba7ccdff7222a5a0fb38b7">generic_constraints</a> () const</td></tr>
<tr class="memdesc:a63a221ef50ba7ccdff7222a5a0fb38b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all generic constraints.  <a href="#a63a221ef50ba7ccdff7222a5a0fb38b7">More...</a><br /></td></tr>
<tr class="separator:a63a221ef50ba7ccdff7222a5a0fb38b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac264e3eaafb940135dfa11d3ba84c67"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aac264e3eaafb940135dfa11d3ba84c67">linear_equality_constraints</a> () const</td></tr>
<tr class="memdesc:aac264e3eaafb940135dfa11d3ba84c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for linear equality constraints.  <a href="#aac264e3eaafb940135dfa11d3ba84c67">More...</a><br /></td></tr>
<tr class="separator:aac264e3eaafb940135dfa11d3ba84c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073a43c000385cfb134619ac960ab36f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a073a43c000385cfb134619ac960ab36f">linear_costs</a> () const</td></tr>
<tr class="memdesc:a073a43c000385cfb134619ac960ab36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for linear costs.  <a href="#a073a43c000385cfb134619ac960ab36f">More...</a><br /></td></tr>
<tr class="separator:a073a43c000385cfb134619ac960ab36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67254b4fe297880931e6c66562f36353"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a67254b4fe297880931e6c66562f36353">quadratic_costs</a> () const</td></tr>
<tr class="memdesc:a67254b4fe297880931e6c66562f36353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for quadratic costs.  <a href="#a67254b4fe297880931e6c66562f36353">More...</a><br /></td></tr>
<tr class="separator:a67254b4fe297880931e6c66562f36353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5febe285490e9ce74e824de29f2ecd9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a5febe285490e9ce74e824de29f2ecd9f">linear_constraints</a> () const</td></tr>
<tr class="memdesc:a5febe285490e9ce74e824de29f2ecd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for linear constraints.  <a href="#a5febe285490e9ce74e824de29f2ecd9f">More...</a><br /></td></tr>
<tr class="separator:a5febe285490e9ce74e824de29f2ecd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9af8bd45f4e7aa63918031b0774fed0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae9af8bd45f4e7aa63918031b0774fed0">lorentz_cone_constraints</a> () const</td></tr>
<tr class="memdesc:ae9af8bd45f4e7aa63918031b0774fed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for Lorentz cone constraint.  <a href="#ae9af8bd45f4e7aa63918031b0774fed0">More...</a><br /></td></tr>
<tr class="separator:ae9af8bd45f4e7aa63918031b0774fed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8ffa00352e1b2d8f1e8cfa720dc88c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aeb8ffa00352e1b2d8f1e8cfa720dc88c">rotated_lorentz_cone_constraints</a> () const</td></tr>
<tr class="memdesc:aeb8ffa00352e1b2d8f1e8cfa720dc88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for rotated Lorentz cone constraint.  <a href="#aeb8ffa00352e1b2d8f1e8cfa720dc88c">More...</a><br /></td></tr>
<tr class="separator:aeb8ffa00352e1b2d8f1e8cfa720dc88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653ebdfdf842cca45abac0c708d1195e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a653ebdfdf842cca45abac0c708d1195e">positive_semidefinite_constraints</a> () const</td></tr>
<tr class="memdesc:a653ebdfdf842cca45abac0c708d1195e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for positive semidefinite constraint.  <a href="#a653ebdfdf842cca45abac0c708d1195e">More...</a><br /></td></tr>
<tr class="separator:a653ebdfdf842cca45abac0c708d1195e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e3ce329f648aae3bea248179013b34"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a27e3ce329f648aae3bea248179013b34">linear_matrix_inequality_constraints</a> () const</td></tr>
<tr class="memdesc:a27e3ce329f648aae3bea248179013b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for linear matrix inequality constraint.  <a href="#a27e3ce329f648aae3bea248179013b34">More...</a><br /></td></tr>
<tr class="separator:a27e3ce329f648aae3bea248179013b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90403c02bdb7c61d7a8de5dd39e9c39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ad90403c02bdb7c61d7a8de5dd39e9c39">GetAllCosts</a> () const</td></tr>
<tr class="memdesc:ad90403c02bdb7c61d7a8de5dd39e9c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter returning all costs.  <a href="#ad90403c02bdb7c61d7a8de5dd39e9c39">More...</a><br /></td></tr>
<tr class="separator:ad90403c02bdb7c61d7a8de5dd39e9c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fe85b6ddbc665b74e8cf9c6bf02d3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a17fe85b6ddbc665b74e8cf9c6bf02d3e">GetAllLinearConstraints</a> () const</td></tr>
<tr class="memdesc:a17fe85b6ddbc665b74e8cf9c6bf02d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter returning all linear constraints (both linear equality and inequality constraints).  <a href="#a17fe85b6ddbc665b74e8cf9c6bf02d3e">More...</a><br /></td></tr>
<tr class="separator:a17fe85b6ddbc665b74e8cf9c6bf02d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee45efd038cc24341094591bf1cbdbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#afee45efd038cc24341094591bf1cbdbc">GetAllConstraints</a> () const</td></tr>
<tr class="memdesc:afee45efd038cc24341094591bf1cbdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for returning all constraints.  <a href="#afee45efd038cc24341094591bf1cbdbc">More...</a><br /></td></tr>
<tr class="separator:afee45efd038cc24341094591bf1cbdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39c3045633d664d62c161a5ef4f3c4c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af39c3045633d664d62c161a5ef4f3c4c">bounding_box_constraints</a> () const</td></tr>
<tr class="memdesc:af39c3045633d664d62c161a5ef4f3c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all bounding box constraints.  <a href="#af39c3045633d664d62c161a5ef4f3c4c">More...</a><br /></td></tr>
<tr class="separator:af39c3045633d664d62c161a5ef4f3c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9e00f78efde184f9f7377ed0a42700"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1d9e00f78efde184f9f7377ed0a42700">linear_complementarity_constraints</a> () const</td></tr>
<tr class="memdesc:a1d9e00f78efde184f9f7377ed0a42700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all linear complementarity constraints.  <a href="#a1d9e00f78efde184f9f7377ed0a42700">More...</a><br /></td></tr>
<tr class="separator:a1d9e00f78efde184f9f7377ed0a42700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b609790733dca7e3b174959d2ab2c31"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b609790733dca7e3b174959d2ab2c31"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4b609790733dca7e3b174959d2ab2c31">GetSolverData</a> ()</td></tr>
<tr class="separator:a4b609790733dca7e3b174959d2ab2c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224e4c35014e87139f73f9a517866796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a224e4c35014e87139f73f9a517866796">num_vars</a> () const</td></tr>
<tr class="memdesc:a224e4c35014e87139f73f9a517866796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for number of variables in the optimization program.  <a href="#a224e4c35014e87139f73f9a517866796">More...</a><br /></td></tr>
<tr class="separator:a224e4c35014e87139f73f9a517866796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d203a1789d8fe03eeaaacdb49a267d4"><td class="memItemLeft" align="right" valign="top">const Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8d203a1789d8fe03eeaaacdb49a267d4">initial_guess</a> () const</td></tr>
<tr class="memdesc:a8d203a1789d8fe03eeaaacdb49a267d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the initial guess.  <a href="#a8d203a1789d8fe03eeaaacdb49a267d4">More...</a><br /></td></tr>
<tr class="separator:a8d203a1789d8fe03eeaaacdb49a267d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f25e54555621691b390c1658e21872f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a2f25e54555621691b390c1658e21872f">FindDecisionVariableIndex</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var) const</td></tr>
<tr class="memdesc:a2f25e54555621691b390c1658e21872f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the decision variable.  <a href="#a2f25e54555621691b390c1658e21872f">More...</a><br /></td></tr>
<tr class="separator:a2f25e54555621691b390c1658e21872f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa2cdf4c8e6fae22b6b78718aeb0db0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a5aa2cdf4c8e6fae22b6b78718aeb0db0">FindDecisionVariableIndices</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="nlopt__solver_8cc.html#a71b3bdebc1452e7157ace238fada496e">vars</a>) const</td></tr>
<tr class="memdesc:a5aa2cdf4c8e6fae22b6b78718aeb0db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indices of the decision variables.  <a href="#a5aa2cdf4c8e6fae22b6b78718aeb0db0">More...</a><br /></td></tr>
<tr class="separator:a5aa2cdf4c8e6fae22b6b78718aeb0db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1e942fc28f03d2b987fc0ea880e831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3b1e942fc28f03d2b987fc0ea880e831">num_indeterminates</a> () const</td></tr>
<tr class="memdesc:a3b1e942fc28f03d2b987fc0ea880e831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of indeterminates in the optimization program.  <a href="#a3b1e942fc28f03d2b987fc0ea880e831">More...</a><br /></td></tr>
<tr class="separator:a3b1e942fc28f03d2b987fc0ea880e831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1470ed93553619a1f630bc8035947556"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1470ed93553619a1f630bc8035947556">FindIndeterminateIndex</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var) const</td></tr>
<tr class="memdesc:a1470ed93553619a1f630bc8035947556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the indeterminate.  <a href="#a1470ed93553619a1f630bc8035947556">More...</a><br /></td></tr>
<tr class="separator:a1470ed93553619a1f630bc8035947556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f9009b5477548c86d6253f21975323"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad3f9009b5477548c86d6253f21975323"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ad3f9009b5477548c86d6253f21975323">GetSolution</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;var) const</td></tr>
<tr class="memdesc:ad3f9009b5477548c86d6253f21975323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the solution of an <a class="el" href="namespace_eigen.html">Eigen</a> matrix of decision variables.  <a href="#ad3f9009b5477548c86d6253f21975323">More...</a><br /></td></tr>
<tr class="separator:ad3f9009b5477548c86d6253f21975323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75eb95dd928015b0410479833c607f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae75eb95dd928015b0410479833c607f7">GetSolution</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var) const</td></tr>
<tr class="memdesc:ae75eb95dd928015b0410479833c607f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a single decision variable.  <a href="#ae75eb95dd928015b0410479833c607f7">More...</a><br /></td></tr>
<tr class="separator:ae75eb95dd928015b0410479833c607f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806624bdd09d8a198d65059d91839225"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a806624bdd09d8a198d65059d91839225"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt; <a class="el" href="classdouble.html">double</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a806624bdd09d8a198d65059d91839225">GetSolution</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;var, const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> &amp;<a class="el" href="ipopt__solver_8cc.html#a1b96859d8d2b1bddf6e5c68171983df3">result</a>) const</td></tr>
<tr class="memdesc:a806624bdd09d8a198d65059d91839225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the solution of an <a class="el" href="namespace_eigen.html">Eigen</a> matrix of decision variables.  <a href="#a806624bdd09d8a198d65059d91839225">More...</a><br /></td></tr>
<tr class="separator:a806624bdd09d8a198d65059d91839225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23658fd494c462200ab524ed7724e689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a23658fd494c462200ab524ed7724e689">GetSolution</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var, const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> &amp;<a class="el" href="ipopt__solver_8cc.html#a1b96859d8d2b1bddf6e5c68171983df3">result</a>) const</td></tr>
<tr class="memdesc:a23658fd494c462200ab524ed7724e689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of a single decision variable.  <a href="#a23658fd494c462200ab524ed7724e689">More...</a><br /></td></tr>
<tr class="separator:a23658fd494c462200ab524ed7724e689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961df24d54138d7528f160332c7e36fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a961df24d54138d7528f160332c7e36fb">SubstituteSolution</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e) const</td></tr>
<tr class="memdesc:a961df24d54138d7528f160332c7e36fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the variables in an expression with the solutions to the variables, returns the expression after substitution.  <a href="#a961df24d54138d7528f160332c7e36fb">More...</a><br /></td></tr>
<tr class="separator:a961df24d54138d7528f160332c7e36fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a5adf7062ec2d1360e37112c132267"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a00a5adf7062ec2d1360e37112c132267">SubstituteSolution</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;p) const</td></tr>
<tr class="memdesc:a00a5adf7062ec2d1360e37112c132267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the decision variables in a polynomial with the solutions to the variables, returns the polynomial after substitution.  <a href="#a00a5adf7062ec2d1360e37112c132267">More...</a><br /></td></tr>
<tr class="separator:a00a5adf7062ec2d1360e37112c132267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac012f5939e75603d8318ab593b8d04b"><td class="memTemplParams" colspan="2">template&lt;typename C , typename DerivedX &gt; </td></tr>
<tr class="memitem:aac012f5939e75603d8318ab593b8d04b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; DerivedX &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; typename DerivedX::Scalar &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aac012f5939e75603d8318ab593b8d04b">EvalBinding</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;binding, const Eigen::MatrixBase&lt; DerivedX &gt; &amp;prog_var_vals) const</td></tr>
<tr class="memdesc:aac012f5939e75603d8318ab593b8d04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the value of some binding, for some input value for all decision variables.  <a href="#aac012f5939e75603d8318ab593b8d04b">More...</a><br /></td></tr>
<tr class="separator:aac012f5939e75603d8318ab593b8d04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588201aaba06e4f4e6b1b76b7270d1bf"><td class="memTemplParams" colspan="2">template&lt;typename C , typename DerivedX &gt; </td></tr>
<tr class="memitem:a588201aaba06e4f4e6b1b76b7270d1bf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; DerivedX &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; typename DerivedX::Scalar &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a588201aaba06e4f4e6b1b76b7270d1bf">EvalBindings</a> (const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt;&gt; &amp;bindings, const Eigen::MatrixBase&lt; DerivedX &gt; &amp;prog_var_vals) const</td></tr>
<tr class="memdesc:a588201aaba06e4f4e6b1b76b7270d1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a set of bindings (plural version of <code>EvalBinding</code>).  <a href="#a588201aaba06e4f4e6b1b76b7270d1bf">More...</a><br /></td></tr>
<tr class="separator:a588201aaba06e4f4e6b1b76b7270d1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856ded9f90eaac91a1c66f2c139566b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a856ded9f90eaac91a1c66f2c139566b5">EvalVisualizationCallbacks</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;prog_var_vals) const</td></tr>
<tr class="memdesc:a856ded9f90eaac91a1c66f2c139566b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates all visualization callbacks registered with the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="#a856ded9f90eaac91a1c66f2c139566b5">More...</a><br /></td></tr>
<tr class="separator:a856ded9f90eaac91a1c66f2c139566b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c00066544e9e2b4ca941a3e13f622cb"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a0c00066544e9e2b4ca941a3e13f622cb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0c00066544e9e2b4ca941a3e13f622cb">EvalBindingAtSolution</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;binding) const</td></tr>
<tr class="memdesc:a0c00066544e9e2b4ca941a3e13f622cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the evaluator in <code>binding</code> at the solution value.  <a href="#a0c00066544e9e2b4ca941a3e13f622cb">More...</a><br /></td></tr>
<tr class="separator:a0c00066544e9e2b4ca941a3e13f622cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb46a0ff11d6f6d22d69d9c16bfce94"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a0eb46a0ff11d6f6d22d69d9c16bfce94"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0eb46a0ff11d6f6d22d69d9c16bfce94">EvalBindingAtInitialGuess</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;binding) const</td></tr>
<tr class="memdesc:a0eb46a0ff11d6f6d22d69d9c16bfce94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the evaluator in <code>binding</code> at the initial guess.  <a href="#a0eb46a0ff11d6f6d22d69d9c16bfce94">More...</a><br /></td></tr>
<tr class="separator:a0eb46a0ff11d6f6d22d69d9c16bfce94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b7242d08574fad6a8b10cfc8e54bca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a24b7242d08574fad6a8b10cfc8e54bca">decision_variables</a> () const</td></tr>
<tr class="memdesc:a24b7242d08574fad6a8b10cfc8e54bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all decision variables in the program.  <a href="#a24b7242d08574fad6a8b10cfc8e54bca">More...</a><br /></td></tr>
<tr class="separator:a24b7242d08574fad6a8b10cfc8e54bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7647680c7f56fdae6dc324db6aed1e45"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7647680c7f56fdae6dc324db6aed1e45">decision_variable</a> (<a class="el" href="classint.html">int</a> <a class="el" href="geometry__properties__test_8cc.html#acb559820d9ca11295b4500f179ef6392">i</a>) const</td></tr>
<tr class="memdesc:a7647680c7f56fdae6dc324db6aed1e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the decision variable with index <code>i</code> in the program.  <a href="#a7647680c7f56fdae6dc324db6aed1e45">More...</a><br /></td></tr>
<tr class="separator:a7647680c7f56fdae6dc324db6aed1e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac236784fdf749e0e3b7921f1d75de1ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac236784fdf749e0e3b7921f1d75de1ff">indeterminates</a> () const</td></tr>
<tr class="memdesc:ac236784fdf749e0e3b7921f1d75de1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all indeterminates in the program.  <a href="#ac236784fdf749e0e3b7921f1d75de1ff">More...</a><br /></td></tr>
<tr class="separator:ac236784fdf749e0e3b7921f1d75de1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6736e7e843acfd67ecd254b9a2270863"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a6736e7e843acfd67ecd254b9a2270863">indeterminate</a> (<a class="el" href="classint.html">int</a> <a class="el" href="geometry__properties__test_8cc.html#acb559820d9ca11295b4500f179ef6392">i</a>) const</td></tr>
<tr class="memdesc:a6736e7e843acfd67ecd254b9a2270863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the indeterminate with index <code>i</code> in the program.  <a href="#a6736e7e843acfd67ecd254b9a2270863">More...</a><br /></td></tr>
<tr class="separator:a6736e7e843acfd67ecd254b9a2270863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4f083b551f632b17ebdddbba2dcef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a2b4f083b551f632b17ebdddbba2dcef0">SetSolverResult</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_result.html">SolverResult</a> &amp;solver_result)</td></tr>
<tr class="memdesc:a2b4f083b551f632b17ebdddbba2dcef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver reports its result back to <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, by passing the solver_result, which contains the solver result.  <a href="#a2b4f083b551f632b17ebdddbba2dcef0">More...</a><br /></td></tr>
<tr class="separator:a2b4f083b551f632b17ebdddbba2dcef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7f71f7ae23678cd721de4cfcb52f54"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a2a7f71f7ae23678cd721de4cfcb52f54">required_capabilities</a> () const</td></tr>
<tr class="memdesc:a2a7f71f7ae23678cd721de4cfcb52f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the required capability on the solver, given the cost/constraint/variable types in the program.  <a href="#a2a7f71f7ae23678cd721de4cfcb52f54">More...</a><br /></td></tr>
<tr class="separator:a2a7f71f7ae23678cd721de4cfcb52f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a6d281d024510ccc0f7787ebbb1e534ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;)=delete</td></tr>
<tr class="separator:a6d281d024510ccc0f7787ebbb1e534ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751cdda7529e03736fc7530fad6bd7fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a751cdda7529e03736fc7530fad6bd7fa">operator=</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;)=delete</td></tr>
<tr class="separator:a751cdda7529e03736fc7530fad6bd7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1935f9e12a11b66c67eda33fd165b4d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1935f9e12a11b66c67eda33fd165b4d3">MathematicalProgram</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a1935f9e12a11b66c67eda33fd165b4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bf33171369a5b673c956f7e21e1c5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ad6bf33171369a5b673c956f7e21e1c5f">operator=</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ad6bf33171369a5b673c956f7e21e1c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">scaled diagonally dominant matrix constraint</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="addsdd"></a></p>
<p>Adds the constraint that a symmetric matrix is scaled diagonally dominant (sdd). A matrix X is sdd if there exists a diagonal matrix D, such that the product DXD is diagonally dominant with non-negative diagonal entries, namely d(i)X(i, i) ≥ ∑ⱼ |d(j)X(i, j)| ∀ j ≠ i where d(i) = D(i, i). X being sdd is equivalent to the existence of symmetric matrices Mⁱʲ∈ ℝⁿˣⁿ, i &lt; j, such that all entries in Mⁱʲ are 0, except Mⁱʲ(i, i), Mⁱʲ(i, j), Mⁱʲ(j, j). (Mⁱʲ(i, i), Mⁱʲ(j, j), Mⁱʲ(i, j)) is in the rotated Lorentz cone, and X = ∑ᵢⱼ Mⁱʲ.</p>
<p>The users can refer to "DSOS and SDSOS Optimization: More Tractable
Alternatives to Sum of Squares and Semidefinite Optimization" by Amir Ali Ahmadi and Anirudha Majumdar, with arXiv link <a href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a>. </p>
</div></td></tr>
<tr class="memitem:a35d050759f5f740a1e116aea34aa2d10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a35d050759f5f740a1e116aea34aa2d10">AddScaledDiagonallyDominantMatrixConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;X)</td></tr>
<tr class="memdesc:a35d050759f5f740a1e116aea34aa2d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded variant of <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#addsdd">scaled diagonally dominant matrix constraint</a>.  <a href="#a35d050759f5f740a1e116aea34aa2d10">More...</a><br /></td></tr>
<tr class="separator:a35d050759f5f740a1e116aea34aa2d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc0f171dcf3d56002c1f2560e430d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4fc0f171dcf3d56002c1f2560e430d89">AddScaledDiagonallyDominantMatrixConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;X)</td></tr>
<tr class="memdesc:a4fc0f171dcf3d56002c1f2560e430d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded variant of <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#addsdd">scaled diagonally dominant matrix constraint</a>.  <a href="#a4fc0f171dcf3d56002c1f2560e430d89">More...</a><br /></td></tr>
<tr class="separator:a4fc0f171dcf3d56002c1f2560e430d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8f76110fcfea54be86c2ef1ebfeaab55"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a8f76110fcfea54be86c2ef1ebfeaab55"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8f76110fcfea54be86c2ef1ebfeaab55">MakeCost</a> (<a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &amp;&amp;f)</td></tr>
<tr class="memdesc:a8f76110fcfea54be86c2ef1ebfeaab55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an input of type <code>F</code> to a FunctionCost object.  <a href="#a8f76110fcfea54be86c2ef1ebfeaab55">More...</a><br /></td></tr>
<tr class="separator:a8f76110fcfea54be86c2ef1ebfeaab55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a78994b92c87719287528546dc12538bb"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a78994b92c87719287528546dc12538bb">kGlobalInfeasibleCost</a></td></tr>
<tr class="memdesc:a78994b92c87719287528546dc12538bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The optimal cost is +∞ when the problem is globally infeasible.  <a href="#a78994b92c87719287528546dc12538bb">More...</a><br /></td></tr>
<tr class="separator:a78994b92c87719287528546dc12538bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab953e201d71c0ce608e7c95607a4f256"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ab953e201d71c0ce608e7c95607a4f256">kUnboundedCost</a></td></tr>
<tr class="memdesc:ab953e201d71c0ce608e7c95607a4f256"><td class="mdescLeft">&#160;</td><td class="mdescRight">The optimal cost is -∞ when the problem is unbounded.  <a href="#ab953e201d71c0ce608e7c95607a4f256">More...</a><br /></td></tr>
<tr class="separator:ab953e201d71c0ce608e7c95607a4f256"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> stores the decision variables, the constraints and costs of an optimization problem. </p>
<p>The user can solve the problem by calling <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae20c365943aa8acb50dfd6b99b7e5194" title="Solve the MathematicalProgram. ">Solve()</a> function, and obtain the results of the optimization. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aaed05d048d1ac7b1d4960e328c20d02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed05d048d1ac7b1d4960e328c20d02f">&#9670;&nbsp;</a></span>VarType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">VarType</a> =  <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">symbolic::Variable::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a407fb21fc13a5122994e71a05a6a0818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407fb21fc13a5122994e71a05a6a0818">&#9670;&nbsp;</a></span>NonnegativePolynomial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types of non-negative polynomial that can be found through conic optimization. </p>
<p>We currently support SOS, SDSOS and DSOS. For more information about these polynomial types, please refer to "DSOS and SDSOS Optimization: More Tractable
Alternatives to Sum of Squares and Semidefinite Optimization" by Amir Ali Ahmadi and Anirudha Majumdar, with arXiv link <a href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076"></a>kSos&#160;</td><td class="fielddoc"><p>A sum-of-squares polynomial. </p>
</td></tr>
<tr><td class="fieldname"><a id="a407fb21fc13a5122994e71a05a6a0818a28b23c4ed46cc23775486c764a920e29"></a>kSdsos&#160;</td><td class="fielddoc"><p>A scaled-diagonally dominant sum-of-squares polynomial. </p>
</td></tr>
<tr><td class="fieldname"><a id="a407fb21fc13a5122994e71a05a6a0818a26e1dbaa56329cec4d3ba803424aed81"></a>kDsos&#160;</td><td class="fielddoc"><p>A diagonally dominant sum-of-squares polynomial. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6d281d024510ccc0f7787ebbb1e534ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d281d024510ccc0f7787ebbb1e534ee">&#9670;&nbsp;</a></span>MathematicalProgram() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1935f9e12a11b66c67eda33fd165b4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1935f9e12a11b66c67eda33fd165b4d3">&#9670;&nbsp;</a></span>MathematicalProgram() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac577d0f44c9c07256230cf2642ec6822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac577d0f44c9c07256230cf2642ec6822">&#9670;&nbsp;</a></span>MathematicalProgram() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65d19f450570339ad19df40415cb3592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d19f450570339ad19df40415cb3592">&#9670;&nbsp;</a></span>~MathematicalProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b4d1c9278bc20bf599b1e74178f51c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4d1c9278bc20bf599b1e74178f51c8">&#9670;&nbsp;</a></span>AddBoundingBoxConstraint() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AddBoundingBoxConstraint. </p>
<p>Adds bounding box constraints referencing potentially a subset of the decision variables (defined in the vars parameter). Example </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> <a class="code" href="gurobi__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>;</div><div class="line"><span class="keyword">auto</span> <a class="code" href="ipopt__solver_8cc.html#ab0de8209ca91d50f02e57b337ac47611">x</a> = prog.NewContinuousDecisionVariables&lt;2&gt;(<span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"><span class="keyword">auto</span> y = prog.NewContinuousDecisionVariables&lt;1&gt;(<span class="stringliteral">&quot;y&quot;</span>);</div><div class="line">Eigen::Vector3d lb(0, 1, 2);</div><div class="line">Eigen::Vector3d ub(1, 2, 3);</div><div class="line"><span class="comment">// Imposes the constraint</span></div><div class="line"><span class="comment">// 0 ≤ x(0) ≤ 1</span></div><div class="line"><span class="comment">// 1 ≤ x(1) ≤ 2</span></div><div class="line"><span class="comment">// 2 ≤ y    ≤ 3</span></div><div class="line">prog.AddBoundingBoxConstraint(lb, ub, {<a class="code" href="ipopt__solver_8cc.html#ab0de8209ca91d50f02e57b337ac47611">x</a>, y});</div></div><!-- fragment --> 
</div>
</div>
<a id="acad39fd8296f6a779756b2afd9782b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad39fd8296f6a779756b2afd9782b95">&#9670;&nbsp;</a></span>AddBoundingBoxConstraint() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds bounding box constraints referencing potentially a subset of the decision variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>The lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>The upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>Will imposes constraint lb(i) &lt;= vars(i) &lt;= ub(i). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form . ">BoundingBoxConstraint</a>. </dd></dl>

</div>
</div>
<a id="a5c41563c9fea14a00330000b42a682fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c41563c9fea14a00330000b42a682fc">&#9670;&nbsp;</a></span>AddBoundingBoxConstraint() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds bounds for a single variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">var</td><td>The decision variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e8c7c4993cbaa6cc2ca30874be835d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8c7c4993cbaa6cc2ca30874be835d7">&#9670;&nbsp;</a></span>AddBoundingBoxConstraint() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the same scalar lower and upper bound to every variable in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a368eb40bf59115cde7610cda3112d3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368eb40bf59115cde7610cda3112d3f9">&#9670;&nbsp;</a></span>AddBoundingBoxConstraint() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; Derived::ColsAtCompileTime == 1, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the same scalar lower and upper bound to every variable in <code>vars</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An <a class="el" href="namespace_eigen.html">Eigen</a> Vector type with Variable as the scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68cc6bbf63a154236317beff5382c04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cc6bbf63a154236317beff5382c04d">&#9670;&nbsp;</a></span>AddBoundingBoxConstraint() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a> &amp;&amp; Derived::ColsAtCompileTime != 1, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the same scalar lower and upper bound to every variable in <code>vars</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen::Matrix with Variable as the scalar type. The matrix has unknown number of columns at compile time, or has more than one column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af05fa6863859ca8be0153e10c29def11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05fa6863859ca8be0153e10c29def11">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a generic constraint to the program. </p>
<p>This should only be used if a more specific type of constraint is not available, as it may require the use of a significantly more expensive solver. </p>

</div>
</div>
<a id="ab94e40b82b4d9d62a702cf6636493416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94e40b82b4d9d62a702cf6636493416">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of constraint lb &lt;= e &lt;= ub where <code>e</code> is a symbolic expression. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if<ol type="1">
<li><code>lb &lt;= e &lt;= ub</code> is a trivial constraint such as 1 &lt;= 2 &lt;= 3.</li>
<li><code>lb &lt;= e &lt;= ub</code> is unsatisfiable such as 1 &lt;= -5 &lt;= 3</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A symbolic expression of the the decision variables. </td></tr>
    <tr><td class="paramname">lb</td><td>A scalar, the lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>A scalar, the upper bound.</td></tr>
  </table>
  </dd>
</dl>
<p>The resulting constraint may be a <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form . ">BoundingBoxConstraint</a>, <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html" title="Implements a constraint of the form . ">LinearConstraint</a>, <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form . ">LinearEqualityConstraint</a>, or <a class="el" href="classdrake_1_1solvers_1_1_expression_constraint.html" title="Impose a generic (potentially nonlinear) constraint represented as a vector of symbolic Expression...">ExpressionConstraint</a>, depending on the arguments. Constraints of the form x == 1 (which could be created as a <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form . ">BoundingBoxConstraint</a> or <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form . ">LinearEqualityConstraint</a>) will be constructed as a <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form . ">LinearEqualityConstraint</a>. </p>

</div>
</div>
<a id="a412ef43fcfe9a34e19b1054d8750836b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412ef43fcfe9a34e19b1054d8750836b">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8d9bfe34ef20a9f343e518fccc40bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d9bfe34ef20a9f343e518fccc40bd6">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a constraint represented by a symbolic formula to the program. </p>
<p>The input formula <code>f</code> can be of the following forms:</p>
<ol type="1">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
<li>A conjunction of relational formulas where each conjunct is a relational formula matched by 1, 2, or 3.</li>
</ol>
<p>Note that first two cases might return an object of Binding&lt;BoundingBoxConstraint&gt;, Binding&lt;LinearConstraint&gt;, or Binding&lt;ExpressionConstraint&gt;, depending on <code>f</code>. Also the third case might return an object of Binding&lt;LinearEqualityConstraint&gt; or Binding&lt;ExpressionConstraint&gt;.</p>
<p>It throws an exception if</p><ol type="1">
<li><code>f</code> is not matched with one of the above patterns. Especially, strict inequalities (&lt;, &gt;) are not allowed.</li>
<li><code>f</code> is either a trivial constraint such as "1 &lt;= 2" or an unsatisfiable constraint such as "2 &lt;= 1".</li>
<li>It is not possible to find numerical bounds of <code>e1</code> and <code>e2</code> where <code>f</code> = e1 ≃ e2. We allow <code>e1</code> and <code>e2</code> to be infinite but only if there are no other terms. For example, <code>x &lt;= ∞</code> is allowed. However, <code>x - ∞ &lt;= 0</code> is not allowed because <code>x ↦ ∞</code> introduces <code>nan</code> in the evaluation.</li>
</ol>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>A common use-case of this function is to add a constraint with the element-wise comparison between two <a class="el" href="namespace_eigen.html">Eigen</a> matrices, using <code>A.array() &lt;= B.array()</code>. See the following example.</p>
<div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> <a class="code" href="gurobi__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>;</div><div class="line">Eigen::Matrix&lt;double, 2, 2&gt; <a class="code" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>;</div><div class="line"><span class="keyword">auto</span> <a class="code" href="ipopt__solver_8cc.html#ab0de8209ca91d50f02e57b337ac47611">x</a> = prog.NewContinuousVariables(2, <span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"><a class="code" href="constraint__solver__test_8cc.html#a824159f5c2a14336f9082b0e04374fdc">Eigen::Vector2d</a> b;</div><div class="line">... <span class="comment">// set up A and b</span></div><div class="line">prog.AddConstraint((A * <a class="code" href="ipopt__solver_8cc.html#ab0de8209ca91d50f02e57b337ac47611">x</a>).array() &lt;= b.array());</div></div><!-- fragment --><p>A formula in <code>formulas</code> can be of the following forms:</p>
<ol type="1">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
</ol>
<p>It throws an exception if <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae8d9bfe34ef20a9f343e518fccc40bd6" title="Add a constraint represented by a symbolic formula to the program. ">AddConstraint(const symbolic::Formula&amp; f)</a> throws an exception for f ∈ <code>formulas</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An <a class="el" href="namespace_eigen.html">Eigen</a> Array type of Formula. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a801d3b07132b5d3ae66a3bf96b80a74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801d3b07132b5d3ae66a3bf96b80a74e">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt;Derived, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a>&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>formulas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c28156f900997a8fb1b0079e30fce6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c28156f900997a8fb1b0079e30fce6d">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto AddConstraint </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; C &gt;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a generic constraint to the program. </p>
<p>This should only be used if a more specific type of constraint is not available, as it may require the use of a significantly more expensive solver. </p>

</div>
</div>
<a id="a8d26f3d31c9cfba7144b9a0d96aebdd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d26f3d31c9cfba7144b9a0d96aebdd0">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto AddConstraint </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; C &gt;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a generic constraint to the program. </p>
<p>This should only be used if a more specific type of constraint is not available, as it may require the use of a significantly more expensive solver. </p>

</div>
</div>
<a id="adb35904c3fd69181dba1a7f185662473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb35904c3fd69181dba1a7f185662473">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="a9673db3dce831cddef02eb3345a5f809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9673db3dce831cddef02eb3345a5f809">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear equality constraints referencing potentially a subset of the decision variables. </p>

</div>
</div>
<a id="a3e23aa9a8116a05e5ef8c9dd6d7fa5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e23aa9a8116a05e5ef8c9dd6d7fa5e3">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds bounding box constraints referencing potentially a subest of the decision variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>Binds a <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form . ">BoundingBoxConstraint</a> with some decision variables, such that binding.evaluator()-&gt;lower_bound()(i) &lt;= binding.variables()(i) &lt;= binding.evaluator().upper_bound()(i) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a008804cb1833a8496b6131daf8ace573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008804cb1833a8496b6131daf8ace573">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint referencing potentially a subset of the decision variables. </p>
<p>The linear expression \( z=Ax+b \) is in the Lorentz cone. A vector \( z \in\mathbb{R}^n \) is in the Lorentz cone, if</p>
<p class="formulaDsp">
\[ z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2} \]
</p>
 
</div>
</div>
<a id="a63a80e477decc42724b9e814d70cc339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a80e477decc42724b9e814d70cc339">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables. </p>
<p>The linear expression \( z=Ax+b \) is in rotated Lorentz cone. A vector \( z \in\mathbb{R}^n \) is in the rotated Lorentz cone, if</p>
<p class="formulaDsp">
\[ z_0z_1 \ge z_2^2 + ... + z_{n-1}^2 \]
</p>
 
</div>
</div>
<a id="a69dd1bb48c3631c7a2e0a70e50022c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69dd1bb48c3631c7a2e0a70e50022c1a">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear complementarity constraints referencing a subset of the decision variables. </p>

</div>
</div>
<a id="a7eaff79975646e0a4381f073a47c9974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eaff79975646e0a4381f073a47c9974">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a positive semidefinite constraint on a symmetric matrix. </p>

</div>
</div>
<a id="a46c66d4086096ed5206e2168d8a6fe3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c66d4086096ed5206e2168d8a6fe3f">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>symmetric_matrix_var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a positive semidefinite constraint on a symmetric matrix. </p>

</div>
</div>
<a id="a8b781bb7ad3b694a9d9fcbf636235469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b781bb7ad3b694a9d9fcbf636235469">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear matrix inequality constraint to the program. </p>

</div>
</div>
<a id="a4efea1b480be940fe05070939b7954ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efea1b480be940fe05070939b7954ac">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a generic cost to the optimization program. </p>

</div>
</div>
<a id="a60e141e79d84c40fbc83ea8e3aab7823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e141e79d84c40fbc83ea8e3aab7823">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto AddCost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a cost type to the optimization program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The added objective. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the cost depend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24f0ccf74cf7be71ca7bc12d81051cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f0ccf74cf7be71ca7bc12d81051cad">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto AddCost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a generic cost to the optimization program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The added objective. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the cost depend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3dd64529a087eec92208ac063f984fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dd64529a087eec92208ac063f984fa">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structdrake_1_1solvers_1_1detail_1_1is__cost__functor__candidate.html">detail::is_cost_functor_candidate</a>&lt;<a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> AddCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a cost to the optimization program on a list of variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>it should define functions numInputs, numOutputs and eval. Check <a class="el" href="structdrake_1_1solvers_1_1detail_1_1_function_traits.html" title="FunctionTraits. ">drake::solvers::detail::FunctionTraits</a> for more detail. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36b84fed8288d7fd99ecde678c14bc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b84fed8288d7fd99ecde678c14bc04">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structdrake_1_1solvers_1_1detail_1_1is__cost__functor__candidate.html">detail::is_cost_functor_candidate</a>&lt;<a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> AddCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a cost to the optimization program on an Eigen::Vector containing decision variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Type that defines functions numInputs, numOutputs and eval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structdrake_1_1solvers_1_1detail_1_1_function_traits.html" title="FunctionTraits. ">drake::solvers::detail::FunctionTraits</a>. </dd></dl>

</div>
</div>
<a id="a4f6efe825a3e8d2532cb52196c31560d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6efe825a3e8d2532cb52196c31560d">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structdrake_1_1solvers_1_1detail_1_1assert__if__is__constraint.html">detail::assert_if_is_constraint</a>&lt;<a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> AddCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vars &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Statically assert if a user inadvertently passes a binding-compatible <a class="el" href="classdrake_1_1solvers_1_1_constraint.html" title="A constraint is a function + lower and upper bounds. ">Constraint</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9361760e08efc82cecdb7d73abdaf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9361760e08efc82cecdb7d73abdaf08">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form c'*x. </p>
<p>Applied to a subset of the variables and pushes onto the linear cost data structure. </p>

</div>
</div>
<a id="a413bc850a691a89ffd076b6bfbd6ffea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413bc850a691a89ffd076b6bfbd6ffea">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form 0.5*x'*Q*x + b'x. </p>
<p>Applied to subset of the variables and pushes onto the quadratic cost data structure. </p>

</div>
</div>
<a id="adeaa05fb1b97a02f8d14c393bebe68bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeaa05fb1b97a02f8d14c393bebe68bf">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost in the symbolic form. </p>
<p>Note that the constant part of the cost is ignored. So if you set <code>e = x + 2</code>, then only the cost on <code>x</code> is added, the constant term 2 is ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The linear or quadratic expression of the cost. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is linear or <code>e</code> is quadratic. Otherwise throws a runtime error. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created cost, together with the bound variables. </dd></dl>

</div>
</div>
<a id="a2b2754b7d6e748804b771b513e0df552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2754b7d6e748804b771b513e0df552">&#9670;&nbsp;</a></span>AddDecisionVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddDecisionVariables </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>decision_variables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends new variables to the end of the existing variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decision_variables</td><td>The newly added decision_variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>decision_variables</code> should not intersect with the existing variables or indeterminates in the optimization program. </dd>
<dd>
Each entry in <code>decision_variables</code> should not be a dummy variable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the preconditions are not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46c7fda7a953076c526e686a24fc1c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c7fda7a953076c526e686a24fc1c3b">&#9670;&nbsp;</a></span>AddIndeterminates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_indeterminates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates. </p>
<p>This method appends some indeterminates to the end of the program's old indeterminates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_indeterminates</td><td>The indeterminates to be appended to the program's old indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>new_indeterminates</code> should not intersect with the program's old indeterminates or decision variables. </dd>
<dd>
Each entry in new_indeterminates should not be dummy. </dd>
<dd>
Each entry in new_indeterminates should be of CONTINUOUS type. </dd></dl>

</div>
</div>
<a id="a2a915ebc93c14da19b845df70e95bf6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a915ebc93c14da19b845df70e95bf6c">&#9670;&nbsp;</a></span>AddL2NormCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; AddL2NormCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a cost term of the form | Ax - b |^2. </p>

</div>
</div>
<a id="ae12e1f27eb841aef6de75e3e7e5a96fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12e1f27eb841aef6de75e3e7e5a96fe">&#9670;&nbsp;</a></span>AddL2NormCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; AddL2NormCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a cost term of the form | Ax - b |^2. </p>

</div>
</div>
<a id="aefb8281bc9e90a665dab64afa9749542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb8281bc9e90a665dab64afa9749542">&#9670;&nbsp;</a></span>AddLinearComplementarityConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a>&gt; AddLinearComplementarityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a linear complementarity constraints referencing a subset of the decision variables. </p>

</div>
</div>
<a id="ad946ddf713f3d8f248c417cf9b728ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad946ddf713f3d8f248c417cf9b728ec8">&#9670;&nbsp;</a></span>AddLinearComplementarityConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; AddLinearComplementarityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear complementarity constraints referencing a subset of the decision variables. </p>

</div>
</div>
<a id="a7d60c0944a1bf43c50dd26b6dbbc3c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d60c0944a1bf43c50dd26b6dbbc3c1b">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="ae78a44ed429e0dea8964470adbb46218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78a44ed429e0dea8964470adbb46218">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="aea3340539f7b90d2f7d6987eea1a7242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3340539f7b90d2f7d6987eea1a7242">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds one row of linear constraint referencing potentially a subset of the decision variables (defined in the vars parameter). </p>
<p>lb &lt;= a*vars &lt;= ub </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A row vector. </td></tr>
    <tr><td class="paramname">lb</td><td>A scalar, the lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>A scalar, the upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which to impose the linear constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2358db7c4dc6aa23411618b1d21d9a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2358db7c4dc6aa23411618b1d21d9a07">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds one row of linear constraint referencing potentially a subset of the decision variables (defined in the vars parameter). </p>
<p>lb &lt;= a*vars &lt;= ub </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A row vector. </td></tr>
    <tr><td class="paramname">lb</td><td>A scalar, the lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>A scalar, the upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which to impose the linear constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11440aef6df9ddedfd6675ce56fe6e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11440aef6df9ddedfd6675ce56fe6e16">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear constraint lb &lt;= e &lt;= ub where <code>e</code> is a symbolic expression. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if<ol type="1">
<li><code>e</code> is a non-linear expression.</li>
<li><code>lb &lt;= e &lt;= ub</code> is a trivial constraint such as 1 &lt;= 2 &lt;= 3.</li>
<li><code>lb &lt;= e &lt;= ub</code> is unsatisfiable such as 1 &lt;= -5 &lt;= 3</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A linear symbolic expression in the form of <code>c0 + c1 * v1 + ... + cn * vn</code> where <code>c_i</code> is a constant and  is a variable. </td></tr>
    <tr><td class="paramname">lb</td><td>A scalar, the lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>A scalar, the upper bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2519f91e26b48c81fbae688cf774b41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2519f91e26b48c81fbae688cf774b41d">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints represented by symbolic expressions to the program. </p>
<p>It throws if  includes a non-linear expression or <code>lb &lt;= v &lt;= ub</code> includes trivial/unsatisfiable constraints. </p>

</div>
</div>
<a id="a1ecde2056d0658ea4dac1c0e632ad353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecde2056d0658ea4dac1c0e632ad353">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a linear constraint represented by a symbolic formula to the program. </p>
<p>The input formula <code>f</code> can be of the following forms:</p>
<ol type="1">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
<li>A conjunction of relational formulas where each conjunct is a relational formula matched by 1, 2, or 3.</li>
</ol>
<p>Note that first two cases might return an object of Binding&lt;BoundingBoxConstraint&gt; depending on <code>f</code>. Also the third case returns an object of Binding&lt;LinearEqualityConstraint&gt;.</p>
<p>It throws an exception if</p><ol type="1">
<li><code>f</code> is not matched with one of the above patterns. Especially, strict inequalities (&lt;, &gt;) are not allowed.</li>
<li><code>f</code> includes a non-linear expression.</li>
<li><code>f</code> is either a trivial constraint such as "1 &lt;= 2" or an unsatisfiable constraint such as "2 &lt;= 1".</li>
<li>It is not possible to find numerical bounds of <code>e1</code> and <code>e2</code> where <code>f</code> = e1 ≃ e2. We allow <code>e1</code> and <code>e2</code> to be infinite but only if there are no other terms. For example, <code>x &lt;= ∞</code> is allowed. However, <code>x - ∞ &lt;= 0</code> is not allowed because <code>x ↦ ∞</code> introduces <code>nan</code> in the evaluation. </li>
</ol>

</div>
</div>
<a id="a62eade914da1066e0f1cf0c53dc3a3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62eade914da1066e0f1cf0c53dc3a3d7">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt;Derived, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>formulas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a linear constraint represented by an Eigen::Array&lt;symbolic::Formula&gt; to the program. </p>
<p>A common use-case of this function is to add a linear constraint with the element-wise comparison between two <a class="el" href="namespace_eigen.html">Eigen</a> matrices, using <code>A.array() &lt;= B.array()</code>. See the following example.</p>
<div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> <a class="code" href="gurobi__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>;</div><div class="line">Eigen::Matrix&lt;double, 2, 2&gt; <a class="code" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>;</div><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables(2, <span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"><a class="code" href="constraint__solver__test_8cc.html#a824159f5c2a14336f9082b0e04374fdc">Eigen::Vector2d</a> b;</div><div class="line">... <span class="comment">// set up A and b</span></div><div class="line">prog.AddLinearConstraint((A * x).array() &lt;= b.array());</div></div><!-- fragment --><p>A formula in <code>formulas</code> can be of the following forms:</p>
<ol type="1">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
</ol>
<p>It throws an exception if <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1ecde2056d0658ea4dac1c0e632ad353" title="Add a linear constraint represented by a symbolic formula to the program. ">AddLinearConstraint(const symbolic::Formula&amp; f)</a> throws an exception for f ∈ <code>formulas</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An <a class="el" href="namespace_eigen.html">Eigen</a> Array type of Formula. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a8dae8551794a05aadea978f2ae5ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8dae8551794a05aadea978f2ae5ae3">&#9670;&nbsp;</a></span>AddLinearCost() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; AddLinearCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear cost term of the form a'*x + b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A linear symbolic expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>e is a linear expression a'*x + b, where each entry of x is a decision variable in the mathematical program. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added linear constraint, together with the bound variables. </dd></dl>

</div>
</div>
<a id="ab5d909ab79bbc45767206daaa8d145c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d909ab79bbc45767206daaa8d145c8">&#9670;&nbsp;</a></span>AddLinearCost() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt; AddLinearCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a linear cost term of the form a'*x + b. </p>
<p>Applied to a subset of the variables and pushes onto the linear cost data structure. </p>

</div>
</div>
<a id="a3bc63e8400b182a07b2b9372a4418114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc63e8400b182a07b2b9372a4418114">&#9670;&nbsp;</a></span>AddLinearCost() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; AddLinearCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear cost term of the form a'*x + b. </p>
<p>Applied to a subset of the variables and pushes onto the linear cost data structure. </p>

</div>
</div>
<a id="a06dbd6c1bf0971fc28366df95ee1bca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06dbd6c1bf0971fc28366df95ee1bca2">&#9670;&nbsp;</a></span>AddLinearCost() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt; AddLinearCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">VarType</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a linear cost term of the form a'*x. </p>
<p>Applied to a subset of the variables and pushes onto the linear cost data structure. </p>

</div>
</div>
<a id="adce9200575be00912b9f62ee4ea53599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce9200575be00912b9f62ee4ea53599">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear constraint e = b where <code>e</code> is a symbolic expression. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if<ol type="1">
<li><code>e</code> is a non-linear expression.</li>
<li><code>e</code> is a constant.</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A linear symbolic expression in the form of <code>c0 + c1 * x1 + ... + cn * xn</code> where <code>c_i</code> is a constant and  is a variable. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added linear equality constraint, together with the bound variable. </dd></dl>

</div>
</div>
<a id="a51f626f98cede0db08541462de301bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f626f98cede0db08541462de301bf9">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear equality constraint represented by a symbolic formula to the program. </p>
<p>The input formula <code>f</code> is either an equality formula (<code>e1 == e2</code>) or a conjunction of equality formulas.</p>
<p>It throws an exception if</p>
<ol type="1">
<li><code>f</code> is neither an equality formula nor a conjunction of equalities.</li>
<li><code>f</code> includes a non-linear expression. </li>
</ol>

</div>
</div>
<a id="a352b1445c6c1cd2f70770a7da4b7e498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352b1445c6c1cd2f70770a7da4b7e498">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector__expression__double__pair.html">is_eigen_vector_expression_double_pair</a>&lt;DerivedV, DerivedB&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds linear equality constraints \( v = b \), where <code>v(i)</code> is a symbolic linear expression. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if<ol type="1">
<li><code>v(i)</code> is a non-linear expression.</li>
<li><code>v(i)</code> is a constant.</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>An <a class="el" href="namespace_eigen.html">Eigen</a> Matrix type of Expression. A column vector. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An <a class="el" href="namespace_eigen.html">Eigen</a> Matrix type of double. A column vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>v(i) is a linear symbolic expression in the form of <code> c0 + c1 * x1 + ... + cn * xn </code> where ci is a constant and  is a variable. </td></tr>
    <tr><td class="paramname">b</td><td>A vector of doubles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added linear equality constraint, together with the bound variables. </dd></dl>

</div>
</div>
<a id="a13e634ab834b9139a429d17667256b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e634ab834b9139a429d17667256b1d">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__nonvector__expression__double__pair.html">is_eigen_nonvector_expression_double_pair</a>&lt;DerivedV, DerivedB&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>lower_triangle</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a linear equality constraint for a matrix of linear expression <code>V</code>, such that V(i, j) = B(i, j). </p>
<p>If V is a symmetric matrix, then the user may only want to constrain the lower triangular part of V. This function is meant to provide convenience to the user, it incurs additional copy and memory allocation. For faster speed, add each column of the matrix equality in a for loop. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>An <a class="el" href="namespace_eigen.html">Eigen</a> Matrix type of Expression. The number of columns at compile time should not be 1. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An <a class="el" href="namespace_eigen.html">Eigen</a> Matrix type of double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>An <a class="el" href="namespace_eigen.html">Eigen</a> Matrix of symbolic expressions. V(i, j) should be a linear expression. </td></tr>
    <tr><td class="paramname">B</td><td>An <a class="el" href="namespace_eigen.html">Eigen</a> Matrix of doubles. </td></tr>
    <tr><td class="paramname">lower_triangle</td><td>If true, then only the lower triangular part of <code>V</code> is constrained, otherwise the whole matrix V is constrained. <br />
 <em>Default:</em> is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added linear equality constraint, together with the bound variables. </dd></dl>

</div>
</div>
<a id="aa4aec5ef573ea5fb0667475c7e5a1914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4aec5ef573ea5fb0667475c7e5a1914">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Aeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>beq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AddLinearEqualityConstraint. </p>
<p>Adds linear equality constraints referencing potentially a subset of the decision variables.</p>
<p>Example: to add two equality constraints which only depend on two of the elements of x, you could use </p><div class="fragment"><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousDecisionVariable(6,<span class="stringliteral">&quot;myvar&quot;</span>);</div><div class="line">Eigen::Matrix2d Aeq;</div><div class="line">Aeq &lt;&lt; -1, 2,</div><div class="line">        1, 1;</div><div class="line"><a class="code" href="constraint__solver__test_8cc.html#a824159f5c2a14336f9082b0e04374fdc">Eigen::Vector2d</a> beq(1, 3);</div><div class="line">prog.AddLinearEqualityConstraint(Aeq, beq, {x.segment&lt;1&gt;(2),</div><div class="line">                                 x.segment&lt;1&gt;(5)});</div></div><!-- fragment --><p> The code above imposes constraints </p><p class="formulaDsp">
\[-x(2) + 2x(5) = 1 \]
</p>
 <p class="formulaDsp">
\[ x(2) + x(5) = 3 \]
</p>
 
</div>
</div>
<a id="ae7cd4f274bef65432200b7af16fd9547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cd4f274bef65432200b7af16fd9547">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Aeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>beq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AddLinearEqualityConstraint. </p>
<p>Adds linear equality constraints referencing potentially a subset of the decision variables.</p>
<p>Example: to add two equality constraints which only depend on two of the elements of x, you could use </p><div class="fragment"><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousDecisionVariable(6,<span class="stringliteral">&quot;myvar&quot;</span>);</div><div class="line">Eigen::Matrix2d Aeq;</div><div class="line">Aeq &lt;&lt; -1, 2,</div><div class="line">        1, 1;</div><div class="line"><a class="code" href="constraint__solver__test_8cc.html#a824159f5c2a14336f9082b0e04374fdc">Eigen::Vector2d</a> beq(1, 3);</div><div class="line"><span class="comment">// Imposes constraint</span></div><div class="line"><span class="comment">// -x(0) + 2x(1) = 1</span></div><div class="line"><span class="comment">//  x(0) +  x(1) = 3</span></div><div class="line">prog.AddLinearEqualityConstraint(Aeq, beq, x.head&lt;2&gt;());</div></div><!-- fragment --> 
</div>
</div>
<a id="adba470b9c71439a795a0d647d171f71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba470b9c71439a795a0d647d171f71b">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>beq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds one row of linear equality constraint referencing potentially a subset of decision variables. </p>
<p class="formulaDsp">
\[ ax = beq \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A row vector. </td></tr>
    <tr><td class="paramname">beq</td><td>A scalar. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the constraint is imposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ca8d2a20e1ba47d1c658613569eb447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca8d2a20e1ba47d1c658613569eb447">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>beq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds one row of linear equality constraint referencing potentially a subset of decision variables. </p>
<p class="formulaDsp">
\[ ax = beq \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A row vector. </td></tr>
    <tr><td class="paramname">beq</td><td>A scalar. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the constraint is imposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cca1ac259f166dc97725ed23b7e5739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cca1ac259f166dc97725ed23b7e5739">&#9670;&nbsp;</a></span>AddLinearMatrixInequalityConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a>&gt; AddLinearMatrixInequalityConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Ref&lt; const Eigen::MatrixXd &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a linear matrix inequality constraint to the program. </p>

</div>
</div>
<a id="a11b15080aade12f067877a6e84006c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b15080aade12f067877a6e84006c8d">&#9670;&nbsp;</a></span>AddLinearMatrixInequalityConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; AddLinearMatrixInequalityConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Ref&lt; const Eigen::MatrixXd &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear matrix inequality constraint to the program. </p>

</div>
</div>
<a id="a37f5fbc13ef9deda258e09952942dee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f5fbc13ef9deda258e09952942dee8">&#9670;&nbsp;</a></span>AddLorentzConeConstraint() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint referencing potentially a subset of the decision variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An Eigen::Vector of <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression. ">symbolic::Expression</a>. Constraining that <p class="formulaDsp">
\[ v_0 \ge \sqrt{v_1^2 + ... + v_{n-1}^2} \]
</p>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed Lorentz cone constraint with the bounded variables. </dd></dl>

</div>
</div>
<a id="a13e7cbefcdcdf2e9d339100f522c3c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e7cbefcdcdf2e9d339100f522c3c10">&#9670;&nbsp;</a></span>AddLorentzConeConstraint() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>linear_expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>quadratic_expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint on the linear expression v1 and quadratic expression v2, such that v1 &gt;= sqrt(v2) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_expression</td><td>The linear expression v1. </td></tr>
    <tr><td class="paramname">quadratic_expression</td><td>The quadratic expression v2. </td></tr>
    <tr><td class="paramname">tol</td><td>The tolerance to determine if the matrix in v2 is positive semidefinite or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DecomposePositiveQuadraticForm for more explanation. <br />
 <em>Default:</em> is 0. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">binding</td><td>The newly added Lorentz cone constraint, together with the bound variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ol type="1">
<li><code>v1</code> is a linear expression, in the form of c'*x + d.</li>
<li><code>v2</code> is a quadratic expression, in the form of <pre>
         x'*Q*x + b'x + a
   </pre> Also the quadratic expression has to be convex, namely Q is a positive semidefinite matrix, and the quadratic expression needs to be non-negative for any x. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the preconditions are not satisfied.</td></tr>
  </table>
  </dd>
</dl>
<p>Notice this constraint is equivalent to the vector [z;y] is within a Lorentz cone, where </p><pre>
 z = v1
 y = R * x + d
</pre><p> while (R, d) satisfies y'*y = x'*Q*x + b'*x + a </p>

</div>
</div>
<a id="a579bccc0dc41e5b6bf662c9aeb994fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579bccc0dc41e5b6bf662c9aeb994fc4">&#9670;&nbsp;</a></span>AddLorentzConeConstraint() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint referencing potentially a subset of the decision variables (defined in the vars parameter). </p>
<p>The linear expression \( z=Ax+b \) is in the Lorentz cone. A vector \( z \in\mathbb{R}^n \) is in the Lorentz cone, if</p>
<p class="formulaDsp">
\[ z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2} \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A \(\mathbb{R}^{n\times m}\) matrix, whose number of columns equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">b</td><td>A \(\mathbb{R}^n\) vector, whose number of rows equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>The list of \( m \) decision variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="a80d9c1941285be6b2b6e51c1e0941654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d9c1941285be6b2b6e51c1e0941654">&#9670;&nbsp;</a></span>AddLorentzConeConstraint() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint referencing potentially a subset of the decision variables (defined in the vars parameter). </p>
<p>The linear expression \( z=Ax+b \) is in the Lorentz cone. A vector \( z \in\mathbb{R}^n \) is in the Lorentz cone, if</p>
<p class="formulaDsp">
\[ z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2} \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A \(\mathbb{R}^{n\times m}\) matrix, whose number of columns equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">b</td><td>A \(\mathbb{R}^n\) vector, whose number of rows equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>The <a class="el" href="namespace_eigen.html">Eigen</a> vector of \( m \) decision variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="a0c56319ef4614b8952aa1c4a05805783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c56319ef4614b8952aa1c4a05805783">&#9670;&nbsp;</a></span>AddLorentzConeConstraint() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Imposes that a vector \( x\in\mathbb{R}^m \) lies in Lorentz cone. </p>
<p>Namely </p><p class="formulaDsp">
\[ x_0 \ge \sqrt{x_1^2 + .. + x_{m-1}^2} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The stacked column of vars should lie within the Lorentz cone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="a9a8ae8ccec0fb23009ff8a010e5ad519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8ae8ccec0fb23009ff8a010e5ad519">&#9670;&nbsp;</a></span>AddLorentzConeConstraint() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; rows &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Imposes that a vector \( x\in\mathbb{R}^m \) lies in Lorentz cone. </p>
<p>Namely </p><p class="formulaDsp">
\[ x_0 \ge \sqrt{x_1^2 + .. + x_{m-1}^2} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The stacked column of vars should lie within the Lorentz cone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="a4f25487f506aa0756bc7aeda562822d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f25487f506aa0756bc7aeda562822d5">&#9670;&nbsp;</a></span>AddPolynomialConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a>&gt; AddPolynomialConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="polynomial_8h.html#a00cbebcd97766579bb36e35abcf44acf">VectorXPoly</a> &amp;&#160;</td>
          <td class="paramname"><em>polynomials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="class_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">Polynomiald::VarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a polynomial constraint to the program referencing a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="ac119a5e6eb9a5cbb3135d2bc2d022d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac119a5e6eb9a5cbb3135d2bc2d022d59">&#9670;&nbsp;</a></span>AddPolynomialConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; AddPolynomialConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="polynomial_8h.html#a00cbebcd97766579bb36e35abcf44acf">VectorXPoly</a> &amp;&#160;</td>
          <td class="paramname"><em>polynomials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="class_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">Polynomiald::VarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a polynomial constraint to the program referencing a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="acaac50719294dcb0ddad7ccb1df3ae03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaac50719294dcb0ddad7ccb1df3ae03">&#9670;&nbsp;</a></span>AddPolynomialCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_polynomial_cost.html">PolynomialCost</a> &gt; AddPolynomialCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term in the polynomial form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A symbolic expression in the polynomial form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created cost and the bound variables. </dd></dl>

</div>
</div>
<a id="a589dbafbe9df2c711789428c7964b838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589dbafbe9df2c711789428c7964b838">&#9670;&nbsp;</a></span>AddPositiveDiagonallyDominantMatrixConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; AddPositiveDiagonallyDominantMatrixConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the constraint that a symmetric matrix is diagonally dominant with non-negative diagonal entries. </p>
<p>A symmetric matrix X is diagonally dominant with non-negative diagonal entries if X(i, i) &gt;= ∑ⱼ |X(i, j)| ∀ j ≠ i namely in each row, the diagonal entry is larger than the sum of the absolute values of all other entries in the same row. A matrix being diagonally dominant with non-negative diagonals is a sufficient (but not necessary) condition of a matrix being positive semidefinite. Internally we will create a matrix Y as slack variables, such that Y(i, j) represents the absolute value |X(i, j)| ∀ j ≠ i. The diagonal entries Y(i, i) = X(i, i) The users can refer to "DSOS and SDSOS Optimization: More Tractable
Alternatives to Sum of Squares and Semidefinite Optimization" by Amir Ali Ahmadi and Anirudha Majumdar, with arXiv link <a href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The matrix X. We will use 0.5(X+Xᵀ) as the "symmetric version" of X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Y The slack variable. Y(i, j) represents |X(i, j)| ∀ j ≠ i, with the constraint Y(i, j) &gt;= X(i, j) and Y(i, j) &gt;= -X(i, j). Y is a symmetric matrix. The diagonal entries Y(i, i) = X(i, i) </dd></dl>

</div>
</div>
<a id="a1eede327356f097ffbe492929b4effb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eede327356f097ffbe492929b4effb7">&#9670;&nbsp;</a></span>AddPositiveSemidefiniteConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; AddPositiveSemidefiniteConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>symmetric_matrix_var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a positive semidefinite constraint on a symmetric matrix. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>in Debug mode if <code>symmetric_matrix_var</code> is not symmetric. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symmetric_matrix_var</td><td>A symmetric MatrixDecisionVariable object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa97e94e833feb1d3570a61226b1e4a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97e94e833feb1d3570a61226b1e4a19">&#9670;&nbsp;</a></span>AddPositiveSemidefiniteConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a>&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> AddPositiveSemidefiniteConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a positive semidefinite constraint on a symmetric matrix of symbolic expressions <code>e</code>. </p>
<p>We create a new symmetric matrix of variables M being positive semidefinite, with the linear equality constraint e == M. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An <a class="el" href="namespace_eigen.html">Eigen</a> Matrix of symbolic expressions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Imposes constraint "e is positive semidefinite". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{1. e is symmetric.<ol type="1">
<li>e(i, j) is linear for all i, j } </li>
</ol>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added positive semidefinite constraint, with the bound variable M that are also newly added. </dd></dl>

</div>
</div>
<a id="ab9a78776183f17d6ec22b4e3a9d27cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a78776183f17d6ec22b4e3a9d27cdb">&#9670;&nbsp;</a></span>AddQuadraticCost() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddQuadraticCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a quadratic cost term of the form 0.5*x'*Q*x + b'*x + c. </p>
<p>Notice that in the optimization program, the constant term <code>c</code> in the cost is ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A quadratic symbolic expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime</td><td>error if the expression is not quadratic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added cost together with the bound variables. </dd></dl>

</div>
</div>
<a id="aae9708627dc1a8b2def71c1524006092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9708627dc1a8b2def71c1524006092">&#9670;&nbsp;</a></span>AddQuadraticCost() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; AddQuadraticCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a cost term of the form 0.5*x'*Q*x + b'x. </p>
<p>Applied to subset of the variables. </p>

</div>
</div>
<a id="a6cc7aa67cc26a874779ec034ab47d679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc7aa67cc26a874779ec034ab47d679">&#9670;&nbsp;</a></span>AddQuadraticCost() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddQuadraticCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form 0.5*x'*Q*x + b'x + c Applied to subset of the variables. </p>

</div>
</div>
<a id="a2b50b2f95a7c6c064f65d5a54449be06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b50b2f95a7c6c064f65d5a54449be06">&#9670;&nbsp;</a></span>AddQuadraticCost() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddQuadraticCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form 0.5*x'*Q*x + b'x Applied to subset of the variables. </p>

</div>
</div>
<a id="a1ae7eae6436a037740a2b8b7ba31f123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae7eae6436a037740a2b8b7ba31f123">&#9670;&nbsp;</a></span>AddQuadraticErrorCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; AddQuadraticErrorCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired). </p>

</div>
</div>
<a id="a3b19f7bda6ac7551c6d0213b40527bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b19f7bda6ac7551c6d0213b40527bf5">&#9670;&nbsp;</a></span>AddQuadraticErrorCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddQuadraticErrorCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired). </p>

</div>
</div>
<a id="a52ceaba09e755defc9a689829a1ceb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ceaba09e755defc9a689829a1ceb84">&#9670;&nbsp;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>linear_expression1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>linear_expression2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>quadratic_expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds rotated Lorentz cone constraint on the linear expression v1, v2 and quadratic expression u, such that v1 * v2 &gt;= u, v1 &gt;= 0, v2 &gt;= 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_expression1</td><td>The linear expression v1. </td></tr>
    <tr><td class="paramname">linear_expression2</td><td>The linear expression v2. </td></tr>
    <tr><td class="paramname">quadratic_expression</td><td>The quadratic expression u. </td></tr>
    <tr><td class="paramname">tol</td><td>The tolerance to determine if the matrix in v2 is positive semidefinite or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DecomposePositiveQuadraticForm for more explanation. <br />
 <em>Default:</em> is 0. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">binding</td><td>The newly added rotated Lorentz cone constraint, together with the bound variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ol type="1">
<li><code>linear_expression1</code> is a linear (affine) expression, in the form of v1 = c1'*x + d1.</li>
<li><code>linear_expression2</code> is a linear (affine) expression, in the form of v2 = c2'*x + d2.</li>
</ol>
<ol type="1">
<li><code>quadratic_expression</code> is a quadratic expression, in the form of <pre>
         u = x'*Q*x + b'x + a
   </pre> Also the quadratic expression has to be convex, namely Q is a positive semidefinite matrix, and the quadratic expression needs to be non-negative for any x. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the preconditions are not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8888193e1130288e45be9edd3f47a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8888193e1130288e45be9edd3f47a7e">&#9670;&nbsp;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constraint that a symbolic expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is in the rotated Lorentz cone, i.e., <p class="formulaDsp">
\[ v_0v_1 \ge v_2^2 + ... + v_{n-1}^2\\ v_0 \ge 0, v_1 \ge 0 \]
</p>
 </td></tr>
    <tr><td class="paramname">v</td><td>A linear expression of variables, \( v = A x + b\), where \( A, b \) are given matrices of the correct size, \( x \) is the vector of decision variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">binding</td><td>The newly added rotated Lorentz cone constraint, together with the bound variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad038198c145926f0e63faf04b254c7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad038198c145926f0e63faf04b254c7a3">&#9670;&nbsp;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables, The linear expression \( z=Ax+b \) is in rotated Lorentz cone. </p>
<p>A vector \( z \in\mathbb{R}^n \) is in the rotated Lorentz cone, if</p>
<p class="formulaDsp">
\[ z_0z_1 \ge z_2^2 + ... + z_{n-1}^2 \]
</p>
<p> where \( A\in\mathbb{R}^{n\times m}, b\in\mathbb{R}^n\) are given matrices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A matrix whose number of columns equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">b</td><td>A vector whose number of rows equals to the size fo the decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the constraint is imposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbaf2d641fd2fffcb7c7a3c68f0929be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbaf2d641fd2fffcb7c7a3c68f0929be">&#9670;&nbsp;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables, The linear expression \( z=Ax+b \) is in rotated Lorentz cone. </p>
<p>A vector \( z \in\mathbb{R}^n \) is in the rotated Lorentz cone, if</p>
<p class="formulaDsp">
\[ z_0z_1 \ge z_2^2 + ... + z_{n-1}^2 \]
</p>
<p> where \( A\in\mathbb{R}^{n\times m}, b\in\mathbb{R}^n\) are given matrices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A matrix whose number of columns equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">b</td><td>A vector whose number of rows equals to the size fo the decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the constraint is imposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c0b88b023b5603a6534662bf98af309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0b88b023b5603a6534662bf98af309">&#9670;&nbsp;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose that a vector \( x\in\mathbb{R}^m \) is in rotated Lorentz cone. </p>
<p>Namely </p><p class="formulaDsp">
\[ x_0 x_1 \ge x_2^2 + ... + x_{m-1}^2\\ x_0 \ge 0, x_1 \ge 0 \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The stacked column of vars lies in the rotated Lorentz cone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added rotated Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="af5a5ef4b6da552936dabb22caae98f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a5ef4b6da552936dabb22caae98f4b">&#9670;&nbsp;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; rows &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose that a vector \( x\in\mathbb{R}^m \) is in rotated Lorentz cone. </p>
<p>Namely </p><p class="formulaDsp">
\[ x_0 x_1 \ge x_2^2 + ... + x_{m-1}^2\\ x_0 \ge 0, x_1 \ge 0 \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The stacked column of vars lies in the rotated Lorentz cone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added rotated Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="a35d050759f5f740a1e116aea34aa2d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d050759f5f740a1e116aea34aa2d10">&#9670;&nbsp;</a></span>AddScaledDiagonallyDominantMatrixConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &gt; AddScaledDiagonallyDominantMatrixConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded variant of <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#addsdd">scaled diagonally dominant matrix constraint</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The matrix X to be constrained scaled diagonally dominant. X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>X(i, j) should be a linear expression of decision variables. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>M A vector of vectors of 2 x 2 symmetric matrices M. For i &lt; j, M[i][j] is <pre>
[Mⁱʲ(i, i), Mⁱʲ(i, j)]
[Mⁱʲ(i, j), Mⁱʲ(j, j)].
</pre> Note that M[i][j](0, 1) = Mⁱʲ(i, j) = (X(i, j) + X(j, i)) / 2 for i &gt;= j, M[i][j] is the zero matrix. </dd></dl>

</div>
</div>
<a id="a4fc0f171dcf3d56002c1f2560e430d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc0f171dcf3d56002c1f2560e430d89">&#9670;&nbsp;</a></span>AddScaledDiagonallyDominantMatrixConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &gt; AddScaledDiagonallyDominantMatrixConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded variant of <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#addsdd">scaled diagonally dominant matrix constraint</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The symmetric matrix X to be constrained scaled diagonally dominant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M For i &lt; j M[i][j] contains the slack variables, mentioned in <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#addsdd">scaled diagonally dominant matrix constraint</a>. For i &gt;= j, M[i][j] contains dummy variables. </dd></dl>

</div>
</div>
<a id="ad1d190e8e690c020760bb1eb14405759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d190e8e690c020760bb1eb14405759">&#9670;&nbsp;</a></span>AddSosConstraint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt; AddSosConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>monomial_basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints that a given polynomial <code>p</code> is a sums-of-squares (SOS), that is, <code>p</code> can be decomposed into <code>mᵀQm</code>, where m is the <code>monomial_basis</code>. </p>
<p>It returns a pair expressing:</p>
<ul>
<li>The coefficients matrix Q, which is positive semidefinite.</li>
<li>The coefficients matching conditions in linear equality constraint. </li>
</ul>

</div>
</div>
<a id="a69e6a59cb48bb8b82a39f44f0eb5fae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e6a59cb48bb8b82a39f44f0eb5fae5">&#9670;&nbsp;</a></span>AddSosConstraint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt; AddSosConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints that a given polynomial <code>p</code> is a sums-of-squares (SOS), that is, <code>p</code> can be decomposed into <code>mᵀQm</code>, where m is the monomial basis of all indeterminates in the program with degree equal to half the TotalDegree of <code>p</code>. </p>
<p>It returns a pair of constraint bindings expressing:</p>
<ul>
<li>The coefficients matrix Q, which is positive semidefinite.</li>
<li>The coefficients matching conditions in linear equality constraint. </li>
</ul>

</div>
</div>
<a id="a6e00f880b6d61bbc722f04ee19dc7ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e00f880b6d61bbc722f04ee19dc7ece">&#9670;&nbsp;</a></span>AddSosConstraint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt; AddSosConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>monomial_basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints that a given symbolic expression <code>e</code> is a sums-of-squares (SOS), that is, <code>p</code> can be decomposed into <code>mᵀQm</code>, where m is the <code>monomial_basis</code>. </p>
<p>Note that it decomposes <code>e</code> into a polynomial with respect to <code><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac236784fdf749e0e3b7921f1d75de1ff" title="Getter for all indeterminates in the program. ">indeterminates()</a></code> in this mathematical program. It returns a pair of constraint bindings expressing:</p>
<ul>
<li>The coefficients matrix Q, which is positive semidefinite.</li>
<li>The coefficients matching conditions in linear equality constraint. </li>
</ul>

</div>
</div>
<a id="a1126da802ae20d4c6556cf5a1258c1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1126da802ae20d4c6556cf5a1258c1cb">&#9670;&nbsp;</a></span>AddSosConstraint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt; AddSosConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints that a given symbolic expression <code>e</code> is a sums-of-squares (SOS), that is, <code>e</code> can be decomposed into <code>mTQm</code>. </p>
<p>Note that it decomposes <code>e</code> into a polynomial with respect to <code><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac236784fdf749e0e3b7921f1d75de1ff" title="Getter for all indeterminates in the program. ">indeterminates()</a></code> in this mathematical program. It returns a pair of constraint bindings expressing:</p>
<ul>
<li>The coefficients matrix Q, which is positive semidefinite.</li>
<li>The coefficients matching conditions in linear equality constraint. </li>
</ul>

</div>
</div>
<a id="a4724865fbef538d6b26a1d1934f93166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4724865fbef538d6b26a1d1934f93166">&#9670;&nbsp;</a></span>AddVisualizationCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt; AddVisualizationCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html#a84c15b60ba647eabef0aaa2d5dd3943e">VisualizationCallback::CallbackFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a callback method to visualize intermediate results of the optimization. </p>
<dl class="section note"><dt>Note</dt><dd>Just like other costs/constraints, not all solvers support callbacks. Adding a callback here will force <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae20c365943aa8acb50dfd6b99b7e5194" title="Solve the MathematicalProgram. ">MathematicalProgram::Solve</a> to select a solver that support callbacks. For instance, adding a visualization callback to a quadratic programming problem may result in using a nonlinear programming solver as the default solver.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>a std::function that accepts an Eigen::Vector of doubles representing the bound decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>the decision variables that should be passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d2cc4c49122282ae0b2fe0511e86817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2cc4c49122282ae0b2fe0511e86817">&#9670;&nbsp;</a></span>AddVisualizationCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a>&gt; AddVisualizationCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html#a84c15b60ba647eabef0aaa2d5dd3943e">VisualizationCallback::CallbackFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback method to visualize intermediate results of the optimization. </p>
<dl class="section note"><dt>Note</dt><dd>Just like other costs/constraints, not all solvers support callbacks. Adding a callback here will force <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae20c365943aa8acb50dfd6b99b7e5194" title="Solve the MathematicalProgram. ">MathematicalProgram::Solve</a> to select a solver that support callbacks. For instance, adding a visualization callback to a quadratic programming problem may result in using a nonlinear programming solver as the default solver.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>a std::function that accepts an Eigen::Vector of doubles representing the for the bound decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>the decision variables that should be passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af39c3045633d664d62c161a5ef4f3c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39c3045633d664d62c161a5ef4f3c4c">&#9670;&nbsp;</a></span>bounding_box_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; &gt;&amp; bounding_box_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for all bounding box constraints. </p>

</div>
</div>
<a id="a8bf8eca4db252695b1950209857df07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf8eca4db252695b1950209857df07a">&#9670;&nbsp;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &gt; Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clones an optimization program. </p>
<p>The clone will be functionally equivalent to the source program with the same:</p>
<ul>
<li>decision variables</li>
<li>constraints</li>
<li>costs</li>
<li>solver settings</li>
<li>initial guess</li>
</ul>
<p>However, the clone's x values will be initialized to NaN, and all internal solvers will be freshly constructed. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">new_prog.</td><td>The newly constructed mathematical program. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7647680c7f56fdae6dc324db6aed1e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7647680c7f56fdae6dc324db6aed1e45">&#9670;&nbsp;</a></span>decision_variable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&amp; decision_variable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the decision variable with index <code>i</code> in the program. </p>

</div>
</div>
<a id="a24b7242d08574fad6a8b10cfc8e54bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b7242d08574fad6a8b10cfc8e54bca">&#9670;&nbsp;</a></span>decision_variables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&amp; decision_variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for all decision variables in the program. </p>

</div>
</div>
<a id="aac012f5939e75603d8318ab593b8d04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac012f5939e75603d8318ab593b8d04b">&#9670;&nbsp;</a></span>EvalBinding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt;DerivedX&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;typename DerivedX::Scalar&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> EvalBinding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>prog_var_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the value of some binding, for some input value for all decision variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>A <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C...">Binding</a> whose variables are decision variables in this program. </td></tr>
    <tr><td class="paramname">prog_var_vals</td><td>The value of all the decision variables in this program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the size of <code>prog_var_vals</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eb46a0ff11d6f6d22d69d9c16bfce94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb46a0ff11d6f6d22d69d9c16bfce94">&#9670;&nbsp;</a></span>EvalBindingAtInitialGuess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd EvalBindingAtInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the evaluator in <code>binding</code> at the initial guess. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of <code>binding</code> at the initial guess. </dd></dl>

</div>
</div>
<a id="a0c00066544e9e2b4ca941a3e13f622cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c00066544e9e2b4ca941a3e13f622cb">&#9670;&nbsp;</a></span>EvalBindingAtSolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd EvalBindingAtSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the evaluator in <code>binding</code> at the solution value. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of <code>binding</code> at the solution value. </dd></dl>

</div>
</div>
<a id="a588201aaba06e4f4e6b1b76b7270d1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588201aaba06e4f4e6b1b76b7270d1bf">&#9670;&nbsp;</a></span>EvalBindings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt;DerivedX&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;typename DerivedX::Scalar&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> EvalBindings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>prog_var_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates a set of bindings (plural version of <code>EvalBinding</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindings</td><td>List of bindings. </td></tr>
    <tr><td class="paramname">prog</td><td></td></tr>
    <tr><td class="paramname">prog_var_vals</td><td>The value of all the decision variables in this program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All binding values, concatenated into a single vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the size of <code>prog_var_vals</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a856ded9f90eaac91a1c66f2c139566b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856ded9f90eaac91a1c66f2c139566b5">&#9670;&nbsp;</a></span>EvalVisualizationCallbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EvalVisualizationCallbacks </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>prog_var_vals</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates all visualization callbacks registered with the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog_var_vals</td><td>The value of all the decision variables in this program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the size does not match. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f25e54555621691b390c1658e21872f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f25e54555621691b390c1658e21872f">&#9670;&nbsp;</a></span>FindDecisionVariableIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> FindDecisionVariableIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the decision variable. </p>
<p>Internally the solvers thinks all variables are stored in an array, and it accesses each individual variable using its index. This index is used when adding constraints and costs for each solver. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>var</code> is a decision variable in the mathematical program, otherwise this function throws a runtime error.} </dd></dl>

</div>
</div>
<a id="a5aa2cdf4c8e6fae22b6b78718aeb0db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa2cdf4c8e6fae22b6b78718aeb0db0">&#9670;&nbsp;</a></span>FindDecisionVariableIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; FindDecisionVariableIndices </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the indices of the decision variables. </p>
<p>Internally the solvers thinks all variables are stored in an array, and it accesses each individual variable using its index. This index is used when adding constraints and costs for each solver. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>vars</code> are decision variables in the mathematical program, otherwise this function throws a runtime error.} </dd></dl>

</div>
</div>
<a id="a1470ed93553619a1f630bc8035947556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1470ed93553619a1f630bc8035947556">&#9670;&nbsp;</a></span>FindIndeterminateIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FindIndeterminateIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the indeterminate. </p>
<p>Internally a solver thinks all indeterminates are stored in an array, and it accesses each individual indeterminate using its index. This index is used when adding constraints and costs for each solver. </p><dl class="section pre"><dt>Precondition</dt><dd><code>var</code> is a indeterminate in the mathematical program, otherwise this function throws a runtime error. </dd></dl>

</div>
</div>
<a id="a63a221ef50ba7ccdff7222a5a0fb38b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a221ef50ba7ccdff7222a5a0fb38b7">&#9670;&nbsp;</a></span>generic_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a>&gt; &gt;&amp; generic_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for all generic constraints. </p>

</div>
</div>
<a id="a76eeecc02d2b6d3f2c11b407e70baf86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76eeecc02d2b6d3f2c11b407e70baf86">&#9670;&nbsp;</a></span>generic_costs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; &gt;&amp; generic_costs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for all generic costs. </p>

</div>
</div>
<a id="afee45efd038cc24341094591bf1cbdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee45efd038cc24341094591bf1cbdbc">&#9670;&nbsp;</a></span>GetAllConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a>&gt; &gt; GetAllConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for returning all constraints. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of all constraint bindings. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The group ordering may change as more constraint types are added. </dd></dl>

</div>
</div>
<a id="ad90403c02bdb7c61d7a8de5dd39e9c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90403c02bdb7c61d7a8de5dd39e9c39">&#9670;&nbsp;</a></span>GetAllCosts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; &gt; GetAllCosts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter returning all costs. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of all cost bindings. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The group ordering may change as more cost types are added. </dd></dl>

</div>
</div>
<a id="a17fe85b6ddbc665b74e8cf9c6bf02d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fe85b6ddbc665b74e8cf9c6bf02d3e">&#9670;&nbsp;</a></span>GetAllLinearConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; &gt; GetAllLinearConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter returning all linear constraints (both linear equality and inequality constraints). </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of all linear constraint bindings. </dd></dl>

</div>
</div>
<a id="aa44e07a559ca22d055de33fa1154c095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44e07a559ca22d055de33fa1154c095">&#9670;&nbsp;</a></span>GetInitialGuess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>decision_variable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the initial guess for a single variable. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>decision_variable</code> has been registered in the optimization program. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the pre condition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14f923497a86e90898843b496cc3f4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f923497a86e90898843b496cc3f4e5">&#9670;&nbsp;</a></span>GetInitialGuess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> GetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>decision_variable_mat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the initial guess for some variables. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Each variable in <code>decision_variable_mat</code> has been registered in the optimization program. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the pre condition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f32040318cf7c8e905b0b800be60bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f32040318cf7c8e905b0b800be60bac">&#9670;&nbsp;</a></span>GetLowerBoundCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GetLowerBoundCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for lower bound on optimal cost. </p>
<p>Defaults to -Infinity if a lower bound has not been found. </p>

</div>
</div>
<a id="a57c1b4cd100b3f6f6b6a22d8e924df4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c1b4cd100b3f6f6b6a22d8e924df4e">&#9670;&nbsp;</a></span>GetOptimalCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GetOptimalCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for optimal cost at the solution. </p>
<p>If the solver finds an optimal solution, then we return the cost evaluated at this solution. If the program is unbounded, then the optimal cost is -∞. If the program is globally infeasible, then the optimal cost is +∞. If the program is locally infeasible, then the solver (e.g. SNOPT) might return some finite value as the optimal cost. Otherwise, the optimal cost is NaN. </p>

</div>
</div>
<a id="ad3f9009b5477548c86d6253f21975323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f9009b5477548c86d6253f21975323">&#9670;&nbsp;</a></span>GetSolution() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> GetSolution </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the solution of an <a class="el" href="namespace_eigen.html">Eigen</a> matrix of decision variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An <a class="el" href="namespace_eigen.html">Eigen</a> matrix containing Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The decision variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the decision variable after solving the problem. </dd></dl>

</div>
</div>
<a id="ae75eb95dd928015b0410479833c607f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75eb95dd928015b0410479833c607f7">&#9670;&nbsp;</a></span>GetSolution() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GetSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of a single decision variable. </p>

</div>
</div>
<a id="a806624bdd09d8a198d65059d91839225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806624bdd09d8a198d65059d91839225">&#9670;&nbsp;</a></span>GetSolution() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt;<a class="el" href="classdouble.html">double</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> GetSolution </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the solution of an <a class="el" href="namespace_eigen.html">Eigen</a> matrix of decision variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An <a class="el" href="namespace_eigen.html">Eigen</a> matrix containing Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The decision variables. </td></tr>
    <tr><td class="paramname">result</td><td>The result returned from the solver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function doesn't use the decision variable values stored inside <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">solvers::MathematicalProgram</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the decision variable after solving the problem. </dd></dl>

</div>
</div>
<a id="a23658fd494c462200ab524ed7724e689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23658fd494c462200ab524ed7724e689">&#9670;&nbsp;</a></span>GetSolution() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GetSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of a single decision variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The symbolic variable as a decision variable of the program. </td></tr>
    <tr><td class="paramname">result</td><td>The result returned from calling the solver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if result.get_x_vals().rows() != <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a224e4c35014e87139f73f9a517866796" title="Getter for number of variables in the optimization program. ">num_vars()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b609790733dca7e3b174959d2ab2c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b609790733dca7e3b174959d2ab2c31">&#9670;&nbsp;</a></span>GetSolverData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; GetSolverData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54cf76d7a3bab899a9454a9cd6d19264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54cf76d7a3bab899a9454a9cd6d19264">&#9670;&nbsp;</a></span>GetSolverId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a9f2ec0f640175b49517f43f37073bfc8">optional</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a>&gt; GetSolverId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ID of the solver that was used to solve this program. </p>
<p>Returns empty if <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae20c365943aa8acb50dfd6b99b7e5194" title="Solve the MathematicalProgram. ">Solve()</a> has not been called. </p>

</div>
</div>
<a id="a7abf83f965123608bf855d5eef56806f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abf83f965123608bf855d5eef56806f">&#9670;&nbsp;</a></span>GetSolverOptionsDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;std::string, <a class="el" href="classdouble.html">double</a>&gt;&amp; GetSolverOptionsDouble </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa53e7b6bf2db39795a28138edda49638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53e7b6bf2db39795a28138edda49638">&#9670;&nbsp;</a></span>GetSolverOptionsInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;std::string, <a class="el" href="classint.html">int</a>&gt;&amp; GetSolverOptionsInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac296d646cdfb000b49df738e9da24159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac296d646cdfb000b49df738e9da24159">&#9670;&nbsp;</a></span>GetSolverOptionsStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;std::string, std::string&gt;&amp; GetSolverOptionsStr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6736e7e843acfd67ecd254b9a2270863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6736e7e843acfd67ecd254b9a2270863">&#9670;&nbsp;</a></span>indeterminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&amp; indeterminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the indeterminate with index <code>i</code> in the program. </p>

</div>
</div>
<a id="ac236784fdf749e0e3b7921f1d75de1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac236784fdf749e0e3b7921f1d75de1ff">&#9670;&nbsp;</a></span>indeterminates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&amp; indeterminates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for all indeterminates in the program. </p>

</div>
</div>
<a id="a8d203a1789d8fe03eeaaacdb49a267d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d203a1789d8fe03eeaaacdb49a267d4">&#9670;&nbsp;</a></span>initial_guess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::VectorXd&amp; initial_guess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the initial guess. </p>

</div>
</div>
<a id="a1d9e00f78efde184f9f7377ed0a42700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9e00f78efde184f9f7377ed0a42700">&#9670;&nbsp;</a></span>linear_complementarity_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a>&gt; &gt;&amp; linear_complementarity_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for all linear complementarity constraints. </p>

</div>
</div>
<a id="a5febe285490e9ce74e824de29f2ecd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5febe285490e9ce74e824de29f2ecd9f">&#9670;&nbsp;</a></span>linear_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; &gt;&amp; linear_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for linear constraints. </p>

</div>
</div>
<a id="a073a43c000385cfb134619ac960ab36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073a43c000385cfb134619ac960ab36f">&#9670;&nbsp;</a></span>linear_costs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt; &gt;&amp; linear_costs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for linear costs. </p>

</div>
</div>
<a id="aac264e3eaafb940135dfa11d3ba84c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac264e3eaafb940135dfa11d3ba84c67">&#9670;&nbsp;</a></span>linear_equality_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; &gt;&amp; linear_equality_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for linear equality constraints. </p>

</div>
</div>
<a id="a27e3ce329f648aae3bea248179013b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e3ce329f648aae3bea248179013b34">&#9670;&nbsp;</a></span>linear_matrix_inequality_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a>&gt; &gt;&amp; linear_matrix_inequality_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for linear matrix inequality constraint. </p>

</div>
</div>
<a id="ae9af8bd45f4e7aa63918031b0774fed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9af8bd45f4e7aa63918031b0774fed0">&#9670;&nbsp;</a></span>lorentz_cone_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; &gt;&amp; lorentz_cone_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for Lorentz cone constraint. </p>

</div>
</div>
<a id="a8f76110fcfea54be86c2ef1ebfeaab55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f76110fcfea54be86c2ef1ebfeaab55">&#9670;&nbsp;</a></span>MakeCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; MakeCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an input of type <code>F</code> to a FunctionCost object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>This class should have functions numInputs(), numOutputs and eval(x, y). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structdrake_1_1solvers_1_1detail_1_1_function_traits.html" title="FunctionTraits. ">drake::solvers::detail::FunctionTraits</a>. </dd></dl>

</div>
</div>
<a id="ae4e5827a62c6aadac95e0a053cf3fe08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e5827a62c6aadac95e0a053cf3fe08">&#9670;&nbsp;</a></span>NewBinaryVariables() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;Rows, Cols&gt; NewBinaryVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds binary variables, appending them to an internal vector of any existing vars. </p>
<p>The initial guess values for the new variables are set to NaN, to indicate that an initial guess has not been assigned. Callers are expected to add costs and/or constraints to have any effect during optimization. Callers can also set the initial guess of the decision variables through <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae48cb6d2263ccf09e38932dcd27f769f" title="Sets the initial guess for a single variable decision_variable. ">SetInitialGuess()</a> or <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae35679ed5aabea90fcf4ff3b337b44f5" title="Set the initial guess for ALL decision variables. ">SetInitialGuessForAllVariables()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>The number of rows in the new variables. </td></tr>
    <tr><td class="paramname">Cols</td><td>The number of columns in the new variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new variables. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new variables. </td></tr>
    <tr><td class="paramname">name</td><td>The commonly shared name of the new variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixDecisionVariable of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> <a class="code" href="gurobi__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>;</div><div class="line"><span class="keyword">auto</span> b = prog.NewBinaryVariables(2, 3, <span class="stringliteral">&quot;b&quot;</span>);</div></div><!-- fragment --><p> This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a07b5acd86b0429f7cd22b04355f1f774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b5acd86b0429f7cd22b04355f1f774">&#9670;&nbsp;</a></span>NewBinaryVariables() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;Rows, Cols&gt; NewBinaryVariables </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;b&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a matrix of binary variables into the optimization program. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>The number of rows in the newly added binary variables. </td></tr>
    <tr><td class="paramname">Cols</td><td>The number of columns in the new variables. The default is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Each newly added binary variable will share the same name. The default name is "b". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix containing the newly added variables. </dd></dl>

</div>
</div>
<a id="a30759ec657805673fd0ce5e9edc166a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30759ec657805673fd0ce5e9edc166a2">&#9670;&nbsp;</a></span>NewBinaryVariables() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> NewBinaryVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;b&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds binary variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<p>The new variables are viewed as a column vector, with size <code>rows</code> x 1. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae4e5827a62c6aadac95e0a053cf3fe08" title="Adds binary variables, appending them to an internal vector of any existing vars. ...">NewBinaryVariables</a>(int rows, int cols, const std::vector&lt;std::string&gt;&amp; <a class="el" href="translator__test_8cc.html#a9c4192866025823ecd5592526c757c0b">names</a>); </dd></dl>

</div>
</div>
<a id="a53949966a66a6f53ba90596fc5a439ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53949966a66a6f53ba90596fc5a439ef">&#9670;&nbsp;</a></span>NewContinuousVariables() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> NewContinuousVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;x&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds continuous variables, appending them to an internal vector of any existing vars. </p>
<p>The initial guess values for the new variables are set to NaN, to indicate that an initial guess has not been assigned. Callers are expected to add costs and/or constraints to have any effect during optimization. Callers can also set the initial guess of the decision variables through <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae48cb6d2263ccf09e38932dcd27f769f" title="Sets the initial guess for a single variable decision_variable. ">SetInitialGuess()</a> or <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae35679ed5aabea90fcf4ff3b337b44f5" title="Set the initial guess for ALL decision variables. ">SetInitialGuessForAllVariables()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new variables. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the newly added variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The VectorDecisionVariable of size rows x 1, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> <a class="code" href="gurobi__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>;</div><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables(2, <span class="stringliteral">&quot;x&quot;</span>);</div></div><!-- fragment --><p> This adds a 2 x 1 vector containing decision variables into the program. The names of the variables are "x(0)" and "x(1)".</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a2cd612c938a2bb1887476dadf65dd0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd612c938a2bb1887476dadf65dd0a5">&#9670;&nbsp;</a></span>NewContinuousVariables() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;Rows, Cols&gt; NewContinuousVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;X&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds continuous variables, appending them to an internal vector of any existing vars. </p>
<p>The initial guess values for the new variables are set to NaN, to indicate that an initial guess has not been assigned. Callers are expected to add costs and/or constraints to have any effect during optimization. Callers can also set the initial guess of the decision variables through <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae48cb6d2263ccf09e38932dcd27f769f" title="Sets the initial guess for a single variable decision_variable. ">SetInitialGuess()</a> or <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae35679ed5aabea90fcf4ff3b337b44f5" title="Set the initial guess for ALL decision variables. ">SetInitialGuessForAllVariables()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>The number of rows of the new variables, in the compile time. </td></tr>
    <tr><td class="paramname">Cols</td><td>The number of columns of the new variables, in the compile time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new variables. When Rows is not Eigen::Dynamic, rows is ignored. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new variables. When Cols is not Eigen::Dynamic, cols is ignored. </td></tr>
    <tr><td class="paramname">name</td><td>All variables will share the same name, but different index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixDecisionVariable of size Rows x Cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> <a class="code" href="gurobi__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>;</div><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables(2, 3, <span class="stringliteral">&quot;X&quot;</span>);</div><div class="line"><span class="keyword">auto</span> y = prog.NewContinuousVariables&lt;2, 3&gt;(2, 3, <span class="stringliteral">&quot;X&quot;</span>);</div></div><!-- fragment --><p> This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a8f22188fff7a464ac091b8fea727a89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f22188fff7a464ac091b8fea727a89d">&#9670;&nbsp;</a></span>NewContinuousVariables() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;Rows, Cols&gt; NewContinuousVariables </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;X&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds continuous variables, appending them to an internal vector of any existing vars. </p>
<p>The initial guess values for the new variables are set to NaN, to indicate that an initial guess has not been assigned. Callers are expected to add costs and/or constraints to have any effect during optimization. Callers can also set the initial guess of the decision variables through <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae48cb6d2263ccf09e38932dcd27f769f" title="Sets the initial guess for a single variable decision_variable. ">SetInitialGuess()</a> or <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae35679ed5aabea90fcf4ff3b337b44f5" title="Set the initial guess for ALL decision variables. ">SetInitialGuessForAllVariables()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>The number of rows in the new variables. </td></tr>
    <tr><td class="paramname">Cols</td><td>The number of columns in the new variables. The default is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>All variables will share the same name, but different index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixDecisionVariable of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> <a class="code" href="gurobi__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>;</div><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables&lt;2, 3&gt;(<span class="stringliteral">&quot;X&quot;</span>);</div></div><!-- fragment --><p> This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="ae6a71c1f6466e5dedbd2cd73372dfcd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a71c1f6466e5dedbd2cd73372dfcd5">&#9670;&nbsp;</a></span>NewFreePolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> NewFreePolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>indeterminates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>coeff_name</em> = <code>&quot;a&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a free polynomial in a monomial basis over <code>indeterminates</code> of a given <code>degree</code>. </p>
<p>It uses <code>coeff_name</code> to make new decision variables and use them as coefficients. For example, <code>NewFreePolynomial({x₀, x₁}, 2)</code> returns a₀x₁² + a₁x₀x₁ + a₂x₀² + a₃x₁ + a₄x₀ + a₅. </p>

</div>
</div>
<a id="a0228101da15efa318a6e51349d3ff0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0228101da15efa318a6e51349d3ff0a4">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt;rows, cols&gt; NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::string, rows *cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds indeterminates, appending them to an internal vector of any existing indeterminates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>A vector of strings containing the name for each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixIndeterminate of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> <a class="code" href="gurobi__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>;</div><div class="line">std::array&lt;std::string, 6&gt; <a class="code" href="translator__test_8cc.html#a9c4192866025823ecd5592526c757c0b">names</a> = {<span class="stringliteral">&quot;x1&quot;</span>, <span class="stringliteral">&quot;x2&quot;</span>, <span class="stringliteral">&quot;x3&quot;</span>, <span class="stringliteral">&quot;x4&quot;</span>, <span class="stringliteral">&quot;x5&quot;</span>, <span class="stringliteral">&quot;x6&quot;</span>};</div><div class="line"><span class="keyword">auto</span> x = prog.NewIndeterminates&lt;2, 3&gt;(<a class="code" href="translator__test_8cc.html#a9c4192866025823ecd5592526c757c0b">names</a>);</div></div><!-- fragment --><p> This adds a 2 x 3 matrix indeterminates into the program.</p>
<p>The name of the indeterminates is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="aae23f7c130166d82b578205015aed630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae23f7c130166d82b578205015aed630">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt;rows&gt; NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::string, rows &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds indeterminates, appending them to an internal vector of any existing indeterminates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>A vector of strings containing the name for each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixIndeterminate of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> <a class="code" href="gurobi__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>;</div><div class="line">std::array&lt;std::string, 2&gt; names = {<span class="stringliteral">&quot;x1&quot;</span>, <span class="stringliteral">&quot;x2&quot;</span>};</div><div class="line"><span class="keyword">auto</span> x = prog.NewIndeterminates&lt;2&gt;(<a class="code" href="translator__test_8cc.html#a9c4192866025823ecd5592526c757c0b">names</a>);</div></div><!-- fragment --><p> This adds a 2 vector indeterminates into the program.</p>
<p>The name of the indeterminates is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a84c82857db425d76e1e49d69560f989d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c82857db425d76e1e49d69560f989d">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt;rows, cols&gt; NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;X&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds indeterminates, appending them to an internal vector of any existing indeterminates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>A vector of strings containing the name for each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixIndeterminate of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> <a class="code" href="gurobi__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>;</div><div class="line"><span class="keyword">auto</span> x = prog.NewIndeterminates&lt;2, 3&gt;(<span class="stringliteral">&quot;X&quot;</span>);</div></div><!-- fragment --><p> This adds a 2 x 3 matrix indeterminates into the program.</p>
<p>The name of the indeterminates is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a26d51c28aae22e905563f6b00f3c65a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d51c28aae22e905563f6b00f3c65a7">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt;rows&gt; NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;x&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds indeterminates to the program. </p>
<p>The name for all newly added indeterminates are set to <code>name</code>. The default name is "x" </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aae23f7c130166d82b578205015aed630" title="Adds indeterminates, appending them to an internal vector of any existing indeterminates. ">NewIndeterminates(const std::array&lt;std::string, rows&gt;&amp; names)</a> </dd></dl>

</div>
</div>
<a id="a0fd679ea34528e50d76d23f79fcd294f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd679ea34528e50d76d23f79fcd294f">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0228101da15efa318a6e51349d3ff0a4" title="Adds indeterminates, appending them to an internal vector of any existing indeterminates. ">NewIndeterminates</a>(int rows, int cols, const std::vector&lt;std::string&gt;&amp; <a class="el" href="translator__test_8cc.html#a9c4192866025823ecd5592526c757c0b">names</a>); </dd></dl>

</div>
</div>
<a id="ae4ec9c4fc4ae8f5d8ff8382b227dd82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ec9c4fc4ae8f5d8ff8382b227dd82f">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;x&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, with default name "x". </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0228101da15efa318a6e51349d3ff0a4" title="Adds indeterminates, appending them to an internal vector of any existing indeterminates. ">NewIndeterminates</a>(int rows, int cols, const std::vector&lt;std::string&gt;&amp; <a class="el" href="translator__test_8cc.html#a9c4192866025823ecd5592526c757c0b">names</a>); </dd></dl>

</div>
</div>
<a id="a12431081348a404711db4d3bb25c8a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12431081348a404711db4d3bb25c8a76">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a> NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates, appending them to an internal vector of any existing vars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new indeterminates. </td></tr>
    <tr><td class="paramname">names</td><td>A vector of strings containing the name for each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixIndeterminate of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> <a class="code" href="gurobi__solver_8cc.html#a696e816beb9a54549c52c173a8b7ef04">prog</a>;</div><div class="line"><span class="keyword">auto</span> x = prog.NewIndeterminates(2, 3, {<span class="stringliteral">&quot;x1&quot;</span>, <span class="stringliteral">&quot;x2&quot;</span>, <span class="stringliteral">&quot;x3&quot;</span>, <span class="stringliteral">&quot;x4&quot;</span>,</div><div class="line"><span class="stringliteral">&quot;x5&quot;</span>, <span class="stringliteral">&quot;x6&quot;</span>});</div></div><!-- fragment --><p> This adds a 2 x 3 matrix indeterminates into the program.</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="ad7e4fa58845ca19073b0c532431ac141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e4fa58845ca19073b0c532431ac141">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a> NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;X&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, with default name "X". </p>
<p>The new variables are returned and viewed as a matrix, with size <code>rows</code> x <code>cols</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0228101da15efa318a6e51349d3ff0a4" title="Adds indeterminates, appending them to an internal vector of any existing indeterminates. ">NewIndeterminates</a>(int rows, int cols, const std::vector&lt;std::string&gt;&amp; <a class="el" href="translator__test_8cc.html#a9c4192866025823ecd5592526c757c0b">names</a>); </dd></dl>

</div>
</div>
<a id="a5404758e930bc3fc23b26635092458da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5404758e930bc3fc23b26635092458da">&#9670;&nbsp;</a></span>NewNonnegativePolynomial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; NewNonnegativePolynomial </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>monomial_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair of nonnegative polynomial p = mᵀQm and the coefficient matrix Q, where m is <code>monomial_basis</code>. </p>
<p>Adds Q as decision variables to the program. Depending on the type of the polynomial, we will impose different constraint on Q. if type = kSos, we impose Q being positive semidefinite. if type = kSdsos, we impose Q being scaled diagonally dominant. if type = kDsos, we impose Q being positive diagonally dominant. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monomial_basis</td><td>The monomial basis. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the nonnegative polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(p, Q) The polynomial p and the coefficient matrix Q. Q has been added as decision variables to the program. </dd></dl>

</div>
</div>
<a id="af0e1be270437666161b6c427209a7267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e1be270437666161b6c427209a7267">&#9670;&nbsp;</a></span>NewNonnegativePolynomial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; NewNonnegativePolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>indeterminates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair of nonnegative polynomial p = mᵀQm and the coefficient matrix Q, where m is the monomial basis, containing all monomials of <code>indeterminates</code> of total order up to <code>degree</code> / 2, hence the polynomial p contains all the monomials of total order up to <code>degree</code>, as p is quadratic in m. </p>
<p>Adds Q as decision variables to the program. Depending on the type of the polynomial, we will impose different constraint on Q. if type = kSos, we impose Q being positive semidefinite. if type = kSdsos, we impose Q being scaled diagonally dominant. if type = kDsos, we impose Q being positive diagonally dominant. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indeterminates</td><td>All the indeterminates in the polynomial p. </td></tr>
    <tr><td class="paramname">degree</td><td>The polynomial p will contain all the monomials up to order <code>degree</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the nonnegative polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(p, Q) The polynomial p and the coefficient matrix Q. Q has been added as decision variables to the program. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>degree</code> is a positive even number. </dd></dl>

</div>
</div>
<a id="a790ff49f1d271fed2a533347c4686bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790ff49f1d271fed2a533347c4686bf9">&#9670;&nbsp;</a></span>NewSosPolynomial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; NewSosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>monomial_basis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair of a SOS polynomial p = mᵀQm and the coefficient matrix Q, where m is the <code>monomial</code> basis. </p>
<p>For example, <code>NewSosPolynomial(Vector2&lt;Monomial&gt;{x,y})</code> returns a polynomial p = Q₍₀,₀₎x² + 2Q₍₁,₀₎xy + Q₍₁,₁₎y² and Q. </p><dl class="section note"><dt>Note</dt><dd>Q is a symmetric monomial_basis.rows() x monomial_basis.rows() matrix. </dd></dl>

</div>
</div>
<a id="a559577e6f188c292f246a3866528d1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559577e6f188c292f246a3866528d1e6">&#9670;&nbsp;</a></span>NewSosPolynomial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; NewSosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>indeterminates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair of a SOS polynomial p = m(x)ᵀQm(x) of degree <code>degree</code> and the coefficient matrix Q that should be PSD, where m(x) is the result of calling <code>MonomialBasis(indeterminates, degree/2)</code>. </p>
<p>For example, <code>NewSosPolynomial({x}, 4)</code> returns a pair of a polynomial p = Q₍₀,₀₎x⁴ + 2Q₍₁,₀₎ x³ + (2Q₍₂,₀₎ + Q₍₁,₁₎)x² + 2Q₍₂,₁₎x + Q₍₂,₂₎ and Q.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>degree</code> is not a positive even integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>MonomialBasis. </dd></dl>

</div>
</div>
<a id="a8f718351922bc149cb6e7fa6d82288a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f718351922bc149cb6e7fa6d82288a5">&#9670;&nbsp;</a></span>NewSymmetricContinuousVariables() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> NewSymmetricContinuousVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;Symmetric&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a runtime sized symmetric matrix as decision variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<p>The optimization will only use the stacked columns of the lower triangular part of the symmetric matrix as decision variables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the symmetric matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the matrix. It is only used the for user to understand the optimization program. The default name is "Symmetric", and each variable will be named as <pre>
Symmetric(0, 0)     Symmetric(1, 0)     ... Symmetric(rows-1, 0)
Symmetric(1, 0)     Symmetric(1, 1)     ... Symmetric(rows-1, 1)
           ...
Symmetric(rows-1,0) Symmetric(rows-1,1) ... Symmetric(rows-1, rows-1)
</pre> Notice that the (i,j)'th entry and (j,i)'th entry has the same name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added decision variables. </dd></dl>

</div>
</div>
<a id="af9a84a217cea56358191de7d25c142c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a84a217cea56358191de7d25c142c0">&#9670;&nbsp;</a></span>NewSymmetricContinuousVariables() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;rows, rows&gt; NewSymmetricContinuousVariables </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;Symmetric&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a static sized symmetric matrix as decision variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<p>The optimization will only use the stacked columns of the lower triangular part of the symmetric matrix as decision variables. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the symmetric matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the matrix. It is only used the for user to understand the optimization program. The default name is "Symmetric", and each variable will be named as <pre>
Symmetric(0, 0)     Symmetric(1, 0)     ... Symmetric(rows-1, 0)
Symmetric(1, 0)     Symmetric(1, 1)     ... Symmetric(rows-1, 1)
           ...
Symmetric(rows-1,0) Symmetric(rows-1,1) ... Symmetric(rows-1, rows-1)
</pre> Notice that the (i,j)'th entry and (j,i)'th entry has the same name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added decision variables. </dd></dl>

</div>
</div>
<a id="a3b1e942fc28f03d2b987fc0ea880e831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1e942fc28f03d2b987fc0ea880e831">&#9670;&nbsp;</a></span>num_indeterminates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_indeterminates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of indeterminates in the optimization program. </p>

</div>
</div>
<a id="a224e4c35014e87139f73f9a517866796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224e4c35014e87139f73f9a517866796">&#9670;&nbsp;</a></span>num_vars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_vars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for number of variables in the optimization program. </p>

</div>
</div>
<a id="a751cdda7529e03736fc7530fad6bd7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751cdda7529e03736fc7530fad6bd7fa">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6bf33171369a5b673c956f7e21e1c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bf33171369a5b673c956f7e21e1c5f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a653ebdfdf842cca45abac0c708d1195e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653ebdfdf842cca45abac0c708d1195e">&#9670;&nbsp;</a></span>positive_semidefinite_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a>&gt; &gt;&amp; positive_semidefinite_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for positive semidefinite constraint. </p>

</div>
</div>
<a id="a58b055ec02e32a70bd184a3f17f57734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b055ec02e32a70bd184a3f17f57734">&#9670;&nbsp;</a></span>PrintSolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PrintSolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a67254b4fe297880931e6c66562f36353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67254b4fe297880931e6c66562f36353">&#9670;&nbsp;</a></span>quadratic_costs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; &gt;&amp; quadratic_costs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for quadratic costs. </p>

</div>
</div>
<a id="a2a7f71f7ae23678cd721de4cfcb52f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7f71f7ae23678cd721de4cfcb52f54">&#9670;&nbsp;</a></span>required_capabilities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a>&amp; required_capabilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for the required capability on the solver, given the cost/constraint/variable types in the program. </p>

</div>
</div>
<a id="aeb8ffa00352e1b2d8f1e8cfa720dc88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8ffa00352e1b2d8f1e8cfa720dc88c">&#9670;&nbsp;</a></span>rotated_lorentz_cone_constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; &gt;&amp; rotated_lorentz_cone_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for rotated Lorentz cone constraint. </p>

</div>
</div>
<a id="ae48cb6d2263ccf09e38932dcd27f769f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48cb6d2263ccf09e38932dcd27f769f">&#9670;&nbsp;</a></span>SetInitialGuess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>decision_variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>variable_guess_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the initial guess for a single variable <code>decision_variable</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>decision_variable is a registered decision variable in the program. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if precondition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6eca61aa09da31d13c9d476cf1b6b760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eca61aa09da31d13c9d476cf1b6b760">&#9670;&nbsp;</a></span>SetInitialGuess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>decision_variable_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the initial guess for the decision variables stored in <code>decision_variable_mat</code> to be <code>x0</code>. </p>
<p>Variables begin with a default initial guess of NaN to indicate that no guess is available. </p>

</div>
</div>
<a id="ae35679ed5aabea90fcf4ff3b337b44f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35679ed5aabea90fcf4ff3b337b44f5">&#9670;&nbsp;</a></span>SetInitialGuessForAllVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetInitialGuessForAllVariables </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the initial guess for ALL decision variables. </p>
<p>Note that variables begin with a default initial guess of NaN to indicate that no guess is available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>A vector of appropriate size (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a224e4c35014e87139f73f9a517866796" title="Getter for number of variables in the optimization program. ">num_vars()</a> x 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77b58f1d09a3aec5918813ba163c1098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b58f1d09a3aec5918813ba163c1098">&#9670;&nbsp;</a></span>SetSolverOption() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetSolverOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solver_option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>option_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3aafa15b34bc04d8a3449f39787bc76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aafa15b34bc04d8a3449f39787bc76e">&#9670;&nbsp;</a></span>SetSolverOption() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetSolverOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solver_option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>option_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00b38acbaeb959344b7ef04e84f4c40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b38acbaeb959344b7ef04e84f4c40c">&#9670;&nbsp;</a></span>SetSolverOption() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetSolverOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solver_option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>option_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b4f083b551f632b17ebdddbba2dcef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4f083b551f632b17ebdddbba2dcef0">&#9670;&nbsp;</a></span>SetSolverResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetSolverResult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_result.html">SolverResult</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solver reports its result back to <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, by passing the solver_result, which contains the solver result. </p>
<dl class="section note"><dt>Note</dt><dd>This method should only be called by each solver, after it solves the optimization problem stored in <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. The user should NOT call this method. </dd></dl>

</div>
</div>
<a id="ae20c365943aa8acb50dfd6b99b7e5194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20c365943aa8acb50dfd6b99b7e5194">&#9670;&nbsp;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> Solve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>SolutionResult indicating if the solution was successful. </dd></dl>

</div>
</div>
<a id="a4737cb6ed52094f3d292e0ed4ca187da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4737cb6ed52094f3d292e0ed4ca187da">&#9670;&nbsp;</a></span>solver_options()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a>&amp; solver_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the solver options stored inside <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>

</div>
</div>
<a id="a961df24d54138d7528f160332c7e36fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961df24d54138d7528f160332c7e36fb">&#9670;&nbsp;</a></span>SubstituteSolution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> SubstituteSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the variables in an expression with the solutions to the variables, returns the expression after substitution. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if some variables in the expression <code>e</code> are NOT decision variables or indeterminates in the optimization program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the expression <code>e</code> contains both decision variables and indeterminates of the optimization program, then the decision variables will be substituted by its solutions in double values, but not the indeterminates. </dd></dl>

</div>
</div>
<a id="a00a5adf7062ec2d1360e37112c132267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a5adf7062ec2d1360e37112c132267">&#9670;&nbsp;</a></span>SubstituteSolution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> SubstituteSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the decision variables in a polynomial with the solutions to the variables, returns the polynomial after substitution. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if some decision variables in the polynomial <code>p</code> are NOT decision variables in the optimization program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the polynomial <code>p</code> contains both decision variables and indeterminates of the optimization program, then the decision variables will be substituted by its solutions in double values, but not the indeterminates. </dd></dl>

</div>
</div>
<a id="a744f8ed184bc9260b5970f7b8e12812a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744f8ed184bc9260b5970f7b8e12812a">&#9670;&nbsp;</a></span>visualization_callbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a>&gt; &gt;&amp; visualization_callbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for all callbacks. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a78994b92c87719287528546dc12538bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78994b92c87719287528546dc12538bb">&#9670;&nbsp;</a></span>kGlobalInfeasibleCost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classdouble.html">double</a> kGlobalInfeasibleCost</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">      std::numeric_limits&lt;double&gt;::infinity()</div></div><!-- fragment -->
<p>The optimal cost is +∞ when the problem is globally infeasible. </p>

</div>
</div>
<a id="ab953e201d71c0ce608e7c95607a4f256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab953e201d71c0ce608e7c95607a4f256">&#9670;&nbsp;</a></span>kUnboundedCost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classdouble.html">double</a> kUnboundedCost</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">      -std::numeric_limits&lt;double&gt;::infinity()</div></div><!-- fragment -->
<p>The optimal cost is -∞ when the problem is unbounded. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/solvers/<a class="el" href="mathematical__program_8h.html">mathematical_program.h</a></li>
<li>drake/solvers/<a class="el" href="mathematical__program_8cc.html">mathematical_program.cc</a></li>
<li>drake/solvers/<a class="el" href="mathematical__program__api_8cc.html">mathematical_program_api.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1solvers.html">solvers</a></li><li class="navelem"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
