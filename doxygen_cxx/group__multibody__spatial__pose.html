<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Spatial Pose and Transform</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__multibody__spatial__pose.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Spatial Pose and Transform<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a> &raquo; <a class="el" href="group__multibody.html">Multibody Dynamics</a> &raquo; <a class="el" href="group__multibody__concepts.html">Multibody Dynamics Concepts</a> &raquo; <a class="el" href="group__multibody__spatial__algebra.html">Spatial Algebra</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p>A <em>spatial pose</em>, more commonly just <em>pose</em>, provides the location and orientation of a frame B with respect to another frame A. </p>
<p>A <em>spatial transform</em>, or just <em>transform</em>, is the "verb" form of a pose. It is a linear operator that is easily constructed from the pose information as we will show below. A transform can be used to map a point whose location is known in frame B to that same point's location in frame A. We'll discuss location and orientation separately and then show how they are combined to form a convenient spatial quantity.</p>
<h3>Location</h3>
<p>The location of a point S in a frame A is given by a position vector \(^Ap^S\), measured from A's origin Ao. When used for computation, we assume this vector is expressed in A's basis. When useful for clarity, the basis can be shown explicitly as \([^{A_O}p^S]_A\). In monogram notation, we write these symbols as <code>p_AS</code> and <code>p_AoS_A</code>, respectively. When used in a pose, we are interested in the location of frame B's origin Bo in A, \(^Ap^{B_O}\) (<code>p_ABo</code>), or more explicitly \([^{A_O}p^{B_O}]_A\) (<code>p_AoBo_A</code>).</p>
<p><a class="anchor" id="orientation_discussion"></a></p><h3>Orientation</h3>
<p>A rotation matrix R, also known as a direction cosine matrix, is an orthogonal 3×3 matrix whose columns and rows are directions (that is, unit vectors) that are mutually orthogonal. Furthermore, if the columns (or rows) are labeled x,y,z it always holds that z = x X y (rather than -(x X y)) ensuring that this is a right-handed rotation matrix. This is equivalent to saying that the determinant of a rotation matrix is 1, not -1.</p>
<p>A rotation matrix can be considered the "verb" form of a basis that represents the orientation of a frame F in another frame G. The columns of a rotation matrix are simply the basis F, and the rows are the basis G. The rotation matrix can then be used to re-express quantities from one basis to another. Suppose we have a vector r_F expressed in terms of the right-handed, orthogonal basis Fx, Fy, Fz and would like to express r instead as r_G, in terms of a right-handed, orthogonal basis Gx, Gy, Gz. To calculate r_G, we form a rotation matrix \(^GR^F\) (<code>R_GF</code>) whose columns are the F basis vectors re-expressed in G: </p><pre>
          ---- ---- ----
         |    |    |    |
  R_GF = |Fx_G|Fy_G|Fz_G|
         |    |    |    |
          ---- ---- ----  3×3
where
          -----           -----           -----
         |Fx⋅Gx|         |Fy⋅Gx|         |Fz⋅Gx|
  Fx_G = |Fx⋅Gy|  Fy_G = |Fy⋅Gy|  Fz_G = |Fz⋅Gy|
         |Fx⋅Gz|         |Fy⋅Gz|         |Fz⋅Gz|
          -----           -----           -----  3×1
</pre><p> In the above, v⋅w=vᵀw is the dot product of two vectors v and w. (Looking at the element definitions above, you can see that the rows are the G basis vectors re-expressed in F.) Now we can re-express the vector r from frame F to frame G via </p><pre>
     r_G = R_GF * r_F.
</pre><p> Because a rotation is orthogonal, its transpose is its inverse. Hence <code>R_FG = (R_GF)⁻¹ = (R_GF)ᵀ</code>. (In Eigen that is <code>R_GF.transpose()</code>). This transposed matrix can be used to re-express r_G in terms of Fx, Fy, Fz as </p><pre>
     r_F = R_FG * r_G  or  r_F = R_GF.transpose() * r_G
</pre><p> In either direction, correct behavior can be obtained by using the recommended notation and then matching up the frame labels pairwise left to right (after interpreting the <code>transpose()</code> operator as reversing the labels). Rotations are easily composed, with correctness assured by pairwise matching of frame symbols: </p><pre>
    R_WC = R_WA * R_AB * R_BC.
</pre><p>We generally use quaternions as a more-compact representation of a rotation matrix, and use the Eigen::Quaternion class to represent them. Conceptually, a quaternion <code>q_GF</code> has the same meaning and can be used in the same way as the equivalent rotation matrix <code>R_GF</code>.</p>
<h3>Transforms</h3>
<p>A transform combines position and orientation so contains a pose as defined above. We use the quantity symbol \(X\) for transforms, so they appear as \(^AX^B\) when typeset and <code>X_AB</code> in code. Drake uses the <code>Isometry3</code> variant of the Eigen::Transform class to represent transforms. ("Isometry" indicates that the transform preserves lengths, that is, it does not scale or shear but only translates and rotates.) Conceptually, a transform is a 4×4 matrix structured as follows: </p><pre>
          --------- ----     ---- ---- ---- ----
         |         |    |   |    |    |    |    |
         |  R_GF   |p_GF|   |Fx_G|Fy_G|Fz_G|p_GF|
  X_GF = |         |    | = |    |    |    |    |
         | 0  0  0 | 1  |   |  0 |  0 |  0 | 1  |
          --------- ----     ---- ---- ---- ----  4×4
</pre><p> There is a rotation matrix in the upper left 3×3 block (see above), and a position vector in the first 3×1 elements of the rightmost column. Then the bottom row is <code>[0 0 0 1]</code>. The rightmost column can also be viewed as the homogenous form of the position vector, <code>[x y z 1]ᵀ</code>. See Eigen's documentation for Eigen::Transform for a detailed discussion.</p>
<p>A transform may be applied to position vectors to translate the measured-from point to a different frame origin, and to re-express the vector in that frame's basis. For example, if we know the location of a point P measured in and expressed in frame A, we write that <code>p_AP</code> (or <code>p_AoP_A</code>) to mean the vector from A's origin Ao to the point P, expressed in A. If we want to know the location of that same point P, but measured in and expressed in frame B, we can write: </p><pre>
    p_BP = X_BA * p_AP.
</pre><p> The inverse of a transform reverses the superscripts so </p><pre>
    X_FG = (X_GF)⁻¹
</pre><p> The inverse has a particularly simple form. Given <code>X_GF</code> as depicted above, <code>X_FG</code> is </p><pre>
          --------- -------------     --------- ----
         |         |             |   |         |    |
         | (R_GF)ᵀ |−(R_GF)ᵀ*p_GF|   |  R_FG   |p_FG|
  X_FG = |         |             | = |         |    |
         | 0  0  0 |      1      |   | 0  0  0 | 1  |
          --------- --------------    --------- ----
</pre><p> Transforms are easily composed, with correctness assured by pairwise matching of frame symbols: </p><pre>
    X_WC = X_WA * X_AB * X_BC.
</pre><p>Next topic: <a class="el" href="group__multibody__spatial__vectors.html">Spatial Vectors</a> </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
