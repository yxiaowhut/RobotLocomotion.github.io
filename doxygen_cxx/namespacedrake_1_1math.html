<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacedrake_1_1math.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drake::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake_1_1math_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1math_1_1quaternion__test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math_1_1quaternion__test.html">quaternion_test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1math_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_auto_diff_to_gradient_matrix.html">AutoDiffToGradientMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_auto_diff_to_value_matrix.html">AutoDiffToValueMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_barycentric_mesh.html">BarycentricMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a multi-linear function (from vector inputs to vector outputs) by interpolating between points on a mesh using (triangular) barycentric interpolation.  <a href="classdrake_1_1math_1_1_barycentric_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_array.html">GetSubMatrixGradientArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_single_element.html">GetSubMatrixGradientSingleElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_gradient.html">Gradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_gradient_3_01_derived_00_01_nq_00_011_01_4.html">Gradient&lt; Derived, Nq, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_gray_codes_matrix.html">GrayCodesMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structdrake_1_1math_1_1_gray_codes_matrix.html#a83c3b24ce255b931f182e59775510cb1">GrayCodesMatrix::type</a> returns an <a class="el" href="namespace_eigen.html">Eigen</a> matrix of integers.  <a href="structdrake_1_1math_1_1_gray_codes_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_gray_codes_matrix_3_01_eigen_1_1_dynamic_01_4.html">GrayCodesMatrix&lt; Eigen::Dynamic &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult.html">MatGradMult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult_mat.html">MatGradMultMat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a proper rigid transform between two frames which can be regarded in two ways.  <a href="classdrake_1_1math_1_1_rigid_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the orientation between two arbitrary frames A and D associated with a Space-fixed (extrinsic) X-Y-Z rotation by "roll-pitch-yaw" angles <code>[r, p, y]</code>, which is equivalent to a Body-fixed (intrinsic) Z-Y-X rotation by "yaw-pitch-roll" angles <code>[y, p, r]</code>.  <a href="classdrake_1_1math_1_1_roll_pitch_yaw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure users create valid rotation matrices.  <a href="classdrake_1_1math_1_1_rotation_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a65ee44eb97ff7373bd2b6b088b8390b6"><td class="memTemplParams" colspan="2">template&lt;typename Derived , int Nq&gt; </td></tr>
<tr class="memitem:a65ee44eb97ff7373bd2b6b088b8390b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a65ee44eb97ff7373bd2b6b088b8390b6">AutoDiffMatrixType</a> = Eigen::Matrix&lt; Eigen::AutoDiffScalar&lt; Eigen::Matrix&lt; typename Derived::Scalar, Nq, 1 &gt; &gt;, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime &gt;</td></tr>
<tr class="memdesc:a65ee44eb97ff7373bd2b6b088b8390b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The appropriate AutoDiffScalar gradient type given the value type and the number of derivatives at compile time.  <a href="#a65ee44eb97ff7373bd2b6b088b8390b6">More...</a><br /></td></tr>
<tr class="separator:a65ee44eb97ff7373bd2b6b088b8390b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2131d12e81399c3201b29118d59adc87"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a2131d12e81399c3201b29118d59adc87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_auto_diff_to_value_matrix.html">AutoDiffToValueMatrix</a>&lt; Derived &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a2131d12e81399c3201b29118d59adc87">autoDiffToValueMatrix</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;auto_diff_matrix)</td></tr>
<tr class="separator:a2131d12e81399c3201b29118d59adc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc937230e65e9d6bcc7f64f9121d876"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1fc937230e65e9d6bcc7f64f9121d876"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdouble.html">double</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt; typename Derived::Scalar::Scalar, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a1fc937230e65e9d6bcc7f64f9121d876">DiscardGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;auto_diff_matrix)</td></tr>
<tr class="memdesc:a1fc937230e65e9d6bcc7f64f9121d876"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>B = DiscardGradient(A)</code> enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar type, explicitly throwing away any gradient information.  <a href="#a1fc937230e65e9d6bcc7f64f9121d876">More...</a><br /></td></tr>
<tr class="separator:a1fc937230e65e9d6bcc7f64f9121d876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa073cea3a21484021ae39541671549"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:adfa073cea3a21484021ae39541671549"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdouble.html">double</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const Eigen::MatrixBase&lt; Derived &gt; &amp; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#adfa073cea3a21484021ae39541671549">DiscardGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="separator:adfa073cea3a21484021ae39541671549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d9583177e64caf842b9ca82899d9ad"><td class="memTemplParams" colspan="2">template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </td></tr>
<tr class="memitem:ad2d9583177e64caf842b9ca82899d9ad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !std::is_same&lt; _Scalar, <a class="el" href="classdouble.html">double</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Transform&lt; typename _Scalar::Scalar, _Dim, _Mode, _Options &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ad2d9583177e64caf842b9ca82899d9ad">DiscardGradient</a> (const Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp;auto_diff_transform)</td></tr>
<tr class="separator:ad2d9583177e64caf842b9ca82899d9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4868fa25c958b604954155feba6effb"><td class="memTemplParams" colspan="2">template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </td></tr>
<tr class="memitem:ae4868fa25c958b604954155feba6effb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; _Scalar, <a class="el" href="classdouble.html">double</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ae4868fa25c958b604954155feba6effb">DiscardGradient</a> (const Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp;transform)</td></tr>
<tr class="separator:ae4868fa25c958b604954155feba6effb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d860f5fd00b3004e866af6f73a1362"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename DerivedAutoDiff &gt; </td></tr>
<tr class="memitem:a32d860f5fd00b3004e866af6f73a1362"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a32d860f5fd00b3004e866af6f73a1362">initializeAutoDiff</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;val, Eigen::MatrixBase&lt; DerivedAutoDiff &gt; &amp;auto_diff_matrix, Eigen::DenseIndex num_derivatives=Eigen::Dynamic, Eigen::DenseIndex deriv_num_start=0)</td></tr>
<tr class="memdesc:a32d860f5fd00b3004e866af6f73a1362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a single autodiff matrix given the corresponding value matrix.  <a href="#a32d860f5fd00b3004e866af6f73a1362">More...</a><br /></td></tr>
<tr class="separator:a32d860f5fd00b3004e866af6f73a1362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab773f7c582bc83dd2f26c0965de1e427"><td class="memTemplParams" colspan="2">template&lt;int Nq = Eigen::Dynamic, typename Derived &gt; </td></tr>
<tr class="memitem:ab773f7c582bc83dd2f26c0965de1e427"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1math.html#a65ee44eb97ff7373bd2b6b088b8390b6">AutoDiffMatrixType</a>&lt; Derived, Nq &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ab773f7c582bc83dd2f26c0965de1e427">initializeAutoDiff</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;mat, Eigen::DenseIndex num_derivatives=-1, Eigen::DenseIndex deriv_num_start=0)</td></tr>
<tr class="memdesc:ab773f7c582bc83dd2f26c0965de1e427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a single autodiff matrix given the corresponding value matrix.  <a href="#ab773f7c582bc83dd2f26c0965de1e427">More...</a><br /></td></tr>
<tr class="separator:ab773f7c582bc83dd2f26c0965de1e427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc1b9bbef766b25c3e3684df19eee0c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7fc1b9bbef766b25c3e3684df19eee0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a7fc1b9bbef766b25c3e3684df19eee0c">resizeDerivativesToMatchScalar</a> (Eigen::MatrixBase&lt; Derived &gt; &amp;mat, const typename Derived::Scalar &amp;scalar)</td></tr>
<tr class="memdesc:a7fc1b9bbef766b25c3e3684df19eee0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize derivatives vector of each element of a matrix to to match the size of the derivatives vector of a given scalar.  <a href="#a7fc1b9bbef766b25c3e3684df19eee0c">More...</a><br /></td></tr>
<tr class="separator:a7fc1b9bbef766b25c3e3684df19eee0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5c76a80b6a785f91dd3e06200e3f83"><td class="memTemplParams" colspan="2">template&lt;typename... Deriveds&gt; </td></tr>
<tr class="memitem:a6e5c76a80b6a785f91dd3e06200e3f83"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacedrake_1_1math.html#a65ee44eb97ff7373bd2b6b088b8390b6">AutoDiffMatrixType</a>&lt; Deriveds, <a class="el" href="namespacedrake_1_1math_1_1internal.html#a7f71df2d6b5bc2d9ddebca9a8cd3947a">internal::totalSizeAtCompileTime</a>&lt; Deriveds... &gt;)&gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a6e5c76a80b6a785f91dd3e06200e3f83">initializeAutoDiffTuple</a> (const Eigen::MatrixBase&lt; Deriveds &gt; &amp;... args)</td></tr>
<tr class="memdesc:a6e5c76a80b6a785f91dd3e06200e3f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a series of <a class="el" href="namespace_eigen.html">Eigen</a> matrices, create a tuple of corresponding AutoDiff matrices with values equal to the input matrices and properly initialized derivative vectors.  <a href="#a6e5c76a80b6a785f91dd3e06200e3f83">More...</a><br /></td></tr>
<tr class="separator:a6e5c76a80b6a785f91dd3e06200e3f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00cd34bea44b187b01da164d5207ae3"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af00cd34bea44b187b01da164d5207ae3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_auto_diff_to_gradient_matrix.html">AutoDiffToGradientMatrix</a>&lt; Derived &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#af00cd34bea44b187b01da164d5207ae3">autoDiffToGradientMatrix</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;auto_diff_matrix, <a class="el" href="classint.html">int</a> num_variables=Eigen::Dynamic)</td></tr>
<tr class="separator:af00cd34bea44b187b01da164d5207ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627c51b97633b728056e96ee26daf583"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename DerivedGradient , typename DerivedAutoDiff &gt; </td></tr>
<tr class="memitem:a627c51b97633b728056e96ee26daf583"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a627c51b97633b728056e96ee26daf583">initializeAutoDiffGivenGradientMatrix</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;val, const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;gradient, Eigen::MatrixBase&lt; DerivedAutoDiff &gt; &amp;auto_diff_matrix)</td></tr>
<tr class="memdesc:a627c51b97633b728056e96ee26daf583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an autodiff matrix given a matrix of values and gradient matrix.  <a href="#a627c51b97633b728056e96ee26daf583">More...</a><br /></td></tr>
<tr class="separator:a627c51b97633b728056e96ee26daf583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1337cae81c66571d592dd9be50df7c"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename DerivedGradient &gt; </td></tr>
<tr class="memitem:a3e1337cae81c66571d592dd9be50df7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1math.html#a65ee44eb97ff7373bd2b6b088b8390b6">AutoDiffMatrixType</a>&lt; Derived, DerivedGradient::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a3e1337cae81c66571d592dd9be50df7c">initializeAutoDiffGivenGradientMatrix</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;val, const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;gradient)</td></tr>
<tr class="memdesc:a3e1337cae81c66571d592dd9be50df7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes an autodiff matrix given a matrix of values and gradient matrix.  <a href="#a3e1337cae81c66571d592dd9be50df7c">More...</a><br /></td></tr>
<tr class="separator:a3e1337cae81c66571d592dd9be50df7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5aa65ce6d612ea5275c1f724a7f319"><td class="memTemplParams" colspan="2">template&lt;typename DerivedGradient , typename DerivedAutoDiff &gt; </td></tr>
<tr class="memitem:a9a5aa65ce6d612ea5275c1f724a7f319"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a9a5aa65ce6d612ea5275c1f724a7f319">gradientMatrixToAutoDiff</a> (const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;gradient, Eigen::MatrixBase&lt; DerivedAutoDiff &gt; &amp;auto_diff_matrix)</td></tr>
<tr class="separator:a9a5aa65ce6d612ea5275c1f724a7f319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44dafc4c3502cdb9bc73393bd7460f49"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a44dafc4c3502cdb9bc73393bd7460f49"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdouble.html">double</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt; typename Derived::Scalar::Scalar, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a44dafc4c3502cdb9bc73393bd7460f49">DiscardZeroGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;auto_diff_matrix, const typename Eigen::NumTraits&lt; typename Derived::Scalar::Scalar &gt;::Real &amp;precision=Eigen::NumTraits&lt; typename Derived::Scalar::Scalar &gt;::dummy_precision())</td></tr>
<tr class="memdesc:a44dafc4c3502cdb9bc73393bd7460f49"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>B = DiscardZeroGradient(A, precision)</code> enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar type, but first checking that the gradient matrix is empty or zero.  <a href="#a44dafc4c3502cdb9bc73393bd7460f49">More...</a><br /></td></tr>
<tr class="separator:a44dafc4c3502cdb9bc73393bd7460f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c18d1e6fa89e66ed1e7c83239cda96"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aa2c18d1e6fa89e66ed1e7c83239cda96"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdouble.html">double</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const Eigen::MatrixBase&lt; Derived &gt; &amp; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#aa2c18d1e6fa89e66ed1e7c83239cda96">DiscardZeroGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, <a class="el" href="classdouble.html">double</a> precision=0.)</td></tr>
<tr class="separator:aa2c18d1e6fa89e66ed1e7c83239cda96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b824ea80b3f2ac8891dc02b0730367"><td class="memTemplParams" colspan="2">template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </td></tr>
<tr class="memitem:a61b824ea80b3f2ac8891dc02b0730367"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !std::is_same&lt; _Scalar, <a class="el" href="classdouble.html">double</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Transform&lt; typename _Scalar::Scalar, _Dim, _Mode, _Options &gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a61b824ea80b3f2ac8891dc02b0730367">DiscardZeroGradient</a> (const Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp;auto_diff_transform, const typename Eigen::NumTraits&lt; typename _Scalar::Scalar &gt;::Real &amp;precision=Eigen::NumTraits&lt; typename _Scalar::Scalar &gt;::dummy_precision())</td></tr>
<tr class="separator:a61b824ea80b3f2ac8891dc02b0730367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286452ec0226092c95d7436b487b0ace"><td class="memTemplParams" colspan="2">template&lt;typename _Scalar , int _Dim, int _Mode, int _Options&gt; </td></tr>
<tr class="memitem:a286452ec0226092c95d7436b487b0ace"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; _Scalar, <a class="el" href="classdouble.html">double</a> &gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a286452ec0226092c95d7436b487b0ace">DiscardZeroGradient</a> (const Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp;transform, <a class="el" href="classdouble.html">double</a> precision=0.)</td></tr>
<tr class="separator:a286452ec0226092c95d7436b487b0ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d4e4f52f3321536bf570b3a1a23718"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a47d4e4f52f3321536bf570b3a1a23718">ContinuousAlgebraicRiccatiEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;B, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::LLT&lt; Eigen::MatrixXd &gt; &amp;R_cholesky)</td></tr>
<tr class="memdesc:a47d4e4f52f3321536bf570b3a1a23718"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is functionally the same as ContinuousAlgebraicRiccatiEquation(A, B, Q, R).  <a href="#a47d4e4f52f3321536bf570b3a1a23718">More...</a><br /></td></tr>
<tr class="separator:a47d4e4f52f3321536bf570b3a1a23718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed596a7b73bd51a9acfa28df7be4214f"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#aed596a7b73bd51a9acfa28df7be4214f">ContinuousAlgebraicRiccatiEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;B, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;R)</td></tr>
<tr class="memdesc:aed596a7b73bd51a9acfa28df7be4214f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unique stabilizing solution S to the continuous-time algebraic Riccati equation:  <a href="#aed596a7b73bd51a9acfa28df7be4214f">More...</a><br /></td></tr>
<tr class="separator:aed596a7b73bd51a9acfa28df7be4214f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad7ab2561d0c05591eb9720adccc7d5"><td class="memTemplParams" colspan="2">template&lt;typename v_Type , typename DtB_v_Type , typename w_AB_Type &gt; </td></tr>
<tr class="memitem:a7ad7ab2561d0c05591eb9720adccc7d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; typename v_Type::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a7ad7ab2561d0c05591eb9720adccc7d5">ConvertTimeDerivativeToOtherFrame</a> (const Eigen::MatrixBase&lt; v_Type &gt; &amp;v_E, const Eigen::MatrixBase&lt; DtB_v_Type &gt; &amp;DtB_v_E, const Eigen::MatrixBase&lt; w_AB_Type &gt; &amp;w_AB_E)</td></tr>
<tr class="memdesc:a7ad7ab2561d0c05591eb9720adccc7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given ᴮd/dt(v) (the time derivative in frame B of an arbitrary 3D vector v) and given ᴬωᴮ (frame B's angular velocity in another frame A), this method computes ᴬd/dt(v) (the time derivative in frame A of v) by: ᴬd/dt(v) = ᴮd/dt(v) + ᴬωᴮ x v.  <a href="#a7ad7ab2561d0c05591eb9720adccc7d5">More...</a><br /></td></tr>
<tr class="separator:a7ad7ab2561d0c05591eb9720adccc7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d78f6f294270fdc03dcb68de424536a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a2d78f6f294270fdc03dcb68de424536a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">drake::Matrix3</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a2d78f6f294270fdc03dcb68de424536a">VectorToSkewSymmetric</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;p)</td></tr>
<tr class="separator:a2d78f6f294270fdc03dcb68de424536a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcef78b318bd0da2f388b83bc6fafa81"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#afcef78b318bd0da2f388b83bc6fafa81">DiscreteAlgebraicRiccatiEquation</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;B, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;R)</td></tr>
<tr class="memdesc:afcef78b318bd0da2f388b83bc6fafa81"><td class="mdescLeft">&#160;</td><td class="mdescRight">DiscreteAlgebraicRiccatiEquation function computes the unique stabilizing solution X to the discrete-time algebraic Riccati equation: </p><p class="formulaDsp">
\[ A&#39;XA - X - A&#39;XB(B&#39;XB+R)^{-1}B&#39;XA + Q = 0 \]
</p>
<p>.  <a href="#afcef78b318bd0da2f388b83bc6fafa81">More...</a><br /></td></tr>
<tr class="separator:afcef78b318bd0da2f388b83bc6fafa81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866d4d3082e830e8eb0c91cb5bf91ef1"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a866d4d3082e830e8eb0c91cb5bf91ef1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Triplet&lt; typename Derived::Scalar &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a866d4d3082e830e8eb0c91cb5bf91ef1">SparseMatrixToTriplets</a> (const Derived &amp;matrix)</td></tr>
<tr class="memdesc:a866d4d3082e830e8eb0c91cb5bf91ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a sparse matrix, return a vector of triplets, such that we can reconstruct the matrix using setFromTriplet function.  <a href="#a866d4d3082e830e8eb0c91cb5bf91ef1">More...</a><br /></td></tr>
<tr class="separator:a866d4d3082e830e8eb0c91cb5bf91ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9681555f84d48a48d09601d913246934"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9681555f84d48a48d09601d913246934"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a9681555f84d48a48d09601d913246934">SparseMatrixToRowColumnValueVectors</a> (const Derived &amp;matrix, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Index &gt; &amp;row_indices, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Index &gt; &amp;col_indices, <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; typename Derived::Scalar &gt; &amp;val)</td></tr>
<tr class="memdesc:a9681555f84d48a48d09601d913246934"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a sparse matrix, return the row indices, the column indices, and value of the non-zero entries.  <a href="#a9681555f84d48a48d09601d913246934">More...</a><br /></td></tr>
<tr class="separator:a9681555f84d48a48d09601d913246934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba688f2a2db17563f2ef13e199816d9"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix3Xd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#adba688f2a2db17563f2ef13e199816d9">UniformPtsOnSphereFibonacci</a> (<a class="el" href="classint.html">int</a> num_points)</td></tr>
<tr class="memdesc:adba688f2a2db17563f2ef13e199816d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deterministically generates approximate evenly distributed points on a unit sphere.  <a href="#adba688f2a2db17563f2ef13e199816d9">More...</a><br /></td></tr>
<tr class="separator:adba688f2a2db17563f2ef13e199816d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc8c0d47e42141e066c524543c5dd92"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4bc8c0d47e42141e066c524543c5dd92"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived::Scalar, 4, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a4bc8c0d47e42141e066c524543c5dd92">expmap2quat</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;v)</td></tr>
<tr class="separator:a4bc8c0d47e42141e066c524543c5dd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd18e2f0405f7355c3029e724355db6e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedQ &gt; </td></tr>
<tr class="memitem:abd18e2f0405f7355c3029e724355db6e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename DerivedQ::Scalar, 3, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#abd18e2f0405f7355c3029e724355db6e">quat2expmap</a> (const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;q)</td></tr>
<tr class="separator:abd18e2f0405f7355c3029e724355db6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c61a24dd7c544df6747676b6faa04a"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:ab3c61a24dd7c544df6747676b6faa04a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived1::Scalar, 3, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ab3c61a24dd7c544df6747676b6faa04a">closestExpmap</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;expmap1, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;expmap2)</td></tr>
<tr class="separator:ab3c61a24dd7c544df6747676b6faa04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068e4e5c69ceccbfebfaeb9c91723d39"><td class="memTemplParams" colspan="2">template&lt;typename DerivedQ , typename DerivedE &gt; </td></tr>
<tr class="memitem:a068e4e5c69ceccbfebfaeb9c91723d39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a068e4e5c69ceccbfebfaeb9c91723d39">quat2expmapSequence</a> (const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;quat, const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;quat_dot, Eigen::MatrixBase&lt; DerivedE &gt; &amp;expmap, Eigen::MatrixBase&lt; DerivedE &gt; &amp;expmap_dot)</td></tr>
<tr class="separator:a068e4e5c69ceccbfebfaeb9c91723d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb0d39dab703d87f0f582cf310c6134"><td class="memTemplParams" colspan="2">template&lt;std::size_t Size&gt; </td></tr>
<tr class="memitem:a6eb0d39dab703d87f0f582cf310c6134"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="classint.html">int</a>, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a6eb0d39dab703d87f0f582cf310c6134">intRange</a> (<a class="el" href="classint.html">int</a> start)</td></tr>
<tr class="separator:a6eb0d39dab703d87f0f582cf310c6134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c21cde851510ab3ae5a7527ed62d22"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a20c21cde851510ab3ae5a7527ed62d22"><td class="memTemplItemLeft" align="right" valign="top">Derived::PlainObject&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a20c21cde851510ab3ae5a7527ed62d22">transposeGrad</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dX, typename Derived::Index rows_X)</td></tr>
<tr class="separator:a20c21cde851510ab3ae5a7527ed62d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fb0200e4ab7c796576b2fe17408ec8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedDA , typename DerivedDB &gt; </td></tr>
<tr class="memitem:a41fb0200e4ab7c796576b2fe17408ec8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult_mat.html">MatGradMultMat</a>&lt; DerivedA, DerivedB, DerivedDA &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a41fb0200e4ab7c796576b2fe17408ec8">matGradMultMat</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;<a class="el" href="snopt__solver__f2c_8cc.html#a28fdf301ca7bedd7362bed4af954c407">A</a>, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedDA &gt; &amp;dA, const Eigen::MatrixBase&lt; DerivedDB &gt; &amp;dB)</td></tr>
<tr class="separator:a41fb0200e4ab7c796576b2fe17408ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4805a6b4a327bedeb7793cd1ce11523c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedDA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a4805a6b4a327bedeb7793cd1ce11523c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult.html">MatGradMult</a>&lt; DerivedDA, DerivedB &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a4805a6b4a327bedeb7793cd1ce11523c">matGradMult</a> (const Eigen::MatrixBase&lt; DerivedDA &gt; &amp;dA, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="separator:a4805a6b4a327bedeb7793cd1ce11523c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5269630d172b12a31b34d6c98b4e64"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a5c5269630d172b12a31b34d6c98b4e64"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived::Scalar, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a5c5269630d172b12a31b34d6c98b4e64">getSubMatrixGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dM, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;rows, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;cols, typename Derived::Index M_rows, <a class="el" href="classint.html">int</a> q_start=0, typename Derived::Index q_subvector_size=-1)</td></tr>
<tr class="separator:a5c5269630d172b12a31b34d6c98b4e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b8fed3ad399a2bd53630c3b5b6d335"><td class="memTemplParams" colspan="2">template&lt;int QSubvectorSize, typename Derived , std::size_t NRows, std::size_t NCols&gt; </td></tr>
<tr class="memitem:ad4b8fed3ad399a2bd53630c3b5b6d335"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_array.html">GetSubMatrixGradientArray</a>&lt; QSubvectorSize, Derived, NRows, NCols &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ad4b8fed3ad399a2bd53630c3b5b6d335">getSubMatrixGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dM, const std::array&lt; <a class="el" href="classint.html">int</a>, NRows &gt; &amp;rows, const std::array&lt; <a class="el" href="classint.html">int</a>, NCols &gt; &amp;cols, typename Derived::Index M_rows, <a class="el" href="classint.html">int</a> q_start=0, typename Derived::Index q_subvector_size=QSubvectorSize)</td></tr>
<tr class="separator:ad4b8fed3ad399a2bd53630c3b5b6d335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259ed4f41a444e8eed6a2a30998af53f"><td class="memTemplParams" colspan="2">template&lt;int QSubvectorSize, typename Derived &gt; </td></tr>
<tr class="memitem:a259ed4f41a444e8eed6a2a30998af53f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_single_element.html">GetSubMatrixGradientSingleElement</a>&lt; QSubvectorSize, Derived &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a259ed4f41a444e8eed6a2a30998af53f">getSubMatrixGradient</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;dM, <a class="el" href="classint.html">int</a> row, <a class="el" href="classint.html">int</a> col, typename Derived::Index M_rows, typename Derived::Index q_start=0, typename Derived::Index q_subvector_size=QSubvectorSize)</td></tr>
<tr class="separator:a259ed4f41a444e8eed6a2a30998af53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d857f8398886aff22da2ea64bc1113"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a30d857f8398886aff22da2ea64bc1113"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a30d857f8398886aff22da2ea64bc1113">setSubMatrixGradient</a> (Eigen::MatrixBase&lt; DerivedA &gt; &amp;dM, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;dM_submatrix, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;rows, const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;cols, typename DerivedA::Index M_rows, typename DerivedA::Index q_start=0, typename DerivedA::Index q_subvector_size=-1)</td></tr>
<tr class="separator:a30d857f8398886aff22da2ea64bc1113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae748bcfe9270b9ed5dd2fb71df3941b6"><td class="memTemplParams" colspan="2">template&lt;int QSubvectorSize, typename DerivedA , typename DerivedB , std::size_t NRows, std::size_t NCols&gt; </td></tr>
<tr class="memitem:ae748bcfe9270b9ed5dd2fb71df3941b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ae748bcfe9270b9ed5dd2fb71df3941b6">setSubMatrixGradient</a> (Eigen::MatrixBase&lt; DerivedA &gt; &amp;dM, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;dM_submatrix, const std::array&lt; <a class="el" href="classint.html">int</a>, NRows &gt; &amp;rows, const std::array&lt; <a class="el" href="classint.html">int</a>, NCols &gt; &amp;cols, typename DerivedA::Index M_rows, typename DerivedA::Index q_start=0, typename DerivedA::Index q_subvector_size=QSubvectorSize)</td></tr>
<tr class="separator:ae748bcfe9270b9ed5dd2fb71df3941b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54df9b3b01c7c5509373712fda88ad4"><td class="memTemplParams" colspan="2">template&lt;int QSubvectorSize, typename DerivedDM , typename DerivedDMSub &gt; </td></tr>
<tr class="memitem:ab54df9b3b01c7c5509373712fda88ad4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ab54df9b3b01c7c5509373712fda88ad4">setSubMatrixGradient</a> (Eigen::MatrixBase&lt; DerivedDM &gt; &amp;dM, const Eigen::MatrixBase&lt; DerivedDMSub &gt; &amp;dM_submatrix, <a class="el" href="classint.html">int</a> row, <a class="el" href="classint.html">int</a> col, typename DerivedDM::Index M_rows, typename DerivedDM::Index q_start=0, typename DerivedDM::Index q_subvector_size=QSubvectorSize)</td></tr>
<tr class="separator:ab54df9b3b01c7c5509373712fda88ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b836de6a2619d82ebb7793a920e7b67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a9b836de6a2619d82ebb7793a920e7b67">GrayCodeToInteger</a> (const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;gray_code)</td></tr>
<tr class="memdesc:a9b836de6a2619d82ebb7793a920e7b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the Gray code to an integer.  <a href="#a9b836de6a2619d82ebb7793a920e7b67">More...</a><br /></td></tr>
<tr class="separator:a9b836de6a2619d82ebb7793a920e7b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad276064dcd8cb5e77d3dc41140840e8c"><td class="memTemplParams" colspan="2">template&lt;int NumDigits = Eigen::Dynamic&gt; </td></tr>
<tr class="memitem:ad276064dcd8cb5e77d3dc41140840e8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_gray_codes_matrix.html">GrayCodesMatrix</a>&lt; NumDigits &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ad276064dcd8cb5e77d3dc41140840e8c">CalculateReflectedGrayCodes</a> (<a class="el" href="classint.html">int</a> num_digits=NumDigits)</td></tr>
<tr class="memdesc:ad276064dcd8cb5e77d3dc41140840e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix whose i'th row is the Gray code for integer i.  <a href="#ad276064dcd8cb5e77d3dc41140840e8c">More...</a><br /></td></tr>
<tr class="separator:ad276064dcd8cb5e77d3dc41140840e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57457683becdddf605a55be881c065b4"><td class="memTemplParams" colspan="2">template&lt;int MaxChunkSize = 10, class F , class Arg &gt; </td></tr>
<tr class="memitem:a57457683becdddf605a55be881c065b4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a57457683becdddf605a55be881c065b4">jacobian</a> (<a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &amp;&amp;f, Arg &amp;&amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>)</td></tr>
<tr class="memdesc:a57457683becdddf605a55be881c065b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function </p><p class="formulaDsp">
\[ f:\mathbb{R}^{n\times m}\rightarrow\mathbb{R}^{p\times q} \]
</p>
<p> (f: R^n*m -&gt; R^p*q) can be extracted.  <a href="#a57457683becdddf605a55be881c065b4">More...</a><br /></td></tr>
<tr class="separator:a57457683becdddf605a55be881c065b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dce37732e3e532f7b87cd517789da7f"><td class="memTemplParams" colspan="2">template&lt;int MaxChunkSizeOuter = 10, int MaxChunkSizeInner = 10, class F , class Arg &gt; </td></tr>
<tr class="memitem:a6dce37732e3e532f7b87cd517789da7f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a6dce37732e3e532f7b87cd517789da7f">hessian</a> (<a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &amp;&amp;f, Arg &amp;&amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>)</td></tr>
<tr class="memdesc:a6dce37732e3e532f7b87cd517789da7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a matrix of AutoDiffScalars from which the value, Jacobian, and Hessian of a function </p><p class="formulaDsp">
\[ f:\mathbb{R}^{n\times m}\rightarrow\mathbb{R}^{p\times q} \]
</p>
<p> (f: R^n*m -&gt; R^p*q) can be extracted.  <a href="#a6dce37732e3e532f7b87cd517789da7f">More...</a><br /></td></tr>
<tr class="separator:a6dce37732e3e532f7b87cd517789da7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84760cbea23b50efdbe9a85f3967f098"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a84760cbea23b50efdbe9a85f3967f098"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a84760cbea23b50efdbe9a85f3967f098">IsSymmetric</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a84760cbea23b50efdbe9a85f3967f098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a matrix is symmetric.  <a href="#a84760cbea23b50efdbe9a85f3967f098">More...</a><br /></td></tr>
<tr class="separator:a84760cbea23b50efdbe9a85f3967f098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141ec70804c105e09ab3b0a855152b8b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a141ec70804c105e09ab3b0a855152b8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a141ec70804c105e09ab3b0a855152b8b">IsSymmetric</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, const typename Derived::Scalar &amp;precision)</td></tr>
<tr class="memdesc:a141ec70804c105e09ab3b0a855152b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a matrix is symmetric based on whether the difference between matrix(i, j) and matrix(j, i) is smaller than <code>precision</code> for all i, j.  <a href="#a141ec70804c105e09ab3b0a855152b8b">More...</a><br /></td></tr>
<tr class="separator:a141ec70804c105e09ab3b0a855152b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5390bb2dadbe96cd6dfbe26c6891f100"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a5390bb2dadbe96cd6dfbe26c6891f100"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a5390bb2dadbe96cd6dfbe26c6891f100">ToSymmetricMatrixFromLowerTriangularColumns</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;lower_triangular_columns)</td></tr>
<tr class="memdesc:a5390bb2dadbe96cd6dfbe26c6891f100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a column vector containing the stacked columns of the lower triangular part of a square matrix, returning a symmetric matrix whose lower triangular part is the same as the original matrix.  <a href="#a5390bb2dadbe96cd6dfbe26c6891f100">More...</a><br /></td></tr>
<tr class="separator:a5390bb2dadbe96cd6dfbe26c6891f100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d81fb8e0b28f46bad7838ed39bffbce"><td class="memTemplParams" colspan="2">template&lt;int rows, typename Derived &gt; </td></tr>
<tr class="memitem:a6d81fb8e0b28f46bad7838ed39bffbce"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived::Scalar, rows, rows &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a6d81fb8e0b28f46bad7838ed39bffbce">ToSymmetricMatrixFromLowerTriangularColumns</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;lower_triangular_columns)</td></tr>
<tr class="memdesc:a6d81fb8e0b28f46bad7838ed39bffbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a column vector containing the stacked columns of the lower triangular part of a square matrix, returning a symmetric matrix whose lower triangular part is the same as the original matrix.  <a href="#a6d81fb8e0b28f46bad7838ed39bffbce">More...</a><br /></td></tr>
<tr class="separator:a6d81fb8e0b28f46bad7838ed39bffbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48484009086db12d881bea6bcaab2514"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a48484009086db12d881bea6bcaab2514"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a48484009086db12d881bea6bcaab2514">NormalizeVector</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;<a class="el" href="vtk__util__test_8cc.html#af88b946fb90d5f08b5fb740c70e98c10">x</a>, typename Derived::PlainObject &amp;x_norm, typename <a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Derived, Derived::RowsAtCompileTime, 1 &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> *dx_norm=nullptr, typename <a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Derived, Derived::RowsAtCompileTime, 2 &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> *ddx_norm=nullptr)</td></tr>
<tr class="memdesc:a48484009086db12d881bea6bcaab2514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the normalized vector, optionally with its gradient and second derivative.  <a href="#a48484009086db12d881bea6bcaab2514">More...</a><br /></td></tr>
<tr class="separator:a48484009086db12d881bea6bcaab2514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a25d66185d603162f5702d31136b31c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5a25d66185d603162f5702d31136b31c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a5a25d66185d603162f5702d31136b31c">ComputeBasisFromAxis</a> (<a class="el" href="classint.html">int</a> axis_index, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;axis_W)</td></tr>
<tr class="memdesc:a5a25d66185d603162f5702d31136b31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a right-handed local basis from a given axis.  <a href="#a5a25d66185d603162f5702d31136b31c">More...</a><br /></td></tr>
<tr class="separator:a5a25d66185d603162f5702d31136b31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a65e79a6ec2bcb347afa75baefc125"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ae8a65e79a6ec2bcb347afa75baefc125">DecomposePSDmatrixIntoXtransposeTimesX</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Y, <a class="el" href="classdouble.html">double</a> zero_tol)</td></tr>
<tr class="memdesc:ae8a65e79a6ec2bcb347afa75baefc125"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a symmetric positive semidefinite matrix Y, decompose it into XᵀX, where the number of rows in X equals to the rank of Y.  <a href="#ae8a65e79a6ec2bcb347afa75baefc125">More...</a><br /></td></tr>
<tr class="separator:ae8a65e79a6ec2bcb347afa75baefc125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cb8ebf50f381b19b98f5901b6dea96"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::MatrixXd, Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ac0cb8ebf50f381b19b98f5901b6dea96">DecomposePositiveQuadraticForm</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, <a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdouble.html">double</a> tol=0)</td></tr>
<tr class="memdesc:ac0cb8ebf50f381b19b98f5901b6dea96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a quadratic form xᵀQx + bᵀx + c to (Rx+d)ᵀ(Rx+d) where RᵀR = Q Rᵀd = b / 2 Notice that this decomposition is not unique.  <a href="#ac0cb8ebf50f381b19b98f5901b6dea96">More...</a><br /></td></tr>
<tr class="separator:ac0cb8ebf50f381b19b98f5901b6dea96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e37615af3b6facc6f7dec51323a628e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a5e37615af3b6facc6f7dec51323a628e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Quaternion&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a5e37615af3b6facc6f7dec51323a628e">ClosestQuaternion</a> (const Eigen::Quaternion&lt; Scalar &gt; &amp;q0, const Eigen::Quaternion&lt; Scalar &gt; &amp;q1)</td></tr>
<tr class="memdesc:a5e37615af3b6facc6f7dec51323a628e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unit quaternion that represents the same orientation as <code>q1</code>, and has the "shortest" geodesic distance on the unit sphere to <code>q0</code>.  <a href="#a5e37615af3b6facc6f7dec51323a628e">More...</a><br /></td></tr>
<tr class="separator:a5e37615af3b6facc6f7dec51323a628e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6bdc00adb60394da9687fc9aa5b0aa"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7e6bdc00adb60394da9687fc9aa5b0aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a7e6bdc00adb60394da9687fc9aa5b0aa">quatConjugate</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;q)</td></tr>
<tr class="separator:a7e6bdc00adb60394da9687fc9aa5b0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29059591a43a840c9a7e2f31a2d55130"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a29059591a43a840c9a7e2f31a2d55130"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a29059591a43a840c9a7e2f31a2d55130">quatProduct</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;q1, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;q2)</td></tr>
<tr class="separator:a29059591a43a840c9a7e2f31a2d55130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc70ebdc0ea497711e6e7b69eddef2d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedQ , typename DerivedV &gt; </td></tr>
<tr class="memitem:a0fc70ebdc0ea497711e6e7b69eddef2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; typename DerivedV::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a0fc70ebdc0ea497711e6e7b69eddef2d">quatRotateVec</a> (const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;q, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;v)</td></tr>
<tr class="separator:a0fc70ebdc0ea497711e6e7b69eddef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ef93ff1fa2dc788507d6eadb4bb78f"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:ae2ef93ff1fa2dc788507d6eadb4bb78f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; typename Derived1::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ae2ef93ff1fa2dc788507d6eadb4bb78f">quatDiff</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;q1, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;q2)</td></tr>
<tr class="separator:ae2ef93ff1fa2dc788507d6eadb4bb78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad298b049679492bf3e846165c6c7e023"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 , typename DerivedU &gt; </td></tr>
<tr class="memitem:ad298b049679492bf3e846165c6c7e023"><td class="memTemplItemLeft" align="right" valign="top">Derived1::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ad298b049679492bf3e846165c6c7e023">quatDiffAxisInvar</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;q1, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;q2, const Eigen::MatrixBase&lt; DerivedU &gt; &amp;u)</td></tr>
<tr class="separator:ad298b049679492bf3e846165c6c7e023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6538743074d86b4dc68c7d0455b680"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 , typename Scalar &gt; </td></tr>
<tr class="memitem:a0d6538743074d86b4dc68c7d0455b680"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a0d6538743074d86b4dc68c7d0455b680">Slerp</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;q1, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;q2, const Scalar &amp;interpolation_parameter)</td></tr>
<tr class="memdesc:a0d6538743074d86b4dc68c7d0455b680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Q = Slerp(q1, q2, f) Spherical linear interpolation between two quaternions This function uses the implementation given in Algorithm 8 of [1].  <a href="#a0d6538743074d86b4dc68c7d0455b680">More...</a><br /></td></tr>
<tr class="separator:a0d6538743074d86b4dc68c7d0455b680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7969c04c7e7d65986baf0f7d8e8db49e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7969c04c7e7d65986baf0f7d8e8db49e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a7969c04c7e7d65986baf0f7d8e8db49e">DRAKE_DEPRECATED</a> (&quot;Use  <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>(Eigen::Quaternion). &quot; &quot;Code will be deleted after February 5, 2019.&quot;) Matrix3&lt; typename Derived</td></tr>
<tr class="separator:a7969c04c7e7d65986baf0f7d8e8db49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a6d40e458bc9f766f33b819a7b4900"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88a6d40e458bc9f766f33b819a7b4900"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a88a6d40e458bc9f766f33b819a7b4900">is_quaternion_in_canonical_form</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat)</td></tr>
<tr class="memdesc:a88a6d40e458bc9f766f33b819a7b4900"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether a quaternion is in "canonical form" meaning that it tests whether the quaternion [w, x, y, z] has a non-negative w value.  <a href="#a88a6d40e458bc9f766f33b819a7b4900">More...</a><br /></td></tr>
<tr class="separator:a88a6d40e458bc9f766f33b819a7b4900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad74d3c5baa84fa6ef04b6ada5ffcbe5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad74d3c5baa84fa6ef04b6ada5ffcbe5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Quaternion&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#aad74d3c5baa84fa6ef04b6ada5ffcbe5">QuaternionToCanonicalForm</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat)</td></tr>
<tr class="memdesc:aad74d3c5baa84fa6ef04b6ada5ffcbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a quaternion in its "canonical form" meaning that it returns a quaternion [w, x, y, z] with a non-negative w.  <a href="#aad74d3c5baa84fa6ef04b6ada5ffcbe5">More...</a><br /></td></tr>
<tr class="separator:aad74d3c5baa84fa6ef04b6ada5ffcbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc96357c54438cadae5c8aefbd16713d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc96357c54438cadae5c8aefbd16713d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#adc96357c54438cadae5c8aefbd16713d">AreQuaternionsEqualForOrientation</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat1, const Eigen::Quaternion&lt; T &gt; &amp;quat2, const T <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>)</td></tr>
<tr class="memdesc:adc96357c54438cadae5c8aefbd16713d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests whether two quaternions represent the same orientation.  <a href="#adc96357c54438cadae5c8aefbd16713d">More...</a><br /></td></tr>
<tr class="separator:adc96357c54438cadae5c8aefbd16713d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bf90f81dcf655d829ed2d718251215"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4bf90f81dcf655d829ed2d718251215"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ab4bf90f81dcf655d829ed2d718251215">CalculateQuaternionDtFromAngularVelocityExpressedInB</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat_AB, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;w_AB_B)</td></tr>
<tr class="memdesc:ab4bf90f81dcf655d829ed2d718251215"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates a quaternion's time-derivative from its quaternion and angular velocity.  <a href="#ab4bf90f81dcf655d829ed2d718251215">More...</a><br /></td></tr>
<tr class="separator:ab4bf90f81dcf655d829ed2d718251215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98411a94334e6d40ef2ca10bfc053118"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98411a94334e6d40ef2ca10bfc053118"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a98411a94334e6d40ef2ca10bfc053118">CalculateAngularVelocityExpressedInBFromQuaternionDt</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat_AB, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;quatDt)</td></tr>
<tr class="memdesc:a98411a94334e6d40ef2ca10bfc053118"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates angular velocity from a quaternion and its time- derivative.  <a href="#a98411a94334e6d40ef2ca10bfc053118">More...</a><br /></td></tr>
<tr class="separator:a98411a94334e6d40ef2ca10bfc053118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06541dcb249b4b951ea73d45d2067337"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06541dcb249b4b951ea73d45d2067337"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a06541dcb249b4b951ea73d45d2067337">CalculateQuaternionDtConstraintViolation</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;quatDt)</td></tr>
<tr class="memdesc:a06541dcb249b4b951ea73d45d2067337"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates how well a quaternion and its time-derivative satisfy the quaternion time-derivative constraint specified in [Kane, 1983] Section 1.13, equations 12-13, page 59.  <a href="#a06541dcb249b4b951ea73d45d2067337">More...</a><br /></td></tr>
<tr class="separator:a06541dcb249b4b951ea73d45d2067337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056f9de21690e59551e2904bde9ac928"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a056f9de21690e59551e2904bde9ac928"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a056f9de21690e59551e2904bde9ac928">IsQuaternionValid</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat, const <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>)</td></tr>
<tr class="memdesc:a056f9de21690e59551e2904bde9ac928"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests if a quaternion satisfies the quaternion constraint specified in [Kane, 1983] Section 1.3, equation 4, page 12, i.e., a quaternion [w, x, y, z] must satisfy: w^2 + x^2 + y^2 + z^2 = 1.  <a href="#a056f9de21690e59551e2904bde9ac928">More...</a><br /></td></tr>
<tr class="separator:a056f9de21690e59551e2904bde9ac928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b38bdfc1e3df8662c8726bc89a08ed0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b38bdfc1e3df8662c8726bc89a08ed0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a3b38bdfc1e3df8662c8726bc89a08ed0">IsBothQuaternionAndQuaternionDtOK</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;quatDt, const <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>)</td></tr>
<tr class="memdesc:a3b38bdfc1e3df8662c8726bc89a08ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests if a quaternion satisfies the time-derivative constraint specified in [Kane, 1983] Section 1.13, equation 13, page 59.  <a href="#a3b38bdfc1e3df8662c8726bc89a08ed0">More...</a><br /></td></tr>
<tr class="separator:a3b38bdfc1e3df8662c8726bc89a08ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e47f892f2417dfc861a095328019361"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e47f892f2417dfc861a095328019361"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a2e47f892f2417dfc861a095328019361">IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB</a> (const Eigen::Quaternion&lt; T &gt; &amp;quat, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;quatDt, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;w_B, const <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#a628d801d093e5d9b41ecaa82592ee92d">tolerance</a>)</td></tr>
<tr class="memdesc:a2e47f892f2417dfc861a095328019361"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests if a quaternion and a quaternions time-derivative can calculate and match an angular velocity to within a tolerance.  <a href="#a2e47f892f2417dfc861a095328019361">More...</a><br /></td></tr>
<tr class="separator:a2e47f892f2417dfc861a095328019361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6aefde593f0fbe2f9ef04f40979827f"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, class Generator  = RandomGenerator&gt; </td></tr>
<tr class="memitem:ae6aefde593f0fbe2f9ef04f40979827f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::AngleAxis&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#ae6aefde593f0fbe2f9ef04f40979827f">UniformlyRandomAngleAxis</a> (Generator *generator)</td></tr>
<tr class="memdesc:ae6aefde593f0fbe2f9ef04f40979827f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a rotation (in the axis-angle representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere.  <a href="#ae6aefde593f0fbe2f9ef04f40979827f">More...</a><br /></td></tr>
<tr class="separator:ae6aefde593f0fbe2f9ef04f40979827f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c92561b046b32c1ebe172bd32dc8276"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, class Generator  = RandomGenerator&gt; </td></tr>
<tr class="memitem:a6c92561b046b32c1ebe172bd32dc8276"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Quaternion&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a6c92561b046b32c1ebe172bd32dc8276">UniformlyRandomQuaternion</a> (Generator *generator)</td></tr>
<tr class="memdesc:a6c92561b046b32c1ebe172bd32dc8276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a rotation (in the quaternion representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere.  <a href="#a6c92561b046b32c1ebe172bd32dc8276">More...</a><br /></td></tr>
<tr class="separator:a6c92561b046b32c1ebe172bd32dc8276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27920d083eb816f24f832091a662f28"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, class Generator  = RandomGenerator&gt; </td></tr>
<tr class="memitem:af27920d083eb816f24f832091a662f28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#af27920d083eb816f24f832091a662f28">UniformlyRandomRotationMatrix</a> (Generator *generator)</td></tr>
<tr class="memdesc:af27920d083eb816f24f832091a662f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a rotation (in the rotation matrix representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere.  <a href="#af27920d083eb816f24f832091a662f28">More...</a><br /></td></tr>
<tr class="separator:af27920d083eb816f24f832091a662f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc24ae9bbbf0b9d253f3344b97a9f3d4"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, class Generator  = RandomGenerator&gt; </td></tr>
<tr class="memitem:acc24ae9bbbf0b9d253f3344b97a9f3d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#acc24ae9bbbf0b9d253f3344b97a9f3d4">UniformlyRandomRPY</a> (Generator *generator)</td></tr>
<tr class="memdesc:acc24ae9bbbf0b9d253f3344b97a9f3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a rotation (in the roll-pitch-yaw representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere.  <a href="#acc24ae9bbbf0b9d253f3344b97a9f3d4">More...</a><br /></td></tr>
<tr class="separator:acc24ae9bbbf0b9d253f3344b97a9f3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c173b1efc658d118057a0cccd1ccbfa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c173b1efc658d118057a0cccd1ccbfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a5c173b1efc658d118057a0cccd1ccbfa">CalcRollPitchYawFromQuaternionAndRotationMatrix</a> (const Eigen::Quaternion&lt; T &gt; &amp;quaternion, const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;R)</td></tr>
<tr class="separator:a5c173b1efc658d118057a0cccd1ccbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f832c0837ee2ac76c713ed23440e8e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a00f832c0837ee2ac76c713ed23440e8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt; typename Derived::Scalar, 3, 3 &gt;, <a class="el" href="namespacedrake.html#a07869e660ffe730425feca7595de2273">drake::kQuaternionSize</a> &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a00f832c0837ee2ac76c713ed23440e8e">dquat2rotmat</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;quaternion)</td></tr>
<tr class="memdesc:a00f832c0837ee2ac76c713ed23440e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradient of the function that converts a unit length quaternion to a rotation matrix.  <a href="#a00f832c0837ee2ac76c713ed23440e8e">More...</a><br /></td></tr>
<tr class="separator:a00f832c0837ee2ac76c713ed23440e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee0d3618f370d3b31682a8ca479376e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedR , typename DerivedDR &gt; </td></tr>
<tr class="memitem:adee0d3618f370d3b31682a8ca479376e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt; typename DerivedR::Scalar, <a class="el" href="namespacedrake.html#aeab5b0d99cafc2f6ae5812128cea27a3">drake::kRpySize</a>, 1 &gt;, DerivedDR::ColsAtCompileTime &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#adee0d3618f370d3b31682a8ca479376e">drotmat2rpy</a> (const Eigen::MatrixBase&lt; DerivedR &gt; &amp;R, const Eigen::MatrixBase&lt; DerivedDR &gt; &amp;dR)</td></tr>
<tr class="memdesc:adee0d3618f370d3b31682a8ca479376e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradient of the function that converts a rotation matrix to body-fixed z-y'-x'' Euler angles.  <a href="#adee0d3618f370d3b31682a8ca479376e">More...</a><br /></td></tr>
<tr class="separator:adee0d3618f370d3b31682a8ca479376e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02d13e3a0cbc27e905be533959b8d2a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedR , typename DerivedDR &gt; </td></tr>
<tr class="memitem:aa02d13e3a0cbc27e905be533959b8d2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt; typename DerivedR::Scalar, <a class="el" href="namespacedrake.html#a07869e660ffe730425feca7595de2273">drake::kQuaternionSize</a>, 1 &gt;, DerivedDR::ColsAtCompileTime &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#aa02d13e3a0cbc27e905be533959b8d2a">drotmat2quat</a> (const Eigen::MatrixBase&lt; DerivedR &gt; &amp;R, const Eigen::MatrixBase&lt; DerivedDR &gt; &amp;dR)</td></tr>
<tr class="memdesc:aa02d13e3a0cbc27e905be533959b8d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradient of the function that converts rotation matrix to quaternion.  <a href="#aa02d13e3a0cbc27e905be533959b8d2a">More...</a><br /></td></tr>
<tr class="separator:aa02d13e3a0cbc27e905be533959b8d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2323e3640559f027b0681945cb3f1a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a0a2323e3640559f027b0681945cb3f1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a0a2323e3640559f027b0681945cb3f1a">ProjectMatToRotMatWithAxis</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;M, const Eigen::Vector3d &amp;axis, const <a class="el" href="classdouble.html">double</a> angle_lb, const <a class="el" href="classdouble.html">double</a> angle_ub)</td></tr>
<tr class="memdesc:a0a2323e3640559f027b0681945cb3f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects an approximate 3 x 3 rotation matrix M onto an orthonormal matrix R so that R is a rotation matrix associated with a angle-axis rotation by an angle θ about a vector direction <code>axis</code>, with <code>angle_lb &lt;= θ &lt;= angle_ub</code>.  <a href="#a0a2323e3640559f027b0681945cb3f1a">More...</a><br /></td></tr>
<tr class="separator:a0a2323e3640559f027b0681945cb3f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ee101d8378756998cecdfe62796a93"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a68ee101d8378756998cecdfe62796a93"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a68ee101d8378756998cecdfe62796a93">DRAKE_DEPRECATED</a> (&quot;Use  <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>(<a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>(<a class="el" href="rgbd__camera__publish__lcm__example_8cc.html#adcd24d59c62f70778c30dd0d4466b202">rpy</a>)).matrix() as per issue &quot; &quot;#8323. Code will be deleted after February 5, 2019. Consider &quot; &quot;updating call sites to use the <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> class rather &quot; &quot;than a <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a> because it ensures the underlying 3x3 matrix &quot; &quot;is a valid rotation matrix.&quot;) Matrix3&lt; typename Derived</td></tr>
<tr class="separator:a68ee101d8378756998cecdfe62796a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecdf6a7ef606861457807da4b56e7ff"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class T3 &gt; </td></tr>
<tr class="memitem:adecdf6a7ef606861457807da4b56e7ff"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#adecdf6a7ef606861457807da4b56e7ff">saturate</a> (const T1 &amp;<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const T2 &amp;low, const T3 &amp;high)</td></tr>
<tr class="memdesc:adecdf6a7ef606861457807da4b56e7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saturates the input <code>value</code> between upper and lower bounds.  <a href="#adecdf6a7ef606861457807da4b56e7ff">More...</a><br /></td></tr>
<tr class="separator:adecdf6a7ef606861457807da4b56e7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bd1ea33cbb7fd030ff6bf3061eb3fe"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a64bd1ea33cbb7fd030ff6bf3061eb3fe"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html#a64bd1ea33cbb7fd030ff6bf3061eb3fe">wrap_to</a> (const T1 &amp;<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const T2 &amp;low, const T2 &amp;high)</td></tr>
<tr class="memdesc:a64bd1ea33cbb7fd030ff6bf3061eb3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">For variables that are meant to be periodic, (e.g.  <a href="#a64bd1ea33cbb7fd030ff6bf3061eb3fe">More...</a><br /></td></tr>
<tr class="separator:a64bd1ea33cbb7fd030ff6bf3061eb3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a65ee44eb97ff7373bd2b6b088b8390b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ee44eb97ff7373bd2b6b088b8390b6">&#9670;&nbsp;</a></span>AutoDiffMatrixType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1math.html#a65ee44eb97ff7373bd2b6b088b8390b6">AutoDiffMatrixType</a> =  Eigen::Matrix&lt; Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;typename Derived::Scalar, Nq, 1&gt; &gt;, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The appropriate AutoDiffScalar gradient type given the value type and the number of derivatives at compile time. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adc96357c54438cadae5c8aefbd16713d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc96357c54438cadae5c8aefbd16713d">&#9670;&nbsp;</a></span>AreQuaternionsEqualForOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::math::AreQuaternionsEqualForOrientation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests whether two quaternions represent the same orientation. </p>
<p>This function converts each quaternion to its canonical form and tests whether the absolute value of the difference in corresponding elements of these canonical quaternions is within tolerance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat1</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quat2</td><td>Quaternion with a description analogous to quat1. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Nonnegative real scalar defining the allowable difference in the orientation described by quat1 and quat2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if quat1 and quat2 represent the same orientation (to within tolerance), otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="af00cd34bea44b187b01da164d5207ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00cd34bea44b187b01da164d5207ae3">&#9670;&nbsp;</a></span>autoDiffToGradientMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_auto_diff_to_gradient_matrix.html">AutoDiffToGradientMatrix</a>&lt;Derived&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::autoDiffToGradientMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_variables</em> = <code>Eigen::Dynamic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2131d12e81399c3201b29118d59adc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2131d12e81399c3201b29118d59adc87">&#9670;&nbsp;</a></span>autoDiffToValueMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_auto_diff_to_value_matrix.html">AutoDiffToValueMatrix</a>&lt;Derived&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::autoDiffToValueMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c173b1efc658d118057a0cccd1ccbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c173b1efc658d118057a0cccd1ccbfa">&#9670;&nbsp;</a></span>CalcRollPitchYawFromQuaternionAndRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; CalcRollPitchYawFromQuaternionAndRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98411a94334e6d40ef2ca10bfc053118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98411a94334e6d40ef2ca10bfc053118">&#9670;&nbsp;</a></span>CalculateAngularVelocityExpressedInBFromQuaternionDt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; drake::math::CalculateAngularVelocityExpressedInBFromQuaternionDt </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quatDt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates angular velocity from a quaternion and its time- derivative. </p>
<p>Algorithm from [Kane, 1983] Section 1.13, Pages 58-59.</p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat_AB</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quatDt</td><td>Time-derivative of <code>quat_AB</code>, i.e. [ẇ, ẋ, ẏ, ż]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">w_AB_B</td><td>B's angular velocity in A, expressed in B. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06541dcb249b4b951ea73d45d2067337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06541dcb249b4b951ea73d45d2067337">&#9670;&nbsp;</a></span>CalculateQuaternionDtConstraintViolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T drake::math::CalculateQuaternionDtConstraintViolation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quatDt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates how well a quaternion and its time-derivative satisfy the quaternion time-derivative constraint specified in [Kane, 1983] Section 1.13, equations 12-13, page 59. </p>
<p>For a quaternion [w, x, y, z], the quaternion must satisfy: w^2 + x^2 + y^2 + z^2 = 1, hence its time-derivative must satisfy: 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) = 0.</p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A quaternion like quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quatDt</td><td>Time-derivative of <code>quat</code>, i.e., [ẇ, ẋ, ẏ, ż]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">quaternionDt_constraint_violation</td><td>The amount the time- derivative of the quaternion constraint has been violated, which may be positive or negative (0 means the constraint is perfectly satisfied). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4bf90f81dcf655d829ed2d718251215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bf90f81dcf655d829ed2d718251215">&#9670;&nbsp;</a></span>CalculateQuaternionDtFromAngularVelocityExpressedInB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt;T&gt; drake::math::CalculateQuaternionDtFromAngularVelocityExpressedInB </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_AB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates a quaternion's time-derivative from its quaternion and angular velocity. </p>
<p>Algorithm from [Kane, 1983] Section 1.13, Pages 58-59.</p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (With P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat_AB</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">w_AB_B</td><td>B's angular velocity in A, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">quatDt</td><td>Time-derivative of quat_AB, i.e., [ẇ, ẋ, ẏ, ż]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad276064dcd8cb5e77d3dc41140840e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad276064dcd8cb5e77d3dc41140840e8c">&#9670;&nbsp;</a></span>CalculateReflectedGrayCodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_gray_codes_matrix.html">GrayCodesMatrix</a>&lt;NumDigits&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::CalculateReflectedGrayCodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_digits</em> = <code>NumDigits</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a matrix whose i'th row is the Gray code for integer i. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NumDigits</td><td>The number of digits in the Gray code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_digits</td><td>The number of digits in the Gray code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M. M is a matrix of size 2ᵏ x k, where <code>k</code> is <code>num_digits</code>. M.row(i) is the Gray code for integer i. </dd></dl>

</div>
</div>
<a id="ab3c61a24dd7c544df6747676b6faa04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c61a24dd7c544df6747676b6faa04a">&#9670;&nbsp;</a></span>closestExpmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename Derived1::Scalar, 3, 1&gt; drake::math::closestExpmap </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>expmap1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>expmap2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e37615af3b6facc6f7dec51323a628e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e37615af3b6facc6f7dec51323a628e">&#9670;&nbsp;</a></span>ClosestQuaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt;Scalar&gt; drake::math::ClosestQuaternion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>q0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternion&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a unit quaternion that represents the same orientation as <code>q1</code>, and has the "shortest" geodesic distance on the unit sphere to <code>q0</code>. </p>

</div>
</div>
<a id="a5a25d66185d603162f5702d31136b31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a25d66185d603162f5702d31136b31c">&#9670;&nbsp;</a></span>ComputeBasisFromAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt;T&gt; drake::math::ComputeBasisFromAxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a right-handed local basis from a given axis. </p>
<p>Defines two other arbitrary axes such that the basis is orthonormal. The basis is R_WL, where W is the frame in which the input axis is expressed and L is a local basis such that v_W = R_WL * v_L.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axis_index</td><td>The index of the axis (in the range [0,2]), with 0 corresponding to the x-axis, 1 corresponding to the y-axis, and z-corresponding to the z-axis. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis_W</td><td>The vector defining the basis's given axis expressed in frame W. The vector need not be a unit vector: this routine will normalize it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">R_WL</td><td>The computed basis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the norm of <code>axis_W</code> is within 1e-10 to zero or <code>axis_index</code> does not lie in the range [0,2]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47d4e4f52f3321536bf570b3a1a23718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d4e4f52f3321536bf570b3a1a23718">&#9670;&nbsp;</a></span>ContinuousAlgebraicRiccatiEquation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd ContinuousAlgebraicRiccatiEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::LLT&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_cholesky</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is functionally the same as ContinuousAlgebraicRiccatiEquation(A, B, Q, R). </p>
<p>The Cholesky decomposition of R is passed in instead of R. </p>

</div>
</div>
<a id="aed596a7b73bd51a9acfa28df7be4214f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed596a7b73bd51a9acfa28df7be4214f">&#9670;&nbsp;</a></span>ContinuousAlgebraicRiccatiEquation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd ContinuousAlgebraicRiccatiEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the unique stabilizing solution S to the continuous-time algebraic Riccati equation: </p>
<pre class="fragment">///  S A + A' S - S B inv(R) B' S + Q = 0
/// </pre> <pre class="fragment">@throws std::runtime_error if R is not positive definite.

Based on the Matrix Sign Function method outlined in this paper:
http://www.engr.iupui.edu/~skoskie/ECE684/Riccati_algorithms.pdf</pre> 
</div>
</div>
<a id="a7ad7ab2561d0c05591eb9720adccc7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad7ab2561d0c05591eb9720adccc7d5">&#9670;&nbsp;</a></span>ConvertTimeDerivativeToOtherFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;typename v_Type::Scalar&gt; drake::math::ConvertTimeDerivativeToOtherFrame </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; v_Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DtB_v_Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>DtB_v_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; w_AB_Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_AB_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given ᴮd/dt(v) (the time derivative in frame B of an arbitrary 3D vector v) and given ᴬωᴮ (frame B's angular velocity in another frame A), this method computes ᴬd/dt(v) (the time derivative in frame A of v) by: ᴬd/dt(v) = ᴮd/dt(v) + ᴬωᴮ x v. </p>
<p>This mathematical operation is known as the "Transport Theorem" or the "Golden Rule for Vector Differentiation" [Mitiguy 2016, §7.3]. It was discovered by Euler in 1758. Its explicit notation with superscript frames was invented by Thomas Kane in 1950. Its use as the defining property of angular velocity was by Mitiguy in 1993.</p>
<p>In source code and comments, we use the following monogram notations: DtA_v = ᴬd/dt(v) denotes the time derivative in frame A of the vector v. DtA_v_E = [ᴬd/dt(v)]_E denotes the time derivative in frame A of vector v, with the resulting new vector quantity expressed in a frame E.</p>
<p>In source code, this mathematical operation is performed with all vectors expressed in the same frame E as [ᴬd/dt(v)]ₑ = [ᴮd/dt(v)]ₑ + [ᴬωᴮ]ₑ x [v]ₑ which in monogram notation is: </p><pre>
  DtA_v_E = DtB_v_E + w_AB_E x v_E
</pre><p>[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics &amp; Motion Simulation. </p>

</div>
</div>
<a id="ac0cb8ebf50f381b19b98f5901b6dea96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cb8ebf50f381b19b98f5901b6dea96">&#9670;&nbsp;</a></span>DecomposePositiveQuadraticForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::MatrixXd, Eigen::MatrixXd &gt; DecomposePositiveQuadraticForm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a quadratic form xᵀQx + bᵀx + c to (Rx+d)ᵀ(Rx+d) where RᵀR = Q Rᵀd = b / 2 Notice that this decomposition is not unique. </p>
<p>For example, with any permutation matrix P, we can define R₁ = P*R d₁ = P*d Then (R₁*x+d₁)ᵀ(R₁*x+d₁) gives the same quadratic form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>The square matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The vector containing the linear coefficients. </td></tr>
    <tr><td class="paramname">c</td><td>The constatnt term. </td></tr>
    <tr><td class="paramname">tol</td><td>We will determine if this quadratic form is always non-negative, by checking the <a class="el" href="namespace_eigen.html">Eigen</a> values of the matrix [Q b/2] [bᵀ/2 c] are all greater than -tol. <br />
 <em>Default:</em> is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">(R,d).</td><td>R and d have the same number of rows. R.cols() == x.rows(). The matrix X = [R d] has the same number of rows as the rank of <pre>
   [Q    b/2]
   [bᵀ/2   c]
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1. The quadratic form is always non-negative, namely the matrix <pre>
        [Q    b/2]
        [bᵀ/2   c]
        </pre> is positive semidefinite.<ol type="1">
<li><code>Q</code> and <code>b</code> are of the correct size.</li>
<li><code>tol</code> is non-negative. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the precondition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8a65e79a6ec2bcb347afa75baefc125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a65e79a6ec2bcb347afa75baefc125">&#9670;&nbsp;</a></span>DecomposePSDmatrixIntoXtransposeTimesX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd DecomposePSDmatrixIntoXtransposeTimesX </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>zero_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a symmetric positive semidefinite matrix Y, decompose it into XᵀX, where the number of rows in X equals to the rank of Y. </p>
<p>Notice that this decomposition is not unique. For any orthonormal matrix U, s.t UᵀU = identity, X_prime = UX also satisfies X_primeᵀX_prime = Y. Here we only return one valid decomposition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y</td><td>A symmetric positive semidefinite matrix. </td></tr>
    <tr><td class="paramname">zero_tol</td><td>We will need to check if some value (for example, the absolute value of Y's eigenvalues) is smaller than zero_tol. If it is, then we deem that value as 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X.</td><td>The matrix X satisfies XᵀX = Y and X.rows() = rank(Y). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1. Y is positive semidefinite.<ol type="1">
<li>zero_tol is non-negative. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when the pre-conditions are not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fc937230e65e9d6bcc7f64f9121d876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc937230e65e9d6bcc7f64f9121d876">&#9670;&nbsp;</a></span>DiscardGradient() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdouble.html">double</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt;typename Derived::Scalar::Scalar, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::DiscardGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>B = DiscardGradient(A)</code> enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar type, explicitly throwing away any gradient information. </p>
<p>For a matrix of type, e.g. <code>MatrixX&lt;AutoDiffXd&gt; A</code>, the comparable operation <code>B = A.cast&lt;double&gt;()</code> should (and does) fail to compile. Use <code>DiscardGradient(A)</code> if you want to force the cast (and explicitly declare that information is lost).</p>
<p>This method is overloaded to permit the user to call it for double types and AutoDiffScalar types (to avoid the calling function having to handle the two cases differently).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a44dafc4c3502cdb9bc73393bd7460f49" title="B = DiscardZeroGradient(A, precision) enables casting from a matrix of AutoDiffScalars to AutoDiffSca...">DiscardZeroGradient</a> </dd></dl>

</div>
</div>
<a id="adfa073cea3a21484021ae39541671549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa073cea3a21484021ae39541671549">&#9670;&nbsp;</a></span>DiscardGradient() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdouble.html">double</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const Eigen::MatrixBase&lt;Derived&gt;&amp;&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::DiscardGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a1fc937230e65e9d6bcc7f64f9121d876" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">DiscardGradient()</a>. </dd></dl>

</div>
</div>
<a id="ad2d9583177e64caf842b9ca82899d9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d9583177e64caf842b9ca82899d9ad">&#9670;&nbsp;</a></span>DiscardGradient() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_same&lt;_Scalar, <a class="el" href="classdouble.html">double</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Transform&lt;typename _Scalar::Scalar, _Dim, _Mode, _Options&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::DiscardGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp;&#160;</td>
          <td class="paramname"><em>auto_diff_transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a1fc937230e65e9d6bcc7f64f9121d876" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">DiscardGradient()</a>. </dd></dl>

</div>
</div>
<a id="ae4868fa25c958b604954155feba6effb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4868fa25c958b604954155feba6effb">&#9670;&nbsp;</a></span>DiscardGradient() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;_Scalar, <a class="el" href="classdouble.html">double</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const Eigen::Transform&lt;_Scalar, _Dim, _Mode, _Options&gt;&amp;&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::DiscardGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a1fc937230e65e9d6bcc7f64f9121d876" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">DiscardGradient()</a>. </dd></dl>

</div>
</div>
<a id="a44dafc4c3502cdb9bc73393bd7460f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44dafc4c3502cdb9bc73393bd7460f49">&#9670;&nbsp;</a></span>DiscardZeroGradient() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdouble.html">double</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Matrix&lt;typename Derived::Scalar::Scalar, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::DiscardZeroGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Eigen::NumTraits&lt; typename Derived::Scalar::Scalar &gt;::Real &amp;&#160;</td>
          <td class="paramname"><em>precision</em> = <code>Eigen::NumTraits&lt;typename&#160;Derived::Scalar::Scalar&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>B = DiscardZeroGradient(A, precision)</code> enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar type, but first checking that the gradient matrix is empty or zero. </p>
<p>For a matrix of type, e.g. <code>MatrixX&lt;AutoDiffXd&gt; A</code>, the comparable operation <code>B = A.cast&lt;double&gt;()</code> should (and does) fail to compile. Use <code>DiscardZeroGradient(A)</code> if you want to force the cast (and the check).</p>
<p>This method is overloaded to permit the user to call it for double types and AutoDiffScalar types (to avoid the calling function having to handle the two cases differently).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">precision</td><td>is passed to <a class="el" href="namespace_eigen.html">Eigen</a>'s isZero(precision) to evaluate whether the gradients are zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the gradients were not empty nor zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a1fc937230e65e9d6bcc7f64f9121d876" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">DiscardGradient</a> </dd></dl>

</div>
</div>
<a id="aa2c18d1e6fa89e66ed1e7c83239cda96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c18d1e6fa89e66ed1e7c83239cda96">&#9670;&nbsp;</a></span>DiscardZeroGradient() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdouble.html">double</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const Eigen::MatrixBase&lt;Derived&gt;&amp;&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::DiscardZeroGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a44dafc4c3502cdb9bc73393bd7460f49" title="B = DiscardZeroGradient(A, precision) enables casting from a matrix of AutoDiffScalars to AutoDiffSca...">DiscardZeroGradient()</a>. </dd></dl>

</div>
</div>
<a id="a61b824ea80b3f2ac8891dc02b0730367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b824ea80b3f2ac8891dc02b0730367">&#9670;&nbsp;</a></span>DiscardZeroGradient() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_same&lt;_Scalar, <a class="el" href="classdouble.html">double</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, Eigen::Transform&lt;typename _Scalar::Scalar, _Dim, _Mode, _Options&gt; &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::DiscardZeroGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp;&#160;</td>
          <td class="paramname"><em>auto_diff_transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Eigen::NumTraits&lt; typename _Scalar::Scalar &gt;::Real &amp;&#160;</td>
          <td class="paramname"><em>precision</em> = <code>Eigen::NumTraits&lt;typename&#160;_Scalar::Scalar&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a44dafc4c3502cdb9bc73393bd7460f49" title="B = DiscardZeroGradient(A, precision) enables casting from a matrix of AutoDiffScalars to AutoDiffSca...">DiscardZeroGradient()</a>. </dd></dl>

</div>
</div>
<a id="a286452ec0226092c95d7436b487b0ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286452ec0226092c95d7436b487b0ace">&#9670;&nbsp;</a></span>DiscardZeroGradient() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;_Scalar, <a class="el" href="classdouble.html">double</a>&gt;::<a class="el" href="lcm__subscriber__system__test_8cc.html#a999459b8af9d4480b112b99074033d38">value</a>, const Eigen::Transform&lt;_Scalar, _Dim, _Mode, _Options&gt;&amp;&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::DiscardZeroGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; _Scalar, _Dim, _Mode, _Options &gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a44dafc4c3502cdb9bc73393bd7460f49" title="B = DiscardZeroGradient(A, precision) enables casting from a matrix of AutoDiffScalars to AutoDiffSca...">DiscardZeroGradient()</a>. </dd></dl>

</div>
</div>
<a id="afcef78b318bd0da2f388b83bc6fafa81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcef78b318bd0da2f388b83bc6fafa81">&#9670;&nbsp;</a></span>DiscreteAlgebraicRiccatiEquation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd DiscreteAlgebraicRiccatiEquation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DiscreteAlgebraicRiccatiEquation function computes the unique stabilizing solution X to the discrete-time algebraic Riccati equation: </p><p class="formulaDsp">
\[ A&#39;XA - X - A&#39;XB(B&#39;XB+R)^{-1}B&#39;XA + Q = 0 \]
</p>
<p>. </p>
<p>Computes the unique stabilizing solution X to the discrete-time algebraic Riccati equation:</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if Q is not positive semi-definite. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if R is not positive definite.</td></tr>
  </table>
  </dd>
</dl>
<p>Based on the Schur Vector approach outlined in this paper: "On the Numerical Solution of the Discrete-Time Algebraic Riccati Equation" by Thrasyvoulos Pappas, Alan J. Laub, and Nils R. Sandell, in TAC, 1980, <a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1102434">http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1102434</a></p>
<p>Note: When, for example, n = 100, m = 80, and entries of A, B, Q_half, R_half are sampled from standard normal distributions, where Q = Q_half'*Q_half and similar for R, the absolute error of the solution is 10^{-6}, while the absolute error of the solution computed by Matlab is 10^{-8}.</p>
<p>TODO(weiqiao.han): I may overwrite the RealQZ function to improve the accuracy, together with more thorough tests.</p>
<p class="formulaDsp">
\[ A&#39;XA - X - A&#39;XB(B&#39;XB+R)^{-1}B&#39;XA + Q = 0 \]
</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if Q is not positive semi-definite. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if R is not positive definite.</td></tr>
  </table>
  </dd>
</dl>
<p>Based on the Schur Vector approach outlined in this paper: "On the Numerical Solution of the Discrete-Time Algebraic Riccati Equation" by Thrasyvoulos Pappas, Alan J. Laub, and Nils R. Sandell </p>

</div>
</div>
<a id="a00f832c0837ee2ac76c713ed23440e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f832c0837ee2ac76c713ed23440e8e">&#9670;&nbsp;</a></span>dquat2rotmat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt;Eigen::Matrix&lt;typename Derived::Scalar, 3, 3&gt;, <a class="el" href="namespacedrake.html#a07869e660ffe730425feca7595de2273">drake::kQuaternionSize</a>&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::dquat2rotmat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the gradient of the function that converts a unit length quaternion to a rotation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternion</td><td>A unit length quaternion [w;x;y;z] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient </dd></dl>

</div>
</div>
<a id="a7969c04c7e7d65986baf0f7d8e8db49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7969c04c7e7d65986baf0f7d8e8db49e">&#9670;&nbsp;</a></span>DRAKE_DEPRECATED() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::math::DRAKE_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;Use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>(Eigen::Quaternion). &quot; &quot;Code will be deleted after February&#160;</td>
          <td class="paramname"><em>5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2019.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68ee101d8378756998cecdfe62796a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ee101d8378756998cecdfe62796a93">&#9670;&nbsp;</a></span>DRAKE_DEPRECATED() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drake::math::DRAKE_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;Use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>(<a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>(<a class="el" href="rgbd__camera__publish__lcm__example_8cc.html#adcd24d59c62f70778c30dd0d4466b202">rpy</a>)).matrix() as per issue &quot; &quot;#8323. Code will be deleted after February&#160;</td>
          <td class="paramname"><em>5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2019. Consider &quot; &quot;updating call sites to use the <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a> class rather &quot; &quot;than a <a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a> because it ensures the underlying 3x3 matrix &quot; &quot;is a valid rotation matrix.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa02d13e3a0cbc27e905be533959b8d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02d13e3a0cbc27e905be533959b8d2a">&#9670;&nbsp;</a></span>drotmat2quat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt;typename DerivedR::Scalar, <a class="el" href="namespacedrake.html#a07869e660ffe730425feca7595de2273">drake::kQuaternionSize</a>, 1&gt;, DerivedDR::ColsAtCompileTime&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::drotmat2quat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDR &gt; &amp;&#160;</td>
          <td class="paramname"><em>dR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the gradient of the function that converts rotation matrix to quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>A 3 x 3 rotation matrix </td></tr>
    <tr><td class="paramname">dR</td><td>A 9 x N matrix, dR(i,j) is the gradient of R(i) w.r.t x_var(j) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient G. G is a 4 x N matrix G(0,j) is the gradient of w w.r.t x_var(j) G(1,j) is the gradient of x w.r.t x_var(j) G(2,j) is the gradient of y w.r.t x_var(j) G(3,j) is the gradient of z w.r.t x_var(j) </dd></dl>

</div>
</div>
<a id="adee0d3618f370d3b31682a8ca479376e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee0d3618f370d3b31682a8ca479376e">&#9670;&nbsp;</a></span>drotmat2rpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Eigen::Matrix&lt;typename DerivedR::Scalar, <a class="el" href="namespacedrake.html#aeab5b0d99cafc2f6ae5812128cea27a3">drake::kRpySize</a>, 1&gt;, DerivedDR::ColsAtCompileTime&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::drotmat2rpy </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDR &gt; &amp;&#160;</td>
          <td class="paramname"><em>dR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the gradient of the function that converts a rotation matrix to body-fixed z-y'-x'' Euler angles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>A 3 x 3 rotation matrix </td></tr>
    <tr><td class="paramname">dR</td><td>A 9 x N matrix, dR(i,j) is the gradient of R(i) w.r.t x(j) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient G. G is a 3 x N matrix. G(0,j) is the gradient of roll w.r.t x(j) G(1,j) is the gradient of pitch w.r.t x(j) G(2,j) is the gradient of yaw w.r.t x(j) </dd></dl>

</div>
</div>
<a id="a4bc8c0d47e42141e066c524543c5dd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc8c0d47e42141e066c524543c5dd92">&#9670;&nbsp;</a></span>expmap2quat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename Derived::Scalar, 4, 1&gt; drake::math::expmap2quat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c5269630d172b12a31b34d6c98b4e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5269630d172b12a31b34d6c98b4e64">&#9670;&nbsp;</a></span>getSubMatrixGradient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename Derived::Scalar, Eigen::Dynamic, Eigen::Dynamic&gt; drake::math::getSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>M_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>q_subvector_size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4b8fed3ad399a2bd53630c3b5b6d335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b8fed3ad399a2bd53630c3b5b6d335">&#9670;&nbsp;</a></span>getSubMatrixGradient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_array.html">GetSubMatrixGradientArray</a>&lt;QSubvectorSize, Derived, NRows, NCols&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::getSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classint.html">int</a>, NRows &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classint.html">int</a>, NCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>M_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>q_subvector_size</em> = <code>QSubvectorSize</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a259ed4f41a444e8eed6a2a30998af53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259ed4f41a444e8eed6a2a30998af53f">&#9670;&nbsp;</a></span>getSubMatrixGradient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_get_sub_matrix_gradient_single_element.html">GetSubMatrixGradientSingleElement</a>&lt;QSubvectorSize, Derived&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::getSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>M_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>q_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>q_subvector_size</em> = <code>QSubvectorSize</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a5aa65ce6d612ea5275c1f724a7f319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5aa65ce6d612ea5275c1f724a7f319">&#9670;&nbsp;</a></span>gradientMatrixToAutoDiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::gradientMatrixToAutoDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedAutoDiff &gt; &amp;&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b836de6a2619d82ebb7793a920e7b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b836de6a2619d82ebb7793a920e7b67">&#9670;&nbsp;</a></span>GrayCodeToInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> GrayCodeToInteger </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>gray_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the Gray code to an integer. </p>
<p>For example (0, 0) -&gt; 0 (0, 1) -&gt; 1 (1, 1) -&gt; 2 (1, 0) -&gt; 3 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gray_code</td><td>The N-digit Gray code, where N is gray_code.rows() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integer represented by the Gray code <code>gray_code</code>. </dd></dl>

</div>
</div>
<a id="a6dce37732e3e532f7b87cd517789da7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dce37732e3e532f7b87cd517789da7f">&#9670;&nbsp;</a></span>hessian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) drake::math::hessian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a matrix of AutoDiffScalars from which the value, Jacobian, and Hessian of a function </p><p class="formulaDsp">
\[ f:\mathbb{R}^{n\times m}\rightarrow\mathbb{R}^{p\times q} \]
</p>
<p> (f: R^n*m -&gt; R^p*q) can be extracted. </p>
<p>The output is a matrix of nested AutoDiffScalars, being the result of calling <a class="el" href="namespacedrake_1_1math.html#a57457683becdddf605a55be881c065b4" title="Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function  (f: R^...">jacobian</a> on a function that returns the output of <a class="el" href="namespacedrake_1_1math.html#a57457683becdddf605a55be881c065b4" title="Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function  (f: R^...">jacobian</a>, called on <code>f</code>.</p>
<p><code>MaxChunkSizeOuter</code> and <code>MaxChunkSizeInner</code> can be used to control chunk sizes (see <a class="el" href="namespacedrake_1_1math.html#a57457683becdddf605a55be881c065b4" title="Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function  (f: R^...">jacobian</a>).</p>
<p>See <a class="el" href="namespacedrake_1_1math.html#a57457683becdddf605a55be881c065b4" title="Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function  (f: R^...">jacobian</a> for requirements on the function <code>f</code> and the argument <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramname">x</td><td>function argument value at which Hessian will be evaluated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AutoDiffScalar matrix corresponding to the Hessian of f evaluated at x </dd></dl>

</div>
</div>
<a id="a32d860f5fd00b3004e866af6f73a1362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d860f5fd00b3004e866af6f73a1362">&#9670;&nbsp;</a></span>initializeAutoDiff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::initializeAutoDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedAutoDiff &gt; &amp;&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseIndex&#160;</td>
          <td class="paramname"><em>num_derivatives</em> = <code>Eigen::Dynamic</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseIndex&#160;</td>
          <td class="paramname"><em>deriv_num_start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a single autodiff matrix given the corresponding value matrix. </p>
<p>Set the values of <code>auto_diff_matrix</code> to be equal to <code>val</code>, and for each element i of <code>auto_diff_matrix</code>, resize the derivatives vector to <code>num_derivatives</code>, and set derivative number <code>deriv_num_start</code> + i to one (all other elements of the derivative vector set to zero).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>'regular' matrix of values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>AutoDiff matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_derivatives</td><td>the size of the derivatives vector <br />
 <em>Default:</em> the size of mat </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deriv_num_start</td><td>starting index into derivative vector (i.e. element deriv_num_start in derivative vector corresponds to mat(0, 0)). <br />
 <em>Default:</em> 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab773f7c582bc83dd2f26c0965de1e427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab773f7c582bc83dd2f26c0965de1e427">&#9670;&nbsp;</a></span>initializeAutoDiff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1math.html#a65ee44eb97ff7373bd2b6b088b8390b6">AutoDiffMatrixType</a>&lt;Derived, Nq&gt; drake::math::initializeAutoDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseIndex&#160;</td>
          <td class="paramname"><em>num_derivatives</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseIndex&#160;</td>
          <td class="paramname"><em>deriv_num_start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a single autodiff matrix given the corresponding value matrix. </p>
<p>Create autodiff matrix that matches <code>mat</code> in size with derivatives of compile time size <code>Nq</code> and runtime size <code>num_derivatives</code>. Set its values to be equal to <code>val</code>, and for each element i of <code>auto_diff_matrix</code>, set derivative number <code>deriv_num_start</code> + i to one (all other derivatives set to zero).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>'regular' matrix of values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_derivatives</td><td>the size of the derivatives vector <br />
 <em>Default:</em> the size of mat </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deriv_num_start</td><td>starting index into derivative vector (i.e. element deriv_num_start in derivative vector corresponds to mat(0, 0)). <br />
 <em>Default:</em> 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AutoDiff matrix </dd></dl>

</div>
</div>
<a id="a627c51b97633b728056e96ee26daf583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627c51b97633b728056e96ee26daf583">&#9670;&nbsp;</a></span>initializeAutoDiffGivenGradientMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::initializeAutoDiffGivenGradientMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedAutoDiff &gt; &amp;&#160;</td>
          <td class="paramname"><em>auto_diff_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an autodiff matrix given a matrix of values and gradient matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradient</td><td>gradient matrix; the derivatives of val(j) are stored in row j of the gradient matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">autodiff_matrix</td><td>matrix of AutoDiffScalars with the same size as <code>val</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e1337cae81c66571d592dd9be50df7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1337cae81c66571d592dd9be50df7c">&#9670;&nbsp;</a></span>initializeAutoDiffGivenGradientMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1math.html#a65ee44eb97ff7373bd2b6b088b8390b6">AutoDiffMatrixType</a>&lt;Derived, DerivedGradient::ColsAtCompileTime&gt; drake::math::initializeAutoDiffGivenGradientMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGradient &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and initializes an autodiff matrix given a matrix of values and gradient matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gradient</td><td>gradient matrix; the derivatives of val(j) are stored in row j of the gradient matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>autodiff_matrix matrix of AutoDiffScalars with the same size as <code>val</code> </dd></dl>

</div>
</div>
<a id="a6e5c76a80b6a785f91dd3e06200e3f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5c76a80b6a785f91dd3e06200e3f83">&#9670;&nbsp;</a></span>initializeAutoDiffTuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespacedrake_1_1math.html#a65ee44eb97ff7373bd2b6b088b8390b6">AutoDiffMatrixType</a>&lt; Deriveds, <a class="el" href="namespacedrake_1_1math_1_1internal.html#a7f71df2d6b5bc2d9ddebca9a8cd3947a">internal::totalSizeAtCompileTime</a>&lt;Deriveds...&gt;)&gt;...&gt; drake::math::initializeAutoDiffTuple </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Deriveds &gt; &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a series of <a class="el" href="namespace_eigen.html">Eigen</a> matrices, create a tuple of corresponding AutoDiff matrices with values equal to the input matrices and properly initialized derivative vectors. </p>
<p>The size of the derivative vector of each element of the matrices in the output tuple will be the same, and will equal the sum of the number of elements of the matrices in <code>args</code>. If all of the matrices in <code>args</code> have fixed size, then the derivative vectors will also have fixed size (being the sum of the sizes at compile time of all of the input arguments), otherwise the derivative vectors will have dynamic size. The 0th element of the derivative vectors will correspond to the derivative with respect to the 0th element of the first argument. Subsequent derivative vector elements correspond first to subsequent elements of the first input argument (traversed first by row, then by column), and so on for subsequent arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>a series of <a class="el" href="namespace_eigen.html">Eigen</a> matrices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of properly initialized AutoDiff matrices corresponding to <code>args</code> </dd></dl>

</div>
</div>
<a id="a6eb0d39dab703d87f0f582cf310c6134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb0d39dab703d87f0f582cf310c6134">&#9670;&nbsp;</a></span>intRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="classint.html">int</a>, Size&gt; drake::math::intRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88a6d40e458bc9f766f33b819a7b4900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a6d40e458bc9f766f33b819a7b4900">&#9670;&nbsp;</a></span>is_quaternion_in_canonical_form()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::math::is_quaternion_in_canonical_form </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests whether a quaternion is in "canonical form" meaning that it tests whether the quaternion [w, x, y, z] has a non-negative w value. </p>
<p>Example: [-0.3, +0.4, +0.5, +0.707] is not in canonical form. Example: [+0.3, -0.4, -0.5, -0.707] is in canonical form. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat is analogous to the rotation matrix R_AB. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if quat.w() is nonnegative (in canonical form), else <code>false</code>. </dd></dl>

</div>
</div>
<a id="a3b38bdfc1e3df8662c8726bc89a08ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b38bdfc1e3df8662c8726bc89a08ed0">&#9670;&nbsp;</a></span>IsBothQuaternionAndQuaternionDtOK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::math::IsBothQuaternionAndQuaternionDtOK </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quatDt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests if a quaternion satisfies the time-derivative constraint specified in [Kane, 1983] Section 1.13, equation 13, page 59. </p>
<p>A quaternion [w, x, y, z] must satisfy w^2 + x^2 + y^2 + z^2 = 1, hence its time-derivative must satisfy 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) = 0. Note: To accurately test whether the time-derivative quaternion constraint is satisfied, the quaternion constraint is also tested to be accurate.</p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A quaternion like quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quatDt</td><td>Time-derivative of <code>quat</code>, i.e., [ẇ, ẋ, ẏ, ż]. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance for quaternion constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both of the two previous constraints are within tolerance. </dd></dl>

</div>
</div>
<a id="a2e47f892f2417dfc861a095328019361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e47f892f2417dfc861a095328019361">&#9670;&nbsp;</a></span>IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::math::IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quatDt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests if a quaternion and a quaternions time-derivative can calculate and match an angular velocity to within a tolerance. </p>
<p>Note: This function first tests if the quaternion [w, x, y, z] satisfies w^2 + x^2 + y^2 + z^2 = 1 (to within tolerance) and if its time-derivative satisfies w*ẇ + x*ẋ + y*ẏ + z*ż = 0 (to within tolerance). Lastly, it tests if each element of the angular velocity calculated from quat and quatDt is within tolerance of w_B (described below). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A quaternion like quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">quatDt</td><td>Time-derivative of <code>quat</code>, i.e., [ẇ, ẋ, ẏ, ż]. </td></tr>
    <tr><td class="paramname">w_B</td><td>Rigid body B's angular velocity in frame A, expressed in B. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance for quaternion constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all three of the previous constraints are within tolerance. </dd></dl>

</div>
</div>
<a id="a056f9de21690e59551e2904bde9ac928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056f9de21690e59551e2904bde9ac928">&#9670;&nbsp;</a></span>IsQuaternionValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::math::IsQuaternionValid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests if a quaternion satisfies the quaternion constraint specified in [Kane, 1983] Section 1.3, equation 4, page 12, i.e., a quaternion [w, x, y, z] must satisfy: w^2 + x^2 + y^2 + z^2 = 1. </p>
<ul>
<li>[Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York, 1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A quaternion like quat_AB is analogous to the rotation matrix R_AB. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance for quaternion constraint, i.e., how much is w^2 + x^2 + y^2 + z^2 allowed to differ from 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the quaternion constraint is satisfied within tolerance. </dd></dl>

</div>
</div>
<a id="a84760cbea23b50efdbe9a85f3967f098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84760cbea23b50efdbe9a85f3967f098">&#9670;&nbsp;</a></span>IsSymmetric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::math::IsSymmetric </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a matrix is symmetric. </p>
<p>If std::equal_to&lt;&gt;()(matrix(i, j), matrix(j, i)) is true for all i, j, then the matrix is symmetric. </p>

</div>
</div>
<a id="a141ec70804c105e09ab3b0a855152b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141ec70804c105e09ab3b0a855152b8b">&#9670;&nbsp;</a></span>IsSymmetric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> drake::math::IsSymmetric </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Derived::Scalar &amp;&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a matrix is symmetric based on whether the difference between matrix(i, j) and matrix(j, i) is smaller than <code>precision</code> for all i, j. </p>
<p>The precision is absolute. Matrix with nan or inf entries is not allowed. </p>

</div>
</div>
<a id="a57457683becdddf605a55be881c065b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57457683becdddf605a55be881c065b4">&#9670;&nbsp;</a></span>jacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) drake::math::jacobian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="snopt__solver__f2c_8cc.html#ae6e3e001d235e03c51cac2079203b29b">F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a matrix of AutoDiffScalars from which both the value and the Jacobian of a function </p><p class="formulaDsp">
\[ f:\mathbb{R}^{n\times m}\rightarrow\mathbb{R}^{p\times q} \]
</p>
<p> (f: R^n*m -&gt; R^p*q) can be extracted. </p>
<p>The derivative vector for each AutoDiffScalar in the output contains the derivatives with respect to all components of the argument \( x \).</p>
<p>The return type of this function is a matrix with the `best' possible AutoDiffScalar scalar type, in the following sense:</p><ul>
<li>If the number of derivatives can be determined at compile time, the AutoDiffScalar derivative vector will have that fixed size.</li>
<li>If the maximum number of derivatives can be determined at compile time, the AutoDiffScalar derivative vector will have that maximum fixed size.</li>
<li>If neither the number, nor the maximum number of derivatives can be determined at compile time, the output AutoDiffScalar derivative vector will be dynamically sized.</li>
</ul>
<p><code>f</code> should have a templated call operator that maps an <a class="el" href="namespace_eigen.html">Eigen</a> matrix argument to another <a class="el" href="namespace_eigen.html">Eigen</a> matrix. The scalar type of the output of \( f \) need not match the scalar type of the input (useful in recursive calls to the function to determine higher order derivatives). The easiest way to create an <code>f</code> is using a C++14 generic lambda.</p>
<p>The algorithm computes the Jacobian in chunks of up to <code>MaxChunkSize</code> derivatives at a time. This has three purposes:</p><ul>
<li>It makes it so that derivative vectors can be allocated on the stack, eliminating dynamic allocations and improving performance if the maximum number of derivatives cannot be determined at compile time.</li>
<li>It gives control over, and limits the number of required instantiations of the call operator of f and all the functions it calls.</li>
<li>Excessively large derivative vectors can result in CPU capacity cache misses; even if the number of derivatives is fixed at compile time, it may be better to break up into chunks if that means that capacity cache misses can be prevented.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramname">x</td><td>function argument value at which Jacobian will be evaluated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AutoDiffScalar matrix corresponding to the Jacobian of f evaluated at x. </dd></dl>

</div>
</div>
<a id="a4805a6b4a327bedeb7793cd1ce11523c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4805a6b4a327bedeb7793cd1ce11523c">&#9670;&nbsp;</a></span>matGradMult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult.html">MatGradMult</a>&lt;DerivedDA, DerivedB&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::matGradMult </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41fb0200e4ab7c796576b2fe17408ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fb0200e4ab7c796576b2fe17408ec8">&#9670;&nbsp;</a></span>matGradMultMat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1math_1_1_mat_grad_mult_mat.html">MatGradMultMat</a>&lt;DerivedA, DerivedB, DerivedDA&gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> drake::math::matGradMultMat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48484009086db12d881bea6bcaab2514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48484009086db12d881bea6bcaab2514">&#9670;&nbsp;</a></span>NormalizeVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::NormalizeVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::PlainObject &amp;&#160;</td>
          <td class="paramname"><em>x_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Derived, Derived::RowsAtCompileTime, 1 &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> *&#160;</td>
          <td class="paramname"><em>dx_norm</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structdrake_1_1math_1_1_gradient.html">drake::math::Gradient</a>&lt; Derived, Derived::RowsAtCompileTime, 2 &gt;::<a class="el" href="multilane_2loader_8cc.html#adb5798caab72849ba8da861ddc3acccd">type</a> *&#160;</td>
          <td class="paramname"><em>ddx_norm</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the normalized vector, optionally with its gradient and second derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>An N x 1 vector to be normalized. Must not be zero. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x_norm</td><td>The normalized vector (N x 1). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dx_norm</td><td>If non-null, returned as an N x N matrix, where dx_norm(i,j) = D x_norm(i)/D x(j). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ddx_norm</td><td>If non-null, and dx_norm is non-null, returned as an N^2 x N matrix, where ddx_norm.col(j) = D dx_norm/D x(j), with dx_norm stacked columnwise.</td></tr>
  </table>
  </dd>
</dl>
<p>(D x / D y above means partial derivative of x with respect to y.) </p>

</div>
</div>
<a id="a0a2323e3640559f027b0681945cb3f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2323e3640559f027b0681945cb3f1a">&#9670;&nbsp;</a></span>ProjectMatToRotMatWithAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> drake::math::ProjectMatToRotMatWithAxis </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>angle_lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>angle_ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects an approximate 3 x 3 rotation matrix M onto an orthonormal matrix R so that R is a rotation matrix associated with a angle-axis rotation by an angle θ about a vector direction <code>axis</code>, with <code>angle_lb &lt;= θ &lt;= angle_ub</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>A 3 x 3 matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>the matrix to be projected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>vector direction associated with angle-axis rotation for R. axis can be a non-unit vector, but cannot be the zero vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_lb</td><td>the lower bound of the rotation angle θ. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_ub</td><td>the upper bound of the rotation angle θ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rotation angle θ of the projected matrix, angle_lb &lt;= θ &lt;= angle_ub </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if M is not a 3 x 3 matrix or if axis is the zero vector or if angle_lb &gt; angle_ub. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is useful for reconstructing a rotation matrix for a revolute joint with joint limits. </dd>
<dd>
This can be formulated as an optimization problem <pre>
  min_θ trace((R - M)ᵀ*(R - M))
  subject to R = I + sinθ * A + (1 - cosθ) * A²   (1)
             angle_lb &lt;= θ &lt;= angle_ub
</pre> where A is the cross product matrix of a = axis / axis.norm() = [a₁, a₂, a₃] <pre>
A = [ 0  -a₃  a₂]
    [ a₃  0  -a₁]
    [-a₂  a₁  0 ]
</pre> Equation (1) is the Rodriguez Formula that computes the rotation matrix R from the angle-axis rotation with angle θ and vector direction <code>axis</code>. For details, see <a href="http://mathworld.wolfram.com/RodriguesRotationFormula.html">http://mathworld.wolfram.com/RodriguesRotationFormula.html</a> The objective function can be simplified as <pre>
   max_θ trace(Rᵀ * M + Mᵀ * R)
</pre> By substituting the matrix <code>R</code> with the angle-axis representation, the optimization problem is formulated as <pre>
   max_θ sinθ * trace(Aᵀ*M) - cosθ * trace(Mᵀ * A²)
   subject to angle_lb &lt;= θ &lt;= angle_ub
</pre> By introducing α = atan2(-trace(Mᵀ * A²), trace(Aᵀ*M)), we can compute the optimal θ as <pre>
   θ = π/2 + 2kπ - α, if angle_lb &lt;= π/2 + 2kπ - α &lt;= angle_ub, k ∈ integers
else
   θ = angle_lb, if sin(angle_lb + α) &gt;= sin(angle_ub + α)
   θ = angle_ub, if sin(angle_lb + α) &lt;  sin(angle_ub + α)
</pre> </dd></dl>
<dl class="section see"><dt>See also</dt><dd>GlobalInverseKinematics for an usage of this function. </dd></dl>

</div>
</div>
<a id="abd18e2f0405f7355c3029e724355db6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd18e2f0405f7355c3029e724355db6e">&#9670;&nbsp;</a></span>quat2expmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename DerivedQ::Scalar, 3, 1&gt; drake::math::quat2expmap </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a068e4e5c69ceccbfebfaeb9c91723d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068e4e5c69ceccbfebfaeb9c91723d39">&#9670;&nbsp;</a></span>quat2expmapSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::quat2expmapSequence </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat_dot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>expmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>expmap_dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e6bdc00adb60394da9687fc9aa5b0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6bdc00adb60394da9687fc9aa5b0aa">&#9670;&nbsp;</a></span>quatConjugate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt;typename Derived::Scalar&gt; drake::math::quatConjugate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2ef93ff1fa2dc788507d6eadb4bb78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ef93ff1fa2dc788507d6eadb4bb78f">&#9670;&nbsp;</a></span>quatDiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt;typename Derived1::Scalar&gt; drake::math::quatDiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad298b049679492bf3e846165c6c7e023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad298b049679492bf3e846165c6c7e023">&#9670;&nbsp;</a></span>quatDiffAxisInvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Derived1::Scalar drake::math::quatDiffAxisInvar </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad74d3c5baa84fa6ef04b6ada5ffcbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad74d3c5baa84fa6ef04b6ada5ffcbe5">&#9670;&nbsp;</a></span>QuaternionToCanonicalForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt;T&gt; drake::math::QuaternionToCanonicalForm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a quaternion in its "canonical form" meaning that it returns a quaternion [w, x, y, z] with a non-negative w. </p>
<p>For example, if passed a quaternion [-0.3, +0.4, +0.5, +0.707], the function returns the quaternion's canonical form [+0.3, -0.4, -0.5, -0.707]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>Quaternion [w, x, y, z] that relates two right-handed orthogonal unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat is analogous to the rotation matrix R_AB. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Canonical form of quat, which means that either the original quat is returned or a quaternion representing the same orientation but with negated [w, x, y, z], to ensure a positive w in returned quaternion. </dd></dl>

</div>
</div>
<a id="a29059591a43a840c9a7e2f31a2d55130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29059591a43a840c9a7e2f31a2d55130">&#9670;&nbsp;</a></span>quatProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt;typename Derived1::Scalar&gt; drake::math::quatProduct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fc70ebdc0ea497711e6e7b69eddef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc70ebdc0ea497711e6e7b69eddef2d">&#9670;&nbsp;</a></span>quatRotateVec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;typename DerivedV::Scalar&gt; drake::math::quatRotateVec </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fc1b9bbef766b25c3e3684df19eee0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc1b9bbef766b25c3e3684df19eee0c">&#9670;&nbsp;</a></span>resizeDerivativesToMatchScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::resizeDerivativesToMatchScalar </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Derived::Scalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize derivatives vector of each element of a matrix to to match the size of the derivatives vector of a given scalar. </p>
<p>If the mat and scalar inputs are AutoDiffScalars, resize the derivatives vector of each element of the matrix mat to match the number of derivatives of the scalar. This is useful in functions that return matrices that do not depend on an AutoDiffScalar argument (e.g. a function with a constant output), while it is desired that information about the number of derivatives is preserved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>matrix, for which the derivative vectors of the elements will be resized </td></tr>
    <tr><td class="paramname">scalar</td><td>scalar to match the derivative size vector against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adecdf6a7ef606861457807da4b56e7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecdf6a7ef606861457807da4b56e7ff">&#9670;&nbsp;</a></span>saturate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T1 drake::math::saturate </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saturates the input <code>value</code> between upper and lower bounds. </p>
<p>If <code>value</code> is within <code>[low, high]</code> then return it; else return the boundary. </p>

</div>
</div>
<a id="a30d857f8398886aff22da2ea64bc1113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d857f8398886aff22da2ea64bc1113">&#9670;&nbsp;</a></span>setSubMatrixGradient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::setSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM_submatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index&#160;</td>
          <td class="paramname"><em>M_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index&#160;</td>
          <td class="paramname"><em>q_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index&#160;</td>
          <td class="paramname"><em>q_subvector_size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae748bcfe9270b9ed5dd2fb71df3941b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae748bcfe9270b9ed5dd2fb71df3941b6">&#9670;&nbsp;</a></span>setSubMatrixGradient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::setSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM_submatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classint.html">int</a>, NRows &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classint.html">int</a>, NCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index&#160;</td>
          <td class="paramname"><em>M_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index&#160;</td>
          <td class="paramname"><em>q_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Index&#160;</td>
          <td class="paramname"><em>q_subvector_size</em> = <code>QSubvectorSize</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab54df9b3b01c7c5509373712fda88ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54df9b3b01c7c5509373712fda88ad4">&#9670;&nbsp;</a></span>setSubMatrixGradient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::setSubMatrixGradient </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedDM &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDMSub &gt; &amp;&#160;</td>
          <td class="paramname"><em>dM_submatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedDM::Index&#160;</td>
          <td class="paramname"><em>M_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedDM::Index&#160;</td>
          <td class="paramname"><em>q_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedDM::Index&#160;</td>
          <td class="paramname"><em>q_subvector_size</em> = <code>QSubvectorSize</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d6538743074d86b4dc68c7d0455b680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6538743074d86b4dc68c7d0455b680">&#9670;&nbsp;</a></span>Slerp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt;Scalar&gt; drake::math::Slerp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>interpolation_parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Q = Slerp(q1, q2, f) Spherical linear interpolation between two quaternions This function uses the implementation given in Algorithm 8 of [1]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>Initial quaternion (w, x, y, z) </td></tr>
    <tr><td class="paramname">q2</td><td>Final quaternion (w, x, y, z) </td></tr>
    <tr><td class="paramname">interpolation_parameter</td><td>between 0 and 1 (inclusive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Q</td><td>Interpolated quaternion(s). 4-by-1 vector.</td></tr>
  </table>
  </dd>
</dl>
<p>[1] Kuffner, J.J., "Effective sampling and distance metrics for 3D rigid
body path planning," Robotics and Automation, 2004. Proceedings. ICRA '04. 2004 IEEE International Conference on , vol.4, no., pp.3993, 3998 Vol.4, April 26-May 1, 2004 doi: 10.1109/ROBOT.2004.1308895 </p>

</div>
</div>
<a id="a9681555f84d48a48d09601d913246934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9681555f84d48a48d09601d913246934">&#9670;&nbsp;</a></span>SparseMatrixToRowColumnValueVectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::math::SparseMatrixToRowColumnValueVectors </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; Eigen::Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; typename Derived::Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a sparse matrix, return the row indices, the column indices, and value of the non-zero entries. </p>
<p>For example, the matrix</p>
<p class="formulaDsp">
\[ mat = \begin{bmatrix} 1 &amp; 0 &amp; 2\\ 0 &amp; 3 &amp; 4\end{bmatrix} \]
</p>
<p> has </p><p class="formulaDsp">
\[ row = \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 1\end{bmatrix}\\ col = \begin{bmatrix} 0 &amp; 1 &amp; 2 &amp; 2\end{bmatrix}\\ val = \begin{bmatrix} 1 &amp; 3 &amp; 2 &amp; 4\end{bmatrix} \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>the input sparse matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">row_indices</td><td>a vector containing the row indices of the non-zero entries </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">col_indices</td><td>a vector containing the column indices of the non-zero entries </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">val</td><td>a vector containing the values of the non-zero entries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a866d4d3082e830e8eb0c91cb5bf91ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866d4d3082e830e8eb0c91cb5bf91ef1">&#9670;&nbsp;</a></span>SparseMatrixToTriplets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;Eigen::Triplet&lt;typename Derived::Scalar&gt; &gt; drake::math::SparseMatrixToTriplets </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a sparse matrix, return a vector of triplets, such that we can reconstruct the matrix using setFromTriplet function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>A sparse matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A triplet with the row, column and value of the non-zero entries. See <a href="https://eigen.tuxfamily.org/dox/group__TutorialSparse.html">https://eigen.tuxfamily.org/dox/group__TutorialSparse.html</a> for more information on the triplet </dd></dl>

</div>
</div>
<a id="a5390bb2dadbe96cd6dfbe26c6891f100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5390bb2dadbe96cd6dfbe26c6891f100">&#9670;&nbsp;</a></span>ToSymmetricMatrixFromLowerTriangularColumns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a>&lt;typename Derived::Scalar&gt; drake::math::ToSymmetricMatrixFromLowerTriangularColumns </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_triangular_columns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a column vector containing the stacked columns of the lower triangular part of a square matrix, returning a symmetric matrix whose lower triangular part is the same as the original matrix. </p>

</div>
</div>
<a id="a6d81fb8e0b28f46bad7838ed39bffbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d81fb8e0b28f46bad7838ed39bffbce">&#9670;&nbsp;</a></span>ToSymmetricMatrixFromLowerTriangularColumns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename Derived::Scalar, rows, rows&gt; drake::math::ToSymmetricMatrixFromLowerTriangularColumns </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_triangular_columns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a column vector containing the stacked columns of the lower triangular part of a square matrix, returning a symmetric matrix whose lower triangular part is the same as the original matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the symmetric matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20c21cde851510ab3ae5a7527ed62d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c21cde851510ab3ae5a7527ed62d22">&#9670;&nbsp;</a></span>transposeGrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Derived::PlainObject drake::math::transposeGrad </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>dX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>rows_X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6aefde593f0fbe2f9ef04f40979827f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6aefde593f0fbe2f9ef04f40979827f">&#9670;&nbsp;</a></span>UniformlyRandomAngleAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::AngleAxis&lt;T&gt; drake::math::UniformlyRandomAngleAxis </td>
          <td>(</td>
          <td class="paramtype">Generator *&#160;</td>
          <td class="paramname"><em>generator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a rotation (in the axis-angle representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere. </p>
<p>Justification for the algorithm can be found in, e.g.: Mervin E. Muller. 1959. A note on a method for generating points uniformly on n-dimensional spheres. Commun. ACM 2, 4 (April 1959), 19-20. DOI=<a href="http://dx.doi.org/10.1145/377939.377946">http://dx.doi.org/10.1145/377939.377946</a> </p>

</div>
</div>
<a id="a6c92561b046b32c1ebe172bd32dc8276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c92561b046b32c1ebe172bd32dc8276">&#9670;&nbsp;</a></span>UniformlyRandomQuaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt;T&gt; drake::math::UniformlyRandomQuaternion </td>
          <td>(</td>
          <td class="paramtype">Generator *&#160;</td>
          <td class="paramname"><em>generator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a rotation (in the quaternion representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere. </p>

</div>
</div>
<a id="af27920d083eb816f24f832091a662f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27920d083eb816f24f832091a662f28">&#9670;&nbsp;</a></span>UniformlyRandomRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt; drake::math::UniformlyRandomRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">Generator *&#160;</td>
          <td class="paramname"><em>generator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a rotation (in the rotation matrix representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere. </p>

</div>
</div>
<a id="acc24ae9bbbf0b9d253f3344b97a9f3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc24ae9bbbf0b9d253f3344b97a9f3d4">&#9670;&nbsp;</a></span>UniformlyRandomRPY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; drake::math::UniformlyRandomRPY </td>
          <td>(</td>
          <td class="paramtype">Generator *&#160;</td>
          <td class="paramname"><em>generator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a rotation (in the roll-pitch-yaw representation) that rotates a point on the unit sphere to another point on the unit sphere with a uniform distribution over the sphere. </p>

</div>
</div>
<a id="adba688f2a2db17563f2ef13e199816d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba688f2a2db17563f2ef13e199816d9">&#9670;&nbsp;</a></span>UniformPtsOnSphereFibonacci()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix3Xd UniformPtsOnSphereFibonacci </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deterministically generates approximate evenly distributed points on a unit sphere. </p>
<p>This method uses Fibonacci number. For the detailed math, please refer to <a href="http://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere">http://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere</a> This algorithm generates the points in O(n) time, where <code>n</code> is the number of points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of points we want on the unit sphere. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The generated points. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>num_samples &gt;= 1. Throw std::runtime_error if num_points &lt; 1 </dd></dl>

</div>
</div>
<a id="a2d78f6f294270fdc03dcb68de424536a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d78f6f294270fdc03dcb68de424536a">&#9670;&nbsp;</a></span>VectorToSkewSymmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">drake::Matrix3</a>&lt;typename Derived::Scalar&gt; drake::math::VectorToSkewSymmetric </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64bd1ea33cbb7fd030ff6bf3061eb3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bd1ea33cbb7fd030ff6bf3061eb3fe">&#9670;&nbsp;</a></span>wrap_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T1 drake::math::wrap_to </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For variables that are meant to be periodic, (e.g. </p>
<p>over a 2π interval), wraps <code>value</code> into the interval <code>[low, high)</code>. Precisely, <code>wrap_to</code> returns: value + k*(high-low) for the unique integer value <code>k</code> that lands the output in the desired interval. <code>low</code> and <code>high</code> must be finite, and low &lt; high. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1math.html">math</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
