<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: DirectionChangeLimiter&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structdrake_1_1multibody_1_1implicit__stribeck_1_1internal_1_1_direction_change_limiter.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structdrake_1_1multibody_1_1implicit__stribeck_1_1internal_1_1_direction_change_limiter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DirectionChangeLimiter&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This struct implements an internal (thus within <code>internal::</code>) detail of the implicit Stribeck solver.  
 <a href="structdrake_1_1multibody_1_1implicit__stribeck_1_1internal_1_1_direction_change_limiter.html#details">More...</a></p>

<p><code>#include &lt;drake/multibody/plant/implicit_stribeck_solver.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a492e799e033ae0043de37081e49135a5"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1implicit__stribeck_1_1internal_1_1_direction_change_limiter.html#a492e799e033ae0043de37081e49135a5">CalcAlpha</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a>&lt; T &gt;&gt; &amp;v, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a>&lt; T &gt;&gt; &amp;dv, <a class="el" href="classdouble.html">double</a> cos_theta_max, <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#acf0ce0b0857d1863bf05a03ceca04164">v_stiction</a>, <a class="el" href="classdouble.html">double</a> relative_tolerance)</td></tr>
<tr class="memdesc:a492e799e033ae0043de37081e49135a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the limiting algorithm described in the documentation above.  <a href="#a492e799e033ae0043de37081e49135a5">More...</a><br /></td></tr>
<tr class="separator:a492e799e033ae0043de37081e49135a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa547966f87ddf191307a2f3b6a7817"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1implicit__stribeck_1_1internal_1_1_direction_change_limiter.html#abaa547966f87ddf191307a2f3b6a7817">CrossesTheStictionRegion</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a>&lt; T &gt;&gt; &amp;v, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a>&lt; T &gt;&gt; &amp;dv, const T &amp;v_dot_dv, const T &amp;dv_norm, const T &amp;dv_norm2, <a class="el" href="classdouble.html">double</a> epsilon_v, <a class="el" href="classdouble.html">double</a> <a class="el" href="implicit__stribeck__solver__test_8cc.html#acf0ce0b0857d1863bf05a03ceca04164">v_stiction</a>, T *alpha)</td></tr>
<tr class="memdesc:abaa547966f87ddf191307a2f3b6a7817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method for detecting when the line connecting v with v1 = v + dv crosses the stiction region, a circle of radius <code>v_stiction</code>.  <a href="#abaa547966f87ddf191307a2f3b6a7817">More...</a><br /></td></tr>
<tr class="separator:abaa547966f87ddf191307a2f3b6a7817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc010fc59606b9760dac78bf529c3e3f"><td class="memItemLeft" align="right" valign="top">static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1implicit__stribeck_1_1internal_1_1_direction_change_limiter.html#afc010fc59606b9760dac78bf529c3e3f">SolveQuadraticForTheSmallestPositiveRoot</a> (const T &amp;a, const T &amp;b, const T &amp;c)</td></tr>
<tr class="memdesc:afc010fc59606b9760dac78bf529c3e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to solve the quadratic equation aα² + bα + c = 0 for the very particular case we know we have real roots (Δ = b² - 4ac &gt; 0) and we are interested in the smallest positive root.  <a href="#afc010fc59606b9760dac78bf529c3e3f">More...</a><br /></td></tr>
<tr class="separator:afc010fc59606b9760dac78bf529c3e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct drake::multibody::implicit_stribeck::internal::DirectionChangeLimiter&lt; T &gt;</h3>

<p>This struct implements an internal (thus within <code>internal::</code>) detail of the implicit Stribeck solver. </p>
<p>The implicit Stribeck solver performs a Newton-Raphson iteration, and at each kth iteration, it computes a tangential velocity update Δvₜᵏ. One Newton strategy would be to compute the tangential velocity at the next iteration (k+1) as vₜᵏ⁺¹ = vₜᵏ + αΔvₜᵏ, where 0 &lt; α &lt; 1, is a coefficient obtained by line search to improve convergence. Line search works very well for smooth problems. However, even though the implicit Stribeck is solving the root of a continuous function, this function has very steep gradients only within the very small regions close to where the tangential velocities are zero. These regions are circles in ℝ² of radius equal to the stiction tolerance of the solver vₛ. We refer to these circular regions as the "stiction regions" and to their boundaries as the "stiction circles". We refer to the region of ℝ² outside the stiction region around the origin as the "sliding region". The implicit Stribeck solver uses the following modified Stribeck function describing the functional dependence of the Stribeck coefficient of friction μₛ with slip speed: </p><pre>
    μₛ(x) = ⌈ μ x (2 - x),  x  &lt; 1
            ⌊ μ          ,  x &gt;= 1
</pre><p> where x corresponds to the dimensionless slip speed x = ‖vₜ‖ / vₛ and μ is the Coulomb's law coefficient of friction. The implicit Stribeck solver makes no distinction between static and dynamic coefficients of friction and therefore a single coefficient μ needs to be specified. The Stribeck function is highly nonlinear and difficult to solve with a conventional Newton-Raphson method. However, it can be partitioned into regions based on how well the local gradients can be used to find a solution. We'll describe the algorithm below in terms of "strong" gradients (∂μ/∂v &gt;&gt; 0) and "weak" gradients (∂μ/∂v ≈ 0). Roughly, the gradients are strong during stiction and weak during sliding. These regions are so small compared to the velocity scales dealt with by the implicit Stribeck solver, that effectively, the Newton-Raphson iterate would only "see" a fixed dynamic coefficient of friction and it would never be able to predict stiction. That is, if search direction Δvₜᵏ computed by the Newton-Raphson algorithm is not limited in some way, the iteration would never fall within the stiction regions where gradients are "strong" to guide the convergence of the solution, to either stiction or sliding.</p>
<p>The remedy to this situation is to limit changes in the tangential velocities at each iteration. The situation described above, in which an update Δvₜᵏ "misses" the stiction circle can be described in purely geometric terms. We exploit this fact to devise a strategy that is appropriate for this particular problem. We use the methodology outlined in [Uchida et al., 2015] and describe particulars to our implementation below.</p>
<p>LimitDirectionChange implements a specific strategy with knowledge of the implicit Stribeck iteration procedure. It is important to note that the implicit Stribeck uses "soft norms" to avoid divisions by zero. That is, friction forces are computed according to: </p><pre>
  fₜ(vₜ) = -μ(‖vₜ‖ₛ) vₜ/‖vₜ‖ₛ
</pre><p> where, to avoid the singularity at zero velocity, we use a "soft norm" ‖vₜ‖ₛ = sqrt(vₜᵀvₜ + εᵥ²), with εᵥ a small fraction of vₛ. Due to the use of soft norms, the gradient of fₜ with vₜ is now well defined, but it goes to zero as vₜ approaches the origin. Therefore, gradients are also "weak" in the neighborhood of ‖vₜ‖ₛ ≲ εᵥ. Due to this, external forcing (either from applied forces or from coupling with other friction forces) has the potential to, mistakenly, force a transition from stiction to sliding. The solver will most likely recover from this, but this will result in a larger number of iterations. LimitDirectionChange considers any tangential velocity vₜ (or change Δvₜ) to be approximately zero if x = ‖vₜ‖/vₛ is smaller than <code>tolerance</code> (see docs below, this is a dimensionless number &lt;&lt; 1). We define <code>εᵥ = tolerance⋅vₛ</code> (with units of m/s).</p>
<p>In what follows we list a number of special scenarios dealt with by LimitDirectionChange. We use the observations made above.</p>
<ul>
<li>LimitDirectionChange first deals with the case ‖vₜ‖ &lt; εᵥ to avoid divisions by zero in the subsequent cases. It essentially clips vₜᵏ⁺¹ to have magnitude vₛ/2 when the update Δvₜᵏ ≠ 0. For small updates Δvₜᵏ leading to vₜᵏ⁺¹ within the stiction region, we take α = 1. See implementation notes for <a class="el" href="structdrake_1_1multibody_1_1implicit__stribeck_1_1internal_1_1_direction_change_limiter.html#a492e799e033ae0043de37081e49135a5" title="Implements the limiting algorithm described in the documentation above. ">CalcAlpha()</a> for further details.</li>
<li>Transition from ‖vₜ‖ &lt; εᵥ (stiction) to ‖vₜ‖/vₛ &gt; 1 (sliding). Since we are in a region of "weak" gradients (due to "norm softening", see discussion above), we limit the update to vₜᵏ⁺¹ = vₜᵏ/‖vₜᵏ‖⋅vₛ/2. In other words, if the speed would grow too fast, we cap it at vₛ/2 so that at least two Newton iterations are required to go from near-0 sticking to sliding.</li>
<li>Transition from sliding ‖vₜᵏ‖/vₛ &gt; 1 to an almost perfect stiction with ‖vₜᵏ⁺¹‖ &lt; εᵥ. In an attempt to avoid weak gradients for the next iteration, we impose the limit vₜᵏ⁺¹ = vₜᵏ/‖vₜᵏ‖⋅vₛ/2, placing the velocity "in the same direction where it came from", within the stiction region, but where gradients are strong.</li>
<li>Velocity change Δvₜᵏ intersects the stiction circle. To be more precise, the line connecting vₜᵏ and vₜᵏ + Δvₜᵏ crosses the stiction region. This situation implies that most likely a stiction transition could happen but the pure Newton-Raphson would miss it. This situation is outlined in [Uchida et al., 2015]. In this case LimitDirectionChange computes α so that vₜᵏ⁺¹ = vₜᵏ + αΔvₜᵏ is the closest vector to the origin. This corresponds to the geometric condition dot(vₜᵏ⁺¹, Δvₜᵏ) = 0.</li>
<li>Velocity change Δvₜᵏ does not intersect the stiction circle, i.e. changes happen in a region away from stiction (within the sliding region). However, large angular changes (measured by the angle θ = acos(vₜᵏ⁺¹⋅vₜᵏ/(‖vₜᵏ⁺¹‖‖vₜᵏ‖)) between vₜᵏ⁺¹ and vₜᵏ) might indicate a solution that is attempting to reach a stiction region. In order to aid convergence, we limit the angle change to θₘₐₓ, and therefore (see [Uchida et al., 2015]) we compute α so that θₘₐₓ = acos(vₜᵏ⁺¹⋅vₜᵏ/(‖vₜᵏ⁺¹‖‖vₜᵏ‖)).</li>
</ul>
<p>Uchida, T.K., Sherman, M.A. and Delp, S.L., 2015. Making a meaningful impact: modelling simultaneous frictional collisions in spatial multibody systems. Proc. R. Soc. A, 471(2177), p.20140859.</p>
<p>LimitDirectionChange implements the algorithm described above. We place it inside a struct so that we can use Eigen::Ref arguments allowing different scalar types T. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a492e799e033ae0043de37081e49135a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492e799e033ae0043de37081e49135a5">&#9670;&nbsp;</a></span>CalcAlpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CalcAlpha </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>cos_theta_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v_stiction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>relative_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the limiting algorithm described in the documentation above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>the k-th iteration tangential velocity vₜᵏ, in m/s. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dv</td><td>the k-th iteration tangential velocity update Δvₜᵏ, in m/s. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cos_theta_max</td><td>precomputed value of cos(θₘₐₓ). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v_stiction</td><td>the stiction tolerance vₛ, in m/s. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relative_tolerance</td><td>a value &lt;&lt; 1 used to determine when ‖vₜ‖ ≈ 0. Typical values lie within the 10⁻³ - 10⁻² range. This allows us to compute <code>εᵥ = tolerance⋅vₛ</code> (in m/s) which defines a "small
tangential velocity scale". This value is used to compute "soft norms" (see class's documentation) and to detect values close to zero, ‖vₜ‖ &lt; εᵥ. A value close to one could cause the solver to miss transitions from/to stiction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">α</td><td>the limit in [0, 1] so that vₜᵏ⁺¹ = vₜᵏ + αΔvₜᵏ. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaa547966f87ddf191307a2f3b6a7817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa547966f87ddf191307a2f3b6a7817">&#9670;&nbsp;</a></span>CrossesTheStictionRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> CrossesTheStictionRegion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v_dot_dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dv_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dv_norm2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>epsilon_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v_stiction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method for detecting when the line connecting v with v1 = v + dv crosses the stiction region, a circle of radius <code>v_stiction</code>. </p>
<p>All other input arguments are quantities already precomputed by <a class="el" href="structdrake_1_1multibody_1_1implicit__stribeck_1_1internal_1_1_direction_change_limiter.html#a492e799e033ae0043de37081e49135a5" title="Implements the limiting algorithm described in the documentation above. ">CalcAlpha()</a> and thus we reuse them. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>when this method returns <code>true</code> (zero crossing), a coefficient in <code>(0, 1]</code> so that <code>v_alpha = v + alpha * dv</code> is the closest vector to the origin. It is not set when the method returns <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the line connecting v with v1 = v + dv crosses the stiction region. </dd></dl>

</div>
</div>
<a id="afc010fc59606b9760dac78bf529c3e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc010fc59606b9760dac78bf529c3e3f">&#9670;&nbsp;</a></span>SolveQuadraticForTheSmallestPositiveRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SolveQuadraticForTheSmallestPositiveRoot </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to solve the quadratic equation aα² + bα + c = 0 for the very particular case we know we have real roots (Δ = b² - 4ac &gt; 0) and we are interested in the smallest positive root. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>drake/multibody/plant/<a class="el" href="implicit__stribeck__solver_8h.html">implicit_stribeck_solver.h</a></li>
<li>drake/multibody/plant/<a class="el" href="implicit__stribeck__solver_8cc.html">implicit_stribeck_solver.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody_1_1implicit__stribeck.html">implicit_stribeck</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody_1_1implicit__stribeck_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="structdrake_1_1multibody_1_1implicit__stribeck_1_1internal_1_1_direction_change_limiter.html">DirectionChangeLimiter</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
