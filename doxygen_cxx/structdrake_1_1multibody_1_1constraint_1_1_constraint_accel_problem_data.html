<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: ConstraintAccelProblemData&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConstraintAccelProblemData&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Structure for holding constraint data for computing forces due to constraints and the resulting multibody accelerations.  
 <a href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#details">More...</a></p>

<p><code>#include &lt;drake/multibody/constraint/constraint_problem_data.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a09f8d0da960e3eed8859508f7efdb421"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a09f8d0da960e3eed8859508f7efdb421">ConstraintAccelProblemData</a> (<a class="el" href="classint.html">int</a> gv_dim)</td></tr>
<tr class="memdesc:a09f8d0da960e3eed8859508f7efdb421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs acceleration problem data for a system with a <code>gv_dim</code> dimensional generalized velocity.  <a href="#a09f8d0da960e3eed8859508f7efdb421">More...</a><br /></td></tr>
<tr class="separator:a09f8d0da960e3eed8859508f7efdb421"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a98c1d757c37c73a7454c7922094ca9ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a98c1d757c37c73a7454c7922094ca9ac">use_complementarity_problem_solver</a> {true}</td></tr>
<tr class="memdesc:a98c1d757c37c73a7454c7922094ca9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for whether the complementarity problem solver should be used to solve this particular problem instance.  <a href="#a98c1d757c37c73a7454c7922094ca9ac">More...</a><br /></td></tr>
<tr class="separator:a98c1d757c37c73a7454c7922094ca9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7420fd6adfed409f3fc8551d0decb96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#ad7420fd6adfed409f3fc8551d0decb96">sliding_contacts</a></td></tr>
<tr class="memdesc:ad7420fd6adfed409f3fc8551d0decb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indices of the sliding contacts (those contacts at which there is non-zero relative velocity between bodies in the plane tangent to the point of contact), out of the set of all contact indices (0...nc-1).  <a href="#ad7420fd6adfed409f3fc8551d0decb96">More...</a><br /></td></tr>
<tr class="separator:ad7420fd6adfed409f3fc8551d0decb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd507a76abfe6745b786bbe0da7f5f89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#afd507a76abfe6745b786bbe0da7f5f89">non_sliding_contacts</a></td></tr>
<tr class="memdesc:afd507a76abfe6745b786bbe0da7f5f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indices of the non-sliding contacts (those contacts at which there is zero relative velocity between bodies in the plane tangent to the point of contact), out of the set of all contact indices (0...nc-1).  <a href="#afd507a76abfe6745b786bbe0da7f5f89">More...</a><br /></td></tr>
<tr class="separator:afd507a76abfe6745b786bbe0da7f5f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfdc8cfc228ee64e73c891738c3863d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#aecfdc8cfc228ee64e73c891738c3863d">r</a></td></tr>
<tr class="memdesc:aecfdc8cfc228ee64e73c891738c3863d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of spanning vectors in the contact tangents (used to linearize the friction cone) at the n <em>non-sliding</em> contact points.  <a href="#aecfdc8cfc228ee64e73c891738c3863d">More...</a><br /></td></tr>
<tr class="separator:aecfdc8cfc228ee64e73c891738c3863d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658dd9b46db6b0a4572e7d6412e6bb40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a658dd9b46db6b0a4572e7d6412e6bb40">mu_sliding</a></td></tr>
<tr class="memdesc:a658dd9b46db6b0a4572e7d6412e6bb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of friction for the ns = nc - nns sliding contacts (where <code>nns</code> is the number of non-sliding contacts).  <a href="#a658dd9b46db6b0a4572e7d6412e6bb40">More...</a><br /></td></tr>
<tr class="separator:a658dd9b46db6b0a4572e7d6412e6bb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedc23d500b8e04f9bf6b96cbb11bbeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#acedc23d500b8e04f9bf6b96cbb11bbeb">mu_non_sliding</a></td></tr>
<tr class="memdesc:acedc23d500b8e04f9bf6b96cbb11bbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of friction for the nns = nc - ns non-sliding contacts (where <code>ns</code> is the number of sliding contacts).  <a href="#acedc23d500b8e04f9bf6b96cbb11bbeb">More...</a><br /></td></tr>
<tr class="separator:acedc23d500b8e04f9bf6b96cbb11bbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35881bb6864939d024dcffcef32de848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a35881bb6864939d024dcffcef32de848">tau</a></td></tr>
<tr class="memdesc:a35881bb6864939d024dcffcef32de848"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ℝⁿᵛ vector tau, the generalized external force vector that comprises gravitational, centrifugal, Coriolis, actuator, etc.  <a href="#a35881bb6864939d024dcffcef32de848">More...</a><br /></td></tr>
<tr class="separator:a35881bb6864939d024dcffcef32de848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c5614af40edee599284c373fba9c09"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a16c5614af40edee599284c373fba9c09">solve_inertia</a></td></tr>
<tr class="memdesc:a16c5614af40edee599284c373fba9c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function for solving the equation MX = B for matrix X, given input matrix B, where M is the generalized inertia matrix for the rigid body system.  <a href="#a16c5614af40edee599284c373fba9c09">More...</a><br /></td></tr>
<tr class="separator:a16c5614af40edee599284c373fba9c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data for bilateral constraints at the acceleration level</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Problem data for bilateral constraints of functions of system acceleration, where the constraint can be formulated as:</p>
<pre>
0 = G(q)⋅v̇ + kᴳ(t,q,v)
</pre><p> which implies the constraint definition g(t,q,v,v̇) ≡ G(q)⋅v̇ + kᴳ(t,q,v). G is defined as the ℝⁿᵇˣⁿᵛ Jacobian matrix that transforms generalized velocities (v ∈ ℝⁿᵛ) into the time derivatives of b bilateral constraint functions. The class of constraint functions naturally includes holonomic constraints, which are constraints posable as g(t,q). Such holonomic constraints must be twice differentiated with respect to time to yield an acceleration-level formulation (i.e., g̈(t, q, v, v̇), for the aforementioned definition of g(t,q)). That differentiation yields g̈ = G⋅v̇ + dG/dt⋅v, which is consistent with the constraint class under the definition kᴳ(t,q,v) ≡ dG/dt⋅v. An example such (holonomic) constraint function is the transmission (gearing) constraint below:</p><pre>
0 = v̇ᵢ - rv̇ⱼ
</pre><p> which can be read as the acceleration at joint i (v̇ᵢ) must equal to <code>r</code> times the acceleration at joint j (v̇ⱼ); <code>r</code> is thus the gear ratio. In this example, the corresponding holonomic constraint function is g(q) ≡ qᵢ - rqⱼ, yielding ̈g(q, v, v̇) = v̇ᵢ - rv̇ⱼ. </p>
</div></td></tr>
<tr class="memitem:aa24636f116f235120b6b9c48c083a7e2"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#aa24636f116f235120b6b9c48c083a7e2">G_mult</a></td></tr>
<tr class="memdesc:aa24636f116f235120b6b9c48c083a7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator that performs the multiplication G⋅v.  <a href="#aa24636f116f235120b6b9c48c083a7e2">More...</a><br /></td></tr>
<tr class="separator:aa24636f116f235120b6b9c48c083a7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d38d1b83f93e18d5a4633beef4639f"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#ac3d38d1b83f93e18d5a4633beef4639f">G_transpose_mult</a></td></tr>
<tr class="memdesc:ac3d38d1b83f93e18d5a4633beef4639f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator that performs the multiplication Gᵀ⋅f where f ∈ ℝⁿᵇ are the magnitudes of the constraint forces.  <a href="#ac3d38d1b83f93e18d5a4633beef4639f">More...</a><br /></td></tr>
<tr class="separator:ac3d38d1b83f93e18d5a4633beef4639f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cde9da79a1a8aba25ee8aacdb2ffd39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a3cde9da79a1a8aba25ee8aacdb2ffd39">kG</a></td></tr>
<tr class="memdesc:a3cde9da79a1a8aba25ee8aacdb2ffd39"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ℝⁿᵇ vector is the vector kᴳ(t,q,v) defined above.  <a href="#a3cde9da79a1a8aba25ee8aacdb2ffd39">More...</a><br /></td></tr>
<tr class="separator:a3cde9da79a1a8aba25ee8aacdb2ffd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data for constraints on accelerations along the contact normal</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Problem data for constraining the acceleration of two bodies projected along the contact surface normal, for n point contacts.</p>
<p>These data center around two Jacobian matrices, N and Q. N is the ℝⁿᶜˣⁿᵛ Jacobian matrix that transforms generalized velocities (v ∈ ℝⁿᵛ) into velocities projected along the contact normals at the nc point contacts. Q ∈ ℝⁿᶜˣⁿᵛ is the Jacobian matrix that transforms generalized velocities (nv is the dimension of generalized velocity) into velocities projected along the directions of sliding at the ns <em>sliding</em> contact points (rows of Q that correspond to non-sliding contacts should be zero). Finally, the Jacobian matrix N allows formulating the non-interpenetration constraint (a constraint imposed at the velocity level) as:</p><pre>
0 ≤ N(q)⋅v̇ + kᴺ(t,q,v)  ⊥  fᶜ ≥ 0
</pre><p> which means that the constraint g̈(q,v,v̇) ≡ N(q)⋅v̇ + kᴺ(t,q,v) is coupled to a force constraint (fᶜ ≥ 0) and a complementarity constraint fᶜ⋅(Nv̇ + kᴺ(t,q,v)) = 0, meaning that the constraint can apply no force if it is inactive (i.e., if g̈(q,v,v̇) is strictly greater than zero). Note that differentiating the original constraint ġ(t,q,v) ≡ Nv (i.e., the constraint posed at the velocity level) once with respect to time, such that all constraints are imposed at the acceleration level, yields: </p><pre>
g̈(t,q,v,v̇) = N(q) v̇ + dN/dt(q,v) v
</pre><p> Thus, the constraint at the acceleration level can be realized by setting kᴺ(t,q,v) = dN/dt(q,v)⋅v. If there is pre-existing constraint error (e.g., if N(q)⋅v &lt; 0), the kᴺ term can be used to "stabilize" this error. For example, one could set <code>kᴺ(t,q,v) = dN/dt(q,v)⋅v + α⋅N(q)⋅v</code>, for α ≥ 0.  </p>
</div></td></tr>
<tr class="memitem:a29af929fcff5a59a15ac072ebe89d26e"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a29af929fcff5a59a15ac072ebe89d26e">N_mult</a></td></tr>
<tr class="memdesc:a29af929fcff5a59a15ac072ebe89d26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator that performs the multiplication N⋅v.  <a href="#a29af929fcff5a59a15ac072ebe89d26e">More...</a><br /></td></tr>
<tr class="separator:a29af929fcff5a59a15ac072ebe89d26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea36727a50f62443fbf5770544a69d4"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a1ea36727a50f62443fbf5770544a69d4">N_minus_muQ_transpose_mult</a></td></tr>
<tr class="memdesc:a1ea36727a50f62443fbf5770544a69d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator that performs the multiplication (Nᵀ - μQᵀ)⋅f, where μ is a diagonal matrix with nonzero entries corresponding to the coefficients of friction at the s sliding contact points, and (Nᵀ - μQᵀ) transforms forces (f ∈ ℝⁿᶜ) applied along the contact normals at the nc point contacts into generalized forces.  <a href="#a1ea36727a50f62443fbf5770544a69d4">More...</a><br /></td></tr>
<tr class="separator:a1ea36727a50f62443fbf5770544a69d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613d499d309c4906c2df5db6580dd665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a613d499d309c4906c2df5db6580dd665">kN</a></td></tr>
<tr class="memdesc:a613d499d309c4906c2df5db6580dd665"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ℝⁿᶜ vector is the vector kᴺ(t,q,v) defined above.  <a href="#a613d499d309c4906c2df5db6580dd665">More...</a><br /></td></tr>
<tr class="separator:a613d499d309c4906c2df5db6580dd665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data for non-sliding contact friction constraints</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Problem data for constraining the tangential acceleration of two bodies projected along the contact surface tangents, for nc point contacts.</p>
<p>These data center around the Jacobian matrix, F ∈ ℝⁿⁿʳˣⁿᵛ, that transforms generalized velocities (v ∈ ℝⁿᵛ) into velocities projected along the nr vectors that span the contact tangents at the nns <em>non-sliding</em> point contacts (these nns * nr vectors are denoted <code>nnr</code>, like "total number of nr", for brevity). For contact problems in two dimensions, nr will be one and nnr would equal nns. For friction pyramids at each contact in three dimensions, nr would be two and nnr would equal 2nns. While the definition of nnr above indicates that every one of the nns non-sliding contacts uses the same "nr", the code imposes no such requirement. Finally, the Jacobian matrix F allows formulating the non-sliding friction force constraints as:</p><pre>
0 ≤ F(q)⋅v̇ + kᶠ(t,q,v) + λe  ⊥  fᶜ ≥ 0
</pre><p> which means that the constraint g̈(t,q,v,v̇) ≡ F(q)⋅v̇ + kᶠ(t,q,v) is coupled to a force constraint (fᶜ ≥ 0) and a complementarity constraint fᶜ⋅(Fv̇ + kᴺ(t,q,v) + λe) = 0: the constraint can apply no force if it is inactive (i.e., if g̈(t,q,v,v̇) is strictly greater than zero). The presence of the λe term is taken directly from [Anitescu 1997], where e is a vector of ones and zeros and λ corresponds roughly to the tangential acceleration at the contacts. The interested reader should refer to [Anitescu 1997] for a more thorough explanation of this constraint; the full constraint equation is presented only to elucidate the purpose of the kᶠ term. Analogously to the case of kᴺ, kᶠ should be set to dF/dt(q,v)⋅v; also analogously, kᶠ can be used to perform constraint stabilization. </p>
</div></td></tr>
<tr class="memitem:a1b267a517e862262fc1f50dd62c48f41"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a1b267a517e862262fc1f50dd62c48f41">F_mult</a></td></tr>
<tr class="memdesc:a1b267a517e862262fc1f50dd62c48f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator that performs the multiplication F⋅v.  <a href="#a1b267a517e862262fc1f50dd62c48f41">More...</a><br /></td></tr>
<tr class="separator:a1b267a517e862262fc1f50dd62c48f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148f4adaece02fe36243c84bafd8d467"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a148f4adaece02fe36243c84bafd8d467">F_transpose_mult</a></td></tr>
<tr class="memdesc:a148f4adaece02fe36243c84bafd8d467"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator that performs the multiplication Fᵀ⋅f, where f ∈ ℝⁿⁿˢʳ corresponds to frictional force magnitudes.  <a href="#a148f4adaece02fe36243c84bafd8d467">More...</a><br /></td></tr>
<tr class="separator:a148f4adaece02fe36243c84bafd8d467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d22b9ce633cccb2b57d1739e59d94d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a83d22b9ce633cccb2b57d1739e59d94d">kF</a></td></tr>
<tr class="memdesc:a83d22b9ce633cccb2b57d1739e59d94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ℝⁿⁿˢʳ vector is the vector kᶠ(t,q,v) defined above.  <a href="#a83d22b9ce633cccb2b57d1739e59d94d">More...</a><br /></td></tr>
<tr class="separator:a83d22b9ce633cccb2b57d1739e59d94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data for unilateral constraints at the acceleration level</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Problem data for unilateral constraints of functions of system acceleration, where the constraint can be formulated as:</p>
<pre>
0 ≤ L(q)⋅v̇ + kᴸ(t,q,v)  ⊥  fᶜ ≥ 0
</pre><p> which means that the constraint g(q,v,v̇) ≡ L(q)⋅v̇ + kᴸ(t,q,v) is coupled to a force constraint (fᶜ ≥ 0) and a complementarity constraint fᶜ⋅(L⋅v̇ + kᴸ(t,q,v)) = 0, meaning that the constraint can apply no force if it is inactive (i.e., if g(q,v,v̇) is strictly greater than zero). L is defined as the ℝⁿᵘˣⁿᵛ Jacobian matrix that transforms generalized velocities (v ∈ ℝⁿᵛ) into the time derivatives of nu unilateral constraint functions. The class of constraint functions naturally includes holonomic constraints, which are constraints posable as g(t,q). Such holonomic constraints must be twice differentiated with respect to time to yield an acceleration-level formulation (i.e., g̈(q, v, v̇, t), for the aforementioned definition of g(t,q)). That differentiation yields g̈ = L⋅v̇ + dL/dt⋅v, which is consistent with the constraint class under the definition kᴸ(t,q,v) ≡ dL/dt⋅v. An example such holonomic constraint function is a joint acceleration limit:</p><pre>
0 ≤ -v̇ⱼ + r  ⊥  fᶜⱼ ≥ 0
</pre><p> which can be read as the acceleration at joint j (v̇ⱼ) must be no larger than r, the force must be applied to limit the acceleration at the joint, and the limiting force cannot be applied if the acceleration at the joint is not at the limit (i.e., v̇ⱼ &lt; r). In this example, the corresponding holonomic constraint function is g(t,q) ≡ -qⱼ + rt², yielding ̈g(q, v, v̇) = -v̇ⱼ + r. </p>
</div></td></tr>
<tr class="memitem:ad03bc5722287da0acf149346388fa1b0"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#ad03bc5722287da0acf149346388fa1b0">L_mult</a></td></tr>
<tr class="memdesc:ad03bc5722287da0acf149346388fa1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator that performs the multiplication L⋅v.  <a href="#ad03bc5722287da0acf149346388fa1b0">More...</a><br /></td></tr>
<tr class="separator:ad03bc5722287da0acf149346388fa1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4a40b91dff8e9d8d5c4d39b3e93df2"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a7c4a40b91dff8e9d8d5c4d39b3e93df2">L_transpose_mult</a></td></tr>
<tr class="memdesc:a7c4a40b91dff8e9d8d5c4d39b3e93df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operator that performs the multiplication Lᵀ⋅f where f ∈ ℝⁿᵘ are the magnitudes of the constraint forces.  <a href="#a7c4a40b91dff8e9d8d5c4d39b3e93df2">More...</a><br /></td></tr>
<tr class="separator:a7c4a40b91dff8e9d8d5c4d39b3e93df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f29fed6311156aa9a7efefa57dfae06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html#a0f29fed6311156aa9a7efefa57dfae06">kL</a></td></tr>
<tr class="memdesc:a0f29fed6311156aa9a7efefa57dfae06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ℝⁿᵘ vector is the vector kᴸ(t,q,v) defined above.  <a href="#a0f29fed6311156aa9a7efefa57dfae06">More...</a><br /></td></tr>
<tr class="separator:a0f29fed6311156aa9a7efefa57dfae06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
struct drake::multibody::constraint::ConstraintAccelProblemData&lt; T &gt;</h3>

<p>Structure for holding constraint data for computing forces due to constraints and the resulting multibody accelerations. </p>
<p>The Newton-Euler equations (essentially F = ma) coupled with constraints on the positional coordinates g(q) yields an Index-3 DAE (see [Hairer 1996]), and generally makes initial value problems hard to solve, computationally speaking; coupling the Newton-Euler equations with the second time derivative of such constraint equations (i.e., g̈(q,v,v̇)) yields a far more manageable Index-1 DAE, again with regard to computation. This structure stores problem data for computing dynamics under such constraints and others (nonholonomic constraints, Coulomb friction constraints, etc.)</p>
<h3>Definition of variables specific to this class</h3>
<p>(See <a class="el" href="group__constraint__variable__defs.html">Variable definitions</a>) for the more general set of definitions).</p>
<ul>
<li>ns ∈ ℕ The number of contacts at which sliding is occurring. Note that nc = ns + nns, where nc is the number of points of contact.</li>
<li>nns ∈ ℕ The number of contacts at which sliding is not occurring. Note that nc = ns + nns. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a09f8d0da960e3eed8859508f7efdb421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f8d0da960e3eed8859508f7efdb421">&#9670;&nbsp;</a></span>ConstraintAccelProblemData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html">ConstraintAccelProblemData</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>gv_dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs acceleration problem data for a system with a <code>gv_dim</code> dimensional generalized velocity. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1b267a517e862262fc1f50dd62c48f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b267a517e862262fc1f50dd62c48f41">&#9670;&nbsp;</a></span>F_mult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&amp;)&gt; F_mult</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An operator that performs the multiplication F⋅v. </p>
<p>The default operator returns an empty vector. </p>

</div>
</div>
<a id="a148f4adaece02fe36243c84bafd8d467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148f4adaece02fe36243c84bafd8d467">&#9670;&nbsp;</a></span>F_transpose_mult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&amp;)&gt; F_transpose_mult</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An operator that performs the multiplication Fᵀ⋅f, where f ∈ ℝⁿⁿˢʳ corresponds to frictional force magnitudes. </p>
<p>The default operator returns a zero vector of dimension equal to that of the generalized forces. </p>

</div>
</div>
<a id="aa24636f116f235120b6b9c48c083a7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24636f116f235120b6b9c48c083a7e2">&#9670;&nbsp;</a></span>G_mult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&amp;)&gt; G_mult</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An operator that performs the multiplication G⋅v. </p>
<p>The default operator returns an empty vector. </p>

</div>
</div>
<a id="ac3d38d1b83f93e18d5a4633beef4639f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d38d1b83f93e18d5a4633beef4639f">&#9670;&nbsp;</a></span>G_transpose_mult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&amp;)&gt; G_transpose_mult</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An operator that performs the multiplication Gᵀ⋅f where f ∈ ℝⁿᵇ are the magnitudes of the constraint forces. </p>
<p>The default operator returns a zero vector of dimension equal to that of the generalized forces. </p>

</div>
</div>
<a id="a83d22b9ce633cccb2b57d1739e59d94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d22b9ce633cccb2b57d1739e59d94d">&#9670;&nbsp;</a></span>kF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; kF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This ℝⁿⁿˢʳ vector is the vector kᶠ(t,q,v) defined above. </p>

</div>
</div>
<a id="a3cde9da79a1a8aba25ee8aacdb2ffd39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cde9da79a1a8aba25ee8aacdb2ffd39">&#9670;&nbsp;</a></span>kG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; kG</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This ℝⁿᵇ vector is the vector kᴳ(t,q,v) defined above. </p>

</div>
</div>
<a id="a0f29fed6311156aa9a7efefa57dfae06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f29fed6311156aa9a7efefa57dfae06">&#9670;&nbsp;</a></span>kL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; kL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This ℝⁿᵘ vector is the vector kᴸ(t,q,v) defined above. </p>

</div>
</div>
<a id="a613d499d309c4906c2df5db6580dd665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613d499d309c4906c2df5db6580dd665">&#9670;&nbsp;</a></span>kN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; kN</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This ℝⁿᶜ vector is the vector kᴺ(t,q,v) defined above. </p>

</div>
</div>
<a id="ad03bc5722287da0acf149346388fa1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03bc5722287da0acf149346388fa1b0">&#9670;&nbsp;</a></span>L_mult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&amp;)&gt; L_mult</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An operator that performs the multiplication L⋅v. </p>
<p>The default operator returns an empty vector. </p>

</div>
</div>
<a id="a7c4a40b91dff8e9d8d5c4d39b3e93df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4a40b91dff8e9d8d5c4d39b3e93df2">&#9670;&nbsp;</a></span>L_transpose_mult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&amp;)&gt; L_transpose_mult</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An operator that performs the multiplication Lᵀ⋅f where f ∈ ℝⁿᵘ are the magnitudes of the constraint forces. </p>
<p>The default operator returns a zero vector of dimension equal to that of the generalized forces. </p>

</div>
</div>
<a id="acedc23d500b8e04f9bf6b96cbb11bbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acedc23d500b8e04f9bf6b96cbb11bbeb">&#9670;&nbsp;</a></span>mu_non_sliding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; mu_non_sliding</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coefficients of friction for the nns = nc - ns non-sliding contacts (where <code>ns</code> is the number of sliding contacts). </p>
<p>The size of this vector should be equal to <code>non_sliding_contacts.size()</code>. </p>

</div>
</div>
<a id="a658dd9b46db6b0a4572e7d6412e6bb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658dd9b46db6b0a4572e7d6412e6bb40">&#9670;&nbsp;</a></span>mu_sliding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; mu_sliding</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coefficients of friction for the ns = nc - nns sliding contacts (where <code>nns</code> is the number of non-sliding contacts). </p>
<p>The size of this vector should be equal to <code>sliding_contacts.size()</code>. </p>

</div>
</div>
<a id="a1ea36727a50f62443fbf5770544a69d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea36727a50f62443fbf5770544a69d4">&#9670;&nbsp;</a></span>N_minus_muQ_transpose_mult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&amp;)&gt; N_minus_muQ_transpose_mult</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An operator that performs the multiplication (Nᵀ - μQᵀ)⋅f, where μ is a diagonal matrix with nonzero entries corresponding to the coefficients of friction at the s sliding contact points, and (Nᵀ - μQᵀ) transforms forces (f ∈ ℝⁿᶜ) applied along the contact normals at the nc point contacts into generalized forces. </p>
<p>The default operator returns a zero vector of dimension equal to that of the generalized forces. </p>

</div>
</div>
<a id="a29af929fcff5a59a15ac072ebe89d26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29af929fcff5a59a15ac072ebe89d26e">&#9670;&nbsp;</a></span>N_mult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&amp;)&gt; N_mult</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An operator that performs the multiplication N⋅v. </p>
<p>The default operator returns an empty vector. </p>

</div>
</div>
<a id="afd507a76abfe6745b786bbe0da7f5f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd507a76abfe6745b786bbe0da7f5f89">&#9670;&nbsp;</a></span>non_sliding_contacts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classint.html">int</a>&gt; non_sliding_contacts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indices of the non-sliding contacts (those contacts at which there is zero relative velocity between bodies in the plane tangent to the point of contact), out of the set of all contact indices (0...nc-1). </p>
<p>This vector must be in sorted order. </p>

</div>
</div>
<a id="aecfdc8cfc228ee64e73c891738c3863d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfdc8cfc228ee64e73c891738c3863d">&#9670;&nbsp;</a></span>r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classint.html">int</a>&gt; r</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of spanning vectors in the contact tangents (used to linearize the friction cone) at the n <em>non-sliding</em> contact points. </p>
<p>For contact problems in two dimensions, each element of r will be one. For contact problems in three dimensions, a friction pyramid (for example), for a contact point i will have rᵢ = 2. [Anitescu 1997] define k such vectors and require that, for each vector w in the spanning set, -w also exists in the spanning set. The RigidContactAccelProblemData structure expects that the contact solving mechanism negates the spanning vectors so <code>r</code> = k/2 spanning vectors will correspond to a k-edge polygon friction cone approximation. </p>

</div>
</div>
<a id="ad7420fd6adfed409f3fc8551d0decb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7420fd6adfed409f3fc8551d0decb96">&#9670;&nbsp;</a></span>sliding_contacts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="translator__test_8cc.html#aa8ec4e9f7594c29b258511283384c33b">std::vector</a>&lt;<a class="el" href="classint.html">int</a>&gt; sliding_contacts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indices of the sliding contacts (those contacts at which there is non-zero relative velocity between bodies in the plane tangent to the point of contact), out of the set of all contact indices (0...nc-1). </p>
<p>This vector must be in sorted order. </p>

</div>
</div>
<a id="a16c5614af40edee599284c373fba9c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c5614af40edee599284c373fba9c09">&#9670;&nbsp;</a></span>solve_inertia</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;T&gt;const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;T&gt;&amp;)&gt; solve_inertia</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function for solving the equation MX = B for matrix X, given input matrix B, where M is the generalized inertia matrix for the rigid body system. </p>

</div>
</div>
<a id="a35881bb6864939d024dcffcef32de848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35881bb6864939d024dcffcef32de848">&#9670;&nbsp;</a></span>tau</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; tau</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The ℝⁿᵛ vector tau, the generalized external force vector that comprises gravitational, centrifugal, Coriolis, actuator, etc. </p>
<p>forces applied to the rigid body system at q. m is the dimension of the generalized force, which is also equal to the dimension of the generalized velocity. </p>

</div>
</div>
<a id="a98c1d757c37c73a7454c7922094ca9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c1d757c37c73a7454c7922094ca9ac">&#9670;&nbsp;</a></span>use_complementarity_problem_solver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> use_complementarity_problem_solver {true}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag for whether the complementarity problem solver should be used to solve this particular problem instance. </p>
<p>If every constraint in the problem data is active, using the linear system solver (<code>use_complementarity_problem_solver=false</code>) will yield a solution much more quickly. If it is unknown whether every constraint is active, the complementarity problem solver should be used; otherwise, the inequality constraints embedded in the problem data may not be satisfied. The safe (and slower) value of <code>true</code> is the default. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>drake/multibody/constraint/<a class="el" href="constraint__problem__data_8h.html">constraint_problem_data.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--HTML footer for doxygen 1.8.13-->
<!--start footer part-->
<div id="nav-path" class="navpath"><!--id is needed for treeview function!-->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody_1_1constraint.html">constraint</a></li><li class="navelem"><a class="el" href="structdrake_1_1multibody_1_1constraint_1_1_constraint_accel_problem_data.html">ConstraintAccelProblemData</a></li>
    <li class="footer">Generated by
    <a href="https://www.stack.nl/~dimitri/doxygen/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
